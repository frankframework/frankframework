test.v1 = 3
test.v2 = 2

# All properties are loaded from properties-files as strings. To use them as numbers, it is easiest
# to insert them as nested variable-expansions
test.vmin = ${=Math.min(${test.v1}, ${test.v2})}

# test.v3 should be added as system property instead of defined in the file
factor = ${=test.v3}

# 'factor' is converted to integer automatically by the JEXL engine in this case, since the first operand is already an integer
test.expr1 = ${= ${test.vmin} * factor }

# Embedded expression should be used to reference properties that do contain dots
test.expr2 = ${= ${test.vmin} * ${test.v3} }

str.c1 = We
str.c2 = Use

str.switch = F

name.current=Frank!Framework
name.legacy=IBIS Adapter Framework

# Directly reference other vars with dotted names
str.text1 = ${=StringUtil.concat(" ", str.c1, str.c2, (str.switch.equals("F") ? name.current : name.legacy)) }
# Insert other vars using nested expansion to reach similar result
str.text2 = ${= "${str.c1} ${str.c2} " + ('${str.switch}' == 'F' ? name.current : name.legacy) }

str.text3 = ${= "%s %s %s".formatted(str.c1, str.c2, str.switch.equals("F") ? name.current : name.legacy)}

inp=${str.text3}

# Reference another computed variable, and call various Framework util functions to do string manipulations
str.transform1 = ${= StringUtil.safeCollectionToString(StringUtil.splitToStream(inp, " ").map(s -> StringUtil.lcFirst(s)).toList()) }

# Referenced property "instance.name" is not defined in the file but the PropertyLoader class will try to dynamically resolve it and that should resolve to empty string ""
instance.name.lc = ${= instance.name.toLowerCase() }
