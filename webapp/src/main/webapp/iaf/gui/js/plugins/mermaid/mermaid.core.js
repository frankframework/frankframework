(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["mermaid"] = factory();
	else
		root["mermaid"] = factory();
})(typeof self !== "undefined" ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/mermaid.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/node-libs-browser/mock/empty.js":
/*!******************************************************!*\
  !*** ./node_modules/node-libs-browser/mock/empty.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, version, description, main, keywords, scripts, repository, author, license, standard, dependencies, devDependencies, files, sideEffects, husky, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"mermaid\",\"version\":\"8.12.0\",\"description\":\"Markdownish syntax for generating flowcharts, sequence diagrams, class diagrams, gantt charts and git graphs.\",\"main\":\"dist/mermaid.core.js\",\"keywords\":[\"diagram\",\"markdown\",\"flowchart\",\"sequence diagram\",\"gantt\",\"class diagram\",\"git graph\"],\"scripts\":{\"build:development\":\"webpack --progress --color\",\"build:production\":\"yarn build:development --mode production --config webpack.config.prod.babel.js\",\"build\":\"yarn build:development && yarn build:production\",\"postbuild\":\"documentation build src/mermaidAPI.js src/config.js src/defaultConfig.js --shallow -f md --markdown-toc false > docs/Setup.md\",\"build:watch\":\"yarn build --watch\",\"release\":\"yarn build\",\"lint\":\"eslint src\",\"e2e:depr\":\"yarn lint && jest e2e --config e2e/jest.config.js\",\"cypress\":\"percy exec -- cypress run\",\"e2e\":\"start-server-and-test dev http://localhost:9000/ cypress\",\"e2e-upd\":\"yarn lint && jest e2e -u --config e2e/jest.config.js\",\"dev\":\"webpack serve --config webpack.config.e2e.js\",\"test\":\"yarn lint && jest src/.*\",\"test:watch\":\"jest --watch src\",\"prepublishOnly\":\"yarn build && yarn test\",\"prepare\":\"yarn build\"},\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/knsv/mermaid\"},\"author\":\"Knut Sveidqvist\",\"license\":\"MIT\",\"standard\":{\"ignore\":[\"**/parser/*.js\",\"dist/**/*.js\",\"cypress/**/*.js\"],\"globals\":[\"page\"]},\"dependencies\":{\"@braintree/sanitize-url\":\"^3.1.0\",\"d3\":\"^7.0.0\",\"dagre\":\"^0.8.5\",\"dagre-d3\":\"^0.6.4\",\"dompurify\":\"2.3.1\",\"graphlib\":\"^2.1.8\",\"khroma\":\"^1.4.1\",\"moment-mini\":\"^2.24.0\",\"stylis\":\"^4.0.10\"},\"devDependencies\":{\"@babel/core\":\"^7.14.6\",\"@babel/eslint-parser\":\"^7.14.7\",\"@babel/preset-env\":\"^7.14.7\",\"@babel/register\":\"^7.14.5\",\"@percy/cli\":\"^1.0.0-beta.58\",\"@percy/cypress\":\"^3.1.0\",\"@percy/migrate\":\"^0.11.0\",\"babel-jest\":\"^27.0.6\",\"babel-loader\":\"^8.2.2\",\"coveralls\":\"^3.0.2\",\"css-to-string-loader\":\"^0.1.3\",\"cypress\":\"8.1.0\",\"documentation\":\"13.2.0\",\"eslint\":\"^7.30.0\",\"eslint-config-prettier\":\"^8.3.0\",\"eslint-plugin-prettier\":\"^3.4.0\",\"husky\":\"^7.0.1\",\"identity-obj-proxy\":\"^3.0.0\",\"jest\":\"^27.0.6\",\"jison\":\"^0.4.18\",\"js-base64\":\"3.6.1\",\"moment\":\"^2.23.0\",\"prettier\":\"^2.3.2\",\"start-server-and-test\":\"^1.12.6\",\"terser-webpack-plugin\":\"^4.2.3\",\"webpack\":\"^4.41.2\",\"webpack-cli\":\"^4.7.2\",\"webpack-dev-server\":\"^3.4.1\",\"webpack-node-externals\":\"^3.0.0\"},\"files\":[\"dist\"],\"sideEffects\":[\"**/*.css\",\"**/*.scss\"],\"husky\":{\"hooks\":{\"pre-push\":\"yarn test\"}}}");

/***/ }),

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/*! exports provided: defaultConfig, updateCurrentConfig, setSiteConfig, saveConfigFromInitilize, updateSiteConfig, getSiteConfig, setConfig, getConfig, sanitize, addDirective, reset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultConfig", function() { return defaultConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateCurrentConfig", function() { return updateCurrentConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setSiteConfig", function() { return setSiteConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveConfigFromInitilize", function() { return saveConfigFromInitilize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateSiteConfig", function() { return updateSiteConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSiteConfig", function() { return getSiteConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConfig", function() { return setConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getConfig", function() { return getConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sanitize", function() { return sanitize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addDirective", function() { return addDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reset", function() { return reset; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/utils.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logger */ "./src/logger.js");
/* harmony import */ var _themes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./themes */ "./src/themes/index.js");
/* harmony import */ var _defaultConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./defaultConfig */ "./src/defaultConfig.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }




 // debugger;

var defaultConfig = Object.freeze(_defaultConfig__WEBPACK_IMPORTED_MODULE_3__["default"]);
var siteConfig = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assignWithDepth"])({}, defaultConfig);
var configFromInitialize;
var directives = [];
var currentConfig = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assignWithDepth"])({}, defaultConfig);
var updateCurrentConfig = function updateCurrentConfig(siteCfg, _directives) {
  // start with config beeing the siteConfig
  var cfg = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assignWithDepth"])({}, siteCfg); // let sCfg = assignWithDepth(defaultConfig, siteConfigDelta);
  // Join directives

  var sumOfDirectives = {};

  for (var i = 0; i < _directives.length; i++) {
    var d = _directives[i];
    sanitize(d); // Apply the data from the directive where the the overrides the themeVaraibles

    sumOfDirectives = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assignWithDepth"])(sumOfDirectives, d);
  }

  cfg = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assignWithDepth"])(cfg, sumOfDirectives);

  if (sumOfDirectives.theme) {
    var tmpConfigFromInitialize = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assignWithDepth"])({}, configFromInitialize);
    var themeVariables = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assignWithDepth"])(tmpConfigFromInitialize.themeVariables || {}, sumOfDirectives.themeVariables);
    cfg.themeVariables = _themes__WEBPACK_IMPORTED_MODULE_2__["default"][cfg.theme].getThemeVariables(themeVariables);
  }

  currentConfig = cfg;
  return cfg;
};
/**
 *## setSiteConfig
 *| Function | Description         | Type    | Values             |
 *| --------- | ------------------- | ------- | ------------------ |
 *| setSiteConfig|Sets the siteConfig to desired values | Put Request | Any Values, except ones in secure array|
 ***Notes:**
 *Sets the siteConfig. The siteConfig is a protected configuration for repeat use. Calls to reset() will reset
 *the currentConfig to siteConfig. Calls to reset(configApi.defaultConfig) will reset siteConfig and currentConfig
 *to the defaultConfig
 *Note: currentConfig is set in this function
 **Default value: At default, will mirror Global Config**
 * @param conf - the base currentConfig to use as siteConfig
 * @returns {*} - the siteConfig
 */

var setSiteConfig = function setSiteConfig(conf) {
  siteConfig = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assignWithDepth"])({}, defaultConfig);
  siteConfig = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assignWithDepth"])(siteConfig, conf);

  if (conf.theme) {
    siteConfig.themeVariables = _themes__WEBPACK_IMPORTED_MODULE_2__["default"][conf.theme].getThemeVariables(conf.themeVariables);
  }

  currentConfig = updateCurrentConfig(siteConfig, directives);
  return siteConfig;
};
var saveConfigFromInitilize = function saveConfigFromInitilize(conf) {
  configFromInitialize = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assignWithDepth"])({}, conf);
};
var updateSiteConfig = function updateSiteConfig(conf) {
  siteConfig = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assignWithDepth"])(siteConfig, conf);
  updateCurrentConfig(siteConfig, directives);
  return siteConfig;
};
/**
 *## getSiteConfig
 *| Function | Description         | Type    |  Values             |
 *| --------- | ------------------- | ------- |  ------------------ |
 *| setSiteConfig|Returns the current siteConfig base configuration | Get Request | Returns Any Values  in siteConfig|
 ***Notes**:
 *Returns **any** values in siteConfig.
 * @returns {*}
 */

var getSiteConfig = function getSiteConfig() {
  return Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assignWithDepth"])({}, siteConfig);
};
/**
 *## setConfig
 *| Function  | Description         | Type    | Values             |
 *| --------- | ------------------- | ------- | ------------------ |
 *| setSiteConfig|Sets the siteConfig to desired values | Put Request| Any Values, except ones in secure array|
 ***Notes**:
 *Sets the currentConfig. The parameter conf is sanitized based on the siteConfig.secure keys. Any
 *values found in conf with key found in siteConfig.secure will be replaced with the corresponding
 *siteConfig value.
 * @param conf - the potential currentConfig
 * @returns {*} - the currentConfig merged with the sanitized conf
 */

var setConfig = function setConfig(conf) {
  // sanitize(conf);
  // Object.keys(conf).forEach(key => {
  //   const manipulator = manipulators[key];
  //   conf[key] = manipulator ? manipulator(conf[key]) : conf[key];
  // });
  Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assignWithDepth"])(currentConfig, conf);
  return getConfig();
};
/**
 *   ## getConfig
 *| Function  | Description         | Type    | Return Values            |
 *| --------- | ------------------- | ------- | ------------------ |
 *| getConfig |Obtains the currentConfig | Get Request | Any Values from currentConfig|
 ***Notes**:
 *Returns **any** the currentConfig
 * @returns {*} - the currentConfig
 */

var getConfig = function getConfig() {
  return Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assignWithDepth"])({}, currentConfig);
};
/**
 *## sanitize
 *| Function | Description         | Type    | Values             |
 *| --------- | ------------------- | ------- | ------------------ |
 *| sanitize  |Sets the siteConfig to desired values. | Put Request |None|
 *Ensures options parameter does not attempt to override siteConfig secure keys
 *Note: modifies options in-place
 * @param options - the potential setConfig parameter
 */

var sanitize = function sanitize(options) {
  // Checking that options are not in the list of excluded options
  Object.keys(siteConfig.secure).forEach(function (key) {
    if (typeof options[siteConfig.secure[key]] !== 'undefined') {
      // DO NOT attempt to print options[siteConfig.secure[key]] within `${}` as a malicious script
      // can exploit the logger's attempt to stringify the value and execute arbitrary code
      _logger__WEBPACK_IMPORTED_MODULE_1__["log"].debug("Denied attempt to modify a secure key ".concat(siteConfig.secure[key]), options[siteConfig.secure[key]]);
      delete options[siteConfig.secure[key]];
    }
  }); // Check that there no attempts of prototype pollution

  Object.keys(options).forEach(function (key) {
    if (key.indexOf('__') === 0) {
      delete options[key];
    }
  }); // Check that there no attempts of xss, there should be no tags at all in the directive
  // blocking data urls as base64 urls can contain svgs with inline script tags

  Object.keys(options).forEach(function (key) {
    if (typeof options[key] === 'string') {
      if (options[key].indexOf('<') > -1 || options[key].indexOf('>') > -1 || options[key].indexOf('url(data:') > -1) {
        delete options[key];
      }
    }

    if (_typeof(options[key]) === 'object') {
      sanitize(options[key]);
    }
  });
};
var addDirective = function addDirective(directive) {
  if (directive.fontFamily) {
    if (!directive.themeVariables) {
      directive.themeVariables = {
        fontFamily: directive.fontFamily
      };
    } else {
      if (!directive.themeVariables.fontFamily) {
        directive.themeVariables = {
          fontFamily: directive.fontFamily
        };
      }
    }
  }

  directives.push(directive);
  updateCurrentConfig(siteConfig, directives);
};
/**
 *## reset
 *| Function | Description         | Type    | Required | Values             |
 *| --------- | ------------------- | ------- | -------- | ------------------ |
 *| reset|Resets currentConfig to conf| Put Request | Required | None|
 *
 *| Parameter | Description |Type | Required | Values|
 *| --- | --- | --- | --- | --- |
 *| conf| base set of values, which currentConfig coul be **reset** to.| Dictionary | Required | Any Values, with respect to the secure Array|
 *
 **Notes :
 (default: current siteConfig ) (optional, default `getSiteConfig()`)
 * @param conf  the base currentConfig to reset to (default: current siteConfig ) (optional, default `getSiteConfig()`)
 */

var reset = function reset() {
  // Replace current config with siteConfig
  directives = [];
  updateCurrentConfig(siteConfig, directives);
};

/***/ }),

/***/ "./src/dagre-wrapper/clusters.js":
/*!***************************************!*\
  !*** ./src/dagre-wrapper/clusters.js ***!
  \***************************************/
/*! exports provided: insertCluster, getClusterTitleWidth, clear, positionCluster */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertCluster", function() { return insertCluster; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getClusterTitleWidth", function() { return getClusterTitleWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "positionCluster", function() { return positionCluster; });
/* harmony import */ var _intersect_intersect_rect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./intersect/intersect-rect */ "./src/dagre-wrapper/intersect/intersect-rect.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logger */ "./src/logger.js");
/* harmony import */ var _createLabel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createLabel */ "./src/dagre-wrapper/createLabel.js");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../config */ "./src/config.js");
/* harmony import */ var _diagrams_common_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../diagrams/common/common */ "./src/diagrams/common/common.js");







var rect = function rect(parent, node) {
  _logger__WEBPACK_IMPORTED_MODULE_1__["log"].trace('Creating subgraph rect for ', node.id, node); // Add outer g element

  var shapeSvg = parent.insert('g').attr('class', 'cluster' + (node.class ? ' ' + node.class : '')).attr('id', node.id); // add the rect

  var rect = shapeSvg.insert('rect', ':first-child'); // Create the label and insert it after the rect

  var label = shapeSvg.insert('g').attr('class', 'cluster-label');
  var text = label.node().appendChild(Object(_createLabel__WEBPACK_IMPORTED_MODULE_2__["default"])(node.labelText, node.labelStyle, undefined, true)); // Get the size of the label

  var bbox = text.getBBox();

  if (Object(_diagrams_common_common__WEBPACK_IMPORTED_MODULE_5__["evaluate"])(Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().flowchart.htmlLabels)) {
    var div = text.children[0];
    var dv = Object(d3__WEBPACK_IMPORTED_MODULE_3__["select"])(text);
    bbox = div.getBoundingClientRect();
    dv.attr('width', bbox.width);
    dv.attr('height', bbox.height);
  }

  var padding = 0 * node.padding;
  var halfPadding = padding / 2;
  var width = node.width <= bbox.width + padding ? bbox.width + padding : node.width;

  if (node.width <= bbox.width + padding) {
    node.diff = (bbox.width - node.width) / 2;
  } else {
    node.diff = -node.padding / 2;
  }

  _logger__WEBPACK_IMPORTED_MODULE_1__["log"].trace('Data ', node, JSON.stringify(node)); // center the rect around its coordinate

  rect.attr('style', node.style).attr('rx', node.rx).attr('ry', node.ry).attr('x', node.x - width / 2).attr('y', node.y - node.height / 2 - halfPadding).attr('width', width).attr('height', node.height + padding); // Center the label

  label.attr('transform', 'translate(' + (node.x - bbox.width / 2) + ', ' + (node.y - node.height / 2 + node.padding / 3) + ')');
  var rectBox = rect.node().getBBox();
  node.width = rectBox.width;
  node.height = rectBox.height;

  node.intersect = function (point) {
    return Object(_intersect_intersect_rect__WEBPACK_IMPORTED_MODULE_0__["default"])(node, point);
  };

  return shapeSvg;
};
/**
 * Non visiable cluster where the note is group with its
 */


var noteGroup = function noteGroup(parent, node) {
  // Add outer g element
  var shapeSvg = parent.insert('g').attr('class', 'note-cluster').attr('id', node.id); // add the rect

  var rect = shapeSvg.insert('rect', ':first-child');
  var padding = 0 * node.padding;
  var halfPadding = padding / 2; // center the rect around its coordinate

  rect.attr('rx', node.rx).attr('ry', node.ry).attr('x', node.x - node.width / 2 - halfPadding).attr('y', node.y - node.height / 2 - halfPadding).attr('width', node.width + padding).attr('height', node.height + padding).attr('fill', 'none');
  var rectBox = rect.node().getBBox();
  node.width = rectBox.width;
  node.height = rectBox.height;

  node.intersect = function (point) {
    return Object(_intersect_intersect_rect__WEBPACK_IMPORTED_MODULE_0__["default"])(node, point);
  };

  return shapeSvg;
};

var roundedWithTitle = function roundedWithTitle(parent, node) {
  // Add outer g element
  var shapeSvg = parent.insert('g').attr('class', node.classes).attr('id', node.id); // add the rect

  var rect = shapeSvg.insert('rect', ':first-child'); // Create the label and insert it after the rect

  var label = shapeSvg.insert('g').attr('class', 'cluster-label');
  var innerRect = shapeSvg.append('rect');
  var text = label.node().appendChild(Object(_createLabel__WEBPACK_IMPORTED_MODULE_2__["default"])(node.labelText, node.labelStyle, undefined, true)); // Get the size of the label

  var bbox = text.getBBox();

  if (Object(_diagrams_common_common__WEBPACK_IMPORTED_MODULE_5__["evaluate"])(Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().flowchart.htmlLabels)) {
    var div = text.children[0];
    var dv = Object(d3__WEBPACK_IMPORTED_MODULE_3__["select"])(text);
    bbox = div.getBoundingClientRect();
    dv.attr('width', bbox.width);
    dv.attr('height', bbox.height);
  }

  bbox = text.getBBox();
  var padding = 0 * node.padding;
  var halfPadding = padding / 2;
  var width = node.width <= bbox.width + node.padding ? bbox.width + node.padding : node.width;

  if (node.width <= bbox.width + node.padding) {
    node.diff = (bbox.width + node.padding * 0 - node.width) / 2;
  } else {
    node.diff = -node.padding / 2;
  } // center the rect around its coordinate


  rect.attr('class', 'outer').attr('x', node.x - width / 2 - halfPadding).attr('y', node.y - node.height / 2 - halfPadding).attr('width', width + padding).attr('height', node.height + padding);
  innerRect.attr('class', 'inner').attr('x', node.x - width / 2 - halfPadding).attr('y', node.y - node.height / 2 - halfPadding + bbox.height - 1).attr('width', width + padding).attr('height', node.height + padding - bbox.height - 3); // Center the label

  label.attr('transform', 'translate(' + (node.x - bbox.width / 2) + ', ' + (node.y - node.height / 2 - node.padding / 3 + (Object(_diagrams_common_common__WEBPACK_IMPORTED_MODULE_5__["evaluate"])(Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().flowchart.htmlLabels) ? 5 : 3)) + ')');
  var rectBox = rect.node().getBBox();
  node.height = rectBox.height;

  node.intersect = function (point) {
    return Object(_intersect_intersect_rect__WEBPACK_IMPORTED_MODULE_0__["default"])(node, point);
  };

  return shapeSvg;
};

var divider = function divider(parent, node) {
  // Add outer g element
  var shapeSvg = parent.insert('g').attr('class', node.classes).attr('id', node.id); // add the rect

  var rect = shapeSvg.insert('rect', ':first-child');
  var padding = 0 * node.padding;
  var halfPadding = padding / 2; // center the rect around its coordinate

  rect.attr('class', 'divider').attr('x', node.x - node.width / 2 - halfPadding).attr('y', node.y - node.height / 2).attr('width', node.width + padding).attr('height', node.height + padding);
  var rectBox = rect.node().getBBox();
  node.width = rectBox.width;
  node.height = rectBox.height;
  node.diff = -node.padding / 2;

  node.intersect = function (point) {
    return Object(_intersect_intersect_rect__WEBPACK_IMPORTED_MODULE_0__["default"])(node, point);
  };

  return shapeSvg;
};

var shapes = {
  rect: rect,
  roundedWithTitle: roundedWithTitle,
  noteGroup: noteGroup,
  divider: divider
};
var clusterElems = {};
var insertCluster = function insertCluster(elem, node) {
  _logger__WEBPACK_IMPORTED_MODULE_1__["log"].trace('Inserting cluster');
  var shape = node.shape || 'rect';
  clusterElems[node.id] = shapes[shape](elem, node);
};
var getClusterTitleWidth = function getClusterTitleWidth(elem, node) {
  var label = Object(_createLabel__WEBPACK_IMPORTED_MODULE_2__["default"])(node.labelText, node.labelStyle, undefined, true);
  elem.node().appendChild(label);
  var width = label.getBBox().width;
  elem.node().removeChild(label);
  return width;
};
var clear = function clear() {
  clusterElems = {};
};
var positionCluster = function positionCluster(node) {
  _logger__WEBPACK_IMPORTED_MODULE_1__["log"].info('Position cluster (' + node.id + ', ' + node.x + ', ' + node.y + ')');
  var el = clusterElems[node.id];
  el.attr('transform', 'translate(' + node.x + ', ' + node.y + ')');
};

/***/ }),

/***/ "./src/dagre-wrapper/createLabel.js":
/*!******************************************!*\
  !*** ./src/dagre-wrapper/createLabel.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logger */ "./src/logger.js");
/* harmony import */ var _diagrams_common_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../diagrams/common/common */ "./src/diagrams/common/common.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config */ "./src/config.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }


 // eslint-disable-line

 // let vertexNode;
// if (evaluate(getConfig().flowchart.htmlLabels)) {
//   // TODO: addHtmlLabel accepts a labelStyle. Do we possibly have that?
//   const node = {
//     label: vertexText.replace(/fa[lrsb]?:fa-[\w-]+/g, s => `<i class='${s.replace(':', ' ')}'></i>`)
//   };
//   vertexNode = addHtmlLabel(svg, node).node();
//   vertexNode.parentNode.removeChild(vertexNode);
// } else {
//   const svgLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
//   svgLabel.setAttribute('style', styles.labelStyle.replace('color:', 'fill:'));
//   const rows = vertexText.split(common.lineBreakRegex);
//   for (let j = 0; j < rows.length; j++) {
//     const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
//     tspan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
//     tspan.setAttribute('dy', '1em');
//     tspan.setAttribute('x', '1');
//     tspan.textContent = rows[j];
//     svgLabel.appendChild(tspan);
//   }
//   vertexNode = svgLabel;
// }



function applyStyle(dom, styleFn) {
  if (styleFn) {
    dom.attr('style', styleFn);
  }
}

function addHtmlLabel(node) {
  // var fo = root.append('foreignObject').attr('width', '100000');
  // var div = fo.append('xhtml:div');
  // div.attr('xmlns', 'http://www.w3.org/1999/xhtml');
  // var label = node.label;
  // switch (typeof label) {
  //   case 'function':
  //     div.insert(label);
  //     break;
  //   case 'object':
  //     // Currently we assume this is a DOM object.
  //     div.insert(function() {
  //       return label;
  //     });
  //     break;
  //   default:
  //     div.html(label);
  // }
  // applyStyle(div, node.labelStyle);
  // div.style('display', 'inline-block');
  // // Fix for firefox
  // div.style('white-space', 'nowrap');
  // var client = div.node().getBoundingClientRect();
  // fo.attr('width', client.width).attr('height', client.height);
  var fo = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject'));
  var div = fo.append('xhtml:div');
  var label = node.label;
  var labelClass = node.isNode ? 'nodeLabel' : 'edgeLabel';
  div.html('<span class="' + labelClass + '" ' + (node.labelStyle ? 'style="' + node.labelStyle + '"' : '') + '>' + label + '</span>');
  applyStyle(div, node.labelStyle);
  div.style('display', 'inline-block'); // Fix for firefox

  div.style('white-space', 'nowrap');
  div.attr('xmlns', 'http://www.w3.org/1999/xhtml');
  return fo.node();
}

var createLabel = function createLabel(_vertexText, style, isTitle, isNode) {
  var vertexText = _vertexText || '';
  if (_typeof(vertexText) === 'object') vertexText = vertexText[0];

  if (Object(_diagrams_common_common__WEBPACK_IMPORTED_MODULE_2__["evaluate"])(Object(_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"])().flowchart.htmlLabels)) {
    // TODO: addHtmlLabel accepts a labelStyle. Do we possibly have that?
    vertexText = vertexText.replace(/\\n|\n/g, '<br />');
    _logger__WEBPACK_IMPORTED_MODULE_1__["log"].info('vertexText' + vertexText);
    var node = {
      isNode: isNode,
      label: vertexText.replace(/fa[lrsb]?:fa-[\w-]+/g, function (s) {
        return "<i class='".concat(s.replace(':', ' '), "'></i>");
      }),
      labelStyle: style.replace('fill:', 'color:')
    };
    var vertexNode = addHtmlLabel(node); // vertexNode.parentNode.removeChild(vertexNode);

    return vertexNode;
  } else {
    var svgLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    svgLabel.setAttribute('style', style.replace('color:', 'fill:'));
    var rows = [];

    if (typeof vertexText === 'string') {
      rows = vertexText.split(/\\n|\n|<br\s*\/?>/gi);
    } else if (Array.isArray(vertexText)) {
      rows = vertexText;
    } else {
      rows = [];
    }

    for (var j = 0; j < rows.length; j++) {
      var tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
      tspan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
      tspan.setAttribute('dy', '1em');
      tspan.setAttribute('x', '0');

      if (isTitle) {
        tspan.setAttribute('class', 'title-row');
      } else {
        tspan.setAttribute('class', 'row');
      }

      tspan.textContent = rows[j].trim();
      svgLabel.appendChild(tspan);
    }

    return svgLabel;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (createLabel);

/***/ }),

/***/ "./src/dagre-wrapper/edges.js":
/*!************************************!*\
  !*** ./src/dagre-wrapper/edges.js ***!
  \************************************/
/*! exports provided: clear, insertEdgeLabel, positionEdgeLabel, intersection, insertEdge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertEdgeLabel", function() { return insertEdgeLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "positionEdgeLabel", function() { return positionEdgeLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersection", function() { return intersection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertEdge", function() { return insertEdge; });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../logger */ "./src/logger.js");
/* harmony import */ var _createLabel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createLabel */ "./src/dagre-wrapper/createLabel.js");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config */ "./src/config.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "./src/utils.js");
/* harmony import */ var _diagrams_common_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../diagrams/common/common */ "./src/diagrams/common/common.js");
 // eslint-disable-line

 // import { line, curveBasis, curveLinear, select } from 'd3';





var edgeLabels = {};
var terminalLabels = {};
var clear = function clear() {
  edgeLabels = {};
  terminalLabels = {};
};
var insertEdgeLabel = function insertEdgeLabel(elem, edge) {
  // Create the actual text element
  var labelElement = Object(_createLabel__WEBPACK_IMPORTED_MODULE_1__["default"])(edge.label, edge.labelStyle); // Create outer g, edgeLabel, this will be positioned after graph layout

  var edgeLabel = elem.insert('g').attr('class', 'edgeLabel'); // Create inner g, label, this will be positioned now for centering the text

  var label = edgeLabel.insert('g').attr('class', 'label');
  label.node().appendChild(labelElement); // Center the label

  var bbox = labelElement.getBBox();

  if (Object(_diagrams_common_common__WEBPACK_IMPORTED_MODULE_5__["evaluate"])(Object(_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"])().flowchart.htmlLabels)) {
    var div = labelElement.children[0];
    var dv = Object(d3__WEBPACK_IMPORTED_MODULE_2__["select"])(labelElement);
    bbox = div.getBoundingClientRect();
    dv.attr('width', bbox.width);
    dv.attr('height', bbox.height);
  }

  label.attr('transform', 'translate(' + -bbox.width / 2 + ', ' + -bbox.height / 2 + ')'); // Make element accessible by id for positioning

  edgeLabels[edge.id] = edgeLabel; // Update the abstract data of the edge with the new information about its width and height

  edge.width = bbox.width;
  edge.height = bbox.height;
  var fo;

  if (edge.startLabelLeft) {
    // Create the actual text element
    var startLabelElement = Object(_createLabel__WEBPACK_IMPORTED_MODULE_1__["default"])(edge.startLabelLeft, edge.labelStyle);
    var startEdgeLabelLeft = elem.insert('g').attr('class', 'edgeTerminals');
    var inner = startEdgeLabelLeft.insert('g').attr('class', 'inner');
    fo = inner.node().appendChild(startLabelElement);
    var slBox = startLabelElement.getBBox();
    inner.attr('transform', 'translate(' + -slBox.width / 2 + ', ' + -slBox.height / 2 + ')');

    if (!terminalLabels[edge.id]) {
      terminalLabels[edge.id] = {};
    }

    terminalLabels[edge.id].startLeft = startEdgeLabelLeft;
    setTerminalWidth(fo, edge.startLabelLeft);
  }

  if (edge.startLabelRight) {
    // Create the actual text element
    var _startLabelElement = Object(_createLabel__WEBPACK_IMPORTED_MODULE_1__["default"])(edge.startLabelRight, edge.labelStyle);

    var startEdgeLabelRight = elem.insert('g').attr('class', 'edgeTerminals');

    var _inner = startEdgeLabelRight.insert('g').attr('class', 'inner');

    fo = startEdgeLabelRight.node().appendChild(_startLabelElement);

    _inner.node().appendChild(_startLabelElement);

    var _slBox = _startLabelElement.getBBox();

    _inner.attr('transform', 'translate(' + -_slBox.width / 2 + ', ' + -_slBox.height / 2 + ')');

    if (!terminalLabels[edge.id]) {
      terminalLabels[edge.id] = {};
    }

    terminalLabels[edge.id].startRight = startEdgeLabelRight;
    setTerminalWidth(fo, edge.startLabelRight);
  }

  if (edge.endLabelLeft) {
    // Create the actual text element
    var endLabelElement = Object(_createLabel__WEBPACK_IMPORTED_MODULE_1__["default"])(edge.endLabelLeft, edge.labelStyle);
    var endEdgeLabelLeft = elem.insert('g').attr('class', 'edgeTerminals');

    var _inner2 = endEdgeLabelLeft.insert('g').attr('class', 'inner');

    fo = _inner2.node().appendChild(endLabelElement);

    var _slBox2 = endLabelElement.getBBox();

    _inner2.attr('transform', 'translate(' + -_slBox2.width / 2 + ', ' + -_slBox2.height / 2 + ')');

    endEdgeLabelLeft.node().appendChild(endLabelElement);

    if (!terminalLabels[edge.id]) {
      terminalLabels[edge.id] = {};
    }

    terminalLabels[edge.id].endLeft = endEdgeLabelLeft;
    setTerminalWidth(fo, edge.endLabelLeft);
  }

  if (edge.endLabelRight) {
    // Create the actual text element
    var _endLabelElement = Object(_createLabel__WEBPACK_IMPORTED_MODULE_1__["default"])(edge.endLabelRight, edge.labelStyle);

    var endEdgeLabelRight = elem.insert('g').attr('class', 'edgeTerminals');

    var _inner3 = endEdgeLabelRight.insert('g').attr('class', 'inner');

    fo = _inner3.node().appendChild(_endLabelElement);

    var _slBox3 = _endLabelElement.getBBox();

    _inner3.attr('transform', 'translate(' + -_slBox3.width / 2 + ', ' + -_slBox3.height / 2 + ')');

    endEdgeLabelRight.node().appendChild(_endLabelElement);

    if (!terminalLabels[edge.id]) {
      terminalLabels[edge.id] = {};
    }

    terminalLabels[edge.id].endRight = endEdgeLabelRight;
    setTerminalWidth(fo, edge.endLabelRight);
  }
};

function setTerminalWidth(fo, value) {
  if (Object(_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"])().flowchart.htmlLabels && fo) {
    fo.style.width = value.length * 9 + 'px';
    fo.style.height = '12px';
  }
}

var positionEdgeLabel = function positionEdgeLabel(edge, paths) {
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('Moving label abc78 ', edge.id, edge.label, edgeLabels[edge.id]);
  var path = paths.updatedPath ? paths.updatedPath : paths.originalPath;

  if (edge.label) {
    var el = edgeLabels[edge.id];
    var x = edge.x;
    var y = edge.y;

    if (path) {
      //   // debugger;
      var pos = _utils__WEBPACK_IMPORTED_MODULE_4__["default"].calcLabelPosition(path);
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('Moving label from (', x, ',', y, ') to (', pos.x, ',', pos.y, ') abc78'); // x = pos.x;
      // y = pos.y;
    }

    el.attr('transform', 'translate(' + x + ', ' + y + ')');
  } //let path = paths.updatedPath ? paths.updatedPath : paths.originalPath;


  if (edge.startLabelLeft) {
    var _el = terminalLabels[edge.id].startLeft;
    var _x2 = edge.x;
    var _y2 = edge.y;

    if (path) {
      // debugger;
      var _pos = _utils__WEBPACK_IMPORTED_MODULE_4__["default"].calcTerminalLabelPosition(edge.arrowTypeStart ? 10 : 0, 'start_left', path);

      _x2 = _pos.x;
      _y2 = _pos.y;
    }

    _el.attr('transform', 'translate(' + _x2 + ', ' + _y2 + ')');
  }

  if (edge.startLabelRight) {
    var _el2 = terminalLabels[edge.id].startRight;
    var _x3 = edge.x;
    var _y3 = edge.y;

    if (path) {
      // debugger;
      var _pos2 = _utils__WEBPACK_IMPORTED_MODULE_4__["default"].calcTerminalLabelPosition(edge.arrowTypeStart ? 10 : 0, 'start_right', path);

      _x3 = _pos2.x;
      _y3 = _pos2.y;
    }

    _el2.attr('transform', 'translate(' + _x3 + ', ' + _y3 + ')');
  }

  if (edge.endLabelLeft) {
    var _el3 = terminalLabels[edge.id].endLeft;
    var _x4 = edge.x;
    var _y4 = edge.y;

    if (path) {
      // debugger;
      var _pos3 = _utils__WEBPACK_IMPORTED_MODULE_4__["default"].calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, 'end_left', path);

      _x4 = _pos3.x;
      _y4 = _pos3.y;
    }

    _el3.attr('transform', 'translate(' + _x4 + ', ' + _y4 + ')');
  }

  if (edge.endLabelRight) {
    var _el4 = terminalLabels[edge.id].endRight;
    var _x5 = edge.x;
    var _y5 = edge.y;

    if (path) {
      // debugger;
      var _pos4 = _utils__WEBPACK_IMPORTED_MODULE_4__["default"].calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, 'end_right', path);

      _x5 = _pos4.x;
      _y5 = _pos4.y;
    }

    _el4.attr('transform', 'translate(' + _x5 + ', ' + _y5 + ')');
  }
}; // const getRelationType = function(type) {
//   switch (type) {
//     case stateDb.relationType.AGGREGATION:
//       return 'aggregation';
//     case stateDb.relationType.EXTENSION:
//       return 'extension';
//     case stateDb.relationType.COMPOSITION:
//       return 'composition';
//     case stateDb.relationType.DEPENDENCY:
//       return 'dependency';
//   }
// };

var outsideNode = function outsideNode(node, point) {
  // log.warn('Checking bounds ', node, point);
  var x = node.x;
  var y = node.y;
  var dx = Math.abs(point.x - x);
  var dy = Math.abs(point.y - y);
  var w = node.width / 2;
  var h = node.height / 2;

  if (dx >= w || dy >= h) {
    return true;
  }

  return false;
};

var intersection = function intersection(node, outsidePoint, insidePoint) {
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn("intersection calc abc89:\n  outsidePoint: ".concat(JSON.stringify(outsidePoint), "\n  insidePoint : ").concat(JSON.stringify(insidePoint), "\n  node        : x:").concat(node.x, " y:").concat(node.y, " w:").concat(node.width, " h:").concat(node.height));
  var x = node.x;
  var y = node.y;
  var dx = Math.abs(x - insidePoint.x); // const dy = Math.abs(y - insidePoint.y);

  var w = node.width / 2;
  var r = insidePoint.x < outsidePoint.x ? w - dx : w + dx;
  var h = node.height / 2; // const edges = {
  //   x1: x - w,
  //   x2: x + w,
  //   y1: y - h,
  //   y2: y + h
  // };
  // if (
  //   outsidePoint.x === edges.x1 ||
  //   outsidePoint.x === edges.x2 ||
  //   outsidePoint.y === edges.y1 ||
  //   outsidePoint.y === edges.y2
  // ) {
  //   log.warn('abc89 calc equals on edge', outsidePoint, edges);
  //   return outsidePoint;
  // }

  var Q = Math.abs(outsidePoint.y - insidePoint.y);
  var R = Math.abs(outsidePoint.x - insidePoint.x); // log.warn();

  if (Math.abs(y - outsidePoint.y) * w > Math.abs(x - outsidePoint.x) * h) {
    // eslint-disable-line
    // Intersection is top or bottom of rect.
    // let q = insidePoint.y < outsidePoint.y ? outsidePoint.y - h - y : y - h - outsidePoint.y;
    var q = insidePoint.y < outsidePoint.y ? outsidePoint.y - h - y : y - h - outsidePoint.y;
    r = R * q / Q;
    var res = {
      x: insidePoint.x < outsidePoint.x ? insidePoint.x + r : insidePoint.x - R + r,
      y: insidePoint.y < outsidePoint.y ? insidePoint.y + Q - q : insidePoint.y - Q + q
    };

    if (r === 0) {
      res.x = outsidePoint.x;
      res.y = outsidePoint.y;
    }

    if (R === 0) {
      res.x = outsidePoint.x;
    }

    if (Q === 0) {
      res.y = outsidePoint.y;
    }

    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn("abc89 topp/bott calc, Q ".concat(Q, ", q ").concat(q, ", R ").concat(R, ", r ").concat(r), res);
    return res;
  } else {
    // Intersection onn sides of rect
    if (insidePoint.x < outsidePoint.x) {
      r = outsidePoint.x - w - x;
    } else {
      // r = outsidePoint.x - w - x;
      r = x - w - outsidePoint.x;
    }

    var _q = Q * r / R; //  OK let _x = insidePoint.x < outsidePoint.x ? insidePoint.x + R - r : insidePoint.x + dx - w;
    // OK let _x = insidePoint.x < outsidePoint.x ? insidePoint.x + R - r : outsidePoint.x + r;


    var _x = insidePoint.x < outsidePoint.x ? insidePoint.x + R - r : insidePoint.x - R + r; // let _x = insidePoint.x < outsidePoint.x ? insidePoint.x + R - r : outsidePoint.x + r;


    var _y = insidePoint.y < outsidePoint.y ? insidePoint.y + _q : insidePoint.y - _q;

    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn("sides calc abc89, Q ".concat(Q, ", q ").concat(_q, ", R ").concat(R, ", r ").concat(r), {
      _x: _x,
      _y: _y
    });

    if (r === 0) {
      _x = outsidePoint.x;
      _y = outsidePoint.y;
    }

    if (R === 0) {
      _x = outsidePoint.x;
    }

    if (Q === 0) {
      _y = outsidePoint.y;
    }

    return {
      x: _x,
      y: _y
    };
  }
};
/**
 * This function will page a path and node where the last point(s) in the path is inside the node
 * and return an update path ending by the border of the node.
 * @param {*} points
 * @param {*} boundryNode
 * @returns
 */

var cutPathAtIntersect = function cutPathAtIntersect(_points, boundryNode) {
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('abc88 cutPathAtIntersect', _points, boundryNode);
  var points = [];
  var lastPointOutside = _points[0];
  var isInside = false;

  _points.forEach(function (point) {
    // const node = clusterDb[edge.toCluster].node;
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('abc88 checking point', point, boundryNode); // check if point is inside the boundry rect

    if (!outsideNode(boundryNode, point) && !isInside) {
      // First point inside the rect found
      // Calc the intersection coord between the point anf the last opint ouside the rect
      var inter = intersection(boundryNode, lastPointOutside, point);
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('abc88 inside', point, lastPointOutside, inter);
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('abc88 intersection', inter); // // Check case where the intersection is the same as the last point

      var pointPresent = false;
      points.forEach(function (p) {
        pointPresent = pointPresent || p.x === inter.x && p.y === inter.y;
      }); // // if (!pointPresent) {

      if (!points.find(function (e) {
        return e.x === inter.x && e.y === inter.y;
      })) {
        points.push(inter);
      } else {
        _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('abc88 no intersect', inter, points);
      } // points.push(inter);


      isInside = true;
    } else {
      // Outside
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('abc88 outside', point, lastPointOutside);
      lastPointOutside = point; // points.push(point);

      if (!isInside) points.push(point);
    }
  });

  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('abc88 returning points', points);
  return points;
}; //(edgePaths, e, edge, clusterDb, diagramtype, graph)


var insertEdge = function insertEdge(elem, e, edge, clusterDb, diagramType, graph) {
  var points = edge.points;
  var pointsHasChanged = false;
  var tail = graph.node(e.v);
  var head = graph.node(e.w);
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('abc88 InsertEdge: ', edge);

  if (head.intersect && tail.intersect) {
    points = points.slice(1, edge.points.length - 1);
    points.unshift(tail.intersect(points[0]));
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('Last point', points[points.length - 1], head, head.intersect(points[points.length - 1]));
    points.push(head.intersect(points[points.length - 1]));
  }

  if (edge.toCluster) {
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('to cluster abc88', clusterDb[edge.toCluster]);
    points = cutPathAtIntersect(edge.points, clusterDb[edge.toCluster].node); // log.trace('edge', edge);
    // points = [];
    // let lastPointOutside; // = edge.points[0];
    // let isInside = false;
    // edge.points.forEach(point => {
    //   const node = clusterDb[edge.toCluster].node;
    //   log.warn('checking from', edge.fromCluster, point, node);
    //   if (!outsideNode(node, point) && !isInside) {
    //     log.trace('inside', edge.toCluster, point, lastPointOutside);
    //     // First point inside the rect
    //     const inter = intersection(node, lastPointOutside, point);
    //     let pointPresent = false;
    //     points.forEach(p => {
    //       pointPresent = pointPresent || (p.x === inter.x && p.y === inter.y);
    //     });
    //     // if (!pointPresent) {
    //     if (!points.find(e => e.x === inter.x && e.y === inter.y)) {
    //       points.push(inter);
    //     } else {
    //       log.warn('no intersect', inter, points);
    //     }
    //     isInside = true;
    // } else {
    //   // outtside
    //   lastPointOutside = point;
    //   if (!isInside) points.push(point);
    // }
    // });

    pointsHasChanged = true;
  }

  if (edge.fromCluster) {
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('from cluster abc88', clusterDb[edge.fromCluster]);
    points = cutPathAtIntersect(points.reverse(), clusterDb[edge.fromCluster].node).reverse(); // log.warn('edge', edge);
    // log.warn('from cluster', clusterDb[edge.fromCluster], points);
    // const updatedPoints = [];
    // let lastPointOutside = edge.points[edge.points.length - 1];
    // let isInside = false;
    // for (let i = points.length - 1; i >= 0; i--) {
    //   const point = points[i];
    //   const node = clusterDb[edge.fromCluster].node;
    //   log.warn('checking to', edge.fromCluster, point, node);
    //   if (!outsideNode(node, point) && !isInside) {
    //     log.warn('inside', edge.fromCluster, point, node);
    //     // First point inside the rect
    //     const inter = intersection(node, lastPointOutside, point);
    //     log.warn('intersect', intersection(node, lastPointOutside, point));
    //     let pointPresent = false;
    //     points.forEach(p => {
    //       pointPresent = pointPresent || (p.x === inter.x && p.y === inter.y);
    //     });
    //     // if (!pointPresent) {
    //     if (!points.find(e => e.x === inter.x && e.y === inter.y)) {
    //       updatedPoints.unshift(inter);
    //       log.warn('Adding point -updated = ', updatedPoints);
    //     } else {
    //       log.warn('no intersect', inter, points);
    //     }
    //     // points.push(insterection);
    //     isInside = true;
    //   } else {
    //     // at the outside
    //     // if (!isInside) updatedPoints.unshift(point);
    //     updatedPoints.unshift(point);
    //     log.warn('Outside point', point, updatedPoints);
    //   }
    //   lastPointOutside = point;
    // }
    // points = updatedPoints;
    // points = edge.points;

    pointsHasChanged = true;
  } // The data for our line


  var lineData = points.filter(function (p) {
    return !Number.isNaN(p.y);
  }); // This is the accessor function we talked about above

  var curve; // Currently only flowcharts get the curve from the settings, perhaps this should
  // be expanded to a common setting? Restricting it for now in order not to cause side-effects that
  // have not been thought through

  if (diagramType === 'graph' || diagramType === 'flowchart') {
    curve = edge.curve || d3__WEBPACK_IMPORTED_MODULE_2__["curveBasis"];
  } else {
    curve = d3__WEBPACK_IMPORTED_MODULE_2__["curveBasis"];
  } // curve = curveLinear;


  var lineFunction = Object(d3__WEBPACK_IMPORTED_MODULE_2__["line"])().x(function (d) {
    return d.x;
  }).y(function (d) {
    return d.y;
  }).curve(curve); // Contruct stroke classes based on properties

  var strokeClasses;

  switch (edge.thickness) {
    case 'normal':
      strokeClasses = 'edge-thickness-normal';
      break;

    case 'thick':
      strokeClasses = 'edge-thickness-thick';
      break;

    default:
      strokeClasses = '';
  }

  switch (edge.pattern) {
    case 'solid':
      strokeClasses += ' edge-pattern-solid';
      break;

    case 'dotted':
      strokeClasses += ' edge-pattern-dotted';
      break;

    case 'dashed':
      strokeClasses += ' edge-pattern-dashed';
      break;
  }

  var svgPath = elem.append('path').attr('d', lineFunction(lineData)).attr('id', edge.id).attr('class', ' ' + strokeClasses + (edge.classes ? ' ' + edge.classes : '')).attr('style', edge.style); // DEBUG code, adds a red circle at each edge coordinate
  // edge.points.forEach(point => {
  //   elem
  //     .append('circle')
  //     .style('stroke', 'red')
  //     .style('fill', 'red')
  //     .attr('r', 1)
  //     .attr('cx', point.x)
  //     .attr('cy', point.y);
  // });

  var url = '';

  if (Object(_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"])().state.arrowMarkerAbsolute) {
    url = window.location.protocol + '//' + window.location.host + window.location.pathname + window.location.search;
    url = url.replace(/\(/g, '\\(');
    url = url.replace(/\)/g, '\\)');
  }

  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('arrowTypeStart', edge.arrowTypeStart);
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('arrowTypeEnd', edge.arrowTypeEnd);

  switch (edge.arrowTypeStart) {
    case 'arrow_cross':
      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-crossStart' + ')');
      break;

    case 'arrow_point':
      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-pointStart' + ')');
      break;

    case 'arrow_barb':
      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-barbStart' + ')');
      break;

    case 'arrow_circle':
      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-circleStart' + ')');
      break;

    case 'aggregation':
      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-aggregationStart' + ')');
      break;

    case 'extension':
      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-extensionStart' + ')');
      break;

    case 'composition':
      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-compositionStart' + ')');
      break;

    case 'dependency':
      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-dependencyStart' + ')');
      break;

    default:
  }

  switch (edge.arrowTypeEnd) {
    case 'arrow_cross':
      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-crossEnd' + ')');
      break;

    case 'arrow_point':
      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-pointEnd' + ')');
      break;

    case 'arrow_barb':
      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-barbEnd' + ')');
      break;

    case 'arrow_circle':
      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-circleEnd' + ')');
      break;

    case 'aggregation':
      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-aggregationEnd' + ')');
      break;

    case 'extension':
      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-extensionEnd' + ')');
      break;

    case 'composition':
      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-compositionEnd' + ')');
      break;

    case 'dependency':
      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-dependencyEnd' + ')');
      break;

    default:
  }

  var paths = {};

  if (pointsHasChanged) {
    paths.updatedPath = points;
  }

  paths.originalPath = edge.points;
  return paths;
};

/***/ }),

/***/ "./src/dagre-wrapper/index.js":
/*!************************************!*\
  !*** ./src/dagre-wrapper/index.js ***!
  \************************************/
/*! exports provided: render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony import */ var dagre__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dagre */ "dagre");
/* harmony import */ var dagre__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dagre__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! graphlib */ "graphlib");
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(graphlib__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _markers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./markers */ "./src/dagre-wrapper/markers.js");
/* harmony import */ var _shapes_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shapes/util */ "./src/dagre-wrapper/shapes/util.js");
/* harmony import */ var _mermaid_graphlib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mermaid-graphlib */ "./src/dagre-wrapper/mermaid-graphlib.js");
/* harmony import */ var _nodes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./nodes */ "./src/dagre-wrapper/nodes.js");
/* harmony import */ var _clusters__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./clusters */ "./src/dagre-wrapper/clusters.js");
/* harmony import */ var _edges__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./edges */ "./src/dagre-wrapper/edges.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../logger */ "./src/logger.js");










var recursiveRender = function recursiveRender(_elem, graph, diagramtype, parentCluster) {
  _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('Graph in recursive render: XXX', graphlib__WEBPACK_IMPORTED_MODULE_1___default.a.json.write(graph), parentCluster);
  var dir = graph.graph().rankdir;
  _logger__WEBPACK_IMPORTED_MODULE_8__["log"].trace('Dir in recursive render - dir:', dir);

  var elem = _elem.insert('g').attr('class', 'root'); // eslint-disable-line


  if (!graph.nodes()) {
    _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('No nodes found for', graph);
  } else {
    _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('Recursive render XXX', graph.nodes());
  }

  if (graph.edges().length > 0) {
    _logger__WEBPACK_IMPORTED_MODULE_8__["log"].trace('Recursive edges', graph.edge(graph.edges()[0]));
  }

  var clusters = elem.insert('g').attr('class', 'clusters'); // eslint-disable-line

  var edgePaths = elem.insert('g').attr('class', 'edgePaths');
  var edgeLabels = elem.insert('g').attr('class', 'edgeLabels');
  var nodes = elem.insert('g').attr('class', 'nodes'); // Insert nodes, this will insert them into the dom and each node will get a size. The size is updated
  // to the abstract node and is later used by dagre for the layout

  graph.nodes().forEach(function (v) {
    var node = graph.node(v);

    if (typeof parentCluster !== 'undefined') {
      var data = JSON.parse(JSON.stringify(parentCluster.clusterData)); // data.clusterPositioning = true;

      _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('Setting data for cluster XXX (', v, ') ', data, parentCluster);
      graph.setNode(parentCluster.id, data);

      if (!graph.parent(v)) {
        _logger__WEBPACK_IMPORTED_MODULE_8__["log"].trace('Setting parent', v, parentCluster.id);
        graph.setParent(v, parentCluster.id, data);
      }
    }

    _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('(Insert) Node XXX' + v + ': ' + JSON.stringify(graph.node(v)));

    if (node && node.clusterNode) {
      // const children = graph.children(v);
      _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('Cluster identified', v, node.width, graph.node(v));
      var o = recursiveRender(nodes, node.graph, diagramtype, graph.node(v));
      var newEl = o.elem;
      Object(_shapes_util__WEBPACK_IMPORTED_MODULE_3__["updateNodeBounds"])(node, newEl);
      node.diff = o.diff || 0;
      _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('Node bounds (abc123)', v, node, node.width, node.x, node.y);
      Object(_nodes__WEBPACK_IMPORTED_MODULE_5__["setNodeElem"])(newEl, node);
      _logger__WEBPACK_IMPORTED_MODULE_8__["log"].warn('Recursive render complete ', newEl, node);
    } else {
      if (graph.children(v).length > 0) {
        // This is a cluster but not to be rendered recusively
        // Render as before
        _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('Cluster - the non recursive path XXX', v, node.id, node, graph);
        _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info(Object(_mermaid_graphlib__WEBPACK_IMPORTED_MODULE_4__["findNonClusterChild"])(node.id, graph));
        _mermaid_graphlib__WEBPACK_IMPORTED_MODULE_4__["clusterDb"][node.id] = {
          id: Object(_mermaid_graphlib__WEBPACK_IMPORTED_MODULE_4__["findNonClusterChild"])(node.id, graph),
          node: node
        }; // insertCluster(clusters, graph.node(v));
      } else {
        _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('Node - the non recursive path', v, node.id, node);
        Object(_nodes__WEBPACK_IMPORTED_MODULE_5__["insertNode"])(nodes, graph.node(v), dir);
      }
    }
  }); // Insert labels, this will insert them into the dom so that the width can be calculated
  // Also figure out which edges point to/from clusters and adjust them accordingly
  // Edges from/to clusters really points to the first child in the cluster.
  // TODO: pick optimal child in the cluster to us as link anchor

  graph.edges().forEach(function (e) {
    var edge = graph.edge(e.v, e.w, e.name);
    _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));
    _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('Edge ' + e.v + ' -> ' + e.w + ': ', e, ' ', JSON.stringify(graph.edge(e))); // Check if link is either from or to a cluster

    _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('Fix', _mermaid_graphlib__WEBPACK_IMPORTED_MODULE_4__["clusterDb"], 'ids:', e.v, e.w, 'Translateing: ', _mermaid_graphlib__WEBPACK_IMPORTED_MODULE_4__["clusterDb"][e.v], _mermaid_graphlib__WEBPACK_IMPORTED_MODULE_4__["clusterDb"][e.w]);
    Object(_edges__WEBPACK_IMPORTED_MODULE_7__["insertEdgeLabel"])(edgeLabels, edge);
  });
  graph.edges().forEach(function (e) {
    _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));
  });
  _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('#############################################');
  _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('###                Layout                 ###');
  _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('#############################################');
  _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info(graph);
  dagre__WEBPACK_IMPORTED_MODULE_0___default.a.layout(graph);
  _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('Graph after layout:', graphlib__WEBPACK_IMPORTED_MODULE_1___default.a.json.write(graph)); // Move the nodes to the correct place

  var diff = 0;
  Object(_mermaid_graphlib__WEBPACK_IMPORTED_MODULE_4__["sortNodesByHierarchy"])(graph).forEach(function (v) {
    var node = graph.node(v);
    _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('Position ' + v + ': ' + JSON.stringify(graph.node(v)));
    _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('Position ' + v + ': (' + node.x, ',' + node.y, ') width: ', node.width, ' height: ', node.height);

    if (node && node.clusterNode) {
      // clusterDb[node.id].node = node;
      Object(_nodes__WEBPACK_IMPORTED_MODULE_5__["positionNode"])(node);
    } else {
      // Non cluster node
      if (graph.children(v).length > 0) {
        // A cluster in the non-recurive way
        // positionCluster(node);
        Object(_clusters__WEBPACK_IMPORTED_MODULE_6__["insertCluster"])(clusters, node);
        _mermaid_graphlib__WEBPACK_IMPORTED_MODULE_4__["clusterDb"][node.id].node = node;
      } else {
        Object(_nodes__WEBPACK_IMPORTED_MODULE_5__["positionNode"])(node);
      }
    }
  }); // Move the edge labels to the correct place after layout

  graph.edges().forEach(function (e) {
    var edge = graph.edge(e);
    _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(edge), edge);
    var paths = Object(_edges__WEBPACK_IMPORTED_MODULE_7__["insertEdge"])(edgePaths, e, edge, _mermaid_graphlib__WEBPACK_IMPORTED_MODULE_4__["clusterDb"], diagramtype, graph);
    Object(_edges__WEBPACK_IMPORTED_MODULE_7__["positionEdgeLabel"])(edge, paths);
  });
  graph.nodes().forEach(function (v) {
    var n = graph.node(v);
    _logger__WEBPACK_IMPORTED_MODULE_8__["log"].info(v, n.type, n.diff);

    if (n.type === 'group') {
      diff = n.diff;
    }
  });
  return {
    elem: elem,
    diff: diff
  };
};

var render = function render(elem, graph, markers, diagramtype, id) {
  Object(_markers__WEBPACK_IMPORTED_MODULE_2__["default"])(elem, markers, diagramtype, id);
  Object(_nodes__WEBPACK_IMPORTED_MODULE_5__["clear"])();
  Object(_edges__WEBPACK_IMPORTED_MODULE_7__["clear"])();
  Object(_clusters__WEBPACK_IMPORTED_MODULE_6__["clear"])();
  Object(_mermaid_graphlib__WEBPACK_IMPORTED_MODULE_4__["clear"])();
  _logger__WEBPACK_IMPORTED_MODULE_8__["log"].warn('Graph at first:', graphlib__WEBPACK_IMPORTED_MODULE_1___default.a.json.write(graph));
  Object(_mermaid_graphlib__WEBPACK_IMPORTED_MODULE_4__["adjustClustersAndEdges"])(graph);
  _logger__WEBPACK_IMPORTED_MODULE_8__["log"].warn('Graph after:', graphlib__WEBPACK_IMPORTED_MODULE_1___default.a.json.write(graph)); // log.warn('Graph ever  after:', graphlib.json.write(graph.node('A').graph));

  recursiveRender(elem, graph, diagramtype);
}; // const shapeDefinitions = {};
// export const addShape = ({ shapeType: fun }) => {
//   shapeDefinitions[shapeType] = fun;
// };
// const arrowDefinitions = {};
// export const addArrow = ({ arrowType: fun }) => {
//   arrowDefinitions[arrowType] = fun;
// };

/***/ }),

/***/ "./src/dagre-wrapper/intersect/index.js":
/*!**********************************************!*\
  !*** ./src/dagre-wrapper/intersect/index.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _intersect_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./intersect-node.js */ "./src/dagre-wrapper/intersect/intersect-node.js");
/* harmony import */ var _intersect_node_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_intersect_node_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _intersect_circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./intersect-circle.js */ "./src/dagre-wrapper/intersect/intersect-circle.js");
/* harmony import */ var _intersect_ellipse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./intersect-ellipse.js */ "./src/dagre-wrapper/intersect/intersect-ellipse.js");
/* harmony import */ var _intersect_polygon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./intersect-polygon.js */ "./src/dagre-wrapper/intersect/intersect-polygon.js");
/* harmony import */ var _intersect_rect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./intersect-rect.js */ "./src/dagre-wrapper/intersect/intersect-rect.js");
/*
 * Borrowed with love from from dagrge-d3. Many thanks to cpettitt!
 */





/* harmony default export */ __webpack_exports__["default"] = ({
  node: _intersect_node_js__WEBPACK_IMPORTED_MODULE_0___default.a,
  circle: _intersect_circle_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  ellipse: _intersect_ellipse_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygon: _intersect_polygon_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  rect: _intersect_rect_js__WEBPACK_IMPORTED_MODULE_4__["default"]
});

/***/ }),

/***/ "./src/dagre-wrapper/intersect/intersect-circle.js":
/*!*********************************************************!*\
  !*** ./src/dagre-wrapper/intersect/intersect-circle.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _intersect_ellipse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./intersect-ellipse */ "./src/dagre-wrapper/intersect/intersect-ellipse.js");


function intersectCircle(node, rx, point) {
  return Object(_intersect_ellipse__WEBPACK_IMPORTED_MODULE_0__["default"])(node, rx, rx, point);
}

/* harmony default export */ __webpack_exports__["default"] = (intersectCircle);

/***/ }),

/***/ "./src/dagre-wrapper/intersect/intersect-ellipse.js":
/*!**********************************************************!*\
  !*** ./src/dagre-wrapper/intersect/intersect-ellipse.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function intersectEllipse(node, rx, ry, point) {
  // Formulae from: http://mathworld.wolfram.com/Ellipse-LineIntersection.html
  var cx = node.x;
  var cy = node.y;
  var px = cx - point.x;
  var py = cy - point.y;
  var det = Math.sqrt(rx * rx * py * py + ry * ry * px * px);
  var dx = Math.abs(rx * ry * px / det);

  if (point.x < cx) {
    dx = -dx;
  }

  var dy = Math.abs(rx * ry * py / det);

  if (point.y < cy) {
    dy = -dy;
  }

  return {
    x: cx + dx,
    y: cy + dy
  };
}

/* harmony default export */ __webpack_exports__["default"] = (intersectEllipse);

/***/ }),

/***/ "./src/dagre-wrapper/intersect/intersect-line.js":
/*!*******************************************************!*\
  !*** ./src/dagre-wrapper/intersect/intersect-line.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*
 * Returns the point at which two lines, p and q, intersect or returns
 * undefined if they do not intersect.
 */
function intersectLine(p1, p2, q1, q2) {
  // Algorithm from J. Avro, (ed.) Graphics Gems, No 2, Morgan Kaufmann, 1994,
  // p7 and p473.
  var a1, a2, b1, b2, c1, c2;
  var r1, r2, r3, r4;
  var denom, offset, num;
  var x, y; // Compute a1, b1, c1, where line joining points 1 and 2 is F(x,y) = a1 x +
  // b1 y + c1 = 0.

  a1 = p2.y - p1.y;
  b1 = p1.x - p2.x;
  c1 = p2.x * p1.y - p1.x * p2.y; // Compute r3 and r4.

  r3 = a1 * q1.x + b1 * q1.y + c1;
  r4 = a1 * q2.x + b1 * q2.y + c1; // Check signs of r3 and r4. If both point 3 and point 4 lie on
  // same side of line 1, the line segments do not intersect.

  if (r3 !== 0 && r4 !== 0 && sameSign(r3, r4)) {
    return;
  } // Compute a2, b2, c2 where line joining points 3 and 4 is G(x,y) = a2 x + b2 y + c2 = 0


  a2 = q2.y - q1.y;
  b2 = q1.x - q2.x;
  c2 = q2.x * q1.y - q1.x * q2.y; // Compute r1 and r2

  r1 = a2 * p1.x + b2 * p1.y + c2;
  r2 = a2 * p2.x + b2 * p2.y + c2; // Check signs of r1 and r2. If both point 1 and point 2 lie
  // on same side of second line segment, the line segments do
  // not intersect.

  if (r1 !== 0 && r2 !== 0 && sameSign(r1, r2)) {
    return;
  } // Line segments intersect: compute intersection point.


  denom = a1 * b2 - a2 * b1;

  if (denom === 0) {
    return;
  }

  offset = Math.abs(denom / 2); // The denom/2 is to get rounding instead of truncating. It
  // is added or subtracted to the numerator, depending upon the
  // sign of the numerator.

  num = b1 * c2 - b2 * c1;
  x = num < 0 ? (num - offset) / denom : (num + offset) / denom;
  num = a2 * c1 - a1 * c2;
  y = num < 0 ? (num - offset) / denom : (num + offset) / denom;
  return {
    x: x,
    y: y
  };
}

function sameSign(r1, r2) {
  return r1 * r2 > 0;
}

/* harmony default export */ __webpack_exports__["default"] = (intersectLine);

/***/ }),

/***/ "./src/dagre-wrapper/intersect/intersect-node.js":
/*!*******************************************************!*\
  !*** ./src/dagre-wrapper/intersect/intersect-node.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = intersectNode;

function intersectNode(node, point) {
  // console.info('Intersect Node');
  return node.intersect(point);
}

/***/ }),

/***/ "./src/dagre-wrapper/intersect/intersect-polygon.js":
/*!**********************************************************!*\
  !*** ./src/dagre-wrapper/intersect/intersect-polygon.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _intersect_line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./intersect-line */ "./src/dagre-wrapper/intersect/intersect-line.js");
/* eslint "no-console": off */

/* harmony default export */ __webpack_exports__["default"] = (intersectPolygon);
/*
 * Returns the point ({x, y}) at which the point argument intersects with the
 * node argument assuming that it has the shape specified by polygon.
 */

function intersectPolygon(node, polyPoints, point) {
  var x1 = node.x;
  var y1 = node.y;
  var intersections = [];
  var minX = Number.POSITIVE_INFINITY;
  var minY = Number.POSITIVE_INFINITY;

  if (typeof polyPoints.forEach === 'function') {
    polyPoints.forEach(function (entry) {
      minX = Math.min(minX, entry.x);
      minY = Math.min(minY, entry.y);
    });
  } else {
    minX = Math.min(minX, polyPoints.x);
    minY = Math.min(minY, polyPoints.y);
  }

  var left = x1 - node.width / 2 - minX;
  var top = y1 - node.height / 2 - minY;

  for (var i = 0; i < polyPoints.length; i++) {
    var p1 = polyPoints[i];
    var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];
    var intersect = Object(_intersect_line__WEBPACK_IMPORTED_MODULE_0__["default"])(node, point, {
      x: left + p1.x,
      y: top + p1.y
    }, {
      x: left + p2.x,
      y: top + p2.y
    });

    if (intersect) {
      intersections.push(intersect);
    }
  }

  if (!intersections.length) {
    // console.log('NO INTERSECTION FOUND, RETURN NODE CENTER', node);
    return node;
  }

  if (intersections.length > 1) {
    // More intersections, find the one nearest to edge end point
    intersections.sort(function (p, q) {
      var pdx = p.x - point.x;
      var pdy = p.y - point.y;
      var distp = Math.sqrt(pdx * pdx + pdy * pdy);
      var qdx = q.x - point.x;
      var qdy = q.y - point.y;
      var distq = Math.sqrt(qdx * qdx + qdy * qdy);
      return distp < distq ? -1 : distp === distq ? 0 : 1;
    });
  }

  return intersections[0];
}

/***/ }),

/***/ "./src/dagre-wrapper/intersect/intersect-rect.js":
/*!*******************************************************!*\
  !*** ./src/dagre-wrapper/intersect/intersect-rect.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var intersectRect = function intersectRect(node, point) {
  var x = node.x;
  var y = node.y; // Rectangle intersection algorithm from:
  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes

  var dx = point.x - x;
  var dy = point.y - y;
  var w = node.width / 2;
  var h = node.height / 2;
  var sx, sy;

  if (Math.abs(dy) * w > Math.abs(dx) * h) {
    // Intersection is top or bottom of rect.
    if (dy < 0) {
      h = -h;
    }

    sx = dy === 0 ? 0 : h * dx / dy;
    sy = h;
  } else {
    // Intersection is left or right of rect.
    if (dx < 0) {
      w = -w;
    }

    sx = w;
    sy = dx === 0 ? 0 : w * dy / dx;
  }

  return {
    x: x + sx,
    y: y + sy
  };
};

/* harmony default export */ __webpack_exports__["default"] = (intersectRect);

/***/ }),

/***/ "./src/dagre-wrapper/markers.js":
/*!**************************************!*\
  !*** ./src/dagre-wrapper/markers.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../logger */ "./src/logger.js");
/**
 * Setup arrow head and define the marker. The result is appended to the svg.
 */
 // Only add the number of markers that the diagram needs

var insertMarkers = function insertMarkers(elem, markerArray, type, id) {
  markerArray.forEach(function (markerName) {
    markers[markerName](elem, type, id);
  });
};

var extension = function extension(elem, type, id) {
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].trace('Making markers for ', id);
  elem.append('defs').append('marker').attr('id', type + '-extensionStart').attr('class', 'marker extension ' + type).attr('refX', 0).attr('refY', 7).attr('markerWidth', 190).attr('markerHeight', 240).attr('orient', 'auto').append('path').attr('d', 'M 1,7 L18,13 V 1 Z');
  elem.append('defs').append('marker').attr('id', type + '-extensionEnd').attr('class', 'marker extension ' + type).attr('refX', 19).attr('refY', 7).attr('markerWidth', 20).attr('markerHeight', 28).attr('orient', 'auto').append('path').attr('d', 'M 1,1 V 13 L18,7 Z'); // this is actual shape for arrowhead
};

var composition = function composition(elem, type) {
  elem.append('defs').append('marker').attr('id', type + '-compositionStart').attr('class', 'marker composition ' + type).attr('refX', 0).attr('refY', 7).attr('markerWidth', 190).attr('markerHeight', 240).attr('orient', 'auto').append('path').attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z');
  elem.append('defs').append('marker').attr('id', type + '-compositionEnd').attr('class', 'marker composition ' + type).attr('refX', 19).attr('refY', 7).attr('markerWidth', 20).attr('markerHeight', 28).attr('orient', 'auto').append('path').attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z');
};

var aggregation = function aggregation(elem, type) {
  elem.append('defs').append('marker').attr('id', type + '-aggregationStart').attr('class', 'marker aggregation ' + type).attr('refX', 0).attr('refY', 7).attr('markerWidth', 190).attr('markerHeight', 240).attr('orient', 'auto').append('path').attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z');
  elem.append('defs').append('marker').attr('id', type + '-aggregationEnd').attr('class', 'marker aggregation ' + type).attr('refX', 19).attr('refY', 7).attr('markerWidth', 20).attr('markerHeight', 28).attr('orient', 'auto').append('path').attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z');
};

var dependency = function dependency(elem, type) {
  elem.append('defs').append('marker').attr('id', type + '-dependencyStart').attr('class', 'marker dependency ' + type).attr('refX', 0).attr('refY', 7).attr('markerWidth', 190).attr('markerHeight', 240).attr('orient', 'auto').append('path').attr('d', 'M 5,7 L9,13 L1,7 L9,1 Z');
  elem.append('defs').append('marker').attr('id', type + '-dependencyEnd').attr('class', 'marker dependency ' + type).attr('refX', 19).attr('refY', 7).attr('markerWidth', 20).attr('markerHeight', 28).attr('orient', 'auto').append('path').attr('d', 'M 18,7 L9,13 L14,7 L9,1 Z');
};

var point = function point(elem, type) {
  elem.append('marker').attr('id', type + '-pointEnd').attr('class', 'marker ' + type).attr('viewBox', '0 0 10 10').attr('refX', 9).attr('refY', 5).attr('markerUnits', 'userSpaceOnUse').attr('markerWidth', 12).attr('markerHeight', 12).attr('orient', 'auto').append('path').attr('d', 'M 0 0 L 10 5 L 0 10 z').attr('class', 'arrowMarkerPath').style('stroke-width', 1).style('stroke-dasharray', '1,0');
  elem.append('marker').attr('id', type + '-pointStart').attr('class', 'marker ' + type).attr('viewBox', '0 0 10 10').attr('refX', 0).attr('refY', 5).attr('markerUnits', 'userSpaceOnUse').attr('markerWidth', 12).attr('markerHeight', 12).attr('orient', 'auto').append('path').attr('d', 'M 0 5 L 10 10 L 10 0 z').attr('class', 'arrowMarkerPath').style('stroke-width', 1).style('stroke-dasharray', '1,0');
};

var circle = function circle(elem, type) {
  elem.append('marker').attr('id', type + '-circleEnd').attr('class', 'marker ' + type).attr('viewBox', '0 0 10 10').attr('refX', 11).attr('refY', 5).attr('markerUnits', 'userSpaceOnUse').attr('markerWidth', 11).attr('markerHeight', 11).attr('orient', 'auto').append('circle').attr('cx', '5').attr('cy', '5').attr('r', '5').attr('class', 'arrowMarkerPath').style('stroke-width', 1).style('stroke-dasharray', '1,0');
  elem.append('marker').attr('id', type + '-circleStart').attr('class', 'marker ' + type).attr('viewBox', '0 0 10 10').attr('refX', -1).attr('refY', 5).attr('markerUnits', 'userSpaceOnUse').attr('markerWidth', 11).attr('markerHeight', 11).attr('orient', 'auto').append('circle').attr('cx', '5').attr('cy', '5').attr('r', '5').attr('class', 'arrowMarkerPath').style('stroke-width', 1).style('stroke-dasharray', '1,0');
};

var cross = function cross(elem, type) {
  elem.append('marker').attr('id', type + '-crossEnd').attr('class', 'marker cross ' + type).attr('viewBox', '0 0 11 11').attr('refX', 12).attr('refY', 5.2).attr('markerUnits', 'userSpaceOnUse').attr('markerWidth', 11).attr('markerHeight', 11).attr('orient', 'auto').append('path') // .attr('stroke', 'black')
  .attr('d', 'M 1,1 l 9,9 M 10,1 l -9,9').attr('class', 'arrowMarkerPath').style('stroke-width', 2).style('stroke-dasharray', '1,0');
  elem.append('marker').attr('id', type + '-crossStart').attr('class', 'marker cross ' + type).attr('viewBox', '0 0 11 11').attr('refX', -1).attr('refY', 5.2).attr('markerUnits', 'userSpaceOnUse').attr('markerWidth', 11).attr('markerHeight', 11).attr('orient', 'auto').append('path') // .attr('stroke', 'black')
  .attr('d', 'M 1,1 l 9,9 M 10,1 l -9,9').attr('class', 'arrowMarkerPath').style('stroke-width', 2).style('stroke-dasharray', '1,0');
};

var barb = function barb(elem, type) {
  elem.append('defs').append('marker').attr('id', type + '-barbEnd').attr('refX', 19).attr('refY', 7).attr('markerWidth', 20).attr('markerHeight', 14).attr('markerUnits', 'strokeWidth').attr('orient', 'auto').append('path').attr('d', 'M 19,7 L9,13 L14,7 L9,1 Z');
}; // TODO rename the class diagram markers to something shape descriptive and semanitc free


var markers = {
  extension: extension,
  composition: composition,
  aggregation: aggregation,
  dependency: dependency,
  point: point,
  circle: circle,
  cross: cross,
  barb: barb
};
/* harmony default export */ __webpack_exports__["default"] = (insertMarkers);

/***/ }),

/***/ "./src/dagre-wrapper/mermaid-graphlib.js":
/*!***********************************************!*\
  !*** ./src/dagre-wrapper/mermaid-graphlib.js ***!
  \***********************************************/
/*! exports provided: clusterDb, clear, extractDecendants, validate, findNonClusterChild, adjustClustersAndEdges, extractor, sortNodesByHierarchy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clusterDb", function() { return clusterDb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractDecendants", function() { return extractDecendants; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validate", function() { return validate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findNonClusterChild", function() { return findNonClusterChild; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjustClustersAndEdges", function() { return adjustClustersAndEdges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractor", function() { return extractor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortNodesByHierarchy", function() { return sortNodesByHierarchy; });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../logger */ "./src/logger.js");
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! graphlib */ "graphlib");
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(graphlib__WEBPACK_IMPORTED_MODULE_1__);
/**
 * Decorates with functions required by mermaids dagre-wrapper.
 */


var clusterDb = {};
var decendants = {};
var parents = {};
var clear = function clear() {
  decendants = {};
  parents = {};
  clusterDb = {};
};

var isDecendant = function isDecendant(id, ancenstorId) {
  // if (id === ancenstorId) return true;
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].trace('In isDecendant', ancenstorId, ' ', id, ' = ', decendants[ancenstorId].indexOf(id) >= 0);
  if (decendants[ancenstorId].indexOf(id) >= 0) return true;
  return false;
};

var edgeInCluster = function edgeInCluster(edge, clusterId) {
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('Decendants of ', clusterId, ' is ', decendants[clusterId]);
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('Edge is ', edge); // Edges to/from the cluster is not in the cluster, they are in the parent

  if (edge.v === clusterId) return false;
  if (edge.w === clusterId) return false;

  if (!decendants[clusterId]) {
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Tilt, ', clusterId, ',not in decendants');
    return false;
  }

  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('Here ');
  if (decendants[clusterId].indexOf(edge.v) >= 0) return true;
  if (isDecendant(edge.v, clusterId)) return true;
  if (isDecendant(edge.w, clusterId)) return true;
  if (decendants[clusterId].indexOf(edge.w) >= 0) return true;
  return false;
};

var copy = function copy(clusterId, graph, newGraph, rootId) {
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('Copying children of ', clusterId, 'root', rootId, 'data', graph.node(clusterId), rootId);
  var nodes = graph.children(clusterId) || []; // Include cluster node if it is not the root

  if (clusterId !== rootId) {
    nodes.push(clusterId);
  }

  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('Copying (nodes) clusterId', clusterId, 'nodes', nodes);
  nodes.forEach(function (node) {
    if (graph.children(node).length > 0) {
      copy(node, graph, newGraph, rootId);
    } else {
      var data = graph.node(node);
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('cp ', node, ' to ', rootId, ' with parent ', clusterId); //,node, data, ' parent is ', clusterId);

      newGraph.setNode(node, data);

      if (rootId !== graph.parent(node)) {
        _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('Setting parent', node, graph.parent(node));
        newGraph.setParent(node, graph.parent(node));
      }

      if (clusterId !== rootId && node !== clusterId) {
        _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Setting parent', node, clusterId);
        newGraph.setParent(node, clusterId);
      } else {
        _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('In copy ', clusterId, 'root', rootId, 'data', graph.node(clusterId), rootId);
        _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Not Setting parent for node=', node, 'cluster!==rootId', clusterId !== rootId, 'node!==clusterId', node !== clusterId);
      }

      var edges = graph.edges(node);
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Copying Edges', edges);
      edges.forEach(function (edge) {
        _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('Edge', edge);
        var data = graph.edge(edge.v, edge.w, edge.name);
        _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('Edge data', data, rootId);

        try {
          // Do not copy edges in and out of the root cluster, they belong to the parent graph
          if (edgeInCluster(edge, rootId)) {
            _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('Copying as ', edge.v, edge.w, data, edge.name);
            newGraph.setEdge(edge.v, edge.w, data, edge.name);
            _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('newGraph edges ', newGraph.edges(), newGraph.edge(newGraph.edges()[0]));
          } else {
            _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('Skipping copy of edge ', edge.v, '-->', edge.w, ' rootId: ', rootId, ' clusterId:', clusterId);
          }
        } catch (e) {
          _logger__WEBPACK_IMPORTED_MODULE_0__["log"].error(e);
        }
      });
    }

    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Removing node', node);
    graph.removeNode(node);
  });
};

var extractDecendants = function extractDecendants(id, graph) {
  // log.debug('Extracting ', id);
  var children = graph.children(id);
  var res = [].concat(children);

  for (var i = 0; i < children.length; i++) {
    parents[children[i]] = id;
    res = res.concat(extractDecendants(children[i], graph));
  }

  return res;
};
/**
 * Validates the graph, checking that all parent child relation points to existing nodes and that
 * edges between nodes also ia correct. When not correct the function logs the discrepancies.
 * @param {graphlib graph} g
 */

var validate = function validate(graph) {
  var edges = graph.edges();
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].trace('Edges: ', edges);

  for (var i = 0; i < edges.length; i++) {
    if (graph.children(edges[i].v).length > 0) {
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].trace('The node ', edges[i].v, ' is part of and edge even though it has children');
      return false;
    }

    if (graph.children(edges[i].w).length > 0) {
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].trace('The node ', edges[i].w, ' is part of and edge even though it has children');
      return false;
    }
  }

  return true;
};
/**
 * Finds a child that is not a cluster. When faking a edge between a node and a cluster.
 * @param {Finds a } id
 * @param {*} graph
 */

var findNonClusterChild = function findNonClusterChild(id, graph) {
  // const node = graph.node(id);
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].trace('Searching', id); // const children = graph.children(id).reverse();

  var children = graph.children(id); //.reverse();

  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].trace('Searching children of id ', id, children);

  if (children.length < 1) {
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].trace('This is a valid node', id);
    return id;
  }

  for (var i = 0; i < children.length; i++) {
    var _id = findNonClusterChild(children[i], graph);

    if (_id) {
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].trace('Found replacement for', id, ' => ', _id);
      return _id;
    }
  }
};

var getAnchorId = function getAnchorId(id) {
  if (!clusterDb[id]) {
    return id;
  } // If the cluster has no external connections


  if (!clusterDb[id].externalConnections) {
    return id;
  } // Return the replacement node


  if (clusterDb[id]) {
    return clusterDb[id].id;
  }

  return id;
};

var adjustClustersAndEdges = function adjustClustersAndEdges(graph, depth) {
  if (!graph || depth > 10) {
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Opting out, no graph ');
    return;
  } else {
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Opting in, graph ');
  } // Go through the nodes and for each cluster found, save a replacment node, this can be used when
  // faking a link to a cluster


  graph.nodes().forEach(function (id) {
    var children = graph.children(id);

    if (children.length > 0) {
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('Cluster identified', id, ' Replacement id in edges: ', findNonClusterChild(id, graph));
      decendants[id] = extractDecendants(id, graph);
      clusterDb[id] = {
        id: findNonClusterChild(id, graph),
        clusterData: graph.node(id)
      };
    }
  }); // Check incoming and outgoing edges for each cluster

  graph.nodes().forEach(function (id) {
    var children = graph.children(id);
    var edges = graph.edges();

    if (children.length > 0) {
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Cluster identified', id, decendants);
      edges.forEach(function (edge) {
        // log.debug('Edge, decendants: ', edge, decendants[id]);
        // Check if any edge leaves the cluster (not the actual cluster, thats a link from the box)
        if (edge.v !== id && edge.w !== id) {
          // Any edge where either the one of the nodes is decending to the cluster but not the other
          // if (decendants[id].indexOf(edge.v) < 0 && decendants[id].indexOf(edge.w) < 0) {
          var d1 = isDecendant(edge.v, id);
          var d2 = isDecendant(edge.w, id); // d1 xor d2 - if either d1 is true and d2 is false or the other way around

          if (d1 ^ d2) {
            _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('Edge: ', edge, ' leaves cluster ', id);
            _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('Decendants of XXX ', id, ': ', decendants[id]);
            clusterDb[id].externalConnections = true;
          }
        }
      });
    } else {
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Not a cluster ', id, decendants);
    }
  }); // For clusters with incoming and/or outgoing edges translate those edges to a real node
  // in the cluster inorder to fake the edge

  graph.edges().forEach(function (e) {
    var edge = graph.edge(e);
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(graph.edge(e)));
    var v = e.v;
    var w = e.w; // Check if link is either from or to a cluster

    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('Fix XXX', clusterDb, 'ids:', e.v, e.w, 'Translateing: ', clusterDb[e.v], ' --- ', clusterDb[e.w]);

    if (clusterDb[e.v] || clusterDb[e.w]) {
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('Fixing and trixing - removing XXX', e.v, e.w, e.name);
      v = getAnchorId(e.v);
      w = getAnchorId(e.w);
      graph.removeEdge(e.v, e.w, e.name);
      if (v !== e.v) edge.fromCluster = e.v;
      if (w !== e.w) edge.toCluster = e.w;
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('Fix Replacing with XXX', v, w, e.name);
      graph.setEdge(v, w, edge, e.name);
    }
  });
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('Adjusted Graph', graphlib__WEBPACK_IMPORTED_MODULE_1___default.a.json.write(graph));
  extractor(graph, 0);
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].trace(clusterDb); // Remove references to extracted cluster
  // graph.edges().forEach(edge => {
  //   if (isDecendant(edge.v, clusterId) || isDecendant(edge.w, clusterId)) {
  //     graph.removeEdge(edge);
  //   }
  // });
};
var extractor = function extractor(graph, depth) {
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('extractor - ', depth, graphlib__WEBPACK_IMPORTED_MODULE_1___default.a.json.write(graph), graph.children('D'));

  if (depth > 10) {
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].error('Bailing out');
    return;
  } // For clusters without incoming and/or outgoing edges, create a new cluster-node
  // containing the nodes and edges in the custer in a new graph
  // for (let i = 0;)


  var nodes = graph.nodes();
  var hasChildren = false;

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var children = graph.children(node);
    hasChildren = hasChildren || children.length > 0;
  }

  if (!hasChildren) {
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Done, no node has children', graph.nodes());
    return;
  } // const clusters = Object.keys(clusterDb);
  // clusters.forEach(clusterId => {


  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Nodes = ', nodes, depth);

  for (var _i = 0; _i < nodes.length; _i++) {
    var _node = nodes[_i];
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Extracting node', _node, clusterDb, clusterDb[_node] && !clusterDb[_node].externalConnections, !graph.parent(_node), graph.node(_node), graph.children('D'), ' Depth ', depth); // Note that the node might have been removed after the Object.keys call so better check
    // that it still is in the game

    if (!clusterDb[_node]) {
      // Skip if the node is not a cluster
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Not a cluster', _node, depth); // break;
    } else if (!clusterDb[_node].externalConnections && // !graph.parent(node) &&
    graph.children(_node) && graph.children(_node).length > 0) {
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('Cluster without external connections, without a parent and with children', _node, depth);
      var graphSettings = graph.graph();
      var dir = graphSettings.rankdir === 'TB' ? 'LR' : 'TB';

      if (clusterDb[_node]) {
        if (clusterDb[_node].clusterData && clusterDb[_node].clusterData.dir) {
          dir = clusterDb[_node].clusterData.dir;
          _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('Fixing dir', clusterDb[_node].clusterData.dir, dir);
        }
      }

      var clusterGraph = new graphlib__WEBPACK_IMPORTED_MODULE_1___default.a.Graph({
        multigraph: true,
        compound: true
      }).setGraph({
        rankdir: dir,
        // Todo: set proper spacing
        nodesep: 50,
        ranksep: 50,
        marginx: 8,
        marginy: 8
      }).setDefaultEdgeLabel(function () {
        return {};
      });
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('Old graph before copy', graphlib__WEBPACK_IMPORTED_MODULE_1___default.a.json.write(graph));
      copy(_node, graph, clusterGraph, _node);
      graph.setNode(_node, {
        clusterNode: true,
        id: _node,
        clusterData: clusterDb[_node].clusterData,
        labelText: clusterDb[_node].labelText,
        graph: clusterGraph
      });
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('New graph after copy node: (', _node, ')', graphlib__WEBPACK_IMPORTED_MODULE_1___default.a.json.write(clusterGraph));
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Old graph after copy', graphlib__WEBPACK_IMPORTED_MODULE_1___default.a.json.write(graph));
    } else {
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('Cluster ** ', _node, ' **not meeting the criteria !externalConnections:', !clusterDb[_node].externalConnections, ' no parent: ', !graph.parent(_node), ' children ', graph.children(_node) && graph.children(_node).length > 0, graph.children('D'), depth);
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug(clusterDb);
    }
  }

  nodes = graph.nodes();
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('New list of nodes', nodes);

  for (var _i2 = 0; _i2 < nodes.length; _i2++) {
    var _node2 = nodes[_i2];
    var data = graph.node(_node2);
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn(' Now next level', _node2, data);

    if (data.clusterNode) {
      extractor(data.graph, depth + 1);
    }
  }
};

var sorter = function sorter(graph, nodes) {
  if (nodes.length === 0) return [];
  var result = Object.assign(nodes);
  nodes.forEach(function (node) {
    var children = graph.children(node);
    var sorted = sorter(graph, children);
    result = result.concat(sorted);
  });
  return result;
};

var sortNodesByHierarchy = function sortNodesByHierarchy(graph) {
  return sorter(graph, graph.children());
};

/***/ }),

/***/ "./src/dagre-wrapper/nodes.js":
/*!************************************!*\
  !*** ./src/dagre-wrapper/nodes.js ***!
  \************************************/
/*! exports provided: insertNode, setNodeElem, clear, positionNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertNode", function() { return insertNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setNodeElem", function() { return setNodeElem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "positionNode", function() { return positionNode; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logger */ "./src/logger.js");
/* harmony import */ var _shapes_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shapes/util */ "./src/dagre-wrapper/shapes/util.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config */ "./src/config.js");
/* harmony import */ var _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./intersect/index.js */ "./src/dagre-wrapper/intersect/index.js");
/* harmony import */ var _createLabel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createLabel */ "./src/dagre-wrapper/createLabel.js");
/* harmony import */ var _shapes_note__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shapes/note */ "./src/dagre-wrapper/shapes/note.js");
/* harmony import */ var _diagrams_class_svgDraw__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../diagrams/class/svgDraw */ "./src/diagrams/class/svgDraw.js");
/* harmony import */ var _diagrams_common_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../diagrams/common/common */ "./src/diagrams/common/common.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }


 // eslint-disable-line









var question = function question(parent, node) {
  var _labelHelper = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["labelHelper"])(parent, node, undefined, true),
      shapeSvg = _labelHelper.shapeSvg,
      bbox = _labelHelper.bbox;

  var w = bbox.width + node.padding;
  var h = bbox.height + node.padding;
  var s = w + h;
  var points = [{
    x: s / 2,
    y: 0
  }, {
    x: s,
    y: -s / 2
  }, {
    x: s / 2,
    y: -s
  }, {
    x: 0,
    y: -s / 2
  }];
  _logger__WEBPACK_IMPORTED_MODULE_1__["log"].info('Question main (Circle)');
  var questionElem = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["insertPolygonShape"])(shapeSvg, s, s, points);
  questionElem.attr('style', node.style);
  Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["updateNodeBounds"])(node, questionElem);

  node.intersect = function (point) {
    _logger__WEBPACK_IMPORTED_MODULE_1__["log"].warn('Intersect called');
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].polygon(node, points, point);
  };

  return shapeSvg;
};

var choice = function choice(parent, node) {
  var shapeSvg = parent.insert('g').attr('class', 'node default').attr('id', node.domId || node.id);
  var s = 28;
  var points = [{
    x: 0,
    y: s / 2
  }, {
    x: s / 2,
    y: 0
  }, {
    x: 0,
    y: -s / 2
  }, {
    x: -s / 2,
    y: 0
  }];
  var choice = shapeSvg.insert('polygon', ':first-child').attr('points', points.map(function (d) {
    return d.x + ',' + d.y;
  }).join(' ')); // center the circle around its coordinate

  choice.attr('class', 'state-start').attr('r', 7).attr('width', 28).attr('height', 28);
  node.width = 28;
  node.height = 28;

  node.intersect = function (point) {
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].circle(node, 14, point);
  };

  return shapeSvg;
};

var hexagon = function hexagon(parent, node) {
  var _labelHelper2 = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["labelHelper"])(parent, node, undefined, true),
      shapeSvg = _labelHelper2.shapeSvg,
      bbox = _labelHelper2.bbox;

  var f = 4;
  var h = bbox.height + node.padding;
  var m = h / f;
  var w = bbox.width + 2 * m + node.padding;
  var points = [{
    x: m,
    y: 0
  }, {
    x: w - m,
    y: 0
  }, {
    x: w,
    y: -h / 2
  }, {
    x: w - m,
    y: -h
  }, {
    x: m,
    y: -h
  }, {
    x: 0,
    y: -h / 2
  }];
  var hex = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["insertPolygonShape"])(shapeSvg, w, h, points);
  hex.attr('style', node.style);
  Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["updateNodeBounds"])(node, hex);

  node.intersect = function (point) {
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].polygon(node, points, point);
  };

  return shapeSvg;
};

var rect_left_inv_arrow = function rect_left_inv_arrow(parent, node) {
  var _labelHelper3 = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["labelHelper"])(parent, node, undefined, true),
      shapeSvg = _labelHelper3.shapeSvg,
      bbox = _labelHelper3.bbox;

  var w = bbox.width + node.padding;
  var h = bbox.height + node.padding;
  var points = [{
    x: -h / 2,
    y: 0
  }, {
    x: w,
    y: 0
  }, {
    x: w,
    y: -h
  }, {
    x: -h / 2,
    y: -h
  }, {
    x: 0,
    y: -h / 2
  }];
  var el = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["insertPolygonShape"])(shapeSvg, w, h, points);
  el.attr('style', node.style);
  node.width = w + h;
  node.height = h;

  node.intersect = function (point) {
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].polygon(node, points, point);
  };

  return shapeSvg;
};

var lean_right = function lean_right(parent, node) {
  var _labelHelper4 = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["labelHelper"])(parent, node, undefined, true),
      shapeSvg = _labelHelper4.shapeSvg,
      bbox = _labelHelper4.bbox;

  var w = bbox.width + node.padding;
  var h = bbox.height + node.padding;
  var points = [{
    x: -2 * h / 6,
    y: 0
  }, {
    x: w - h / 6,
    y: 0
  }, {
    x: w + 2 * h / 6,
    y: -h
  }, {
    x: h / 6,
    y: -h
  }];
  var el = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["insertPolygonShape"])(shapeSvg, w, h, points);
  el.attr('style', node.style);
  Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["updateNodeBounds"])(node, el);

  node.intersect = function (point) {
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].polygon(node, points, point);
  };

  return shapeSvg;
};

var lean_left = function lean_left(parent, node) {
  var _labelHelper5 = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["labelHelper"])(parent, node, undefined, true),
      shapeSvg = _labelHelper5.shapeSvg,
      bbox = _labelHelper5.bbox;

  var w = bbox.width + node.padding;
  var h = bbox.height + node.padding;
  var points = [{
    x: 2 * h / 6,
    y: 0
  }, {
    x: w + h / 6,
    y: 0
  }, {
    x: w - 2 * h / 6,
    y: -h
  }, {
    x: -h / 6,
    y: -h
  }];
  var el = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["insertPolygonShape"])(shapeSvg, w, h, points);
  el.attr('style', node.style);
  Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["updateNodeBounds"])(node, el);

  node.intersect = function (point) {
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].polygon(node, points, point);
  };

  return shapeSvg;
};

var trapezoid = function trapezoid(parent, node) {
  var _labelHelper6 = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["labelHelper"])(parent, node, undefined, true),
      shapeSvg = _labelHelper6.shapeSvg,
      bbox = _labelHelper6.bbox;

  var w = bbox.width + node.padding;
  var h = bbox.height + node.padding;
  var points = [{
    x: -2 * h / 6,
    y: 0
  }, {
    x: w + 2 * h / 6,
    y: 0
  }, {
    x: w - h / 6,
    y: -h
  }, {
    x: h / 6,
    y: -h
  }];
  var el = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["insertPolygonShape"])(shapeSvg, w, h, points);
  el.attr('style', node.style);
  Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["updateNodeBounds"])(node, el);

  node.intersect = function (point) {
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].polygon(node, points, point);
  };

  return shapeSvg;
};

var inv_trapezoid = function inv_trapezoid(parent, node) {
  var _labelHelper7 = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["labelHelper"])(parent, node, undefined, true),
      shapeSvg = _labelHelper7.shapeSvg,
      bbox = _labelHelper7.bbox;

  var w = bbox.width + node.padding;
  var h = bbox.height + node.padding;
  var points = [{
    x: h / 6,
    y: 0
  }, {
    x: w - h / 6,
    y: 0
  }, {
    x: w + 2 * h / 6,
    y: -h
  }, {
    x: -2 * h / 6,
    y: -h
  }];
  var el = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["insertPolygonShape"])(shapeSvg, w, h, points);
  el.attr('style', node.style);
  Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["updateNodeBounds"])(node, el);

  node.intersect = function (point) {
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].polygon(node, points, point);
  };

  return shapeSvg;
};

var rect_right_inv_arrow = function rect_right_inv_arrow(parent, node) {
  var _labelHelper8 = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["labelHelper"])(parent, node, undefined, true),
      shapeSvg = _labelHelper8.shapeSvg,
      bbox = _labelHelper8.bbox;

  var w = bbox.width + node.padding;
  var h = bbox.height + node.padding;
  var points = [{
    x: 0,
    y: 0
  }, {
    x: w + h / 2,
    y: 0
  }, {
    x: w,
    y: -h / 2
  }, {
    x: w + h / 2,
    y: -h
  }, {
    x: 0,
    y: -h
  }];
  var el = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["insertPolygonShape"])(shapeSvg, w, h, points);
  el.attr('style', node.style);
  Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["updateNodeBounds"])(node, el);

  node.intersect = function (point) {
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].polygon(node, points, point);
  };

  return shapeSvg;
};

var cylinder = function cylinder(parent, node) {
  var _labelHelper9 = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["labelHelper"])(parent, node, undefined, true),
      shapeSvg = _labelHelper9.shapeSvg,
      bbox = _labelHelper9.bbox;

  var w = bbox.width + node.padding;
  var rx = w / 2;
  var ry = rx / (2.5 + w / 50);
  var h = bbox.height + ry + node.padding;
  var shape = 'M 0,' + ry + ' a ' + rx + ',' + ry + ' 0,0,0 ' + w + ' 0 a ' + rx + ',' + ry + ' 0,0,0 ' + -w + ' 0 l 0,' + h + ' a ' + rx + ',' + ry + ' 0,0,0 ' + w + ' 0 l 0,' + -h;
  var el = shapeSvg.attr('label-offset-y', ry).insert('path', ':first-child').attr('style', node.style).attr('d', shape).attr('transform', 'translate(' + -w / 2 + ',' + -(h / 2 + ry) + ')');
  Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["updateNodeBounds"])(node, el);

  node.intersect = function (point) {
    var pos = _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].rect(node, point);
    var x = pos.x - node.x;

    if (rx != 0 && (Math.abs(x) < node.width / 2 || Math.abs(x) == node.width / 2 && Math.abs(pos.y - node.y) > node.height / 2 - ry)) {
      // ellipsis equation: x*x / a*a + y*y / b*b = 1
      // solve for y to get adjustion value for pos.y
      var y = ry * ry * (1 - x * x / (rx * rx));
      if (y != 0) y = Math.sqrt(y);
      y = ry - y;
      if (point.y - node.y > 0) y = -y;
      pos.y += y;
    }

    return pos;
  };

  return shapeSvg;
};

var rect = function rect(parent, node) {
  var _labelHelper10 = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["labelHelper"])(parent, node, 'node ' + node.classes, true),
      shapeSvg = _labelHelper10.shapeSvg,
      bbox = _labelHelper10.bbox,
      halfPadding = _labelHelper10.halfPadding;

  _logger__WEBPACK_IMPORTED_MODULE_1__["log"].trace('Classes = ', node.classes); // add the rect

  var rect = shapeSvg.insert('rect', ':first-child');
  rect.attr('class', 'basic label-container').attr('style', node.style).attr('rx', node.rx).attr('ry', node.ry).attr('x', -bbox.width / 2 - halfPadding).attr('y', -bbox.height / 2 - halfPadding).attr('width', bbox.width + node.padding).attr('height', bbox.height + node.padding);
  Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["updateNodeBounds"])(node, rect);

  node.intersect = function (point) {
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].rect(node, point);
  };

  return shapeSvg;
};

var rectWithTitle = function rectWithTitle(parent, node) {
  // const { shapeSvg, bbox, halfPadding } = labelHelper(parent, node, 'node ' + node.classes);
  var classes;

  if (!node.classes) {
    classes = 'node default';
  } else {
    classes = 'node ' + node.classes;
  } // Add outer g element


  var shapeSvg = parent.insert('g').attr('class', classes).attr('id', node.domId || node.id); // Create the title label and insert it after the rect

  var rect = shapeSvg.insert('rect', ':first-child'); // const innerRect = shapeSvg.insert('rect');

  var innerLine = shapeSvg.insert('line');
  var label = shapeSvg.insert('g').attr('class', 'label');
  var text2 = node.labelText.flat ? node.labelText.flat() : node.labelText; // const text2 = typeof text2prim === 'object' ? text2prim[0] : text2prim;

  var title = '';

  if (_typeof(text2) === 'object') {
    title = text2[0];
  } else {
    title = text2;
  }

  _logger__WEBPACK_IMPORTED_MODULE_1__["log"].info('Label text abc79', title, text2, _typeof(text2) === 'object');
  var text = label.node().appendChild(Object(_createLabel__WEBPACK_IMPORTED_MODULE_5__["default"])(title, node.labelStyle, true, true));
  var bbox;

  if (Object(_diagrams_common_common__WEBPACK_IMPORTED_MODULE_8__["evaluate"])(Object(_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"])().flowchart.htmlLabels)) {
    var div = text.children[0];
    var dv = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(text);
    bbox = div.getBoundingClientRect();
    dv.attr('width', bbox.width);
    dv.attr('height', bbox.height);
  }

  _logger__WEBPACK_IMPORTED_MODULE_1__["log"].info('Text 2', text2);
  var textRows = text2.slice(1, text2.length);
  var titleBox = text.getBBox();
  var descr = label.node().appendChild(Object(_createLabel__WEBPACK_IMPORTED_MODULE_5__["default"])(textRows.join ? textRows.join('<br/>') : textRows, node.labelStyle, true, true));

  if (Object(_diagrams_common_common__WEBPACK_IMPORTED_MODULE_8__["evaluate"])(Object(_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"])().flowchart.htmlLabels)) {
    var _div = descr.children[0];

    var _dv = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(descr);

    bbox = _div.getBoundingClientRect();

    _dv.attr('width', bbox.width);

    _dv.attr('height', bbox.height);
  } // bbox = label.getBBox();
  // log.info(descr);


  var halfPadding = node.padding / 2;
  Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(descr).attr('transform', 'translate( ' + (bbox.width > titleBox.width ? 0 : (titleBox.width - bbox.width) / 2) + ', ' + (titleBox.height + halfPadding + 5) + ')');
  Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(text).attr('transform', 'translate( ' + (bbox.width < titleBox.width ? 0 : -(titleBox.width - bbox.width) / 2) + ', ' + 0 + ')'); // Get the size of the label
  // Bounding box for title and text

  bbox = label.node().getBBox(); // Center the label

  label.attr('transform', 'translate(' + -bbox.width / 2 + ', ' + (-bbox.height / 2 - halfPadding + 3) + ')');
  rect.attr('class', 'outer title-state').attr('x', -bbox.width / 2 - halfPadding).attr('y', -bbox.height / 2 - halfPadding).attr('width', bbox.width + node.padding).attr('height', bbox.height + node.padding);
  innerLine.attr('class', 'divider').attr('x1', -bbox.width / 2 - halfPadding).attr('x2', bbox.width / 2 + halfPadding).attr('y1', -bbox.height / 2 - halfPadding + titleBox.height + halfPadding).attr('y2', -bbox.height / 2 - halfPadding + titleBox.height + halfPadding);
  Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["updateNodeBounds"])(node, rect);

  node.intersect = function (point) {
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].rect(node, point);
  };

  return shapeSvg;
};

var stadium = function stadium(parent, node) {
  var _labelHelper11 = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["labelHelper"])(parent, node, undefined, true),
      shapeSvg = _labelHelper11.shapeSvg,
      bbox = _labelHelper11.bbox;

  var h = bbox.height + node.padding;
  var w = bbox.width + h / 4 + node.padding; // add the rect

  var rect = shapeSvg.insert('rect', ':first-child').attr('style', node.style).attr('rx', h / 2).attr('ry', h / 2).attr('x', -w / 2).attr('y', -h / 2).attr('width', w).attr('height', h);
  Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["updateNodeBounds"])(node, rect);

  node.intersect = function (point) {
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].rect(node, point);
  };

  return shapeSvg;
};

var circle = function circle(parent, node) {
  var _labelHelper12 = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["labelHelper"])(parent, node, undefined, true),
      shapeSvg = _labelHelper12.shapeSvg,
      bbox = _labelHelper12.bbox,
      halfPadding = _labelHelper12.halfPadding;

  var circle = shapeSvg.insert('circle', ':first-child'); // center the circle around its coordinate

  circle.attr('style', node.style).attr('rx', node.rx).attr('ry', node.ry).attr('r', bbox.width / 2 + halfPadding).attr('width', bbox.width + node.padding).attr('height', bbox.height + node.padding);
  _logger__WEBPACK_IMPORTED_MODULE_1__["log"].info('Circle main');
  Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["updateNodeBounds"])(node, circle);

  node.intersect = function (point) {
    _logger__WEBPACK_IMPORTED_MODULE_1__["log"].info('Circle intersect', node, bbox.width / 2 + halfPadding, point);
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].circle(node, bbox.width / 2 + halfPadding, point);
  };

  return shapeSvg;
};

var subroutine = function subroutine(parent, node) {
  var _labelHelper13 = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["labelHelper"])(parent, node, undefined, true),
      shapeSvg = _labelHelper13.shapeSvg,
      bbox = _labelHelper13.bbox;

  var w = bbox.width + node.padding;
  var h = bbox.height + node.padding;
  var points = [{
    x: 0,
    y: 0
  }, {
    x: w,
    y: 0
  }, {
    x: w,
    y: -h
  }, {
    x: 0,
    y: -h
  }, {
    x: 0,
    y: 0
  }, {
    x: -8,
    y: 0
  }, {
    x: w + 8,
    y: 0
  }, {
    x: w + 8,
    y: -h
  }, {
    x: -8,
    y: -h
  }, {
    x: -8,
    y: 0
  }];
  var el = Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["insertPolygonShape"])(shapeSvg, w, h, points);
  el.attr('style', node.style);
  Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["updateNodeBounds"])(node, el);

  node.intersect = function (point) {
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].polygon(node, points, point);
  };

  return shapeSvg;
};

var start = function start(parent, node) {
  var shapeSvg = parent.insert('g').attr('class', 'node default').attr('id', node.domId || node.id);
  var circle = shapeSvg.insert('circle', ':first-child'); // center the circle around its coordinate

  circle.attr('class', 'state-start').attr('r', 7).attr('width', 14).attr('height', 14);
  Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["updateNodeBounds"])(node, circle);

  node.intersect = function (point) {
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].circle(node, 7, point);
  };

  return shapeSvg;
};

var forkJoin = function forkJoin(parent, node, dir) {
  var shapeSvg = parent.insert('g').attr('class', 'node default').attr('id', node.domId || node.id);
  var width = 70;
  var height = 10;

  if (dir === 'LR') {
    width = 10;
    height = 70;
  }

  var shape = shapeSvg.append('rect').attr('x', -1 * width / 2).attr('y', -1 * height / 2).attr('width', width).attr('height', height).attr('class', 'fork-join');
  Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["updateNodeBounds"])(node, shape);
  node.height = node.height + node.padding / 2;
  node.width = node.width + node.padding / 2;

  node.intersect = function (point) {
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].rect(node, point);
  };

  return shapeSvg;
};

var end = function end(parent, node) {
  var shapeSvg = parent.insert('g').attr('class', 'node default').attr('id', node.domId || node.id);
  var innerCircle = shapeSvg.insert('circle', ':first-child');
  var circle = shapeSvg.insert('circle', ':first-child');
  circle.attr('class', 'state-start').attr('r', 7).attr('width', 14).attr('height', 14);
  innerCircle.attr('class', 'state-end').attr('r', 5).attr('width', 10).attr('height', 10);
  Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["updateNodeBounds"])(node, circle);

  node.intersect = function (point) {
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].circle(node, 7, point);
  };

  return shapeSvg;
};

var class_box = function class_box(parent, node) {
  var halfPadding = node.padding / 2;
  var rowPadding = 4;
  var lineHeight = 8;
  var classes;

  if (!node.classes) {
    classes = 'node default';
  } else {
    classes = 'node ' + node.classes;
  } // Add outer g element


  var shapeSvg = parent.insert('g').attr('class', classes).attr('id', node.domId || node.id); // Create the title label and insert it after the rect

  var rect = shapeSvg.insert('rect', ':first-child');
  var topLine = shapeSvg.insert('line');
  var bottomLine = shapeSvg.insert('line');
  var maxWidth = 0;
  var maxHeight = rowPadding;
  var labelContainer = shapeSvg.insert('g').attr('class', 'label');
  var verticalPos = 0;
  var hasInterface = node.classData.annotations && node.classData.annotations[0]; // 1. Create the labels

  var interfaceLabelText = node.classData.annotations[0] ? '«' + node.classData.annotations[0] + '»' : '';
  var interfaceLabel = labelContainer.node().appendChild(Object(_createLabel__WEBPACK_IMPORTED_MODULE_5__["default"])(interfaceLabelText, node.labelStyle, true, true));
  var interfaceBBox = interfaceLabel.getBBox();

  if (Object(_diagrams_common_common__WEBPACK_IMPORTED_MODULE_8__["evaluate"])(Object(_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"])().flowchart.htmlLabels)) {
    var div = interfaceLabel.children[0];
    var dv = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(interfaceLabel);
    interfaceBBox = div.getBoundingClientRect();
    dv.attr('width', interfaceBBox.width);
    dv.attr('height', interfaceBBox.height);
  }

  if (node.classData.annotations[0]) {
    maxHeight += interfaceBBox.height + rowPadding;
    maxWidth += interfaceBBox.width;
  }

  var classTitleString = node.classData.id;

  if (node.classData.type !== undefined && node.classData.type !== '') {
    if (Object(_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"])().flowchart.htmlLabels) {
      classTitleString += '&lt;' + node.classData.type + '&gt;';
    } else {
      classTitleString += '<' + node.classData.type + '>';
    }
  }

  var classTitleLabel = labelContainer.node().appendChild(Object(_createLabel__WEBPACK_IMPORTED_MODULE_5__["default"])(classTitleString, node.labelStyle, true, true));
  Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(classTitleLabel).attr('class', 'classTitle');
  var classTitleBBox = classTitleLabel.getBBox();

  if (Object(_diagrams_common_common__WEBPACK_IMPORTED_MODULE_8__["evaluate"])(Object(_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"])().flowchart.htmlLabels)) {
    var _div2 = classTitleLabel.children[0];

    var _dv2 = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(classTitleLabel);

    classTitleBBox = _div2.getBoundingClientRect();

    _dv2.attr('width', classTitleBBox.width);

    _dv2.attr('height', classTitleBBox.height);
  }

  maxHeight += classTitleBBox.height + rowPadding;

  if (classTitleBBox.width > maxWidth) {
    maxWidth = classTitleBBox.width;
  }

  var classAttributes = [];
  node.classData.members.forEach(function (str) {
    var parsedText = Object(_diagrams_class_svgDraw__WEBPACK_IMPORTED_MODULE_7__["parseMember"])(str).displayText;

    if (Object(_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"])().flowchart.htmlLabels) {
      parsedText = parsedText.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    var lbl = labelContainer.node().appendChild(Object(_createLabel__WEBPACK_IMPORTED_MODULE_5__["default"])(parsedText, node.labelStyle, true, true));
    var bbox = lbl.getBBox();

    if (Object(_diagrams_common_common__WEBPACK_IMPORTED_MODULE_8__["evaluate"])(Object(_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"])().flowchart.htmlLabels)) {
      var _div3 = lbl.children[0];

      var _dv3 = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(lbl);

      bbox = _div3.getBoundingClientRect();

      _dv3.attr('width', bbox.width);

      _dv3.attr('height', bbox.height);
    }

    if (bbox.width > maxWidth) {
      maxWidth = bbox.width;
    }

    maxHeight += bbox.height + rowPadding;
    classAttributes.push(lbl);
  });
  maxHeight += lineHeight;
  var classMethods = [];
  node.classData.methods.forEach(function (str) {
    var parsedInfo = Object(_diagrams_class_svgDraw__WEBPACK_IMPORTED_MODULE_7__["parseMember"])(str);
    var displayText = parsedInfo.displayText;

    if (Object(_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"])().flowchart.htmlLabels) {
      displayText = displayText.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    var lbl = labelContainer.node().appendChild(Object(_createLabel__WEBPACK_IMPORTED_MODULE_5__["default"])(displayText, parsedInfo.cssStyle ? parsedInfo.cssStyle : node.labelStyle, true, true));
    var bbox = lbl.getBBox();

    if (Object(_diagrams_common_common__WEBPACK_IMPORTED_MODULE_8__["evaluate"])(Object(_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"])().flowchart.htmlLabels)) {
      var _div4 = lbl.children[0];

      var _dv4 = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(lbl);

      bbox = _div4.getBoundingClientRect();

      _dv4.attr('width', bbox.width);

      _dv4.attr('height', bbox.height);
    }

    if (bbox.width > maxWidth) {
      maxWidth = bbox.width;
    }

    maxHeight += bbox.height + rowPadding;
    classMethods.push(lbl);
  });
  maxHeight += lineHeight; // 2. Position the labels
  // position the interface label

  if (hasInterface) {
    var _diffX = (maxWidth - interfaceBBox.width) / 2;

    Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(interfaceLabel).attr('transform', 'translate( ' + (-1 * maxWidth / 2 + _diffX) + ', ' + -1 * maxHeight / 2 + ')');
    verticalPos = interfaceBBox.height + rowPadding;
  } // Positin the class title label


  var diffX = (maxWidth - classTitleBBox.width) / 2;
  Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(classTitleLabel).attr('transform', 'translate( ' + (-1 * maxWidth / 2 + diffX) + ', ' + (-1 * maxHeight / 2 + verticalPos) + ')');
  verticalPos += classTitleBBox.height + rowPadding;
  topLine.attr('class', 'divider').attr('x1', -maxWidth / 2 - halfPadding).attr('x2', maxWidth / 2 + halfPadding).attr('y1', -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr('y2', -maxHeight / 2 - halfPadding + lineHeight + verticalPos);
  verticalPos += lineHeight;
  classAttributes.forEach(function (lbl) {
    Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(lbl).attr('transform', 'translate( ' + -maxWidth / 2 + ', ' + (-1 * maxHeight / 2 + verticalPos + lineHeight / 2) + ')');
    verticalPos += classTitleBBox.height + rowPadding;
  });
  verticalPos += lineHeight;
  bottomLine.attr('class', 'divider').attr('x1', -maxWidth / 2 - halfPadding).attr('x2', maxWidth / 2 + halfPadding).attr('y1', -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr('y2', -maxHeight / 2 - halfPadding + lineHeight + verticalPos);
  verticalPos += lineHeight;
  classMethods.forEach(function (lbl) {
    Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(lbl).attr('transform', 'translate( ' + -maxWidth / 2 + ', ' + (-1 * maxHeight / 2 + verticalPos) + ')');
    verticalPos += classTitleBBox.height + rowPadding;
  }); //
  // let bbox;
  // if (evaluate(getConfig().flowchart.htmlLabels)) {
  //   const div = interfaceLabel.children[0];
  //   const dv = select(interfaceLabel);
  //   bbox = div.getBoundingClientRect();
  //   dv.attr('width', bbox.width);
  //   dv.attr('height', bbox.height);
  // }
  // bbox = labelContainer.getBBox();
  // log.info('Text 2', text2);
  // const textRows = text2.slice(1, text2.length);
  // let titleBox = text.getBBox();
  // const descr = label
  //   .node()
  //   .appendChild(createLabel(textRows.join('<br/>'), node.labelStyle, true, true));
  // if (evaluate(getConfig().flowchart.htmlLabels)) {
  //   const div = descr.children[0];
  //   const dv = select(descr);
  //   bbox = div.getBoundingClientRect();
  //   dv.attr('width', bbox.width);
  //   dv.attr('height', bbox.height);
  // }
  // // bbox = label.getBBox();
  // // log.info(descr);
  // select(descr).attr(
  //   'transform',
  //   'translate( ' +
  //     // (titleBox.width - bbox.width) / 2 +
  //     (bbox.width > titleBox.width ? 0 : (titleBox.width - bbox.width) / 2) +
  //     ', ' +
  //     (titleBox.height + halfPadding + 5) +
  //     ')'
  // );
  // select(text).attr(
  //   'transform',
  //   'translate( ' +
  //     // (titleBox.width - bbox.width) / 2 +
  //     (bbox.width < titleBox.width ? 0 : -(titleBox.width - bbox.width) / 2) +
  //     ', ' +
  //     0 +
  //     ')'
  // );
  // // Get the size of the label
  // // Bounding box for title and text
  // bbox = label.node().getBBox();
  // // Center the label
  // label.attr(
  //   'transform',
  //   'translate(' + -bbox.width / 2 + ', ' + (-bbox.height / 2 - halfPadding + 3) + ')'
  // );

  rect.attr('class', 'outer title-state').attr('x', -maxWidth / 2 - halfPadding).attr('y', -(maxHeight / 2) - halfPadding).attr('width', maxWidth + node.padding).attr('height', maxHeight + node.padding); // innerLine
  //   .attr('class', 'divider')
  //   .attr('x1', -bbox.width / 2 - halfPadding)
  //   .attr('x2', bbox.width / 2 + halfPadding)
  //   .attr('y1', -bbox.height / 2 - halfPadding + titleBox.height + halfPadding)
  //   .attr('y2', -bbox.height / 2 - halfPadding + titleBox.height + halfPadding);

  Object(_shapes_util__WEBPACK_IMPORTED_MODULE_2__["updateNodeBounds"])(node, rect);

  node.intersect = function (point) {
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].rect(node, point);
  };

  return shapeSvg;
};

var shapes = {
  question: question,
  rect: rect,
  rectWithTitle: rectWithTitle,
  choice: choice,
  circle: circle,
  stadium: stadium,
  hexagon: hexagon,
  rect_left_inv_arrow: rect_left_inv_arrow,
  lean_right: lean_right,
  lean_left: lean_left,
  trapezoid: trapezoid,
  inv_trapezoid: inv_trapezoid,
  rect_right_inv_arrow: rect_right_inv_arrow,
  cylinder: cylinder,
  start: start,
  end: end,
  note: _shapes_note__WEBPACK_IMPORTED_MODULE_6__["default"],
  subroutine: subroutine,
  fork: forkJoin,
  join: forkJoin,
  class_box: class_box
};
var nodeElems = {};
var insertNode = function insertNode(elem, node, dir) {
  var newEl;
  var el; // Add link when appropriate

  if (node.link) {
    newEl = elem.insert('svg:a').attr('xlink:href', node.link).attr('target', node.linkTarget || '_blank');
    el = shapes[node.shape](newEl, node, dir);
  } else {
    el = shapes[node.shape](elem, node, dir);
    newEl = el;
  }

  if (node.tooltip) {
    el.attr('title', node.tooltip);
  }

  if (node.class) {
    el.attr('class', 'node default ' + node.class);
  }

  nodeElems[node.id] = newEl;

  if (node.haveCallback) {
    nodeElems[node.id].attr('class', nodeElems[node.id].attr('class') + ' clickable');
  }
};
var setNodeElem = function setNodeElem(elem, node) {
  nodeElems[node.id] = elem;
};
var clear = function clear() {
  nodeElems = {};
};
var positionNode = function positionNode(node) {
  var el = nodeElems[node.id];
  _logger__WEBPACK_IMPORTED_MODULE_1__["log"].trace('Transforming node', node.diff, node, 'translate(' + (node.x - node.width / 2 - 5) + ', ' + node.width / 2 + ')');
  var padding = 8;
  var diff = node.diff || 0;

  if (node.clusterNode) {
    el.attr('transform', 'translate(' + (node.x + diff - node.width / 2) + ', ' + (node.y - node.height / 2 - padding) + ')');
  } else {
    el.attr('transform', 'translate(' + node.x + ', ' + node.y + ')');
  }

  return diff;
};

/***/ }),

/***/ "./src/dagre-wrapper/shapes/note.js":
/*!******************************************!*\
  !*** ./src/dagre-wrapper/shapes/note.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./src/dagre-wrapper/shapes/util.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _intersect_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../intersect/index.js */ "./src/dagre-wrapper/intersect/index.js");

 // eslint-disable-line



var note = function note(parent, node) {
  var _labelHelper = Object(_util__WEBPACK_IMPORTED_MODULE_0__["labelHelper"])(parent, node, 'node ' + node.classes, true),
      shapeSvg = _labelHelper.shapeSvg,
      bbox = _labelHelper.bbox,
      halfPadding = _labelHelper.halfPadding;

  _logger__WEBPACK_IMPORTED_MODULE_1__["log"].info('Classes = ', node.classes); // add the rect

  var rect = shapeSvg.insert('rect', ':first-child');
  rect.attr('rx', node.rx).attr('ry', node.ry).attr('x', -bbox.width / 2 - halfPadding).attr('y', -bbox.height / 2 - halfPadding).attr('width', bbox.width + node.padding).attr('height', bbox.height + node.padding);
  Object(_util__WEBPACK_IMPORTED_MODULE_0__["updateNodeBounds"])(node, rect);

  node.intersect = function (point) {
    return _intersect_index_js__WEBPACK_IMPORTED_MODULE_2__["default"].rect(node, point);
  };

  return shapeSvg;
};

/* harmony default export */ __webpack_exports__["default"] = (note);

/***/ }),

/***/ "./src/dagre-wrapper/shapes/util.js":
/*!******************************************!*\
  !*** ./src/dagre-wrapper/shapes/util.js ***!
  \******************************************/
/*! exports provided: labelHelper, updateNodeBounds, insertPolygonShape */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "labelHelper", function() { return labelHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateNodeBounds", function() { return updateNodeBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertPolygonShape", function() { return insertPolygonShape; });
/* harmony import */ var _createLabel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLabel */ "./src/dagre-wrapper/createLabel.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _diagrams_common_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../diagrams/common/common */ "./src/diagrams/common/common.js");




var labelHelper = function labelHelper(parent, node, _classes, isNode) {
  var classes;

  if (!_classes) {
    classes = 'node default';
  } else {
    classes = _classes;
  } // Add outer g element


  var shapeSvg = parent.insert('g').attr('class', classes).attr('id', node.domId || node.id); // Create the label and insert it after the rect

  var label = shapeSvg.insert('g').attr('class', 'label').attr('style', node.labelStyle);
  var text = label.node().appendChild(Object(_createLabel__WEBPACK_IMPORTED_MODULE_0__["default"])(node.labelText, node.labelStyle, false, isNode)); // Get the size of the label

  var bbox = text.getBBox();

  if (Object(_diagrams_common_common__WEBPACK_IMPORTED_MODULE_3__["evaluate"])(Object(_config__WEBPACK_IMPORTED_MODULE_1__["getConfig"])().flowchart.htmlLabels)) {
    var div = text.children[0];
    var dv = Object(d3__WEBPACK_IMPORTED_MODULE_2__["select"])(text);
    bbox = div.getBoundingClientRect();
    dv.attr('width', bbox.width);
    dv.attr('height', bbox.height);
  }

  var halfPadding = node.padding / 2; // Center the label

  label.attr('transform', 'translate(' + -bbox.width / 2 + ', ' + -bbox.height / 2 + ')');
  return {
    shapeSvg: shapeSvg,
    bbox: bbox,
    halfPadding: halfPadding,
    label: label
  };
};
var updateNodeBounds = function updateNodeBounds(node, element) {
  var bbox = element.node().getBBox();
  node.width = bbox.width;
  node.height = bbox.height;
};
function insertPolygonShape(parent, w, h, points) {
  return parent.insert('polygon', ':first-child').attr('points', points.map(function (d) {
    return d.x + ',' + d.y;
  }).join(' ')).attr('class', 'label-container').attr('transform', 'translate(' + -w / 2 + ',' + h / 2 + ')');
}

/***/ }),

/***/ "./src/defaultConfig.js":
/*!******************************!*\
  !*** ./src/defaultConfig.js ***!
  \******************************/
/*! exports provided: configKeys, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "configKeys", function() { return configKeys; });
/* harmony import */ var _themes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./themes */ "./src/themes/index.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }


/**
 * **Configuration methods in Mermaid version 8.6.0 have been updated, to learn more[[click here](8.6.0_docs.md)].**
 *
 * ## **What follows are config instructions for older versions**
 *
 * These are the default options which can be overridden with the initialization call like so:
 *
 * **Example 1:**
 * <pre>
 * mermaid.initialize({
 *   flowchart:{
 *     htmlLabels: false
 *   }
 * });
 * </pre>
 *
 * **Example 2:**
 * <pre>
 * &lt;script>
 *   var config = {
 *     startOnLoad:true,
 *     flowchart:{
 *       useMaxWidth:true,
 *       htmlLabels:true,
 *       curve:'cardinal',
 *     },
 *
 *     securityLevel:'loose',
 *   };
 *   mermaid.initialize(config);
 * &lt;/script>
 * </pre>
 * A summary of all options and their defaults is found [here](#mermaidapi-configuration-defaults). A description of each option follows below.
 *
 * @name Configuration
 */

var config = {
  /**
   * theme , the CSS style sheet
   *
   * | Parameter | Description | Type | Required | Values |
   * | --- | --- | --- | --- | --- |
   * | theme | Built in Themes | string | Optional | 'default', 'forest', 'dark', 'neutral', 'null'|
   *
   * **Notes:** To disable any pre-defined mermaid theme, use "null".
   *
   * <pre>
   *  "theme": "forest",
   *  "themeCSS": ".node rect { fill: red; }"
   * </pre>
   */
  theme: 'default',
  themeVariables: _themes__WEBPACK_IMPORTED_MODULE_0__["default"]['default'].getThemeVariables(),
  themeCSS: undefined,

  /* **maxTextSize** - The maximum allowed size of the users text diamgram */
  maxTextSize: 50000,

  /**
   * | Parameter | Description | Type | Required | Values |
   * | --- | --- | --- | --- | --- |
   * | fontFamily | specifies the font to be used in the rendered diagrams| string | Required | Any Posiable CSS FontFamily |
   *
   * **Notes:**
   * Default value: '"trebuchet ms", verdana, arial, sans-serif;'.
   */
  fontFamily: '"trebuchet ms", verdana, arial, sans-serif;',

  /**
   * | Parameter | Description | Type | Required | Values |
   * | --- | --- | --- | --- | --- |
   * | logLevel |This option decides the amount of logging to be used.| string \| number | Required | 1, 2, 3, 4, 5 |
   *
   *
   * **Notes:**
   *
   * - debug: 1
   * - info: 2
   * - warn: 3
   * - error: 4
   * - fatal: 5 (default)
   */
  logLevel: 5,

  /**
   * | Parameter | Description | Type | Required | Values |
   * | --- | --- | --- | --- | --- |
   * | securitylevel | Level of trust for parsed diagram|string | Required | 'strict', 'loose', 'antiscript' |
   *
   * **Notes**:
   *
   * - **strict**: (**default**) tags in text are encoded, click functionality is disabled
   * - **loose**: tags in text are allowed, click functionality is enabled
   * - **antiscript**: html tags in text are allowed, (only script element is removed), click functionality is enabled
   */
  securityLevel: 'strict',

  /**
   * | Parameter | Description | Type | Required | Values |
   * | --- | --- | --- | --- | --- |
   * | startOnLoad | Dictates whether mermaind starts on Page load | boolean | Required | true, false |
   *
   * **Notes:** Default value: true
   */
  startOnLoad: true,

  /**
   * | Parameter | Description |Type | Required |Values|
   * | --- | --- | --- | --- | --- |
   * | arrowMarkerAbsolute | Controls whether or arrow markers in html code are absolute paths or anchors | boolean | Required | true, false |
   *
   *
   * **Notes**:
   *
   * This matters if you are using base tag settings.
   *
   * Default value: false
   */
  arrowMarkerAbsolute: false,

  /**
   * This option controls which currentConfig keys are considered _secure_ and can only be changed via
   * call to mermaidAPI.initialize. Calls to mermaidAPI.reinitialize cannot make changes to
   * the `secure` keys in the current currentConfig. This prevents malicious graph directives from
   * overriding a site's default security.
    * **Notes**:
   *
   * Default value: ['secure', 'securityLevel', 'startOnLoad', 'maxTextSize']
   */
  secure: ['secure', 'securityLevel', 'startOnLoad', 'maxTextSize'],

  /**
   * This option controls if the generated ids of nodes in the SVG are generated randomly or based on a seed.
   * If set to false, the IDs are generated based on the current date and thus are not deterministic. This is the default behaviour.
   *
   * **Notes**:
   *
   * This matters if your files are checked into sourcecontrol e.g. git and should not change unless content is changed.
   *
   * Default value: false
   */
  deterministicIds: false,

  /**
   * This option is the optional seed for deterministic ids. if set to undefined but deterministicIds is true, a simple number iterator is used.
   * You can set this attribute to base the seed on a static string.
   */
  deterministicIDSeed: undefined,

  /**
   * The object containing configurations specific for flowcharts
   */
  flowchart: {
    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | diagramPadding | Amount of padding around the diagram as a whole | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     *
     * The amount of padding around the diagram as a whole so that embedded diagrams have margins, expressed in pixels
     *
     * Default value: 8
     */
    diagramPadding: 8,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | htmlLabels | Flag for setting whether or not a html tag should be used for rendering labels on the edges. | boolean| Required | true, false |
     *
     * **Notes:** Default value: true.
     */
    htmlLabels: true,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | nodeSpacing | Defines the spacing between nodes on the same level | Integer | Required | Any positive Number |
     *
     * **Notes:**
     *
     * Pertains to horizontal spacing for TB (top to bottom) or BT (bottom to top) graphs, and the vertical spacing for LR as well as RL graphs.**
     *
     * Default value: 50
     */
    nodeSpacing: 50,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | rankSpacing | Defines the spacing between nodes on different levels | Integer | Required | Any Positive Number |
     *
     * **Notes**:
     *
     * pertains to vertical spacing for TB (top to bottom) or BT (bottom to top), and the horizontal spacing for LR as well as RL graphs.
     *
     * Default value 50
     */
    rankSpacing: 50,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | curve | Defines how mermaid renders curves for flowcharts. | string | Required | 'basis', 'linear', 'cardinal'|
     *
     * **Notes:**
     *
     * Default Vaue: 'basis'
     */
    curve: 'basis',
    // Only used in new experimental rendering
    // represents the padding between the labels and the shape
    padding: 15,

    /**
     * | Parameter | Description | Type | Required | Values|
     * | --- | --- | --- | --- | --- |
     * | useMaxWidth | See notes | boolean | 4 | true, false |
     *
     * **Notes:**
     *
     * When this flag is set the height and width is set to 100% and is then scaling with the
     * available space if not the absolute space required is used.
     *
     * Default value: true
     */
    useMaxWidth: true,

    /**
     * | Parameter | Description | Type | Required | Values|
     * | --- | --- | --- | --- | --- |
     * | defaultRenderer | See notes | boolean | 4 | dagre-d3, dagre-wrapper |
     *
     * **Notes:**
     *
     * Decides which rendering engine that is to be used for the rendering. Legal values are:
     * * dagre-d3
     * * dagre-wrapper - wrapper for dagre implemented in mermaid
     *
     * Default value: 'dagre-d3'
     */
    defaultRenderer: 'dagre-d3'
  },

  /**
   * The object containing configurations specific for sequence diagrams
   */
  sequence: {
    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | activationWidth | Width of the activation rect | Integer | Required | Any Positive Value |
     *
     *
     * **Notes:** Default value :10
     */
    activationWidth: 10,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | diagramMarginX | Margin to the right and left of the sequence diagram | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 50
     */
    diagramMarginX: 50,

    /**
     *| Parameter | Description | Type | Required | Values |
     *| --- | --- | --- | --- | --- |
     *| diagramMarginY | Margin to the over and under the sequence diagram | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 10
     */
    diagramMarginY: 10,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | actorMargin | Margin between actors | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 50
     */
    actorMargin: 50,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | width | Width of actor boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 150
     */
    width: 150,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | height | Height of actor boxes | Integer | Required | Any Positive Value|
     *
     * **Notes:**
     * Default value: 65
     */
    height: 65,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | boxMargin | Margin around loop boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 10
     */
    boxMargin: 10,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | boxTextMargin | Margin around the text in loop/alt/opt boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 5
     */
    boxTextMargin: 5,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | noteMargin | margin around notes | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 10
     */
    noteMargin: 10,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | messageMargin | Space between messages | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 35
     */
    messageMargin: 35,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | messageAlign | Multiline message alignment | string | Required | 'left', 'center', 'right' |
     *
     * **Notes:**
     * Default value: 'center'
     */
    messageAlign: 'center',

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | mirrorActors | Mirror actors under diagram | boolean | Required | true, false |
     *
     * **Notes:**
     * Default value: true
     */
    mirrorActors: true,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | bottomMarginAdj | Prolongs the edge of the diagram downwards | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     *
     * Depending on css styling this might need adjustment.
     *
     * Default value: 1
     */
    bottomMarginAdj: 1,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | useMaxWidth | See Notes | boolean | Required | true, false |
     *
     * **Notes:**
     * When this flag is set to true, the height and width is set to 100% and is then scaling with the
     * available space. If set to false, the absolute space required is used.
     *
     * Default value: true
     */
    useMaxWidth: true,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | rightAngles | display curve arrows as right angles | boolean | Required | true, false |
     *
     * **Notes:**
     *
     * This will display arrows that start and begin at the same node as right angles, rather than a curve
     *
     * Default value: false
     */
    rightAngles: false,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | showSequenceNumbers | This will show the node numbers | boolean | Required | true, false |
     *
     * **Notes:**
     * Default value: false
     */
    showSequenceNumbers: false,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | actorFontSize| This sets the font size of the actor's description | Integer | Require | Any Positive Value |
     *
     ***Notes:**
     ***Default value 14**..
     */
    actorFontSize: 14,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | actorFontFamily |This sets the font family of the actor's description | string | Required | Any Posiable CSS FontFamily |
     *
     * **Notes:**
     * Default value: "'Open-Sans", "sans-serif"'
     */
    actorFontFamily: '"Open-Sans", "sans-serif"',

    /**
     * This sets the font weight of the actor's description
     *
     * **Notes:**
     * Default value: 400.
     */
    actorFontWeight: 400,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | noteFontSize | This sets the font size of actor-attached notes | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 14
     */
    noteFontSize: 14,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | noteFontFamily| This sets the font family of actor-attached notes. | string | Required | Any Posiable CSS FontFamily |
     *
     * **Notes:**
     * Default value: ''"trebuchet ms", verdana, arial, sans-serif'
     */
    noteFontFamily: '"trebuchet ms", verdana, arial, sans-serif',

    /**
     * This sets the font weight of the note's description
     *
     * **Notes:**
     * Default value: 400
     */
    noteFontWeight: 400,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | noteAlign | This sets the text alignment of actor-attached notes | string | required | 'left', 'center', 'right'|
     *
     * **Notes:**
     * Default value: 'center'
     */
    noteAlign: 'center',

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | messageFontSize | This sets the font size of actor messages | Integer | Required | Any Positive Number |
     *
     * **Notes:**
     * Default value: 16
     */
    messageFontSize: 16,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | messageFontFamily | This sets the font family of actor messages | string | Required | Any Posiable CSS FontFamily |
     *
     * **Notes:**
     * Default value: '"trebuchet ms", verdana, arial, sans-serif'
     */
    messageFontFamily: '"trebuchet ms", verdana, arial, sans-serif',

    /**
     * This sets the font weight of the message's description
     *
     * **Notes:**
     * Default value: 400.
     */
    messageFontWeight: 400,

    /**
     * This sets the auto-wrap state for the diagram
     *
     * **Notes:**
     * Default value: false.
     */
    wrap: false,

    /**
     * This sets the auto-wrap padding for the diagram (sides only)
     *
     * **Notes:**
     * Default value: 0.
     */
    wrapPadding: 10,

    /**
     * This sets the width of the loop-box (loop, alt, opt, par)
     *
     * **Notes:**
     * Default value: 50.
     */
    labelBoxWidth: 50,

    /**
     * This sets the height of the loop-box (loop, alt, opt, par)
     *
     * **Notes:**
     * Default value: 20.
     */
    labelBoxHeight: 20,
    messageFont: function messageFont() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    },
    noteFont: function noteFont() {
      return {
        fontFamily: this.noteFontFamily,
        fontSize: this.noteFontSize,
        fontWeight: this.noteFontWeight
      };
    },
    actorFont: function actorFont() {
      return {
        fontFamily: this.actorFontFamily,
        fontSize: this.actorFontSize,
        fontWeight: this.actorFontWeight
      };
    }
  },

  /**
   * The object containing configurations specific for gantt diagrams
   */
  gantt: {
    /**
     * ### titleTopMargin
     *
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | titleTopMargin | Margin top for the text over the gantt diagram | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 25
     */
    titleTopMargin: 25,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | barHeight | The height of the bars in the graph | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 20
     */
    barHeight: 20,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | barGap | The margin between the different activities in the gantt diagram | Integer | Optional | Any Positive Value |
     *
     * **Notes:**
     * Default value: 4
     */
    barGap: 4,

    /**
     * | Parameter | Description | Type | Required | Values|
     * | --- | --- | --- | --- | --- |
     * | topPadding | Margin between title and gantt diagram and between axis and gantt diagram. | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 50
     */
    topPadding: 50,

    /**
     * | Parameter | Description | Type | Required | Values|
     * | --- | --- | --- | --- | --- |
     * | rightPadding | The space allocated for the section name to the right of the activities | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 75
     */
    rightPadding: 75,

    /**
     * | Parameter | Description | Type | Required | Values|
     * | --- | --- | --- | --- | --- |
     * | leftPadding | The space allocated for the section name to the left of the activities | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 75
     */
    leftPadding: 75,

    /**
     * | Parameter | Description | Type | Required | Values|
     * | --- | --- | --- | --- | --- |
     * | gridLineStartPadding | Vertical starting position of the grid lines | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 35
     */
    gridLineStartPadding: 35,

    /**
     * | Parameter | Description | Type | Required | Values|
     * | --- | --- | --- | --- | --- |
     * | fontSize | Font size | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 11
     */
    fontSize: 11,

    /**
     * | Parameter | Description | Type | Required | Values|
     * | --- | --- | --- | --- | --- |
     * | sectionFontSize | Font size for secions| Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 11
     */
    sectionFontSize: 11,

    /**
     * | Parameter | Description | Type | Required | Values|
     * | --- | --- | --- | --- | --- |
     * | numberSectionStyles | The number of alternating section styles | Integer | 4 | Any Positive Value |
     *
     * **Notes:**
     * Default value: 4
     */
    numberSectionStyles: 4,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | axisFormat | Datetime format of the axis | 3 | Required | Date in yy-mm-dd |
     *
     * **Notes:**
     *
     * This might need adjustment to match your locale and preferences
     *
     * Default value: '%Y-%m-%d'.
     */
    axisFormat: '%Y-%m-%d',

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | useMaxWidth | See notes | boolean | 4 | true, false |
     *
     * **Notes:**
     *
     * When this flag is set the height and width is set to 100% and is then scaling with the
     * available space if not the absolute space required is used.
     *
     * Default value: true
     */
    useMaxWidth: true,

    /**
     *| Parameter | Description |Type | Required | Values|
     *| --- | --- | --- | --- | --- |
     *| topAxis | See notes | Boolean | 4 | True, False |
     *
     ***Notes:** when this flag is set date labels will be added to the
    top of the chart
     *
     ***Default value false**.
     */
    topAxis: false,
    useWidth: undefined
  },

  /**
   * The object containing configurations specific for journey diagrams
   */
  journey: {
    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | diagramMarginX | Margin to the right and left of the sequence diagram | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 50
     */
    diagramMarginX: 50,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | diagramMarginY | Margin to the over and under the sequence diagram. | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 10
     */
    diagramMarginY: 10,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | actorMargin | Margin between actors | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 50
     */
    leftMargin: 150,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | width | Width of actor boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 150
     */
    width: 150,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | height | Height of actor boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 65
     */
    height: 50,

    /**
     *| Parameter | Description |Type | Required | Values|
     *| --- | --- | --- | --- | --- |
     *| boxMargin | Margin around loop boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 10
     */
    boxMargin: 10,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | boxTextMargin | Margin around the text in loop/alt/opt boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 5
     */
    boxTextMargin: 5,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | noteMargin | Margin around notes | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     * Default value: 10
     */
    noteMargin: 10,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | messageMargin |Space between messages. | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     *
     * Space between messages.
     *
     * Default value: 35
     */
    messageMargin: 35,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | messageAlign | Multiline message alignment | 3 | 4 | 'left', 'center', 'right' |
     *
     * **Notes:**
     * Default value: 'center'
     */
    messageAlign: 'center',

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | bottomMarginAdj | Prolongs the edge of the diagram downwards | Integer | 4 | Any Positive Value |
     *
     * **Notes:**
     *
     * Depending on css styling this might need adjustment.
     *
     * Default value: 1
     */
    bottomMarginAdj: 1,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | useMaxWidth | See notes | boolean | 4 | true, false |
     *
     * **Notes:**
     *
     * When this flag is set the height and width is set to 100% and is then scaling with the
     * available space if not the absolute space required is used.
     *
     * Default value: true
     */
    useMaxWidth: true,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | rightAngles | Curved Arrows become Right Angles | 3 | 4 | true, false |
     *
     * **Notes:**
     *
     * This will display arrows that start and begin at the same node as right angles, rather than a curves
     *
     * Default value: false
     */
    rightAngles: false,
    taskFontSize: 14,
    taskFontFamily: '"Open-Sans", "sans-serif"',
    taskMargin: 50,
    // width of activation box
    activationWidth: 10,
    // text placement as: tspan | fo | old only text as before
    textPlacement: 'fo',
    actorColours: ['#8FBC8F', '#7CFC00', '#00FFFF', '#20B2AA', '#B0E0E6', '#FFFFE0'],
    sectionFills: ['#191970', '#8B008B', '#4B0082', '#2F4F4F', '#800000', '#8B4513', '#00008B'],
    sectionColours: ['#fff']
  },
  class: {
    arrowMarkerAbsolute: false,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | useMaxWidth | See notes | boolean | 4 | true, false |
     *
     * **Notes:**
     *
     * When this flag is set the height and width is set to 100% and is then scaling with the
     * available space if not the absolute space required is used.
     *
     * Default value: true
     */
    useMaxWidth: true,

    /**
     * | Parameter | Description | Type | Required | Values|
     * | --- | --- | --- | --- | --- |
     * | defaultRenderer | See notes | boolean | 4 | dagre-d3, dagre-wrapper |
     *
     * **Notes:**
     *
     * Decides which rendering engine that is to be used for the rendering. Legal values are:
     * * dagre-d3
     * * dagre-wrapper - wrapper for dagre implemented in mermaid
     *
     * Default value: 'dagre-d3'
     */
    defaultRenderer: 'dagre-wrapper'
  },
  git: {
    arrowMarkerAbsolute: false,
    useWidth: undefined,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | useMaxWidth | See notes | boolean | 4 | true, false |
     *
     * **Notes:**
     *
     * When this flag is set the height and width is set to 100% and is then scaling with the
     * available space if not the absolute space required is used.
     *
     * Default value: true
     */
    useMaxWidth: true
  },
  state: {
    dividerMargin: 10,
    sizeUnit: 5,
    padding: 8,
    textHeight: 10,
    titleShift: -15,
    noteMargin: 10,
    forkWidth: 70,
    forkHeight: 7,
    // Used
    miniPadding: 2,
    // Font size factor, this is used to guess the width of the edges labels before rendering by dagre
    // layout. This might need updating if/when switching font
    fontSizeFactor: 5.02,
    fontSize: 24,
    labelHeight: 16,
    edgeLengthFactor: '20',
    compositTitleSize: 35,
    radius: 5,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | useMaxWidth | See notes | boolean | 4 | true, false |
     *
     * **Notes:**
     *
     * When this flag is set the height and width is set to 100% and is then scaling with the
     * available space if not the absolute space required is used.
     *
     * Default value: true
     */
    useMaxWidth: true,

    /**
     * | Parameter | Description | Type | Required | Values|
     * | --- | --- | --- | --- | --- |
     * | defaultRenderer | See notes | boolean | 4 | dagre-d3, dagre-wrapper |
     *
     * **Notes:**
     *
     * Decides which rendering engine that is to be used for the rendering. Legal values are:
     * * dagre-d3
     * * dagre-wrapper - wrapper for dagre implemented in mermaid
     *
     * Default value: 'dagre-d3'
     */
    defaultRenderer: 'dagre-wrapper'
  },

  /**
   * The object containing configurations specific for entity relationship diagrams
   */
  er: {
    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | diagramPadding | Amount of padding around the diagram as a whole | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     *
     * The amount of padding around the diagram as a whole so that embedded diagrams have margins, expressed in pixels
     *
     * Default value: 20
     */
    diagramPadding: 20,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | layoutDirection | Directional bias for layout of entities. | string | Required | "TB", "BT", "LR", "RL" |
     *
     * **Notes:**
     *
     * 'TB' for Top-Bottom, 'BT'for Bottom-Top, 'LR' for Left-Right, or 'RL' for Right to Left.
     *
     * T = top, B = bottom, L = left, and R = right.
     *
     * Default value: 'TB'
     */
    layoutDirection: 'TB',

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | minEntityWidth | The mimimum width of an entity box | Integer | Required | Any Positive Value  |
     *
     * **Notes:**
     * Expressed in pixels.
     * Default value: 100
     */
    minEntityWidth: 100,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | minEntityHeight| The minimum height of an entity box | Integer | 4 | Any Positive Value |
     *
     * **Notes:**
     * Expressed in pixels
     * Default value: 75
     */
    minEntityHeight: 75,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | entityPadding | Minimum internal padding betweentext in box and box borders | Integer | 4 | Any Positive Value |
     *
     * **Notes:**
     *
     * The minimum internal padding betweentext in an entity box and the enclosing box borders, expressed in pixels.
     *
     * Default value: 15
     */
    entityPadding: 15,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | stroke | Stroke color of box edges and lines | string | 4 | Any recognized color |
     *
     * **Notes:**
     * Default value: 'gray'
     */
    stroke: 'gray',

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | fill | Fill color of entity boxes | string | 4 | Any recognized color |
     *
     * **Notes:**
     * Default value: 'honeydew'
     */
    fill: 'honeydew',

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | fontSize | Font Size in pixels | Integer |  | Any Positive Value |
     *
     * **Notes:**
     *
     * Font size (expressed as an integer representing a number of pixels)
     * Default value: 12
     */
    fontSize: 12,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | useMaxWidth | See Notes | boolean | Required | true, false |
     *
     * **Notes:**
     *
     * When this flag is set to true, the diagram width is locked to 100% and
     * scaled based on available space. If set to false, the diagram reserves its
     * absolute width.
     *
     * Default value: true
     */
    useMaxWidth: true
  },

  /**
   * The object containing configurations specific for pie diagrams
   */
  pie: {
    useWidth: undefined,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | useMaxWidth | See Notes | boolean | Required | true, false |
     *
     * **Notes:**
     *
     * When this flag is set to true, the diagram width is locked to 100% and
     * scaled based on available space. If set to false, the diagram reserves its
     * absolute width.
     *
     * Default value: true
     */
    useMaxWidth: true
  },

  /**
   * The object containing configurations specific for req diagrams
   */
  requirement: {
    useWidth: undefined,

    /**
     * | Parameter | Description | Type | Required | Values |
     * | --- | --- | --- | --- | --- |
     * | useMaxWidth | See Notes | boolean | Required | true, false |
     *
     * **Notes:**
     *
     * When this flag is set to true, the diagram width is locked to 100% and
     * scaled based on available space. If set to false, the diagram reserves its
     * absolute width.
     *
     * Default value: true
     */
    useMaxWidth: true,
    rect_fill: '#f9f9f9',
    text_color: '#333',
    rect_border_size: '0.5px',
    rect_border_color: '#bbb',
    rect_min_width: 200,
    rect_min_height: 200,
    fontSize: 14,
    rect_padding: 10,
    line_height: 20
  }
};
config.class.arrowMarkerAbsolute = config.arrowMarkerAbsolute;
config.git.arrowMarkerAbsolute = config.arrowMarkerAbsolute;

var keyify = function keyify(obj) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return Object.keys(obj).reduce(function (res, el) {
    if (Array.isArray(obj[el])) {
      return res;
    } else if (_typeof(obj[el]) === 'object' && obj[el] !== null) {
      return [].concat(_toConsumableArray(res), [prefix + el], _toConsumableArray(keyify(obj[el], '')));
    }

    return [].concat(_toConsumableArray(res), [prefix + el]);
  }, []);
};

var configKeys = keyify(config, '');
/* harmony default export */ __webpack_exports__["default"] = (config);

/***/ }),

/***/ "./src/diagrams/class/classDb.js":
/*!***************************************!*\
  !*** ./src/diagrams/class/classDb.js ***!
  \***************************************/
/*! exports provided: parseDirective, addClass, lookUpDomId, clear, getClass, getClasses, getRelations, addRelation, addAnnotation, addMember, addMembers, cleanupLabel, setCssClass, setLink, setClickEvent, bindFunctions, lineType, relationType, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseDirective", function() { return parseDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addClass", function() { return addClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookUpDomId", function() { return lookUpDomId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getClass", function() { return getClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getClasses", function() { return getClasses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRelations", function() { return getRelations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addRelation", function() { return addRelation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addAnnotation", function() { return addAnnotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addMember", function() { return addMember; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addMembers", function() { return addMembers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cleanupLabel", function() { return cleanupLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setCssClass", function() { return setCssClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setLink", function() { return setLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setClickEvent", function() { return setClickEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindFunctions", function() { return bindFunctions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineType", function() { return lineType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "relationType", function() { return relationType; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/* harmony import */ var _common_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/common */ "./src/diagrams/common/common.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");
/* harmony import */ var _mermaidAPI__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../mermaidAPI */ "./src/mermaidAPI.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }







var MERMAID_DOM_ID_PREFIX = 'classid-';
var relations = [];
var classes = {};
var classCounter = 0;
var funs = [];
var parseDirective = function parseDirective(statement, context, type) {
  _mermaidAPI__WEBPACK_IMPORTED_MODULE_5__["default"].parseDirective(this, statement, context, type);
};

var splitClassNameAndType = function splitClassNameAndType(id) {
  var genericType = '';
  var className = id;

  if (id.indexOf('~') > 0) {
    var split = id.split('~');
    className = split[0];
    genericType = split[1];
  }

  return {
    className: className,
    type: genericType
  };
};
/**
 * Function called by parser when a node definition has been found.
 * @param id
 * @public
 */


var addClass = function addClass(id) {
  var classId = splitClassNameAndType(id); // Only add class if not exists

  if (typeof classes[classId.className] !== 'undefined') return;
  classes[classId.className] = {
    id: classId.className,
    type: classId.type,
    cssClasses: [],
    methods: [],
    members: [],
    annotations: [],
    domId: MERMAID_DOM_ID_PREFIX + classId.className + '-' + classCounter
  };
  classCounter++;
};
/**
 * Function to lookup domId from id in the graph definition.
 * @param id
 * @public
 */

var lookUpDomId = function lookUpDomId(id) {
  var classKeys = Object.keys(classes);

  for (var i = 0; i < classKeys.length; i++) {
    if (classes[classKeys[i]].id === id) {
      return classes[classKeys[i]].domId;
    }
  }
};
var clear = function clear() {
  relations = [];
  classes = {};
  funs = [];
  funs.push(setupToolTips);
};
var getClass = function getClass(id) {
  return classes[id];
};
var getClasses = function getClasses() {
  return classes;
};
var getRelations = function getRelations() {
  return relations;
};
var addRelation = function addRelation(relation) {
  _logger__WEBPACK_IMPORTED_MODULE_1__["log"].debug('Adding relation: ' + JSON.stringify(relation));
  addClass(relation.id1);
  addClass(relation.id2);
  relation.id1 = splitClassNameAndType(relation.id1).className;
  relation.id2 = splitClassNameAndType(relation.id2).className;
  relations.push(relation);
};
/**
 * Adds an annotation to the specified class
 * Annotations mark special properties of the given type (like 'interface' or 'service')
 * @param className The class name
 * @param annotation The name of the annotation without any brackets
 * @public
 */

var addAnnotation = function addAnnotation(className, annotation) {
  var validatedClassName = splitClassNameAndType(className).className;
  classes[validatedClassName].annotations.push(annotation);
};
/**
 * Adds a member to the specified class
 * @param className The class name
 * @param member The full name of the member.
 * If the member is enclosed in <<brackets>> it is treated as an annotation
 * If the member is ending with a closing bracket ) it is treated as a method
 * Otherwise the member will be treated as a normal property
 * @public
 */

var addMember = function addMember(className, member) {
  var validatedClassName = splitClassNameAndType(className).className;
  var theClass = classes[validatedClassName];

  if (typeof member === 'string') {
    // Member can contain white spaces, we trim them out
    var memberString = member.trim();

    if (memberString.startsWith('<<') && memberString.endsWith('>>')) {
      // Remove leading and trailing brackets
      theClass.annotations.push(memberString.substring(2, memberString.length - 2));
    } else if (memberString.indexOf(')') > 0) {
      theClass.methods.push(memberString);
    } else if (memberString) {
      theClass.members.push(memberString);
    }
  }
};
var addMembers = function addMembers(className, members) {
  if (Array.isArray(members)) {
    members.reverse();
    members.forEach(function (member) {
      return addMember(className, member);
    });
  }
};
var cleanupLabel = function cleanupLabel(label) {
  if (label.substring(0, 1) === ':') {
    return label.substr(1).trim();
  } else {
    return label.trim();
  }
};
/**
 * Called by parser when a special node is found, e.g. a clickable element.
 * @param ids Comma separated list of ids
 * @param className Class to add
 */

var setCssClass = function setCssClass(ids, className) {
  ids.split(',').forEach(function (_id) {
    var id = _id;
    if (_id[0].match(/\d/)) id = MERMAID_DOM_ID_PREFIX + id;

    if (typeof classes[id] !== 'undefined') {
      classes[id].cssClasses.push(className);
    }
  });
};
/**
 * Called by parser when a tooltip is found, e.g. a clickable element.
 * @param ids Comma separated list of ids
 * @param tooltip Tooltip to add
 */

var setTooltip = function setTooltip(ids, tooltip) {
  var config = _config__WEBPACK_IMPORTED_MODULE_2__["getConfig"]();
  ids.split(',').forEach(function (id) {
    if (typeof tooltip !== 'undefined') {
      classes[id].tooltip = _common_common__WEBPACK_IMPORTED_MODULE_3__["default"].sanitizeText(tooltip, config);
    }
  });
};
/**
 * Called by parser when a link is found. Adds the URL to the vertex data.
 * @param ids Comma separated list of ids
 * @param linkStr URL to create a link for
 * @param target Target of the link, _blank by default as originally defined in the svgDraw.js file
 */


var setLink = function setLink(ids, linkStr, target) {
  var config = _config__WEBPACK_IMPORTED_MODULE_2__["getConfig"]();
  ids.split(',').forEach(function (_id) {
    var id = _id;
    if (_id[0].match(/\d/)) id = MERMAID_DOM_ID_PREFIX + id;

    if (typeof classes[id] !== 'undefined') {
      classes[id].link = _utils__WEBPACK_IMPORTED_MODULE_4__["default"].formatUrl(linkStr, config);

      if (typeof target === 'string') {
        classes[id].linkTarget = target;
      } else {
        classes[id].linkTarget = '_blank';
      }
    }
  });
  setCssClass(ids, 'clickable');
};
/**
 * Called by parser when a click definition is found. Registers an event handler.
 * @param ids Comma separated list of ids
 * @param functionName Function to be called on click
 * @param functionArgs Function args the function should be called with
 */

var setClickEvent = function setClickEvent(ids, functionName, functionArgs) {
  ids.split(',').forEach(function (id) {
    setClickFunc(id, functionName, functionArgs);
    classes[id].haveCallback = true;
  });
  setCssClass(ids, 'clickable');
};

var setClickFunc = function setClickFunc(domId, functionName, functionArgs) {
  var config = _config__WEBPACK_IMPORTED_MODULE_2__["getConfig"]();
  var id = domId;
  var elemId = lookUpDomId(id);

  if (config.securityLevel !== 'loose') {
    return;
  }

  if (typeof functionName === 'undefined') {
    return;
  }

  if (typeof classes[id] !== 'undefined') {
    var argList = [];

    if (typeof functionArgs === 'string') {
      /* Splits functionArgs by ',', ignoring all ',' in double quoted strings */
      argList = functionArgs.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);

      for (var i = 0; i < argList.length; i++) {
        var item = argList[i].trim();
        /* Removes all double quotes at the start and end of an argument */

        /* This preserves all starting and ending whitespace inside */

        if (item.charAt(0) === '"' && item.charAt(item.length - 1) === '"') {
          item = item.substr(1, item.length - 2);
        }

        argList[i] = item;
      }
    }
    /* if no arguments passed into callback, default to passing in id */


    if (argList.length === 0) {
      argList.push(elemId);
    }

    funs.push(function () {
      var elem = document.querySelector("[id=\"".concat(elemId, "\"]"));

      if (elem !== null) {
        elem.addEventListener('click', function () {
          _utils__WEBPACK_IMPORTED_MODULE_4__["default"].runFunc.apply(_utils__WEBPACK_IMPORTED_MODULE_4__["default"], [functionName].concat(_toConsumableArray(argList)));
        }, false);
      }
    });
  }
};

var bindFunctions = function bindFunctions(element) {
  funs.forEach(function (fun) {
    fun(element);
  });
};
var lineType = {
  LINE: 0,
  DOTTED_LINE: 1
};
var relationType = {
  AGGREGATION: 0,
  EXTENSION: 1,
  COMPOSITION: 2,
  DEPENDENCY: 3
};

var setupToolTips = function setupToolTips(element) {
  var tooltipElem = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('.mermaidTooltip');

  if ((tooltipElem._groups || tooltipElem)[0][0] === null) {
    tooltipElem = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('body').append('div').attr('class', 'mermaidTooltip').style('opacity', 0);
  }

  var svg = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(element).select('svg');
  var nodes = svg.selectAll('g.node');
  nodes.on('mouseover', function () {
    var el = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(this);
    var title = el.attr('title'); // Dont try to draw a tooltip if no data is provided

    if (title === null) {
      return;
    }

    var rect = this.getBoundingClientRect();
    tooltipElem.transition().duration(200).style('opacity', '.9');
    tooltipElem.html(el.attr('title')).style('left', window.scrollX + rect.left + (rect.right - rect.left) / 2 + 'px').style('top', window.scrollY + rect.top - 14 + document.body.scrollTop + 'px');
    el.classed('hover', true);
  }).on('mouseout', function () {
    tooltipElem.transition().duration(500).style('opacity', 0);
    var el = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(this);
    el.classed('hover', false);
  });
};

funs.push(setupToolTips);
var direction = 'TB';

var getDirection = function getDirection() {
  return direction;
};

var setDirection = function setDirection(dir) {
  direction = dir;
};

/* harmony default export */ __webpack_exports__["default"] = ({
  parseDirective: parseDirective,
  getConfig: function getConfig() {
    return _config__WEBPACK_IMPORTED_MODULE_2__["getConfig"]().class;
  },
  addClass: addClass,
  bindFunctions: bindFunctions,
  clear: clear,
  getClass: getClass,
  getClasses: getClasses,
  addAnnotation: addAnnotation,
  getRelations: getRelations,
  addRelation: addRelation,
  getDirection: getDirection,
  setDirection: setDirection,
  addMember: addMember,
  addMembers: addMembers,
  cleanupLabel: cleanupLabel,
  lineType: lineType,
  relationType: relationType,
  setClickEvent: setClickEvent,
  setCssClass: setCssClass,
  setLink: setLink,
  setTooltip: setTooltip,
  lookUpDomId: lookUpDomId
});

/***/ }),

/***/ "./src/diagrams/class/classRenderer-v2.js":
/*!************************************************!*\
  !*** ./src/diagrams/class/classRenderer-v2.js ***!
  \************************************************/
/*! exports provided: addClasses, addRelations, setConf, drawOld, draw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addClasses", function() { return addClasses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addRelations", function() { return addRelations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConf", function() { return setConf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawOld", function() { return drawOld; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return draw; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var dagre__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dagre */ "dagre");
/* harmony import */ var dagre__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dagre__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! graphlib */ "graphlib");
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(graphlib__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _classDb__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./classDb */ "./src/diagrams/class/classDb.js");
/* harmony import */ var _parser_classDiagram__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parser/classDiagram */ "./src/diagrams/class/parser/classDiagram.jison");
/* harmony import */ var _parser_classDiagram__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_parser_classDiagram__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _svgDraw__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./svgDraw */ "./src/diagrams/class/svgDraw.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/* harmony import */ var _dagre_wrapper_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../dagre-wrapper/index.js */ "./src/dagre-wrapper/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");
/* harmony import */ var _common_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../common/common */ "./src/diagrams/common/common.js");








 // import addHtmlLabel from 'dagre-d3/lib/label/add-html-label.js';




_parser_classDiagram__WEBPACK_IMPORTED_MODULE_5__["parser"].yy = _classDb__WEBPACK_IMPORTED_MODULE_4__["default"];
var idCache = {};
var padding = 20;
var conf = {
  dividerMargin: 10,
  padding: 5,
  textHeight: 10
};
/**
 * Function that adds the vertices found during parsing to the graph to be rendered.
 * @param vert Object containing the vertices.
 * @param g The graph that is to be drawn.
 */

var addClasses = function addClasses(classes, g) {
  // const svg = select(`[id="${svgId}"]`);
  var keys = Object.keys(classes);
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info('keys:', keys);
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info(classes); // Iterate through each item in the vertex object (containing all the vertices found) in the graph definition

  keys.forEach(function (id) {
    var vertex = classes[id];
    /**
     * Variable for storing the classes for the vertex
     * @type {string}
     */

    var cssClassStr = '';

    if (vertex.cssClasses.length > 0) {
      cssClassStr = cssClassStr + ' ' + vertex.cssClasses.join(' ');
    } // if (vertex.classes.length > 0) {
    //   classStr = vertex.classes.join(' ');
    // }


    var styles = {
      labelStyle: ''
    }; //getStylesFromArray(vertex.styles);
    // Use vertex id as text in the box if no text is provided by the graph definition

    var vertexText = vertex.text !== undefined ? vertex.text : vertex.id; // We create a SVG label, either by delegating to addHtmlLabel or manually
    // let vertexNode;
    // if (evaluate(getConfig().flowchart.htmlLabels)) {
    //   const node = {
    //     label: vertexText.replace(
    //       /fa[lrsb]?:fa-[\w-]+/g,
    //       s => `<i class='${s.replace(':', ' ')}'></i>`
    //     )
    //   };
    //   vertexNode = addHtmlLabel(svg, node).node();
    //   vertexNode.parentNode.removeChild(vertexNode);
    // } else {
    //   const svgLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    //   svgLabel.setAttribute('style', styles.labelStyle.replace('color:', 'fill:'));
    //   const rows = vertexText.split(common.lineBreakRegex);
    //   for (let j = 0; j < rows.length; j++) {
    //     const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
    //     tspan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
    //     tspan.setAttribute('dy', '1em');
    //     tspan.setAttribute('x', '1');
    //     tspan.textContent = rows[j];
    //     svgLabel.appendChild(tspan);
    //   }
    //   vertexNode = svgLabel;
    // }

    var radious = 0;
    var _shape = ''; // Set the shape based parameters

    switch (vertex.type) {
      case 'class':
        _shape = 'class_box';
        break;

      default:
        _shape = 'class_box';
    } // Add the node


    g.setNode(vertex.id, {
      labelStyle: styles.labelStyle,
      shape: _shape,
      labelText: vertexText,
      classData: vertex,
      rx: radious,
      ry: radious,
      class: cssClassStr,
      style: styles.style,
      id: vertex.id,
      domId: vertex.domId,
      haveCallback: vertex.haveCallback,
      link: vertex.link,
      width: vertex.type === 'group' ? 500 : undefined,
      type: vertex.type,
      padding: Object(_config__WEBPACK_IMPORTED_MODULE_7__["getConfig"])().flowchart.padding
    });
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info('setNode', {
      labelStyle: styles.labelStyle,
      shape: _shape,
      labelText: vertexText,
      rx: radious,
      ry: radious,
      class: cssClassStr,
      style: styles.style,
      id: vertex.id,
      width: vertex.type === 'group' ? 500 : undefined,
      type: vertex.type,
      padding: Object(_config__WEBPACK_IMPORTED_MODULE_7__["getConfig"])().flowchart.padding
    });
  });
};
/**
 * Add edges to graph based on parsed graph defninition
 * @param {Object} edges The edges to add to the graph
 * @param {Object} g The graph object
 */

var addRelations = function addRelations(relations, g) {
  var cnt = 0;
  var defaultStyle;
  var defaultLabelStyle; // if (typeof relations.defaultStyle !== 'undefined') {
  //   const defaultStyles = getStylesFromArray(relations.defaultStyle);
  //   defaultStyle = defaultStyles.style;
  //   defaultLabelStyle = defaultStyles.labelStyle;
  // }

  relations.forEach(function (edge) {
    cnt++;
    var edgeData = {}; //Set relationship style and line type

    edgeData.classes = 'relation';
    edgeData.pattern = edge.relation.lineType == 1 ? 'dashed' : 'solid';
    edgeData.id = 'id' + cnt; // Set link type for rendering

    if (edge.type === 'arrow_open') {
      edgeData.arrowhead = 'none';
    } else {
      edgeData.arrowhead = 'normal';
    }

    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info(edgeData, edge); //Set edge extra labels
    //edgeData.startLabelLeft = edge.relationTitle1;

    edgeData.startLabelRight = edge.relationTitle1 === 'none' ? '' : edge.relationTitle1;
    edgeData.endLabelLeft = edge.relationTitle2 === 'none' ? '' : edge.relationTitle2; //edgeData.endLabelRight = edge.relationTitle2;
    //Set relation arrow types

    edgeData.arrowTypeStart = getArrowMarker(edge.relation.type1);
    edgeData.arrowTypeEnd = getArrowMarker(edge.relation.type2);
    var style = '';
    var labelStyle = '';

    if (typeof edge.style !== 'undefined') {
      var styles = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["getStylesFromArray"])(edge.style);
      style = styles.style;
      labelStyle = styles.labelStyle;
    } else {
      style = 'fill:none';

      if (typeof defaultStyle !== 'undefined') {
        style = defaultStyle;
      }

      if (typeof defaultLabelStyle !== 'undefined') {
        labelStyle = defaultLabelStyle;
      }
    }

    edgeData.style = style;
    edgeData.labelStyle = labelStyle;

    if (typeof edge.interpolate !== 'undefined') {
      edgeData.curve = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["interpolateToCurve"])(edge.interpolate, d3__WEBPACK_IMPORTED_MODULE_0__["curveLinear"]);
    } else if (typeof relations.defaultInterpolate !== 'undefined') {
      edgeData.curve = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["interpolateToCurve"])(relations.defaultInterpolate, d3__WEBPACK_IMPORTED_MODULE_0__["curveLinear"]);
    } else {
      edgeData.curve = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["interpolateToCurve"])(conf.curve, d3__WEBPACK_IMPORTED_MODULE_0__["curveLinear"]);
    }

    edge.text = edge.title;

    if (typeof edge.text === 'undefined') {
      if (typeof edge.style !== 'undefined') {
        edgeData.arrowheadStyle = 'fill: #333';
      }
    } else {
      edgeData.arrowheadStyle = 'fill: #333';
      edgeData.labelpos = 'c';

      if (Object(_config__WEBPACK_IMPORTED_MODULE_7__["getConfig"])().flowchart.htmlLabels) {
        // eslint-disable-line
        edgeData.labelType = 'html';
        edgeData.label = '<span class="edgeLabel">' + edge.text + '</span>';
      } else {
        edgeData.labelType = 'text';
        edgeData.label = edge.text.replace(_common_common__WEBPACK_IMPORTED_MODULE_10__["default"].lineBreakRegex, '\n');

        if (typeof edge.style === 'undefined') {
          edgeData.style = edgeData.style || 'stroke: #333; stroke-width: 1.5px;fill:none';
        }

        edgeData.labelStyle = edgeData.labelStyle.replace('color:', 'fill:');
      }
    } // Add the edge to the graph


    g.setEdge(edge.id1, edge.id2, edgeData, cnt);
  });
}; // Todo optimize

var getGraphId = function getGraphId(label) {
  var keys = Object.keys(idCache);

  for (var i = 0; i < keys.length; i++) {
    if (idCache[keys[i]].label === label) {
      return keys[i];
    }
  }

  return undefined;
};

var setConf = function setConf(cnf) {
  var keys = Object.keys(cnf);
  keys.forEach(function (key) {
    conf[key] = cnf[key];
  });
};
/**
 * Draws a flowchart in the tag with id: id based on the graph definition in text.
 * @param text
 * @param id
 */

var drawOld = function drawOld(text, id) {
  idCache = {};
  _parser_classDiagram__WEBPACK_IMPORTED_MODULE_5__["parser"].yy.clear();
  _parser_classDiagram__WEBPACK_IMPORTED_MODULE_5__["parser"].parse(text);
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info('Rendering diagram ' + text); // Fetch the default direction, use TD if none was found

  var diagram = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])("[id='".concat(id, "']")); // insertMarkers(diagram);
  // Layout graph, Create a new directed graph

  var g = new graphlib__WEBPACK_IMPORTED_MODULE_2___default.a.Graph({
    multigraph: true
  }); // Set an object for the graph label

  g.setGraph({
    isMultiGraph: true
  }); // Default to assigning a new object as a label for each new edge.

  g.setDefaultEdgeLabel(function () {
    return {};
  });
  var classes = _classDb__WEBPACK_IMPORTED_MODULE_4__["default"].getClasses();
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info('classes:');
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info(classes);
  var keys = Object.keys(classes);

  for (var i = 0; i < keys.length; i++) {
    var classDef = classes[keys[i]];
    var node = _svgDraw__WEBPACK_IMPORTED_MODULE_6__["default"].drawClass(diagram, classDef, conf);
    idCache[node.id] = node; // Add nodes to the graph. The first argument is the node id. The second is
    // metadata about the node. In this case we're going to add labels to each of
    // our nodes.

    g.setNode(node.id, node);
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info('Org height: ' + node.height);
  }

  var relations = _classDb__WEBPACK_IMPORTED_MODULE_4__["default"].getRelations();
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info('relations:', relations);
  relations.forEach(function (relation) {
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info('tjoho' + getGraphId(relation.id1) + getGraphId(relation.id2) + JSON.stringify(relation));
    g.setEdge(getGraphId(relation.id1), getGraphId(relation.id2), {
      relation: relation
    }, relation.title || 'DEFAULT');
  });
  dagre__WEBPACK_IMPORTED_MODULE_1___default.a.layout(g);
  g.nodes().forEach(function (v) {
    if (typeof v !== 'undefined' && typeof g.node(v) !== 'undefined') {
      _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('Node ' + v + ': ' + JSON.stringify(g.node(v)));
      Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('#' + Object(_classDb__WEBPACK_IMPORTED_MODULE_4__["lookUpDomId"])(v)).attr('transform', 'translate(' + (g.node(v).x - g.node(v).width / 2) + ',' + (g.node(v).y - g.node(v).height / 2) + ' )');
    }
  });
  g.edges().forEach(function (e) {
    if (typeof e !== 'undefined' && typeof g.edge(e) !== 'undefined') {
      _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(g.edge(e)));
      _svgDraw__WEBPACK_IMPORTED_MODULE_6__["default"].drawEdge(diagram, g.edge(e), g.edge(e).relation, conf);
    }
  });
  var svgBounds = diagram.node().getBBox();
  var width = svgBounds.width + padding * 2;
  var height = svgBounds.height + padding * 2;
  Object(_utils__WEBPACK_IMPORTED_MODULE_9__["configureSvgSize"])(diagram, height, width, conf.useMaxWidth); // Ensure the viewBox includes the whole svgBounds area with extra space for padding

  var vBox = "".concat(svgBounds.x - padding, " ").concat(svgBounds.y - padding, " ").concat(width, " ").concat(height);
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug("viewBox ".concat(vBox));
  diagram.attr('viewBox', vBox);
};
var draw = function draw(text, id) {
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info('Drawing class');
  _classDb__WEBPACK_IMPORTED_MODULE_4__["default"].clear(); // const parser = classDb.parser;
  // parser.yy = classDb;
  // Parse the graph definition
  // try {

  _parser_classDiagram__WEBPACK_IMPORTED_MODULE_5__["parser"].parse(text); // } catch (err) {
  // log.debug('Parsing failed');
  // }
  // Fetch the default direction, use TD if none was found
  //let dir = 'TD';

  var conf = Object(_config__WEBPACK_IMPORTED_MODULE_7__["getConfig"])().flowchart;
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info('config:', conf);
  var nodeSpacing = conf.nodeSpacing || 50;
  var rankSpacing = conf.rankSpacing || 50; // Create the input mermaid.graph

  var g = new graphlib__WEBPACK_IMPORTED_MODULE_2___default.a.Graph({
    multigraph: true,
    compound: true
  }).setGraph({
    rankdir: _classDb__WEBPACK_IMPORTED_MODULE_4__["default"].getDirection(),
    nodesep: nodeSpacing,
    ranksep: rankSpacing,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function () {
    return {};
  }); // let subG;
  // const subGraphs = flowDb.getSubGraphs();
  // log.info('Subgraphs - ', subGraphs);
  // for (let i = subGraphs.length - 1; i >= 0; i--) {
  //   subG = subGraphs[i];
  //   log.info('Subgraph - ', subG);
  //   flowDb.addVertex(subG.id, subG.title, 'group', undefined, subG.classes);
  // }
  // Fetch the verices/nodes and edges/links from the parsed graph definition

  var classes = _classDb__WEBPACK_IMPORTED_MODULE_4__["default"].getClasses();
  var relations = _classDb__WEBPACK_IMPORTED_MODULE_4__["default"].getRelations();
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info(relations); // let i = 0;
  // for (i = subGraphs.length - 1; i >= 0; i--) {
  //   subG = subGraphs[i];
  //   selectAll('cluster').append('text');
  //   for (let j = 0; j < subG.nodes.length; j++) {
  //     g.setParent(subG.nodes[j], subG.id);
  //   }
  // }

  addClasses(classes, g, id);
  addRelations(relations, g); // Add custom shapes
  // flowChartShapes.addToRenderV2(addShape);
  // Set up an SVG group so that we can translate the final graph.

  var svg = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])("[id=\"".concat(id, "\"]"));
  svg.attr('xmlns:xlink', 'http://www.w3.org/1999/xlink'); // Run the renderer. This is what draws the final graph.

  var element = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('#' + id + ' g');
  Object(_dagre_wrapper_index_js__WEBPACK_IMPORTED_MODULE_8__["render"])(element, g, ['aggregation', 'extension', 'composition', 'dependency'], 'classDiagram', id); // element.selectAll('g.node').attr('title', function() {
  //   return flowDb.getTooltip(this.id);
  // });

  var padding = 8;
  var svgBounds = svg.node().getBBox();
  var width = svgBounds.width + padding * 2;
  var height = svgBounds.height + padding * 2;
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug("new ViewBox 0 0 ".concat(width, " ").concat(height), "translate(".concat(padding - g._label.marginx, ", ").concat(padding - g._label.marginy, ")"));
  Object(_utils__WEBPACK_IMPORTED_MODULE_9__["configureSvgSize"])(svg, height, width, conf.useMaxWidth);
  svg.attr('viewBox', "0 0 ".concat(width, " ").concat(height));
  svg.select('g').attr('transform', "translate(".concat(padding - g._label.marginx, ", ").concat(padding - svgBounds.y, ")")); // Index nodes
  // flowDb.indexNodes('subGraph' + i);
  // Add label rects for non html labels

  if (!conf.htmlLabels) {
    var labels = document.querySelectorAll('[id="' + id + '"] .edgeLabel .label');

    for (var k = 0; k < labels.length; k++) {
      var label = labels[k]; // Get dimensions of label

      var dim = label.getBBox();
      var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.setAttribute('rx', 0);
      rect.setAttribute('ry', 0);
      rect.setAttribute('width', dim.width);
      rect.setAttribute('height', dim.height); // rect.setAttribute('style', 'fill:#e8e8e8;');

      label.insertBefore(rect, label.firstChild);
    }
  } // If node has a link, wrap it in an anchor SVG object.
  // const keys = Object.keys(classes);
  // keys.forEach(function(key) {
  //   const vertex = classes[key];
  //   if (vertex.link) {
  //     const node = select('#' + id + ' [id="' + key + '"]');
  //     if (node) {
  //       const link = document.createElementNS('http://www.w3.org/2000/svg', 'a');
  //       link.setAttributeNS('http://www.w3.org/2000/svg', 'class', vertex.classes.join(' '));
  //       link.setAttributeNS('http://www.w3.org/2000/svg', 'href', vertex.link);
  //       link.setAttributeNS('http://www.w3.org/2000/svg', 'rel', 'noopener');
  //       const linkNode = node.insert(function() {
  //         return link;
  //       }, ':first-child');
  //       const shape = node.select('.label-container');
  //       if (shape) {
  //         linkNode.append(function() {
  //           return shape.node();
  //         });
  //       }
  //       const label = node.select('.label');
  //       if (label) {
  //         linkNode.append(function() {
  //           return label.node();
  //         });
  //       }
  //     }
  //   }
  // });

};
/* harmony default export */ __webpack_exports__["default"] = ({
  setConf: setConf,
  draw: draw
});

function getArrowMarker(type) {
  var marker;

  switch (type) {
    case 0:
      marker = 'aggregation';
      break;

    case 1:
      marker = 'extension';
      break;

    case 2:
      marker = 'composition';
      break;

    case 3:
      marker = 'dependency';
      break;

    default:
      marker = 'none';
  }

  return marker;
}

/***/ }),

/***/ "./src/diagrams/class/classRenderer.js":
/*!*********************************************!*\
  !*** ./src/diagrams/class/classRenderer.js ***!
  \*********************************************/
/*! exports provided: setConf, draw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConf", function() { return setConf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return draw; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var dagre__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dagre */ "dagre");
/* harmony import */ var dagre__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dagre__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! graphlib */ "graphlib");
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(graphlib__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _classDb__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./classDb */ "./src/diagrams/class/classDb.js");
/* harmony import */ var _parser_classDiagram__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parser/classDiagram */ "./src/diagrams/class/parser/classDiagram.jison");
/* harmony import */ var _parser_classDiagram__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_parser_classDiagram__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _svgDraw__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./svgDraw */ "./src/diagrams/class/svgDraw.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");








_parser_classDiagram__WEBPACK_IMPORTED_MODULE_5__["parser"].yy = _classDb__WEBPACK_IMPORTED_MODULE_4__["default"];
var idCache = {};
var padding = 20;
var conf = {
  dividerMargin: 10,
  padding: 5,
  textHeight: 10
}; // Todo optimize

var getGraphId = function getGraphId(label) {
  var keys = Object.keys(idCache);

  for (var i = 0; i < keys.length; i++) {
    if (idCache[keys[i]].label === label) {
      return keys[i];
    }
  }

  return undefined;
};
/**
 * Setup arrow head and define the marker. The result is appended to the svg.
 */


var insertMarkers = function insertMarkers(elem) {
  elem.append('defs').append('marker').attr('id', 'extensionStart').attr('class', 'extension').attr('refX', 0).attr('refY', 7).attr('markerWidth', 190).attr('markerHeight', 240).attr('orient', 'auto').append('path').attr('d', 'M 1,7 L18,13 V 1 Z');
  elem.append('defs').append('marker').attr('id', 'extensionEnd').attr('refX', 19).attr('refY', 7).attr('markerWidth', 20).attr('markerHeight', 28).attr('orient', 'auto').append('path').attr('d', 'M 1,1 V 13 L18,7 Z'); // this is actual shape for arrowhead

  elem.append('defs').append('marker').attr('id', 'compositionStart').attr('class', 'extension').attr('refX', 0).attr('refY', 7).attr('markerWidth', 190).attr('markerHeight', 240).attr('orient', 'auto').append('path').attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z');
  elem.append('defs').append('marker').attr('id', 'compositionEnd').attr('refX', 19).attr('refY', 7).attr('markerWidth', 20).attr('markerHeight', 28).attr('orient', 'auto').append('path').attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z');
  elem.append('defs').append('marker').attr('id', 'aggregationStart').attr('class', 'extension').attr('refX', 0).attr('refY', 7).attr('markerWidth', 190).attr('markerHeight', 240).attr('orient', 'auto').append('path').attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z');
  elem.append('defs').append('marker').attr('id', 'aggregationEnd').attr('refX', 19).attr('refY', 7).attr('markerWidth', 20).attr('markerHeight', 28).attr('orient', 'auto').append('path').attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z');
  elem.append('defs').append('marker').attr('id', 'dependencyStart').attr('class', 'extension').attr('refX', 0).attr('refY', 7).attr('markerWidth', 190).attr('markerHeight', 240).attr('orient', 'auto').append('path').attr('d', 'M 5,7 L9,13 L1,7 L9,1 Z');
  elem.append('defs').append('marker').attr('id', 'dependencyEnd').attr('refX', 19).attr('refY', 7).attr('markerWidth', 20).attr('markerHeight', 28).attr('orient', 'auto').append('path').attr('d', 'M 18,7 L9,13 L14,7 L9,1 Z');
};

var setConf = function setConf(cnf) {
  var keys = Object.keys(cnf);
  keys.forEach(function (key) {
    conf[key] = cnf[key];
  });
};
/**
 * Draws a flowchart in the tag with id: id based on the graph definition in text.
 * @param text
 * @param id
 */

var draw = function draw(text, id) {
  idCache = {};
  _parser_classDiagram__WEBPACK_IMPORTED_MODULE_5__["parser"].yy.clear();
  _parser_classDiagram__WEBPACK_IMPORTED_MODULE_5__["parser"].parse(text);
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info('Rendering diagram ' + text); // Fetch the default direction, use TD if none was found

  var diagram = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])("[id='".concat(id, "']"));
  diagram.attr('xmlns:xlink', 'http://www.w3.org/1999/xlink');
  insertMarkers(diagram); // Layout graph, Create a new directed graph

  var g = new graphlib__WEBPACK_IMPORTED_MODULE_2___default.a.Graph({
    multigraph: true
  }); // Set an object for the graph label

  g.setGraph({
    isMultiGraph: true
  }); // Default to assigning a new object as a label for each new edge.

  g.setDefaultEdgeLabel(function () {
    return {};
  });
  var classes = _classDb__WEBPACK_IMPORTED_MODULE_4__["default"].getClasses();
  var keys = Object.keys(classes);

  for (var i = 0; i < keys.length; i++) {
    var classDef = classes[keys[i]];
    var node = _svgDraw__WEBPACK_IMPORTED_MODULE_6__["default"].drawClass(diagram, classDef, conf);
    idCache[node.id] = node; // Add nodes to the graph. The first argument is the node id. The second is
    // metadata about the node. In this case we're going to add labels to each of
    // our nodes.

    g.setNode(node.id, node);
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info('Org height: ' + node.height);
  }

  var relations = _classDb__WEBPACK_IMPORTED_MODULE_4__["default"].getRelations();
  relations.forEach(function (relation) {
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info('tjoho' + getGraphId(relation.id1) + getGraphId(relation.id2) + JSON.stringify(relation));
    g.setEdge(getGraphId(relation.id1), getGraphId(relation.id2), {
      relation: relation
    }, relation.title || 'DEFAULT');
  });
  dagre__WEBPACK_IMPORTED_MODULE_1___default.a.layout(g);
  g.nodes().forEach(function (v) {
    if (typeof v !== 'undefined' && typeof g.node(v) !== 'undefined') {
      _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('Node ' + v + ': ' + JSON.stringify(g.node(v)));
      Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('#' + Object(_classDb__WEBPACK_IMPORTED_MODULE_4__["lookUpDomId"])(v)).attr('transform', 'translate(' + (g.node(v).x - g.node(v).width / 2) + ',' + (g.node(v).y - g.node(v).height / 2) + ' )');
    }
  });
  g.edges().forEach(function (e) {
    if (typeof e !== 'undefined' && typeof g.edge(e) !== 'undefined') {
      _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(g.edge(e)));
      _svgDraw__WEBPACK_IMPORTED_MODULE_6__["default"].drawEdge(diagram, g.edge(e), g.edge(e).relation, conf);
    }
  });
  var svgBounds = diagram.node().getBBox();
  var width = svgBounds.width + padding * 2;
  var height = svgBounds.height + padding * 2;
  Object(_utils__WEBPACK_IMPORTED_MODULE_7__["configureSvgSize"])(diagram, height, width, conf.useMaxWidth); // Ensure the viewBox includes the whole svgBounds area with extra space for padding

  var vBox = "".concat(svgBounds.x - padding, " ").concat(svgBounds.y - padding, " ").concat(width, " ").concat(height);
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug("viewBox ".concat(vBox));
  diagram.attr('viewBox', vBox);
};
/* harmony default export */ __webpack_exports__["default"] = ({
  setConf: setConf,
  draw: draw
});

/***/ }),

/***/ "./src/diagrams/class/parser/classDiagram.jison":
/*!******************************************************!*\
  !*** ./src/diagrams/class/parser/classDiagram.jison ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, module) {/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,6],$V1=[1,7],$V2=[1,8],$V3=[1,9],$V4=[1,12],$V5=[1,11],$V6=[1,15,24],$V7=[1,19],$V8=[1,31],$V9=[1,34],$Va=[1,32],$Vb=[1,33],$Vc=[1,35],$Vd=[1,36],$Ve=[1,37],$Vf=[1,38],$Vg=[1,41],$Vh=[1,42],$Vi=[1,43],$Vj=[1,44],$Vk=[15,24],$Vl=[1,56],$Vm=[1,57],$Vn=[1,58],$Vo=[1,59],$Vp=[1,60],$Vq=[1,61],$Vr=[15,24,31,38,39,47,50,51,52,53,54,55,60,62],$Vs=[15,24,29,31,38,39,43,47,50,51,52,53,54,55,60,62,77,78,79,80],$Vt=[7,8,9,10,15,18,22,24],$Vu=[47,77,78,79,80],$Vv=[47,54,55,77,78,79,80],$Vw=[47,50,51,52,53,77,78,79,80],$Vx=[15,24,31],$Vy=[1,93];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"start":3,"mermaidDoc":4,"direction":5,"directive":6,"direction_tb":7,"direction_bt":8,"direction_rl":9,"direction_lr":10,"graphConfig":11,"openDirective":12,"typeDirective":13,"closeDirective":14,"NEWLINE":15,":":16,"argDirective":17,"open_directive":18,"type_directive":19,"arg_directive":20,"close_directive":21,"CLASS_DIAGRAM":22,"statements":23,"EOF":24,"statement":25,"className":26,"alphaNumToken":27,"classLiteralName":28,"GENERICTYPE":29,"relationStatement":30,"LABEL":31,"classStatement":32,"methodStatement":33,"annotationStatement":34,"clickStatement":35,"cssClassStatement":36,"CLASS":37,"STYLE_SEPARATOR":38,"STRUCT_START":39,"members":40,"STRUCT_STOP":41,"ANNOTATION_START":42,"ANNOTATION_END":43,"MEMBER":44,"SEPARATOR":45,"relation":46,"STR":47,"relationType":48,"lineType":49,"AGGREGATION":50,"EXTENSION":51,"COMPOSITION":52,"DEPENDENCY":53,"LINE":54,"DOTTED_LINE":55,"CALLBACK":56,"LINK":57,"LINK_TARGET":58,"CLICK":59,"CALLBACK_NAME":60,"CALLBACK_ARGS":61,"HREF":62,"CSSCLASS":63,"commentToken":64,"textToken":65,"graphCodeTokens":66,"textNoTagsToken":67,"TAGSTART":68,"TAGEND":69,"==":70,"--":71,"PCT":72,"DEFAULT":73,"SPACE":74,"MINUS":75,"keywords":76,"UNICODE_TEXT":77,"NUM":78,"ALPHA":79,"BQUOTE_STR":80,"$accept":0,"$end":1},
terminals_: {2:"error",7:"direction_tb",8:"direction_bt",9:"direction_rl",10:"direction_lr",15:"NEWLINE",16:":",18:"open_directive",19:"type_directive",20:"arg_directive",21:"close_directive",22:"CLASS_DIAGRAM",24:"EOF",29:"GENERICTYPE",31:"LABEL",37:"CLASS",38:"STYLE_SEPARATOR",39:"STRUCT_START",41:"STRUCT_STOP",42:"ANNOTATION_START",43:"ANNOTATION_END",44:"MEMBER",45:"SEPARATOR",47:"STR",50:"AGGREGATION",51:"EXTENSION",52:"COMPOSITION",53:"DEPENDENCY",54:"LINE",55:"DOTTED_LINE",56:"CALLBACK",57:"LINK",58:"LINK_TARGET",59:"CLICK",60:"CALLBACK_NAME",61:"CALLBACK_ARGS",62:"HREF",63:"CSSCLASS",66:"graphCodeTokens",68:"TAGSTART",69:"TAGEND",70:"==",71:"--",72:"PCT",73:"DEFAULT",74:"SPACE",75:"MINUS",76:"keywords",77:"UNICODE_TEXT",78:"NUM",79:"ALPHA",80:"BQUOTE_STR"},
productions_: [0,[3,1],[3,1],[3,2],[5,1],[5,1],[5,1],[5,1],[4,1],[6,4],[6,6],[12,1],[13,1],[17,1],[14,1],[11,4],[23,1],[23,2],[23,3],[26,1],[26,1],[26,2],[26,2],[26,2],[25,1],[25,2],[25,1],[25,1],[25,1],[25,1],[25,1],[25,1],[25,1],[32,2],[32,4],[32,5],[32,7],[34,4],[40,1],[40,2],[33,1],[33,2],[33,1],[33,1],[30,3],[30,4],[30,4],[30,5],[46,3],[46,2],[46,2],[46,1],[48,1],[48,1],[48,1],[48,1],[49,1],[49,1],[35,3],[35,4],[35,3],[35,4],[35,4],[35,5],[35,3],[35,4],[35,4],[35,5],[35,3],[35,4],[35,4],[35,5],[36,3],[64,1],[64,1],[65,1],[65,1],[65,1],[65,1],[65,1],[65,1],[65,1],[67,1],[67,1],[67,1],[67,1],[27,1],[27,1],[27,1],[28,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 4:
 yy.setDirection('TB');
break;
case 5:
 yy.setDirection('BT');
break;
case 6:
 yy.setDirection('RL');
break;
case 7:
 yy.setDirection('LR');
break;
case 11:
 yy.parseDirective('%%{', 'open_directive'); 
break;
case 12:
 yy.parseDirective($$[$0], 'type_directive'); 
break;
case 13:
 $$[$0] = $$[$0].trim().replace(/'/g, '"'); yy.parseDirective($$[$0], 'arg_directive'); 
break;
case 14:
 yy.parseDirective('}%%', 'close_directive', 'class'); 
break;
case 19: case 20:
 this.$=$$[$0]; 
break;
case 21:
 this.$=$$[$0-1]+$$[$0]; 
break;
case 22: case 23:
 this.$=$$[$0-1]+'~'+$$[$0]; 
break;
case 24:
 yy.addRelation($$[$0]); 
break;
case 25:
 $$[$0-1].title =  yy.cleanupLabel($$[$0]); yy.addRelation($$[$0-1]);        
break;
case 33:
yy.addClass($$[$0]);
break;
case 34:
yy.addClass($$[$0-2]);yy.setCssClass($$[$0-2], $$[$0]);
break;
case 35:
/*console.log($$[$0-3],JSON.stringify($$[$0-1]));*/yy.addClass($$[$0-3]);yy.addMembers($$[$0-3],$$[$0-1]);
break;
case 36:
yy.addClass($$[$0-5]);yy.setCssClass($$[$0-5], $$[$0-3]);yy.addMembers($$[$0-5],$$[$0-1]);
break;
case 37:
 yy.addAnnotation($$[$0],$$[$0-2]); 
break;
case 38:
 this.$ = [$$[$0]]; 
break;
case 39:
 $$[$0].push($$[$0-1]);this.$=$$[$0];
break;
case 40:
/*console.log('Rel found',$$[$0]);*/
break;
case 41:
yy.addMember($$[$0-1],yy.cleanupLabel($$[$0]));
break;
case 42:
/*console.warn('Member',$$[$0]);*/
break;
case 43:
/*console.log('sep found',$$[$0]);*/
break;
case 44:
 this.$ = {'id1':$$[$0-2],'id2':$$[$0], relation:$$[$0-1], relationTitle1:'none', relationTitle2:'none'}; 
break;
case 45:
 this.$ = {id1:$$[$0-3], id2:$$[$0], relation:$$[$0-1], relationTitle1:$$[$0-2], relationTitle2:'none'}
break;
case 46:
 this.$ = {id1:$$[$0-3], id2:$$[$0], relation:$$[$0-2], relationTitle1:'none', relationTitle2:$$[$0-1]}; 
break;
case 47:
 this.$ = {id1:$$[$0-4], id2:$$[$0], relation:$$[$0-2], relationTitle1:$$[$0-3], relationTitle2:$$[$0-1]} 
break;
case 48:
 this.$={type1:$$[$0-2],type2:$$[$0],lineType:$$[$0-1]}; 
break;
case 49:
 this.$={type1:'none',type2:$$[$0],lineType:$$[$0-1]}; 
break;
case 50:
 this.$={type1:$$[$0-1],type2:'none',lineType:$$[$0]}; 
break;
case 51:
 this.$={type1:'none',type2:'none',lineType:$$[$0]}; 
break;
case 52:
 this.$=yy.relationType.AGGREGATION;
break;
case 53:
 this.$=yy.relationType.EXTENSION;
break;
case 54:
 this.$=yy.relationType.COMPOSITION;
break;
case 55:
 this.$=yy.relationType.DEPENDENCY;
break;
case 56:
this.$=yy.lineType.LINE;
break;
case 57:
this.$=yy.lineType.DOTTED_LINE;
break;
case 58: case 64:
this.$ = $$[$0-2];yy.setClickEvent($$[$0-1], $$[$0]);
break;
case 59: case 65:
this.$ = $$[$0-3];yy.setClickEvent($$[$0-2], $$[$0-1]);yy.setTooltip($$[$0-2], $$[$0]);
break;
case 60: case 68:
this.$ = $$[$0-2];yy.setLink($$[$0-1], $$[$0]);
break;
case 61:
this.$ = $$[$0-3];yy.setLink($$[$0-2], $$[$0-1],$$[$0]);
break;
case 62: case 70:
this.$ = $$[$0-3];yy.setLink($$[$0-2], $$[$0-1]);yy.setTooltip($$[$0-2], $$[$0]);
break;
case 63: case 71:
this.$ = $$[$0-4];yy.setLink($$[$0-3], $$[$0-2], $$[$0]);yy.setTooltip($$[$0-3], $$[$0-1]);
break;
case 66:
this.$ = $$[$0-3];yy.setClickEvent($$[$0-2], $$[$0-1], $$[$0]);
break;
case 67:
this.$ = $$[$0-4];yy.setClickEvent($$[$0-3], $$[$0-2], $$[$0-1]);yy.setTooltip($$[$0-3], $$[$0]);
break;
case 69:
this.$ = $$[$0-3];yy.setLink($$[$0-2], $$[$0-1], $$[$0]);
break;
case 72:
yy.setCssClass($$[$0-1], $$[$0]);
break;
}
},
table: [{3:1,4:2,5:3,6:4,7:$V0,8:$V1,9:$V2,10:$V3,11:5,12:10,18:$V4,22:$V5},{1:[3]},{1:[2,1]},{1:[2,2]},{3:13,4:2,5:3,6:4,7:$V0,8:$V1,9:$V2,10:$V3,11:5,12:10,18:$V4,22:$V5},{1:[2,8]},o($V6,[2,4]),o($V6,[2,5]),o($V6,[2,6]),o($V6,[2,7]),{13:14,19:[1,15]},{15:[1,16]},{19:[2,11]},{1:[2,3]},{14:17,16:[1,18],21:$V7},o([16,21],[2,12]),{5:29,6:28,7:$V0,8:$V1,9:$V2,10:$V3,12:10,18:$V4,23:20,25:21,26:30,27:39,28:40,30:22,32:23,33:24,34:25,35:26,36:27,37:$V8,42:$V9,44:$Va,45:$Vb,56:$Vc,57:$Vd,59:$Ve,63:$Vf,77:$Vg,78:$Vh,79:$Vi,80:$Vj},{15:[1,45]},{17:46,20:[1,47]},{15:[2,14]},{24:[1,48]},{15:[1,49],24:[2,16]},o($Vk,[2,24],{31:[1,50]}),o($Vk,[2,26]),o($Vk,[2,27]),o($Vk,[2,28]),o($Vk,[2,29]),o($Vk,[2,30]),o($Vk,[2,31]),o($Vk,[2,32]),o($Vk,[2,40],{46:51,48:54,49:55,31:[1,53],47:[1,52],50:$Vl,51:$Vm,52:$Vn,53:$Vo,54:$Vp,55:$Vq}),{26:62,27:39,28:40,77:$Vg,78:$Vh,79:$Vi,80:$Vj},o($Vk,[2,42]),o($Vk,[2,43]),{27:63,77:$Vg,78:$Vh,79:$Vi},{26:64,27:39,28:40,77:$Vg,78:$Vh,79:$Vi,80:$Vj},{26:65,27:39,28:40,77:$Vg,78:$Vh,79:$Vi,80:$Vj},{26:66,27:39,28:40,77:$Vg,78:$Vh,79:$Vi,80:$Vj},{47:[1,67]},o($Vr,[2,19],{27:39,28:40,26:68,29:[1,69],77:$Vg,78:$Vh,79:$Vi,80:$Vj}),o($Vr,[2,20],{29:[1,70]}),o($Vs,[2,86]),o($Vs,[2,87]),o($Vs,[2,88]),o([15,24,29,31,38,39,47,50,51,52,53,54,55,60,62],[2,89]),o($Vt,[2,9]),{14:71,21:$V7},{21:[2,13]},{1:[2,15]},{5:29,6:28,7:$V0,8:$V1,9:$V2,10:$V3,12:10,18:$V4,23:72,24:[2,17],25:21,26:30,27:39,28:40,30:22,32:23,33:24,34:25,35:26,36:27,37:$V8,42:$V9,44:$Va,45:$Vb,56:$Vc,57:$Vd,59:$Ve,63:$Vf,77:$Vg,78:$Vh,79:$Vi,80:$Vj},o($Vk,[2,25]),{26:73,27:39,28:40,47:[1,74],77:$Vg,78:$Vh,79:$Vi,80:$Vj},{46:75,48:54,49:55,50:$Vl,51:$Vm,52:$Vn,53:$Vo,54:$Vp,55:$Vq},o($Vk,[2,41]),{49:76,54:$Vp,55:$Vq},o($Vu,[2,51],{48:77,50:$Vl,51:$Vm,52:$Vn,53:$Vo}),o($Vv,[2,52]),o($Vv,[2,53]),o($Vv,[2,54]),o($Vv,[2,55]),o($Vw,[2,56]),o($Vw,[2,57]),o($Vk,[2,33],{38:[1,78],39:[1,79]}),{43:[1,80]},{47:[1,81]},{47:[1,82]},{60:[1,83],62:[1,84]},{27:85,77:$Vg,78:$Vh,79:$Vi},o($Vr,[2,21]),o($Vr,[2,22]),o($Vr,[2,23]),{15:[1,86]},{24:[2,18]},o($Vx,[2,44]),{26:87,27:39,28:40,77:$Vg,78:$Vh,79:$Vi,80:$Vj},{26:88,27:39,28:40,47:[1,89],77:$Vg,78:$Vh,79:$Vi,80:$Vj},o($Vu,[2,50],{48:90,50:$Vl,51:$Vm,52:$Vn,53:$Vo}),o($Vu,[2,49]),{27:91,77:$Vg,78:$Vh,79:$Vi},{40:92,44:$Vy},{26:94,27:39,28:40,77:$Vg,78:$Vh,79:$Vi,80:$Vj},o($Vk,[2,58],{47:[1,95]}),o($Vk,[2,60],{47:[1,97],58:[1,96]}),o($Vk,[2,64],{47:[1,98],61:[1,99]}),o($Vk,[2,68],{47:[1,101],58:[1,100]}),o($Vk,[2,72]),o($Vt,[2,10]),o($Vx,[2,46]),o($Vx,[2,45]),{26:102,27:39,28:40,77:$Vg,78:$Vh,79:$Vi,80:$Vj},o($Vu,[2,48]),o($Vk,[2,34],{39:[1,103]}),{41:[1,104]},{40:105,41:[2,38],44:$Vy},o($Vk,[2,37]),o($Vk,[2,59]),o($Vk,[2,61]),o($Vk,[2,62],{58:[1,106]}),o($Vk,[2,65]),o($Vk,[2,66],{47:[1,107]}),o($Vk,[2,69]),o($Vk,[2,70],{58:[1,108]}),o($Vx,[2,47]),{40:109,44:$Vy},o($Vk,[2,35]),{41:[2,39]},o($Vk,[2,63]),o($Vk,[2,67]),o($Vk,[2,71]),{41:[1,110]},o($Vk,[2,36])],
defaultActions: {2:[2,1],3:[2,2],5:[2,8],12:[2,11],13:[2,3],19:[2,14],47:[2,13],48:[2,15],72:[2,18],105:[2,39]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
            function lex() {
            var token;
            token = tstack.pop() || lexer.lex() || EOF;
            if (typeof token !== 'number') {
                if (token instanceof Array) {
                    tstack = token;
                    token = tstack.pop();
                }
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
        if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];
            for (p in table[state]) {
                if (this.terminals_[p] && p > TERROR) {
                    expected.push('\'' + this.terminals_[p] + '\'');
                }
            }
            if (lexer.showPosition) {
                errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
                errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }
            this.parseError(errStr, {
                text: lexer.match,
                token: this.terminals_[symbol] || symbol,
                line: lexer.yylineno,
                loc: yyloc,
                expected: expected
            });
        }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0: this.begin('open_directive'); return 18; 
break;
case 1:return 7;
break;
case 2:return 8;
break;
case 3:return 9;
break;
case 4:return 10;
break;
case 5: this.begin('type_directive'); return 19; 
break;
case 6: this.popState(); this.begin('arg_directive'); return 16; 
break;
case 7: this.popState(); this.popState(); return 21; 
break;
case 8:return 20;
break;
case 9:/* skip comments */
break;
case 10:/* skip comments */
break;
case 11:return 15;
break;
case 12:/* skip whitespace */
break;
case 13:return 22;
break;
case 14:return 22;
break;
case 15: this.begin("struct"); /*console.log('Starting struct');*/ return 39;
break;
case 16:return "EOF_IN_STRUCT";
break;
case 17:return "OPEN_IN_STRUCT";
break;
case 18: /*console.log('Ending struct');*/this.popState(); return 41;
break;
case 19:/* nothing */
break;
case 20: /*console.log('lex-member: ' + yy_.yytext);*/  return "MEMBER";
break;
case 21:return 37;
break;
case 22:return 63;
break;
case 23:return 56;
break;
case 24:return 57;
break;
case 25:return 59;
break;
case 26:return 42;
break;
case 27:return 43;
break;
case 28:this.begin("generic");
break;
case 29:this.popState();
break;
case 30:return "GENERICTYPE";
break;
case 31:this.begin("string");
break;
case 32:this.popState();
break;
case 33:return "STR";
break;
case 34:this.begin("bqstring");
break;
case 35:this.popState();
break;
case 36:return "BQUOTE_STR";
break;
case 37:this.begin("href");
break;
case 38:this.popState();
break;
case 39:return 62;
break;
case 40:this.begin("callback_name");
break;
case 41:this.popState();
break;
case 42:this.popState(); this.begin("callback_args");
break;
case 43:return 60;
break;
case 44:this.popState();
break;
case 45:return 61;
break;
case 46:return 58;
break;
case 47:return 58;
break;
case 48:return 58;
break;
case 49:return 58;
break;
case 50:return 51;
break;
case 51:return 51;
break;
case 52:return 53;
break;
case 53:return 53;
break;
case 54:return 52;
break;
case 55:return 50;
break;
case 56:return 54;
break;
case 57:return 55;
break;
case 58:return 31;
break;
case 59:return 38;
break;
case 60:return 75;
break;
case 61:return 'DOT';
break;
case 62:return 'PLUS';
break;
case 63:return 72;
break;
case 64:return 'EQUALS';
break;
case 65:return 'EQUALS';
break;
case 66:return 79;
break;
case 67:return 'PUNCTUATION';
break;
case 68:return 78;
break;
case 69:return 77;
break;
case 70:return 74;
break;
case 71:return 24;
break;
}
},
rules: [/^(?:%%\{)/,/^(?:.*direction\s+TB[^\n]*)/,/^(?:.*direction\s+BT[^\n]*)/,/^(?:.*direction\s+RL[^\n]*)/,/^(?:.*direction\s+LR[^\n]*)/,/^(?:((?:(?!\}%%)[^:.])*))/,/^(?::)/,/^(?:\}%%)/,/^(?:((?:(?!\}%%).|\n)*))/,/^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/,/^(?:%%[^\n]*(\r?\n)*)/,/^(?:(\r?\n)+)/,/^(?:\s+)/,/^(?:classDiagram-v2\b)/,/^(?:classDiagram\b)/,/^(?:[{])/,/^(?:$)/,/^(?:[{])/,/^(?:[}])/,/^(?:[\n])/,/^(?:[^{}\n]*)/,/^(?:class\b)/,/^(?:cssClass\b)/,/^(?:callback\b)/,/^(?:link\b)/,/^(?:click\b)/,/^(?:<<)/,/^(?:>>)/,/^(?:[~])/,/^(?:[~])/,/^(?:[^~]*)/,/^(?:["])/,/^(?:["])/,/^(?:[^"]*)/,/^(?:[`])/,/^(?:[`])/,/^(?:[^`]+)/,/^(?:href[\s]+["])/,/^(?:["])/,/^(?:[^"]*)/,/^(?:call[\s]+)/,/^(?:\([\s]*\))/,/^(?:\()/,/^(?:[^(]*)/,/^(?:\))/,/^(?:[^)]*)/,/^(?:_self\b)/,/^(?:_blank\b)/,/^(?:_parent\b)/,/^(?:_top\b)/,/^(?:\s*<\|)/,/^(?:\s*\|>)/,/^(?:\s*>)/,/^(?:\s*<)/,/^(?:\s*\*)/,/^(?:\s*o\b)/,/^(?:--)/,/^(?:\.\.)/,/^(?::{1}[^:\n;]+)/,/^(?::{3})/,/^(?:-)/,/^(?:\.)/,/^(?:\+)/,/^(?:%)/,/^(?:=)/,/^(?:=)/,/^(?:\w+)/,/^(?:[!"#$%&'*+,-.`?\\/])/,/^(?:[0-9]+)/,/^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/,/^(?:\s)/,/^(?:$)/],
conditions: {"arg_directive":{"rules":[7,8],"inclusive":false},"type_directive":{"rules":[6,7],"inclusive":false},"open_directive":{"rules":[5],"inclusive":false},"callback_args":{"rules":[44,45],"inclusive":false},"callback_name":{"rules":[41,42,43],"inclusive":false},"href":{"rules":[38,39],"inclusive":false},"struct":{"rules":[16,17,18,19,20],"inclusive":false},"generic":{"rules":[29,30],"inclusive":false},"bqstring":{"rules":[35,36],"inclusive":false},"string":{"rules":[32,33],"inclusive":false},"INITIAL":{"rules":[0,1,2,3,4,9,10,11,12,13,14,15,21,22,23,24,25,26,27,28,31,34,37,40,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (true) {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js").readFileSync(__webpack_require__(/*! path */ "./node_modules/path-browserify/index.js").normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if ( true && __webpack_require__.c[__webpack_require__.s] === module) {
  exports.main(process.argv.slice(1));
}
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/diagrams/class/styles.js":
/*!**************************************!*\
  !*** ./src/diagrams/class/styles.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var getStyles = function getStyles(options) {
  return "g.classGroup text {\n  fill: ".concat(options.nodeBorder, ";\n  fill: ").concat(options.classText, ";\n  stroke: none;\n  font-family: ").concat(options.fontFamily, ";\n  font-size: 10px;\n\n  .title {\n    font-weight: bolder;\n  }\n\n}\n\n.nodeLabel, .edgeLabel {\n  color: ").concat(options.classText, ";\n}\n.edgeLabel .label rect {\n  fill: ").concat(options.mainBkg, ";\n}\n.label text {\n  fill: ").concat(options.classText, ";\n}\n.edgeLabel .label span {\n  background: ").concat(options.mainBkg, ";\n}\n\n.classTitle {\n  font-weight: bolder;\n}\n.node rect,\n  .node circle,\n  .node ellipse,\n  .node polygon,\n  .node path {\n    fill: ").concat(options.mainBkg, ";\n    stroke: ").concat(options.nodeBorder, ";\n    stroke-width: 1px;\n  }\n\n\n.divider {\n  stroke: ").concat(options.nodeBorder, ";\n  stroke: 1;\n}\n\ng.clickable {\n  cursor: pointer;\n}\n\ng.classGroup rect {\n  fill: ").concat(options.mainBkg, ";\n  stroke: ").concat(options.nodeBorder, ";\n}\n\ng.classGroup line {\n  stroke: ").concat(options.nodeBorder, ";\n  stroke-width: 1;\n}\n\n.classLabel .box {\n  stroke: none;\n  stroke-width: 0;\n  fill: ").concat(options.mainBkg, ";\n  opacity: 0.5;\n}\n\n.classLabel .label {\n  fill: ").concat(options.nodeBorder, ";\n  font-size: 10px;\n}\n\n.relation {\n  stroke: ").concat(options.lineColor, ";\n  stroke-width: 1;\n  fill: none;\n}\n\n.dashed-line{\n  stroke-dasharray: 3;\n}\n\n#compositionStart, .composition {\n  fill: ").concat(options.lineColor, " !important;\n  stroke: ").concat(options.lineColor, " !important;\n  stroke-width: 1;\n}\n\n#compositionEnd, .composition {\n  fill: ").concat(options.lineColor, " !important;\n  stroke: ").concat(options.lineColor, " !important;\n  stroke-width: 1;\n}\n\n#dependencyStart, .dependency {\n  fill: ").concat(options.lineColor, " !important;\n  stroke: ").concat(options.lineColor, " !important;\n  stroke-width: 1;\n}\n\n#dependencyStart, .dependency {\n  fill: ").concat(options.lineColor, " !important;\n  stroke: ").concat(options.lineColor, " !important;\n  stroke-width: 1;\n}\n\n#extensionStart, .extension {\n  fill: ").concat(options.lineColor, " !important;\n  stroke: ").concat(options.lineColor, " !important;\n  stroke-width: 1;\n}\n\n#extensionEnd, .extension {\n  fill: ").concat(options.lineColor, " !important;\n  stroke: ").concat(options.lineColor, " !important;\n  stroke-width: 1;\n}\n\n#aggregationStart, .aggregation {\n  fill: ").concat(options.mainBkg, " !important;\n  stroke: ").concat(options.lineColor, " !important;\n  stroke-width: 1;\n}\n\n#aggregationEnd, .aggregation {\n  fill: ").concat(options.mainBkg, " !important;\n  stroke: ").concat(options.lineColor, " !important;\n  stroke-width: 1;\n}\n\n.edgeTerminals {\n  font-size: 11px;\n}\n\n");
};

/* harmony default export */ __webpack_exports__["default"] = (getStyles);

/***/ }),

/***/ "./src/diagrams/class/svgDraw.js":
/*!***************************************!*\
  !*** ./src/diagrams/class/svgDraw.js ***!
  \***************************************/
/*! exports provided: drawEdge, drawClass, parseMember, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawEdge", function() { return drawEdge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawClass", function() { return drawClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseMember", function() { return parseMember; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _classDb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classDb */ "./src/diagrams/class/classDb.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");




var edgeCount = 0;
var drawEdge = function drawEdge(elem, path, relation, conf) {
  var getRelationType = function getRelationType(type) {
    switch (type) {
      case _classDb__WEBPACK_IMPORTED_MODULE_1__["relationType"].AGGREGATION:
        return 'aggregation';

      case _classDb__WEBPACK_IMPORTED_MODULE_1__["relationType"].EXTENSION:
        return 'extension';

      case _classDb__WEBPACK_IMPORTED_MODULE_1__["relationType"].COMPOSITION:
        return 'composition';

      case _classDb__WEBPACK_IMPORTED_MODULE_1__["relationType"].DEPENDENCY:
        return 'dependency';
    }
  };

  path.points = path.points.filter(function (p) {
    return !Number.isNaN(p.y);
  }); // The data for our line

  var lineData = path.points; // This is the accessor function we talked about above

  var lineFunction = Object(d3__WEBPACK_IMPORTED_MODULE_0__["line"])().x(function (d) {
    return d.x;
  }).y(function (d) {
    return d.y;
  }).curve(d3__WEBPACK_IMPORTED_MODULE_0__["curveBasis"]);
  var svgPath = elem.append('path').attr('d', lineFunction(lineData)).attr('id', 'edge' + edgeCount).attr('class', 'relation');
  var url = '';

  if (conf.arrowMarkerAbsolute) {
    url = window.location.protocol + '//' + window.location.host + window.location.pathname + window.location.search;
    url = url.replace(/\(/g, '\\(');
    url = url.replace(/\)/g, '\\)');
  }

  if (relation.relation.lineType == 1) {
    svgPath.attr('class', 'relation dashed-line');
  }

  if (relation.relation.type1 !== 'none') {
    svgPath.attr('marker-start', 'url(' + url + '#' + getRelationType(relation.relation.type1) + 'Start' + ')');
  }

  if (relation.relation.type2 !== 'none') {
    svgPath.attr('marker-end', 'url(' + url + '#' + getRelationType(relation.relation.type2) + 'End' + ')');
  }

  var x, y;
  var l = path.points.length; // Calculate Label position

  var labelPosition = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].calcLabelPosition(path.points);
  x = labelPosition.x;
  y = labelPosition.y;
  var p1_card_x, p1_card_y;
  var p2_card_x, p2_card_y;

  if (l % 2 !== 0 && l > 1) {
    var cardinality_1_point = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].calcCardinalityPosition(relation.relation.type1 !== 'none', path.points, path.points[0]);
    var cardinality_2_point = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].calcCardinalityPosition(relation.relation.type2 !== 'none', path.points, path.points[l - 1]);
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('cardinality_1_point ' + JSON.stringify(cardinality_1_point));
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('cardinality_2_point ' + JSON.stringify(cardinality_2_point));
    p1_card_x = cardinality_1_point.x;
    p1_card_y = cardinality_1_point.y;
    p2_card_x = cardinality_2_point.x;
    p2_card_y = cardinality_2_point.y;
  }

  if (typeof relation.title !== 'undefined') {
    var g = elem.append('g').attr('class', 'classLabel');
    var label = g.append('text').attr('class', 'label').attr('x', x).attr('y', y).attr('fill', 'red').attr('text-anchor', 'middle').text(relation.title);
    window.label = label;
    var bounds = label.node().getBBox();
    g.insert('rect', ':first-child').attr('class', 'box').attr('x', bounds.x - conf.padding / 2).attr('y', bounds.y - conf.padding / 2).attr('width', bounds.width + conf.padding).attr('height', bounds.height + conf.padding);
  }

  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info('Rendering relation ' + JSON.stringify(relation));

  if (typeof relation.relationTitle1 !== 'undefined' && relation.relationTitle1 !== 'none') {
    var _g = elem.append('g').attr('class', 'cardinality');

    _g.append('text').attr('class', 'type1').attr('x', p1_card_x).attr('y', p1_card_y).attr('fill', 'black').attr('font-size', '6').text(relation.relationTitle1);
  }

  if (typeof relation.relationTitle2 !== 'undefined' && relation.relationTitle2 !== 'none') {
    var _g2 = elem.append('g').attr('class', 'cardinality');

    _g2.append('text').attr('class', 'type2').attr('x', p2_card_x).attr('y', p2_card_y).attr('fill', 'black').attr('font-size', '6').text(relation.relationTitle2);
  }

  edgeCount++;
};
var drawClass = function drawClass(elem, classDef, conf) {
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info('Rendering class ' + classDef);
  var id = classDef.id;
  var classInfo = {
    id: id,
    label: classDef.id,
    width: 0,
    height: 0
  }; // add class group

  var g = elem.append('g').attr('id', Object(_classDb__WEBPACK_IMPORTED_MODULE_1__["lookUpDomId"])(id)).attr('class', 'classGroup'); // add title

  var title;

  if (classDef.link) {
    title = g.append('svg:a').attr('xlink:href', classDef.link).attr('target', classDef.linkTarget).append('text').attr('y', conf.textHeight + conf.padding).attr('x', 0);
  } else {
    title = g.append('text').attr('y', conf.textHeight + conf.padding).attr('x', 0);
  } // add annotations


  var isFirst = true;
  classDef.annotations.forEach(function (member) {
    var titleText2 = title.append('tspan').text('«' + member + '»');
    if (!isFirst) titleText2.attr('dy', conf.textHeight);
    isFirst = false;
  });
  var classTitleString = classDef.id;

  if (classDef.type !== undefined && classDef.type !== '') {
    classTitleString += '<' + classDef.type + '>';
  }

  var classTitle = title.append('tspan').text(classTitleString).attr('class', 'title'); // If class has annotations the title needs to have an offset of the text height

  if (!isFirst) classTitle.attr('dy', conf.textHeight);
  var titleHeight = title.node().getBBox().height;
  var membersLine = g.append('line') // text label for the x axis
  .attr('x1', 0).attr('y1', conf.padding + titleHeight + conf.dividerMargin / 2).attr('y2', conf.padding + titleHeight + conf.dividerMargin / 2);
  var members = g.append('text') // text label for the x axis
  .attr('x', conf.padding).attr('y', titleHeight + conf.dividerMargin + conf.textHeight).attr('fill', 'white').attr('class', 'classText');
  isFirst = true;
  classDef.members.forEach(function (member) {
    addTspan(members, member, isFirst, conf);
    isFirst = false;
  });
  var membersBox = members.node().getBBox();
  var methodsLine = g.append('line') // text label for the x axis
  .attr('x1', 0).attr('y1', conf.padding + titleHeight + conf.dividerMargin + membersBox.height).attr('y2', conf.padding + titleHeight + conf.dividerMargin + membersBox.height);
  var methods = g.append('text') // text label for the x axis
  .attr('x', conf.padding).attr('y', titleHeight + 2 * conf.dividerMargin + membersBox.height + conf.textHeight).attr('fill', 'white').attr('class', 'classText');
  isFirst = true;
  classDef.methods.forEach(function (method) {
    addTspan(methods, method, isFirst, conf);
    isFirst = false;
  });
  var classBox = g.node().getBBox();
  var cssClassStr = ' ';

  if (classDef.cssClasses.length > 0) {
    cssClassStr = cssClassStr + classDef.cssClasses.join(' ');
  }

  var rect = g.insert('rect', ':first-child').attr('x', 0).attr('y', 0).attr('width', classBox.width + 2 * conf.padding).attr('height', classBox.height + conf.padding + 0.5 * conf.dividerMargin).attr('class', cssClassStr);
  var rectWidth = rect.node().getBBox().width; // Center title
  // We subtract the width of each text element from the class box width and divide it by 2

  title.node().childNodes.forEach(function (x) {
    x.setAttribute('x', (rectWidth - x.getBBox().width) / 2);
  });

  if (classDef.tooltip) {
    title.insert('title').text(classDef.tooltip);
  }

  membersLine.attr('x2', rectWidth);
  methodsLine.attr('x2', rectWidth);
  classInfo.width = rectWidth;
  classInfo.height = classBox.height + conf.padding + 0.5 * conf.dividerMargin;
  return classInfo;
};
var parseMember = function parseMember(text) {
  var fieldRegEx = /(\+|-|~|#)?(\w+)(~\w+~|\[\])?\s+(\w+)/;
  var methodRegEx = /^([+|\-|~|#])?(\w+) *\( *(.*)\) *(\*|\$)? *(\w*[~|[\]]*\s*\w*~?)$/;
  var fieldMatch = text.match(fieldRegEx);
  var methodMatch = text.match(methodRegEx);

  if (fieldMatch && !methodMatch) {
    return buildFieldDisplay(fieldMatch);
  } else if (methodMatch) {
    return buildMethodDisplay(methodMatch);
  } else {
    return buildLegacyDisplay(text);
  }
};

var buildFieldDisplay = function buildFieldDisplay(parsedText) {
  var displayText = '';

  try {
    var visibility = parsedText[1] ? parsedText[1].trim() : '';
    var fieldType = parsedText[2] ? parsedText[2].trim() : '';
    var genericType = parsedText[3] ? parseGenericTypes(parsedText[3].trim()) : '';
    var fieldName = parsedText[4] ? parsedText[4].trim() : '';
    displayText = visibility + fieldType + genericType + ' ' + fieldName;
  } catch (err) {
    displayText = parsedText;
  }

  return {
    displayText: displayText,
    cssStyle: ''
  };
};

var buildMethodDisplay = function buildMethodDisplay(parsedText) {
  var cssStyle = '';
  var displayText = '';

  try {
    var visibility = parsedText[1] ? parsedText[1].trim() : '';
    var methodName = parsedText[2] ? parsedText[2].trim() : '';
    var parameters = parsedText[3] ? parseGenericTypes(parsedText[3].trim()) : '';
    var classifier = parsedText[4] ? parsedText[4].trim() : '';
    var returnType = parsedText[5] ? ' : ' + parseGenericTypes(parsedText[5]).trim() : '';
    displayText = visibility + methodName + '(' + parameters + ')' + returnType;
    cssStyle = parseClassifier(classifier);
  } catch (err) {
    displayText = parsedText;
  }

  return {
    displayText: displayText,
    cssStyle: cssStyle
  };
};

var buildLegacyDisplay = function buildLegacyDisplay(text) {
  // if for some reason we dont have any match, use old format to parse text
  var displayText = '';
  var cssStyle = '';
  var memberText = '';
  var returnType = '';
  var methodStart = text.indexOf('(');
  var methodEnd = text.indexOf(')');

  if (methodStart > 1 && methodEnd > methodStart && methodEnd <= text.length) {
    var visibility = '';
    var methodName = '';
    var firstChar = text.substring(0, 1);

    if (firstChar.match(/\w/)) {
      methodName = text.substring(0, methodStart).trim();
    } else {
      if (firstChar.match(/\+|-|~|#/)) {
        visibility = firstChar;
      }

      methodName = text.substring(1, methodStart).trim();
    }

    var parameters = text.substring(methodStart + 1, methodEnd);
    var classifier = text.substring(methodEnd + 1, 1);
    cssStyle = parseClassifier(classifier);
    displayText = visibility + methodName + '(' + parseGenericTypes(parameters.trim()) + ')';

    if (methodEnd < memberText.length) {
      returnType = text.substring(methodEnd + 2).trim();

      if (returnType !== '') {
        returnType = ' : ' + parseGenericTypes(returnType);
      }
    }
  } else {
    // finally - if all else fails, just send the text back as written (other than parsing for generic types)
    displayText = parseGenericTypes(text);
  }

  return {
    displayText: displayText,
    cssStyle: cssStyle
  };
};

var addTspan = function addTspan(textEl, txt, isFirst, conf) {
  var member = parseMember(txt);
  var tSpan = textEl.append('tspan').attr('x', conf.padding).text(member.displayText);

  if (member.cssStyle !== '') {
    tSpan.attr('style', member.cssStyle);
  }

  if (!isFirst) {
    tSpan.attr('dy', conf.textHeight);
  }
};

var parseGenericTypes = function parseGenericTypes(text) {
  var cleanedText = text;

  if (text.indexOf('~') != -1) {
    cleanedText = cleanedText.replace('~', '<');
    cleanedText = cleanedText.replace('~', '>');
    return parseGenericTypes(cleanedText);
  } else {
    return cleanedText;
  }
};

var parseClassifier = function parseClassifier(classifier) {
  switch (classifier) {
    case '*':
      return 'font-style:italic;';

    case '$':
      return 'text-decoration:underline;';

    default:
      return '';
  }
};

/* harmony default export */ __webpack_exports__["default"] = ({
  drawClass: drawClass,
  drawEdge: drawEdge,
  parseMember: parseMember
});

/***/ }),

/***/ "./src/diagrams/common/common.js":
/*!***************************************!*\
  !*** ./src/diagrams/common/common.js ***!
  \***************************************/
/*! exports provided: getRows, removeScript, sanitizeText, lineBreakRegex, hasBreaks, splitBreaks, evaluate, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRows", function() { return getRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeScript", function() { return removeScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sanitizeText", function() { return sanitizeText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineBreakRegex", function() { return lineBreakRegex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasBreaks", function() { return hasBreaks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitBreaks", function() { return splitBreaks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "evaluate", function() { return evaluate; });
/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dompurify */ "dompurify");
/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dompurify__WEBPACK_IMPORTED_MODULE_0__);

var getRows = function getRows(s) {
  if (!s) return 1;
  var str = breakToPlaceholder(s);
  str = str.replace(/\\n/g, '#br#');
  return str.split('#br#');
};
var removeScript = function removeScript(txt) {
  var rs = '';
  var idx = 0;

  while (idx >= 0) {
    idx = txt.indexOf('<script');

    if (idx >= 0) {
      rs += txt.substr(0, idx);
      txt = txt.substr(idx + 1);
      idx = txt.indexOf('</script>');

      if (idx >= 0) {
        idx += 9;
        txt = txt.substr(idx);
      }
    } else {
      rs += txt;
      idx = -1;
      break;
    }
  }

  rs = rs.replace(/javascript:/g, '#');
  rs = rs.replace(/onerror=/g, 'onerror:');
  rs = rs.replace(/<iframe/g, '');
  return rs;
};

var sanitizeMore = function sanitizeMore(text, config) {
  var txt = text;
  var htmlLabels = true;

  if (config.flowchart && (config.flowchart.htmlLabels === false || config.flowchart.htmlLabels === 'false')) {
    htmlLabels = false;
  }

  if (htmlLabels) {
    var level = config.securityLevel;

    if (level === 'antiscript') {
      txt = removeScript(txt);
    } else if (level !== 'loose') {
      // eslint-disable-line
      txt = breakToPlaceholder(txt);
      txt = txt.replace(/</g, '&lt;').replace(/>/g, '&gt;');
      txt = txt.replace(/=/g, '&equals;');
      txt = placeholderToBreak(txt);
    }
  }

  return txt;
};

var sanitizeText = function sanitizeText(text, config) {
  var txt = sanitizeMore(dompurify__WEBPACK_IMPORTED_MODULE_0___default.a.sanitize(text), config);
  return txt;
};
var lineBreakRegex = /<br\s*\/?>/gi;
var hasBreaks = function hasBreaks(text) {
  return /<br\s*[/]?>/gi.test(text);
};
var splitBreaks = function splitBreaks(text) {
  return text.split(/<br\s*[/]?>/gi);
};

var placeholderToBreak = function placeholderToBreak(s) {
  return s.replace(/#br#/g, '<br/>');
};

var breakToPlaceholder = function breakToPlaceholder(s) {
  return s.replace(lineBreakRegex, '#br#');
};

var getUrl = function getUrl(useAbsolute) {
  var url = '';

  if (useAbsolute) {
    url = window.location.protocol + '//' + window.location.host + window.location.pathname + window.location.search;
    url = url.replace(/\(/g, '\\(');
    url = url.replace(/\)/g, '\\)');
  }

  return url;
};

var evaluate = function evaluate(val) {
  return val === 'false' || val === false ? false : true;
};
/* harmony default export */ __webpack_exports__["default"] = ({
  getRows: getRows,
  sanitizeText: sanitizeText,
  hasBreaks: hasBreaks,
  splitBreaks: splitBreaks,
  lineBreakRegex: lineBreakRegex,
  removeScript: removeScript,
  getUrl: getUrl,
  evaluate: evaluate
});

/***/ }),

/***/ "./src/diagrams/er/erDb.js":
/*!*********************************!*\
  !*** ./src/diagrams/er/erDb.js ***!
  \*********************************/
/*! exports provided: parseDirective, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseDirective", function() { return parseDirective; });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _mermaidAPI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mermaidAPI */ "./src/mermaidAPI.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/**
 *
 */



var entities = {};
var relationships = [];
var title = '';
var Cardinality = {
  ZERO_OR_ONE: 'ZERO_OR_ONE',
  ZERO_OR_MORE: 'ZERO_OR_MORE',
  ONE_OR_MORE: 'ONE_OR_MORE',
  ONLY_ONE: 'ONLY_ONE'
};
var Identification = {
  NON_IDENTIFYING: 'NON_IDENTIFYING',
  IDENTIFYING: 'IDENTIFYING'
};
var parseDirective = function parseDirective(statement, context, type) {
  _mermaidAPI__WEBPACK_IMPORTED_MODULE_1__["default"].parseDirective(this, statement, context, type);
};

var addEntity = function addEntity(name) {
  if (typeof entities[name] === 'undefined') {
    entities[name] = {
      attributes: []
    };
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('Added new entity :', name);
  }

  return entities[name];
};

var getEntities = function getEntities() {
  return entities;
};

var addAttributes = function addAttributes(entityName, attribs) {
  var entity = addEntity(entityName); // May do nothing (if entity has already been added)
  // Process attribs in reverse order due to effect of recursive construction (last attribute is first)

  var i;

  for (i = attribs.length - 1; i >= 0; i--) {
    entity.attributes.push(attribs[i]);
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Added attribute ', attribs[i].attributeName);
  }
};
/**
 * Add a relationship
 * @param entA The first entity in the relationship
 * @param rolA The role played by the first entity in relation to the second
 * @param entB The second entity in the relationship
 * @param rSpec The details of the relationship between the two entities
 */


var addRelationship = function addRelationship(entA, rolA, entB, rSpec) {
  var rel = {
    entityA: entA,
    roleA: rolA,
    entityB: entB,
    relSpec: rSpec
  };
  relationships.push(rel);
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Added new relationship :', rel);
};

var getRelationships = function getRelationships() {
  return relationships;
}; // Keep this - TODO: revisit...allow the diagram to have a title


var setTitle = function setTitle(txt) {
  title = txt;
};

var getTitle = function getTitle() {
  return title;
};

var clear = function clear() {
  entities = {};
  relationships = [];
  title = '';
};

/* harmony default export */ __webpack_exports__["default"] = ({
  Cardinality: Cardinality,
  Identification: Identification,
  parseDirective: parseDirective,
  getConfig: function getConfig() {
    return _config__WEBPACK_IMPORTED_MODULE_2__["getConfig"]().er;
  },
  addEntity: addEntity,
  addAttributes: addAttributes,
  getEntities: getEntities,
  addRelationship: addRelationship,
  getRelationships: getRelationships,
  clear: clear,
  setTitle: setTitle,
  getTitle: getTitle
});

/***/ }),

/***/ "./src/diagrams/er/erMarkers.js":
/*!**************************************!*\
  !*** ./src/diagrams/er/erMarkers.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var ERMarkers = {
  ONLY_ONE_START: 'ONLY_ONE_START',
  ONLY_ONE_END: 'ONLY_ONE_END',
  ZERO_OR_ONE_START: 'ZERO_OR_ONE_START',
  ZERO_OR_ONE_END: 'ZERO_OR_ONE_END',
  ONE_OR_MORE_START: 'ONE_OR_MORE_START',
  ONE_OR_MORE_END: 'ONE_OR_MORE_END',
  ZERO_OR_MORE_START: 'ZERO_OR_MORE_START',
  ZERO_OR_MORE_END: 'ZERO_OR_MORE_END'
};
/**
 * Put the markers into the svg DOM for later use with edge paths
 */

var insertMarkers = function insertMarkers(elem, conf) {
  var marker;
  elem.append('defs').append('marker').attr('id', ERMarkers.ONLY_ONE_START).attr('refX', 0).attr('refY', 9).attr('markerWidth', 18).attr('markerHeight', 18).attr('orient', 'auto').append('path').attr('stroke', conf.stroke).attr('fill', 'none').attr('d', 'M9,0 L9,18 M15,0 L15,18');
  elem.append('defs').append('marker').attr('id', ERMarkers.ONLY_ONE_END).attr('refX', 18).attr('refY', 9).attr('markerWidth', 18).attr('markerHeight', 18).attr('orient', 'auto').append('path').attr('stroke', conf.stroke).attr('fill', 'none').attr('d', 'M3,0 L3,18 M9,0 L9,18');
  marker = elem.append('defs').append('marker').attr('id', ERMarkers.ZERO_OR_ONE_START).attr('refX', 0).attr('refY', 9).attr('markerWidth', 30).attr('markerHeight', 18).attr('orient', 'auto');
  marker.append('circle').attr('stroke', conf.stroke).attr('fill', 'white').attr('cx', 21).attr('cy', 9).attr('r', 6);
  marker.append('path').attr('stroke', conf.stroke).attr('fill', 'none').attr('d', 'M9,0 L9,18');
  marker = elem.append('defs').append('marker').attr('id', ERMarkers.ZERO_OR_ONE_END).attr('refX', 30).attr('refY', 9).attr('markerWidth', 30).attr('markerHeight', 18).attr('orient', 'auto');
  marker.append('circle').attr('stroke', conf.stroke).attr('fill', 'white').attr('cx', 9).attr('cy', 9).attr('r', 6);
  marker.append('path').attr('stroke', conf.stroke).attr('fill', 'none').attr('d', 'M21,0 L21,18');
  elem.append('defs').append('marker').attr('id', ERMarkers.ONE_OR_MORE_START).attr('refX', 18).attr('refY', 18).attr('markerWidth', 45).attr('markerHeight', 36).attr('orient', 'auto').append('path').attr('stroke', conf.stroke).attr('fill', 'none').attr('d', 'M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27');
  elem.append('defs').append('marker').attr('id', ERMarkers.ONE_OR_MORE_END).attr('refX', 27).attr('refY', 18).attr('markerWidth', 45).attr('markerHeight', 36).attr('orient', 'auto').append('path').attr('stroke', conf.stroke).attr('fill', 'none').attr('d', 'M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18');
  marker = elem.append('defs').append('marker').attr('id', ERMarkers.ZERO_OR_MORE_START).attr('refX', 18).attr('refY', 18).attr('markerWidth', 57).attr('markerHeight', 36).attr('orient', 'auto');
  marker.append('circle').attr('stroke', conf.stroke).attr('fill', 'white').attr('cx', 48).attr('cy', 18).attr('r', 6);
  marker.append('path').attr('stroke', conf.stroke).attr('fill', 'none').attr('d', 'M0,18 Q18,0 36,18 Q18,36 0,18');
  marker = elem.append('defs').append('marker').attr('id', ERMarkers.ZERO_OR_MORE_END).attr('refX', 39).attr('refY', 18).attr('markerWidth', 57).attr('markerHeight', 36).attr('orient', 'auto');
  marker.append('circle').attr('stroke', conf.stroke).attr('fill', 'white').attr('cx', 9).attr('cy', 18).attr('r', 6);
  marker.append('path').attr('stroke', conf.stroke).attr('fill', 'none').attr('d', 'M21,18 Q39,0 57,18 Q39,36 21,18');
  return;
};

/* harmony default export */ __webpack_exports__["default"] = ({
  ERMarkers: ERMarkers,
  insertMarkers: insertMarkers
});

/***/ }),

/***/ "./src/diagrams/er/erRenderer.js":
/*!***************************************!*\
  !*** ./src/diagrams/er/erRenderer.js ***!
  \***************************************/
/*! exports provided: setConf, draw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConf", function() { return setConf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return draw; });
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphlib */ "graphlib");
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(graphlib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _erDb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./erDb */ "./src/diagrams/er/erDb.js");
/* harmony import */ var _parser_erDiagram__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parser/erDiagram */ "./src/diagrams/er/parser/erDiagram.jison");
/* harmony import */ var _parser_erDiagram__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_parser_erDiagram__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var dagre__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! dagre */ "dagre");
/* harmony import */ var dagre__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(dagre__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _erMarkers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./erMarkers */ "./src/diagrams/er/erMarkers.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");









var conf = {};
/**
 * Allows the top-level API module to inject config specific to this renderer,
 * storing it in the local conf object. Note that generic config still needs to be
 * retrieved using getConfig() imported from the config module
 */

var setConf = function setConf(cnf) {
  var keys = Object.keys(cnf);

  for (var i = 0; i < keys.length; i++) {
    conf[keys[i]] = cnf[keys[i]];
  }
};
/**
 * Draw attributes for an entity
 * @param groupNode the svg group node for the entity
 * @param entityTextNode the svg node for the entity label text
 * @param attributes an array of attributes defined for the entity (each attribute has a type and a name)
 * @return the bounding box of the entity, after attributes have been added
 */

var drawAttributes = function drawAttributes(groupNode, entityTextNode, attributes) {
  var heightPadding = conf.entityPadding / 3; // Padding internal to attribute boxes

  var widthPadding = conf.entityPadding / 3; // Ditto

  var attrFontSize = conf.fontSize * 0.85;
  var labelBBox = entityTextNode.node().getBBox();
  var attributeNodes = []; // Intermediate storage for attribute nodes created so that we can do a second pass

  var maxTypeWidth = 0;
  var maxNameWidth = 0;
  var cumulativeHeight = labelBBox.height + heightPadding * 2;
  var attrNum = 1;
  attributes.forEach(function (item) {
    var attrPrefix = "".concat(entityTextNode.node().id, "-attr-").concat(attrNum); // Add a text node for the attribute type

    var typeNode = groupNode.append('text').attr('class', 'er entityLabel').attr('id', "".concat(attrPrefix, "-type")).attr('x', 0).attr('y', 0).attr('dominant-baseline', 'middle').attr('text-anchor', 'left').attr('style', 'font-family: ' + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().fontFamily + '; font-size: ' + attrFontSize + 'px').text(item.attributeType); // Add a text node for the attribute name

    var nameNode = groupNode.append('text').attr('class', 'er entityLabel').attr('id', "".concat(attrPrefix, "-name")).attr('x', 0).attr('y', 0).attr('dominant-baseline', 'middle').attr('text-anchor', 'left').attr('style', 'font-family: ' + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().fontFamily + '; font-size: ' + attrFontSize + 'px').text(item.attributeName); // Keep a reference to the nodes so that we can iterate through them later

    attributeNodes.push({
      tn: typeNode,
      nn: nameNode
    });
    var typeBBox = typeNode.node().getBBox();
    var nameBBox = nameNode.node().getBBox();
    maxTypeWidth = Math.max(maxTypeWidth, typeBBox.width);
    maxNameWidth = Math.max(maxNameWidth, nameBBox.width);
    cumulativeHeight += Math.max(typeBBox.height, nameBBox.height) + heightPadding * 2;
    attrNum += 1;
  }); // Calculate the new bounding box of the overall entity, now that attributes have been added

  var bBox = {
    width: Math.max(conf.minEntityWidth, Math.max(labelBBox.width + conf.entityPadding * 2, maxTypeWidth + maxNameWidth + widthPadding * 4)),
    height: attributes.length > 0 ? cumulativeHeight : Math.max(conf.minEntityHeight, labelBBox.height + conf.entityPadding * 2)
  }; // There might be some spare width for padding out attributes if the entity name is very long

  var spareWidth = Math.max(0, bBox.width - (maxTypeWidth + maxNameWidth) - widthPadding * 4);

  if (attributes.length > 0) {
    // Position the entity label near the top of the entity bounding box
    entityTextNode.attr('transform', 'translate(' + bBox.width / 2 + ',' + (heightPadding + labelBBox.height / 2) + ')'); // Add rectangular boxes for the attribute types/names

    var heightOffset = labelBBox.height + heightPadding * 2; // Start at the bottom of the entity label

    var attribStyle = 'attributeBoxOdd'; // We will flip the style on alternate rows to achieve a banded effect

    attributeNodes.forEach(function (nodePair) {
      // Calculate the alignment y co-ordinate for the type/name of the attribute
      var alignY = heightOffset + heightPadding + Math.max(nodePair.tn.node().getBBox().height, nodePair.nn.node().getBBox().height) / 2; // Position the type of the attribute

      nodePair.tn.attr('transform', 'translate(' + widthPadding + ',' + alignY + ')'); // Insert a rectangle for the type

      var typeRect = groupNode.insert('rect', '#' + nodePair.tn.node().id).attr('class', "er ".concat(attribStyle)).attr('fill', conf.fill).attr('fill-opacity', '100%').attr('stroke', conf.stroke).attr('x', 0).attr('y', heightOffset).attr('width', maxTypeWidth + widthPadding * 2 + spareWidth / 2).attr('height', nodePair.tn.node().getBBox().height + heightPadding * 2); // Position the name of the attribute

      nodePair.nn.attr('transform', 'translate(' + (parseFloat(typeRect.attr('width')) + widthPadding) + ',' + alignY + ')'); // Insert a rectangle for the name

      groupNode.insert('rect', '#' + nodePair.nn.node().id).attr('class', "er ".concat(attribStyle)).attr('fill', conf.fill).attr('fill-opacity', '100%').attr('stroke', conf.stroke).attr('x', "".concat(typeRect.attr('x') + typeRect.attr('width'))) //.attr('x', maxTypeWidth + (widthPadding * 2))
      .attr('y', heightOffset).attr('width', maxNameWidth + widthPadding * 2 + spareWidth / 2).attr('height', nodePair.nn.node().getBBox().height + heightPadding * 2); // Increment the height offset to move to the next row

      heightOffset += Math.max(nodePair.tn.node().getBBox().height, nodePair.nn.node().getBBox().height) + heightPadding * 2; // Flip the attribute style for row banding

      attribStyle = attribStyle == 'attributeBoxOdd' ? 'attributeBoxEven' : 'attributeBoxOdd';
    });
  } else {
    // Ensure the entity box is a decent size without any attributes
    bBox.height = Math.max(conf.minEntityHeight, cumulativeHeight); // Position the entity label in the middle of the box

    entityTextNode.attr('transform', 'translate(' + bBox.width / 2 + ',' + bBox.height / 2 + ')');
  }

  return bBox;
};
/**
 * Use D3 to construct the svg elements for the entities
 * @param svgNode the svg node that contains the diagram
 * @param entities The entities to be drawn
 * @param graph The graph that contains the vertex and edge definitions post-layout
 * @return The first entity that was inserted
 */


var drawEntities = function drawEntities(svgNode, entities, graph) {
  var keys = Object.keys(entities);
  var firstOne;
  keys.forEach(function (id) {
    // Create a group for each entity
    var groupNode = svgNode.append('g').attr('id', id);
    firstOne = firstOne === undefined ? id : firstOne; // Label the entity - this is done first so that we can get the bounding box
    // which then determines the size of the rectangle

    var textId = 'entity-' + id;
    var textNode = groupNode.append('text').attr('class', 'er entityLabel').attr('id', textId).attr('x', 0).attr('y', 0).attr('dominant-baseline', 'middle').attr('text-anchor', 'middle').attr('style', 'font-family: ' + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().fontFamily + '; font-size: ' + conf.fontSize + 'px').text(id);

    var _drawAttributes = drawAttributes(groupNode, textNode, entities[id].attributes),
        entityWidth = _drawAttributes.width,
        entityHeight = _drawAttributes.height; // Draw the rectangle - insert it before the text so that the text is not obscured


    var rectNode = groupNode.insert('rect', '#' + textId).attr('class', 'er entityBox').attr('fill', conf.fill).attr('fill-opacity', '100%').attr('stroke', conf.stroke).attr('x', 0).attr('y', 0).attr('width', entityWidth).attr('height', entityHeight);
    var rectBBox = rectNode.node().getBBox(); // Add the entity to the graph

    graph.setNode(id, {
      width: rectBBox.width,
      height: rectBBox.height,
      shape: 'rect',
      id: id
    });
  });
  return firstOne;
}; // drawEntities


var adjustEntities = function adjustEntities(svgNode, graph) {
  graph.nodes().forEach(function (v) {
    if (typeof v !== 'undefined' && typeof graph.node(v) !== 'undefined') {
      svgNode.select('#' + v).attr('transform', 'translate(' + (graph.node(v).x - graph.node(v).width / 2) + ',' + (graph.node(v).y - graph.node(v).height / 2) + ' )');
    }
  });
  return;
};

var getEdgeName = function getEdgeName(rel) {
  return (rel.entityA + rel.roleA + rel.entityB).replace(/\s/g, '');
};
/**
 * Add each relationship to the graph
 * @param relationships the relationships to be added
 * @param g the graph
 * @return {Array} The array of relationships
 */


var addRelationships = function addRelationships(relationships, g) {
  relationships.forEach(function (r) {
    g.setEdge(r.entityA, r.entityB, {
      relationship: r
    }, getEdgeName(r));
  });
  return relationships;
}; // addRelationships


var relCnt = 0;
/**
 * Draw a relationship using edge information from the graph
 * @param svg the svg node
 * @param rel the relationship to draw in the svg
 * @param g the graph containing the edge information
 * @param insert the insertion point in the svg DOM (because relationships have markers that need to sit 'behind' opaque entity boxes)
 */

var drawRelationshipFromLayout = function drawRelationshipFromLayout(svg, rel, g, insert) {
  relCnt++; // Find the edge relating to this relationship

  var edge = g.edge(rel.entityA, rel.entityB, getEdgeName(rel)); // Get a function that will generate the line path

  var lineFunction = Object(d3__WEBPACK_IMPORTED_MODULE_1__["line"])().x(function (d) {
    return d.x;
  }).y(function (d) {
    return d.y;
  }).curve(d3__WEBPACK_IMPORTED_MODULE_1__["curveBasis"]); // Insert the line at the right place

  var svgPath = svg.insert('path', '#' + insert).attr('class', 'er relationshipLine').attr('d', lineFunction(edge.points)).attr('stroke', conf.stroke).attr('fill', 'none'); // ...and with dashes if necessary

  if (rel.relSpec.relType === _erDb__WEBPACK_IMPORTED_MODULE_2__["default"].Identification.NON_IDENTIFYING) {
    svgPath.attr('stroke-dasharray', '8,8');
  } // TODO: Understand this better


  var url = '';

  if (conf.arrowMarkerAbsolute) {
    url = window.location.protocol + '//' + window.location.host + window.location.pathname + window.location.search;
    url = url.replace(/\(/g, '\\(');
    url = url.replace(/\)/g, '\\)');
  } // Decide which start and end markers it needs. It may be possible to be more concise here
  // by reversing a start marker to make an end marker...but this will do for now
  // Note that the 'A' entity's marker is at the end of the relationship and the 'B' entity's marker is at the start


  switch (rel.relSpec.cardA) {
    case _erDb__WEBPACK_IMPORTED_MODULE_2__["default"].Cardinality.ZERO_OR_ONE:
      svgPath.attr('marker-end', 'url(' + url + '#' + _erMarkers__WEBPACK_IMPORTED_MODULE_7__["default"].ERMarkers.ZERO_OR_ONE_END + ')');
      break;

    case _erDb__WEBPACK_IMPORTED_MODULE_2__["default"].Cardinality.ZERO_OR_MORE:
      svgPath.attr('marker-end', 'url(' + url + '#' + _erMarkers__WEBPACK_IMPORTED_MODULE_7__["default"].ERMarkers.ZERO_OR_MORE_END + ')');
      break;

    case _erDb__WEBPACK_IMPORTED_MODULE_2__["default"].Cardinality.ONE_OR_MORE:
      svgPath.attr('marker-end', 'url(' + url + '#' + _erMarkers__WEBPACK_IMPORTED_MODULE_7__["default"].ERMarkers.ONE_OR_MORE_END + ')');
      break;

    case _erDb__WEBPACK_IMPORTED_MODULE_2__["default"].Cardinality.ONLY_ONE:
      svgPath.attr('marker-end', 'url(' + url + '#' + _erMarkers__WEBPACK_IMPORTED_MODULE_7__["default"].ERMarkers.ONLY_ONE_END + ')');
      break;
  }

  switch (rel.relSpec.cardB) {
    case _erDb__WEBPACK_IMPORTED_MODULE_2__["default"].Cardinality.ZERO_OR_ONE:
      svgPath.attr('marker-start', 'url(' + url + '#' + _erMarkers__WEBPACK_IMPORTED_MODULE_7__["default"].ERMarkers.ZERO_OR_ONE_START + ')');
      break;

    case _erDb__WEBPACK_IMPORTED_MODULE_2__["default"].Cardinality.ZERO_OR_MORE:
      svgPath.attr('marker-start', 'url(' + url + '#' + _erMarkers__WEBPACK_IMPORTED_MODULE_7__["default"].ERMarkers.ZERO_OR_MORE_START + ')');
      break;

    case _erDb__WEBPACK_IMPORTED_MODULE_2__["default"].Cardinality.ONE_OR_MORE:
      svgPath.attr('marker-start', 'url(' + url + '#' + _erMarkers__WEBPACK_IMPORTED_MODULE_7__["default"].ERMarkers.ONE_OR_MORE_START + ')');
      break;

    case _erDb__WEBPACK_IMPORTED_MODULE_2__["default"].Cardinality.ONLY_ONE:
      svgPath.attr('marker-start', 'url(' + url + '#' + _erMarkers__WEBPACK_IMPORTED_MODULE_7__["default"].ERMarkers.ONLY_ONE_START + ')');
      break;
  } // Now label the relationship
  // Find the half-way point


  var len = svgPath.node().getTotalLength();
  var labelPoint = svgPath.node().getPointAtLength(len * 0.5); // Append a text node containing the label

  var labelId = 'rel' + relCnt;
  var labelNode = svg.append('text').attr('class', 'er relationshipLabel').attr('id', labelId).attr('x', labelPoint.x).attr('y', labelPoint.y).attr('text-anchor', 'middle').attr('dominant-baseline', 'middle').attr('style', 'font-family: ' + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().fontFamily + '; font-size: ' + conf.fontSize + 'px').text(rel.roleA); // Figure out how big the opaque 'container' rectangle needs to be

  var labelBBox = labelNode.node().getBBox(); // Insert the opaque rectangle before the text label

  svg.insert('rect', '#' + labelId).attr('class', 'er relationshipLabelBox').attr('x', labelPoint.x - labelBBox.width / 2).attr('y', labelPoint.y - labelBBox.height / 2).attr('width', labelBBox.width).attr('height', labelBBox.height).attr('fill', 'white').attr('fill-opacity', '85%');
  return;
};
/**
 * Draw en E-R diagram in the tag with id: id based on the text definition of the diagram
 * @param text the text of the diagram
 * @param id the unique id of the DOM node that contains the diagram
 */


var draw = function draw(text, id) {
  _logger__WEBPACK_IMPORTED_MODULE_6__["log"].info('Drawing ER diagram');
  _erDb__WEBPACK_IMPORTED_MODULE_2__["default"].clear();
  var parser = _parser_erDiagram__WEBPACK_IMPORTED_MODULE_3___default.a.parser;
  parser.yy = _erDb__WEBPACK_IMPORTED_MODULE_2__["default"]; // Parse the text to populate erDb

  try {
    parser.parse(text);
  } catch (err) {
    _logger__WEBPACK_IMPORTED_MODULE_6__["log"].debug('Parsing failed');
  } // Get a reference to the svg node that contains the text


  var svg = Object(d3__WEBPACK_IMPORTED_MODULE_1__["select"])("[id='".concat(id, "']")); // Add cardinality marker definitions to the svg

  _erMarkers__WEBPACK_IMPORTED_MODULE_7__["default"].insertMarkers(svg, conf); // Now we have to construct the diagram in a specific way:
  // ---
  // 1. Create all the entities in the svg node at 0,0, but with the correct dimensions (allowing for text content)
  // 2. Make sure they are all added to the graph
  // 3. Add all the edges (relationships) to the graph aswell
  // 4. Let dagre do its magic to layout the graph.  This assigns:
  //    - the centre co-ordinates for each node, bearing in mind the dimensions and edge relationships
  //    - the path co-ordinates for each edge
  //    But it has no impact on the svg child nodes - the diagram remains with every entity rooted at 0,0
  // 5. Now assign a transform to each entity in the svg node so that it gets drawn in the correct place, as determined by
  //    its centre point, which is obtained from the graph, and it's width and height
  // 6. And finally, create all the edges in the svg node using information from the graph
  // ---
  // Create the graph

  var g; // TODO: Explore directed vs undirected graphs, and how the layout is affected
  // An E-R diagram could be said to be undirected, but there is merit in setting
  // the direction from parent to child in a one-to-many as this influences graphlib to
  // put the parent above the child (does it?), which is intuitive.  Most relationships
  // in ER diagrams are one-to-many.

  g = new graphlib__WEBPACK_IMPORTED_MODULE_0___default.a.Graph({
    multigraph: true,
    directed: true,
    compound: false
  }).setGraph({
    rankdir: conf.layoutDirection,
    marginx: 20,
    marginy: 20,
    nodesep: 100,
    edgesep: 100,
    ranksep: 100
  }).setDefaultEdgeLabel(function () {
    return {};
  }); // Draw the entities (at 0,0), returning the first svg node that got
  // inserted - this represents the insertion point for relationship paths

  var firstEntity = drawEntities(svg, _erDb__WEBPACK_IMPORTED_MODULE_2__["default"].getEntities(), g); // TODO: externalise the addition of entities to the graph - it's a bit 'buried' in the above
  // Add all the relationships to the graph

  var relationships = addRelationships(_erDb__WEBPACK_IMPORTED_MODULE_2__["default"].getRelationships(), g);
  dagre__WEBPACK_IMPORTED_MODULE_4___default.a.layout(g); // Node and edge positions will be updated
  // Adjust the positions of the entities so that they adhere to the layout

  adjustEntities(svg, g); // Draw the relationships

  relationships.forEach(function (rel) {
    drawRelationshipFromLayout(svg, rel, g, firstEntity);
  });
  var padding = conf.diagramPadding;
  var svgBounds = svg.node().getBBox();
  var width = svgBounds.width + padding * 2;
  var height = svgBounds.height + padding * 2;
  Object(_utils__WEBPACK_IMPORTED_MODULE_8__["configureSvgSize"])(svg, height, width, conf.useMaxWidth);
  svg.attr('viewBox', "".concat(svgBounds.x - padding, " ").concat(svgBounds.y - padding, " ").concat(width, " ").concat(height));
}; // draw

/* harmony default export */ __webpack_exports__["default"] = ({
  setConf: setConf,
  draw: draw
});

/***/ }),

/***/ "./src/diagrams/er/parser/erDiagram.jison":
/*!************************************************!*\
  !*** ./src/diagrams/er/parser/erDiagram.jison ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, module) {/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,2],$V1=[1,5],$V2=[6,9,11,23,37],$V3=[1,17],$V4=[1,20],$V5=[1,25],$V6=[1,26],$V7=[1,27],$V8=[1,28],$V9=[1,37],$Va=[23,34,35],$Vb=[4,6,9,11,23,37],$Vc=[30,31,32,33],$Vd=[22,27];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"start":3,"ER_DIAGRAM":4,"document":5,"EOF":6,"directive":7,"line":8,"SPACE":9,"statement":10,"NEWLINE":11,"openDirective":12,"typeDirective":13,"closeDirective":14,":":15,"argDirective":16,"entityName":17,"relSpec":18,"role":19,"BLOCK_START":20,"attributes":21,"BLOCK_STOP":22,"ALPHANUM":23,"attribute":24,"attributeType":25,"attributeName":26,"ATTRIBUTE_WORD":27,"cardinality":28,"relType":29,"ZERO_OR_ONE":30,"ZERO_OR_MORE":31,"ONE_OR_MORE":32,"ONLY_ONE":33,"NON_IDENTIFYING":34,"IDENTIFYING":35,"WORD":36,"open_directive":37,"type_directive":38,"arg_directive":39,"close_directive":40,"$accept":0,"$end":1},
terminals_: {2:"error",4:"ER_DIAGRAM",6:"EOF",9:"SPACE",11:"NEWLINE",15:":",20:"BLOCK_START",22:"BLOCK_STOP",23:"ALPHANUM",27:"ATTRIBUTE_WORD",30:"ZERO_OR_ONE",31:"ZERO_OR_MORE",32:"ONE_OR_MORE",33:"ONLY_ONE",34:"NON_IDENTIFYING",35:"IDENTIFYING",36:"WORD",37:"open_directive",38:"type_directive",39:"arg_directive",40:"close_directive"},
productions_: [0,[3,3],[3,2],[5,0],[5,2],[8,2],[8,1],[8,1],[8,1],[7,4],[7,6],[10,1],[10,5],[10,4],[10,3],[10,1],[17,1],[21,1],[21,2],[24,2],[25,1],[26,1],[18,3],[28,1],[28,1],[28,1],[28,1],[29,1],[29,1],[19,1],[19,1],[12,1],[13,1],[16,1],[14,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
 /*console.log('finished parsing');*/ 
break;
case 3:
 this.$ = [] 
break;
case 4:
$$[$0-1].push($$[$0]);this.$ = $$[$0-1]
break;
case 5: case 6:
 this.$ = $$[$0] 
break;
case 7: case 8:
 this.$=[];
break;
case 12:

          yy.addEntity($$[$0-4]);
          yy.addEntity($$[$0-2]);
          yy.addRelationship($$[$0-4], $$[$0], $$[$0-2], $$[$0-3]);
          /*console.log($$[$0-4] + $$[$0-3] + $$[$0-2] + ':' + $$[$0]);*/
      
break;
case 13:

          /* console.log('detected block'); */
          yy.addEntity($$[$0-3]);
          yy.addAttributes($$[$0-3], $$[$0-1]);
          /* console.log('handled block'); */
      
break;
case 14:
 yy.addEntity($$[$0-2]); 
break;
case 15:
 yy.addEntity($$[$0]); 
break;
case 16:
 this.$ = $$[$0]; /*console.log('Entity: ' + $$[$0]);*/ 
break;
case 17:
 this.$ = [$$[$0]]; 
break;
case 18:
 $$[$0].push($$[$0-1]); this.$=$$[$0]; 
break;
case 19:
 this.$ = { attributeType: $$[$0-1], attributeName: $$[$0] }; 
break;
case 20: case 21:
 this.$=$$[$0]; 
break;
case 22:

        this.$ = { cardA: $$[$0], relType: $$[$0-1], cardB: $$[$0-2] };
        /*console.log('relSpec: ' + $$[$0] + $$[$0-1] + $$[$0-2]);*/
      
break;
case 23:
 this.$ = yy.Cardinality.ZERO_OR_ONE; 
break;
case 24:
 this.$ = yy.Cardinality.ZERO_OR_MORE; 
break;
case 25:
 this.$ = yy.Cardinality.ONE_OR_MORE; 
break;
case 26:
 this.$ = yy.Cardinality.ONLY_ONE; 
break;
case 27:
 this.$ = yy.Identification.NON_IDENTIFYING;  
break;
case 28:
 this.$ = yy.Identification.IDENTIFYING; 
break;
case 29:
 this.$ = $$[$0].replace(/"/g, ''); 
break;
case 30:
 this.$ = $$[$0]; 
break;
case 31:
 yy.parseDirective('%%{', 'open_directive'); 
break;
case 32:
 yy.parseDirective($$[$0], 'type_directive'); 
break;
case 33:
 $$[$0] = $$[$0].trim().replace(/'/g, '"'); yy.parseDirective($$[$0], 'arg_directive'); 
break;
case 34:
 yy.parseDirective('}%%', 'close_directive', 'er'); 
break;
}
},
table: [{3:1,4:$V0,7:3,12:4,37:$V1},{1:[3]},o($V2,[2,3],{5:6}),{3:7,4:$V0,7:3,12:4,37:$V1},{13:8,38:[1,9]},{38:[2,31]},{6:[1,10],7:15,8:11,9:[1,12],10:13,11:[1,14],12:4,17:16,23:$V3,37:$V1},{1:[2,2]},{14:18,15:[1,19],40:$V4},o([15,40],[2,32]),o($V2,[2,8],{1:[2,1]}),o($V2,[2,4]),{7:15,10:21,12:4,17:16,23:$V3,37:$V1},o($V2,[2,6]),o($V2,[2,7]),o($V2,[2,11]),o($V2,[2,15],{18:22,28:24,20:[1,23],30:$V5,31:$V6,32:$V7,33:$V8}),o([6,9,11,15,20,23,30,31,32,33,37],[2,16]),{11:[1,29]},{16:30,39:[1,31]},{11:[2,34]},o($V2,[2,5]),{17:32,23:$V3},{21:33,22:[1,34],24:35,25:36,27:$V9},{29:38,34:[1,39],35:[1,40]},o($Va,[2,23]),o($Va,[2,24]),o($Va,[2,25]),o($Va,[2,26]),o($Vb,[2,9]),{14:41,40:$V4},{40:[2,33]},{15:[1,42]},{22:[1,43]},o($V2,[2,14]),{21:44,22:[2,17],24:35,25:36,27:$V9},{26:45,27:[1,46]},{27:[2,20]},{28:47,30:$V5,31:$V6,32:$V7,33:$V8},o($Vc,[2,27]),o($Vc,[2,28]),{11:[1,48]},{19:49,23:[1,51],36:[1,50]},o($V2,[2,13]),{22:[2,18]},o($Vd,[2,19]),o($Vd,[2,21]),{23:[2,22]},o($Vb,[2,10]),o($V2,[2,12]),o($V2,[2,29]),o($V2,[2,30])],
defaultActions: {5:[2,31],7:[2,2],20:[2,34],31:[2,33],37:[2,20],44:[2,18],47:[2,22]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
            function lex() {
            var token;
            token = tstack.pop() || lexer.lex() || EOF;
            if (typeof token !== 'number') {
                if (token instanceof Array) {
                    tstack = token;
                    token = tstack.pop();
                }
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
        if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];
            for (p in table[state]) {
                if (this.terminals_[p] && p > TERROR) {
                    expected.push('\'' + this.terminals_[p] + '\'');
                }
            }
            if (lexer.showPosition) {
                errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
                errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }
            this.parseError(errStr, {
                text: lexer.match,
                token: this.terminals_[symbol] || symbol,
                line: lexer.yylineno,
                loc: yyloc,
                expected: expected
            });
        }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {"case-insensitive":true},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0: this.begin('open_directive'); return 37; 
break;
case 1: this.begin('type_directive'); return 38; 
break;
case 2: this.popState(); this.begin('arg_directive'); return 15; 
break;
case 3: this.popState(); this.popState(); return 40; 
break;
case 4:return 39;
break;
case 5:/* skip comments */
break;
case 6:/* skip comments */
break;
case 7:return 11;
break;
case 8:/* skip whitespace */
break;
case 9:return 9;
break;
case 10:return 36;
break;
case 11:return 4;
break;
case 12: this.begin("block"); return 20; 
break;
case 13:/* skip whitespace in block */
break;
case 14: return 27; 
break;
case 15:/* nothing */
break;
case 16: this.popState(); return 22; 
break;
case 17:return yy_.yytext[0];
break;
case 18:return 30;
break;
case 19:return 31;
break;
case 20:return 32;
break;
case 21:return 33;
break;
case 22:return 30;
break;
case 23:return 31;
break;
case 24:return 32;
break;
case 25:return 34;
break;
case 26:return 35;
break;
case 27:return 34;
break;
case 28:return 34;
break;
case 29:return 23;
break;
case 30:return yy_.yytext[0];
break;
case 31:return 6;
break;
}
},
rules: [/^(?:%%\{)/i,/^(?:((?:(?!\}%%)[^:.])*))/i,/^(?::)/i,/^(?:\}%%)/i,/^(?:((?:(?!\}%%).|\n)*))/i,/^(?:%(?!\{)[^\n]*)/i,/^(?:[^\}]%%[^\n]*)/i,/^(?:[\n]+)/i,/^(?:\s+)/i,/^(?:[\s]+)/i,/^(?:"[^"]*")/i,/^(?:erDiagram\b)/i,/^(?:\{)/i,/^(?:\s+)/i,/^(?:[A-Za-z][A-Za-z0-9\-_]*)/i,/^(?:[\n]+)/i,/^(?:\})/i,/^(?:.)/i,/^(?:\|o\b)/i,/^(?:\}o\b)/i,/^(?:\}\|)/i,/^(?:\|\|)/i,/^(?:o\|)/i,/^(?:o\{)/i,/^(?:\|\{)/i,/^(?:\.\.)/i,/^(?:--)/i,/^(?:\.-)/i,/^(?:-\.)/i,/^(?:[A-Za-z][A-Za-z0-9\-_]*)/i,/^(?:.)/i,/^(?:$)/i],
conditions: {"open_directive":{"rules":[1],"inclusive":false},"type_directive":{"rules":[2,3],"inclusive":false},"arg_directive":{"rules":[3,4],"inclusive":false},"block":{"rules":[13,14,15,16,17],"inclusive":false},"INITIAL":{"rules":[0,5,6,7,8,9,10,11,12,18,19,20,21,22,23,24,25,26,27,28,29,30,31],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (true) {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js").readFileSync(__webpack_require__(/*! path */ "./node_modules/path-browserify/index.js").normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if ( true && __webpack_require__.c[__webpack_require__.s] === module) {
  exports.main(process.argv.slice(1));
}
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/diagrams/er/styles.js":
/*!***********************************!*\
  !*** ./src/diagrams/er/styles.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var getStyles = function getStyles(options) {
  return "\n  .entityBox {\n    fill: ".concat(options.mainBkg, ";\n    stroke: ").concat(options.nodeBorder, ";\n  }\n\n  .attributeBoxOdd {\n    fill: #ffffff;\n    stroke: ").concat(options.nodeBorder, ";\n  }\n\n  .attributeBoxEven {\n    fill: #f2f2f2;\n    stroke: ").concat(options.nodeBorder, ";\n  }\n\n  .relationshipLabelBox {\n    fill: ").concat(options.tertiaryColor, ";\n    opacity: 0.7;\n    background-color: ").concat(options.tertiaryColor, ";\n      rect {\n        opacity: 0.5;\n      }\n  }\n\n    .relationshipLine {\n      stroke: ").concat(options.lineColor, ";\n    }\n");
};

/* harmony default export */ __webpack_exports__["default"] = (getStyles);

/***/ }),

/***/ "./src/diagrams/flowchart/flowChartShapes.js":
/*!***************************************************!*\
  !*** ./src/diagrams/flowchart/flowChartShapes.js ***!
  \***************************************************/
/*! exports provided: addToRender, addToRenderV2, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addToRender", function() { return addToRender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addToRenderV2", function() { return addToRenderV2; });
/* harmony import */ var dagre_d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dagre-d3 */ "dagre-d3");
/* harmony import */ var dagre_d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dagre_d3__WEBPACK_IMPORTED_MODULE_0__);


function question(parent, bbox, node) {
  var w = bbox.width;
  var h = bbox.height;
  var s = (w + h) * 0.9;
  var points = [{
    x: s / 2,
    y: 0
  }, {
    x: s,
    y: -s / 2
  }, {
    x: s / 2,
    y: -s
  }, {
    x: 0,
    y: -s / 2
  }];
  var shapeSvg = insertPolygonShape(parent, s, s, points);

  node.intersect = function (point) {
    return dagre_d3__WEBPACK_IMPORTED_MODULE_0___default.a.intersect.polygon(node, points, point);
  };

  return shapeSvg;
}

function hexagon(parent, bbox, node) {
  var f = 4;
  var h = bbox.height;
  var m = h / f;
  var w = bbox.width + 2 * m;
  var points = [{
    x: m,
    y: 0
  }, {
    x: w - m,
    y: 0
  }, {
    x: w,
    y: -h / 2
  }, {
    x: w - m,
    y: -h
  }, {
    x: m,
    y: -h
  }, {
    x: 0,
    y: -h / 2
  }];
  var shapeSvg = insertPolygonShape(parent, w, h, points);

  node.intersect = function (point) {
    return dagre_d3__WEBPACK_IMPORTED_MODULE_0___default.a.intersect.polygon(node, points, point);
  };

  return shapeSvg;
}

function rect_left_inv_arrow(parent, bbox, node) {
  var w = bbox.width;
  var h = bbox.height;
  var points = [{
    x: -h / 2,
    y: 0
  }, {
    x: w,
    y: 0
  }, {
    x: w,
    y: -h
  }, {
    x: -h / 2,
    y: -h
  }, {
    x: 0,
    y: -h / 2
  }];
  var shapeSvg = insertPolygonShape(parent, w, h, points);

  node.intersect = function (point) {
    return dagre_d3__WEBPACK_IMPORTED_MODULE_0___default.a.intersect.polygon(node, points, point);
  };

  return shapeSvg;
}

function lean_right(parent, bbox, node) {
  var w = bbox.width;
  var h = bbox.height;
  var points = [{
    x: -2 * h / 6,
    y: 0
  }, {
    x: w - h / 6,
    y: 0
  }, {
    x: w + 2 * h / 6,
    y: -h
  }, {
    x: h / 6,
    y: -h
  }];
  var shapeSvg = insertPolygonShape(parent, w, h, points);

  node.intersect = function (point) {
    return dagre_d3__WEBPACK_IMPORTED_MODULE_0___default.a.intersect.polygon(node, points, point);
  };

  return shapeSvg;
}

function lean_left(parent, bbox, node) {
  var w = bbox.width;
  var h = bbox.height;
  var points = [{
    x: 2 * h / 6,
    y: 0
  }, {
    x: w + h / 6,
    y: 0
  }, {
    x: w - 2 * h / 6,
    y: -h
  }, {
    x: -h / 6,
    y: -h
  }];
  var shapeSvg = insertPolygonShape(parent, w, h, points);

  node.intersect = function (point) {
    return dagre_d3__WEBPACK_IMPORTED_MODULE_0___default.a.intersect.polygon(node, points, point);
  };

  return shapeSvg;
}

function trapezoid(parent, bbox, node) {
  var w = bbox.width;
  var h = bbox.height;
  var points = [{
    x: -2 * h / 6,
    y: 0
  }, {
    x: w + 2 * h / 6,
    y: 0
  }, {
    x: w - h / 6,
    y: -h
  }, {
    x: h / 6,
    y: -h
  }];
  var shapeSvg = insertPolygonShape(parent, w, h, points);

  node.intersect = function (point) {
    return dagre_d3__WEBPACK_IMPORTED_MODULE_0___default.a.intersect.polygon(node, points, point);
  };

  return shapeSvg;
}

function inv_trapezoid(parent, bbox, node) {
  var w = bbox.width;
  var h = bbox.height;
  var points = [{
    x: h / 6,
    y: 0
  }, {
    x: w - h / 6,
    y: 0
  }, {
    x: w + 2 * h / 6,
    y: -h
  }, {
    x: -2 * h / 6,
    y: -h
  }];
  var shapeSvg = insertPolygonShape(parent, w, h, points);

  node.intersect = function (point) {
    return dagre_d3__WEBPACK_IMPORTED_MODULE_0___default.a.intersect.polygon(node, points, point);
  };

  return shapeSvg;
}

function rect_right_inv_arrow(parent, bbox, node) {
  var w = bbox.width;
  var h = bbox.height;
  var points = [{
    x: 0,
    y: 0
  }, {
    x: w + h / 2,
    y: 0
  }, {
    x: w,
    y: -h / 2
  }, {
    x: w + h / 2,
    y: -h
  }, {
    x: 0,
    y: -h
  }];
  var shapeSvg = insertPolygonShape(parent, w, h, points);

  node.intersect = function (point) {
    return dagre_d3__WEBPACK_IMPORTED_MODULE_0___default.a.intersect.polygon(node, points, point);
  };

  return shapeSvg;
}

function stadium(parent, bbox, node) {
  var h = bbox.height;
  var w = bbox.width + h / 4;
  var shapeSvg = parent.insert('rect', ':first-child').attr('rx', h / 2).attr('ry', h / 2).attr('x', -w / 2).attr('y', -h / 2).attr('width', w).attr('height', h);

  node.intersect = function (point) {
    return dagre_d3__WEBPACK_IMPORTED_MODULE_0___default.a.intersect.rect(node, point);
  };

  return shapeSvg;
}

function subroutine(parent, bbox, node) {
  var w = bbox.width;
  var h = bbox.height;
  var points = [{
    x: 0,
    y: 0
  }, {
    x: w,
    y: 0
  }, {
    x: w,
    y: -h
  }, {
    x: 0,
    y: -h
  }, {
    x: 0,
    y: 0
  }, {
    x: -8,
    y: 0
  }, {
    x: w + 8,
    y: 0
  }, {
    x: w + 8,
    y: -h
  }, {
    x: -8,
    y: -h
  }, {
    x: -8,
    y: 0
  }];
  var shapeSvg = insertPolygonShape(parent, w, h, points);

  node.intersect = function (point) {
    return dagre_d3__WEBPACK_IMPORTED_MODULE_0___default.a.intersect.polygon(node, points, point);
  };

  return shapeSvg;
}

function cylinder(parent, bbox, node) {
  var w = bbox.width;
  var rx = w / 2;
  var ry = rx / (2.5 + w / 50);
  var h = bbox.height + ry;
  var shape = 'M 0,' + ry + ' a ' + rx + ',' + ry + ' 0,0,0 ' + w + ' 0 a ' + rx + ',' + ry + ' 0,0,0 ' + -w + ' 0 l 0,' + h + ' a ' + rx + ',' + ry + ' 0,0,0 ' + w + ' 0 l 0,' + -h;
  var shapeSvg = parent.attr('label-offset-y', ry).insert('path', ':first-child').attr('d', shape).attr('transform', 'translate(' + -w / 2 + ',' + -(h / 2 + ry) + ')');

  node.intersect = function (point) {
    var pos = dagre_d3__WEBPACK_IMPORTED_MODULE_0___default.a.intersect.rect(node, point);
    var x = pos.x - node.x;

    if (rx != 0 && (Math.abs(x) < node.width / 2 || Math.abs(x) == node.width / 2 && Math.abs(pos.y - node.y) > node.height / 2 - ry)) {
      // ellipsis equation: x*x / a*a + y*y / b*b = 1
      // solve for y to get adjustion value for pos.y
      var y = ry * ry * (1 - x * x / (rx * rx));
      if (y != 0) y = Math.sqrt(y);
      y = ry - y;
      if (point.y - node.y > 0) y = -y;
      pos.y += y;
    }

    return pos;
  };

  return shapeSvg;
}

function addToRender(render) {
  render.shapes().question = question;
  render.shapes().hexagon = hexagon;
  render.shapes().stadium = stadium;
  render.shapes().subroutine = subroutine;
  render.shapes().cylinder = cylinder; // Add custom shape for box with inverted arrow on left side

  render.shapes().rect_left_inv_arrow = rect_left_inv_arrow; // Add custom shape for box with inverted arrow on left side

  render.shapes().lean_right = lean_right; // Add custom shape for box with inverted arrow on left side

  render.shapes().lean_left = lean_left; // Add custom shape for box with inverted arrow on left side

  render.shapes().trapezoid = trapezoid; // Add custom shape for box with inverted arrow on left side

  render.shapes().inv_trapezoid = inv_trapezoid; // Add custom shape for box with inverted arrow on right side

  render.shapes().rect_right_inv_arrow = rect_right_inv_arrow;
}
function addToRenderV2(addShape) {
  addShape({
    question: question
  });
  addShape({
    hexagon: hexagon
  });
  addShape({
    stadium: stadium
  });
  addShape({
    subroutine: subroutine
  });
  addShape({
    cylinder: cylinder
  }); // Add custom shape for box with inverted arrow on left side

  addShape({
    rect_left_inv_arrow: rect_left_inv_arrow
  }); // Add custom shape for box with inverted arrow on left side

  addShape({
    lean_right: lean_right
  }); // Add custom shape for box with inverted arrow on left side

  addShape({
    lean_left: lean_left
  }); // Add custom shape for box with inverted arrow on left side

  addShape({
    trapezoid: trapezoid
  }); // Add custom shape for box with inverted arrow on left side

  addShape({
    inv_trapezoid: inv_trapezoid
  }); // Add custom shape for box with inverted arrow on right side

  addShape({
    rect_right_inv_arrow: rect_right_inv_arrow
  });
}

function insertPolygonShape(parent, w, h, points) {
  return parent.insert('polygon', ':first-child').attr('points', points.map(function (d) {
    return d.x + ',' + d.y;
  }).join(' ')).attr('transform', 'translate(' + -w / 2 + ',' + h / 2 + ')');
}

/* harmony default export */ __webpack_exports__["default"] = ({
  addToRender: addToRender,
  addToRenderV2: addToRenderV2
});

/***/ }),

/***/ "./src/diagrams/flowchart/flowDb.js":
/*!******************************************!*\
  !*** ./src/diagrams/flowchart/flowDb.js ***!
  \******************************************/
/*! exports provided: parseDirective, lookUpDomId, addVertex, addSingleLink, addLink, updateLinkInterpolate, updateLink, addClass, setDirection, setClass, setLink, getTooltip, setClickEvent, bindFunctions, getDirection, getVertices, getEdges, getClasses, clear, setGen, defaultStyle, addSubGraph, getDepthFirstPos, indexNodes, getSubGraphs, firstGraph, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseDirective", function() { return parseDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookUpDomId", function() { return lookUpDomId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addVertex", function() { return addVertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addSingleLink", function() { return addSingleLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addLink", function() { return addLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateLinkInterpolate", function() { return updateLinkInterpolate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateLink", function() { return updateLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addClass", function() { return addClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDirection", function() { return setDirection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setClass", function() { return setClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setLink", function() { return setLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTooltip", function() { return getTooltip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setClickEvent", function() { return setClickEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindFunctions", function() { return bindFunctions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDirection", function() { return getDirection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVertices", function() { return getVertices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEdges", function() { return getEdges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getClasses", function() { return getClasses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setGen", function() { return setGen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultStyle", function() { return defaultStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addSubGraph", function() { return addSubGraph; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDepthFirstPos", function() { return getDepthFirstPos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "indexNodes", function() { return indexNodes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSubGraphs", function() { return getSubGraphs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "firstGraph", function() { return firstGraph; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/* harmony import */ var _common_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/common */ "./src/diagrams/common/common.js");
/* harmony import */ var _mermaidAPI__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mermaidAPI */ "./src/mermaidAPI.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }







var MERMAID_DOM_ID_PREFIX = 'flowchart-';
var vertexCounter = 0;
var config = _config__WEBPACK_IMPORTED_MODULE_2__["getConfig"]();
var vertices = {};
var edges = [];
var classes = [];
var subGraphs = [];
var subGraphLookup = {};
var tooltips = {};
var subCount = 0;
var firstGraphFlag = true;
var direction;
var version; // As in graph
// Functions to be run after graph rendering

var funs = [];
var parseDirective = function parseDirective(statement, context, type) {
  _mermaidAPI__WEBPACK_IMPORTED_MODULE_4__["default"].parseDirective(this, statement, context, type);
};
/**
 * Function to lookup domId from id in the graph definition.
 * @param id
 * @public
 */

var lookUpDomId = function lookUpDomId(id) {
  var veritceKeys = Object.keys(vertices);

  for (var i = 0; i < veritceKeys.length; i++) {
    if (vertices[veritceKeys[i]].id === id) {
      return vertices[veritceKeys[i]].domId;
    }
  }

  return id;
};
/**
 * Function called by parser when a node definition has been found
 * @param id
 * @param text
 * @param type
 * @param style
 * @param classes
 */

var addVertex = function addVertex(_id, text, type, style, classes, dir) {
  var txt;
  var id = _id;

  if (typeof id === 'undefined') {
    return;
  }

  if (id.trim().length === 0) {
    return;
  } // if (id[0].match(/\d/)) id = MERMAID_DOM_ID_PREFIX + id;


  if (typeof vertices[id] === 'undefined') {
    vertices[id] = {
      id: id,
      domId: MERMAID_DOM_ID_PREFIX + id + '-' + vertexCounter,
      styles: [],
      classes: []
    };
  }

  vertexCounter++;

  if (typeof text !== 'undefined') {
    config = _config__WEBPACK_IMPORTED_MODULE_2__["getConfig"]();
    txt = _common_common__WEBPACK_IMPORTED_MODULE_3__["default"].sanitizeText(text.trim(), config); // strip quotes if string starts and ends with a quote

    if (txt[0] === '"' && txt[txt.length - 1] === '"') {
      txt = txt.substring(1, txt.length - 1);
    }

    vertices[id].text = txt;
  } else {
    if (typeof vertices[id].text === 'undefined') {
      vertices[id].text = _id;
    }
  }

  if (typeof type !== 'undefined') {
    vertices[id].type = type;
  }

  if (typeof style !== 'undefined') {
    if (style !== null) {
      style.forEach(function (s) {
        vertices[id].styles.push(s);
      });
    }
  }

  if (typeof classes !== 'undefined') {
    if (classes !== null) {
      classes.forEach(function (s) {
        vertices[id].classes.push(s);
      });
    }
  }

  if (typeof dir !== 'undefined') {
    vertices[id].dir = dir;
  }
};
/**
 * Function called by parser when a link/edge definition has been found
 * @param start
 * @param end
 * @param type
 * @param linktext
 */

var addSingleLink = function addSingleLink(_start, _end, type, linktext) {
  var start = _start;
  var end = _end; // if (start[0].match(/\d/)) start = MERMAID_DOM_ID_PREFIX + start;
  // if (end[0].match(/\d/)) end = MERMAID_DOM_ID_PREFIX + end;
  // log.info('Got edge...', start, end);

  var edge = {
    start: start,
    end: end,
    type: undefined,
    text: ''
  };
  linktext = type.text;

  if (typeof linktext !== 'undefined') {
    edge.text = _common_common__WEBPACK_IMPORTED_MODULE_3__["default"].sanitizeText(linktext.trim(), config); // strip quotes if string starts and exnds with a quote

    if (edge.text[0] === '"' && edge.text[edge.text.length - 1] === '"') {
      edge.text = edge.text.substring(1, edge.text.length - 1);
    }
  }

  if (typeof type !== 'undefined') {
    edge.type = type.type;
    edge.stroke = type.stroke;
    edge.length = type.length;
  }

  edges.push(edge);
};
var addLink = function addLink(_start, _end, type, linktext) {
  var i, j;

  for (i = 0; i < _start.length; i++) {
    for (j = 0; j < _end.length; j++) {
      addSingleLink(_start[i], _end[j], type, linktext);
    }
  }
};
/**
 * Updates a link's line interpolation algorithm
 * @param pos
 * @param interpolate
 */

var updateLinkInterpolate = function updateLinkInterpolate(positions, interp) {
  positions.forEach(function (pos) {
    if (pos === 'default') {
      edges.defaultInterpolate = interp;
    } else {
      edges[pos].interpolate = interp;
    }
  });
};
/**
 * Updates a link with a style
 * @param pos
 * @param style
 */

var updateLink = function updateLink(positions, style) {
  positions.forEach(function (pos) {
    if (pos === 'default') {
      edges.defaultStyle = style;
    } else {
      if (_utils__WEBPACK_IMPORTED_MODULE_1__["default"].isSubstringInArray('fill', style) === -1) {
        style.push('fill:none');
      }

      edges[pos].style = style;
    }
  });
};
var addClass = function addClass(id, style) {
  if (typeof classes[id] === 'undefined') {
    classes[id] = {
      id: id,
      styles: [],
      textStyles: []
    };
  }

  if (typeof style !== 'undefined') {
    if (style !== null) {
      style.forEach(function (s) {
        if (s.match('color')) {
          var newStyle1 = s.replace('fill', 'bgFill');
          var newStyle2 = newStyle1.replace('color', 'fill');
          classes[id].textStyles.push(newStyle2);
        }

        classes[id].styles.push(s);
      });
    }
  }
};
/**
 * Called by parser when a graph definition is found, stores the direction of the chart.
 * @param dir
 */

var setDirection = function setDirection(dir) {
  direction = dir;

  if (direction.match(/.*</)) {
    direction = 'RL';
  }

  if (direction.match(/.*\^/)) {
    direction = 'BT';
  }

  if (direction.match(/.*>/)) {
    direction = 'LR';
  }

  if (direction.match(/.*v/)) {
    direction = 'TB';
  }
};
/**
 * Called by parser when a special node is found, e.g. a clickable element.
 * @param ids Comma separated list of ids
 * @param className Class to add
 */

var setClass = function setClass(ids, className) {
  ids.split(',').forEach(function (_id) {
    // let id = version === 'gen-2' ? lookUpDomId(_id) : _id;
    var id = _id; // if (_id[0].match(/\d/)) id = MERMAID_DOM_ID_PREFIX + id;

    if (typeof vertices[id] !== 'undefined') {
      vertices[id].classes.push(className);
    }

    if (typeof subGraphLookup[id] !== 'undefined') {
      subGraphLookup[id].classes.push(className);
    }
  });
};

var setTooltip = function setTooltip(ids, tooltip) {
  ids.split(',').forEach(function (id) {
    if (typeof tooltip !== 'undefined') {
      tooltips[version === 'gen-1' ? lookUpDomId(id) : id] = _common_common__WEBPACK_IMPORTED_MODULE_3__["default"].sanitizeText(tooltip, config);
    }
  });
};

var setClickFun = function setClickFun(id, functionName, functionArgs) {
  var domId = lookUpDomId(id); // if (_id[0].match(/\d/)) id = MERMAID_DOM_ID_PREFIX + id;

  if (_config__WEBPACK_IMPORTED_MODULE_2__["getConfig"]().securityLevel !== 'loose') {
    return;
  }

  if (typeof functionName === 'undefined') {
    return;
  }

  var argList = [];

  if (typeof functionArgs === 'string') {
    /* Splits functionArgs by ',', ignoring all ',' in double quoted strings */
    argList = functionArgs.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);

    for (var i = 0; i < argList.length; i++) {
      var item = argList[i].trim();
      /* Removes all double quotes at the start and end of an argument */

      /* This preserves all starting and ending whitespace inside */

      if (item.charAt(0) === '"' && item.charAt(item.length - 1) === '"') {
        item = item.substr(1, item.length - 2);
      }

      argList[i] = item;
    }
  }
  /* if no arguments passed into callback, default to passing in id */


  if (argList.length === 0) {
    argList.push(id);
  }

  if (typeof vertices[id] !== 'undefined') {
    vertices[id].haveCallback = true;
    funs.push(function () {
      var elem = document.querySelector("[id=\"".concat(domId, "\"]"));

      if (elem !== null) {
        elem.addEventListener('click', function () {
          _utils__WEBPACK_IMPORTED_MODULE_1__["default"].runFunc.apply(_utils__WEBPACK_IMPORTED_MODULE_1__["default"], [functionName].concat(_toConsumableArray(argList)));
        }, false);
      }
    });
  }
};
/**
 * Called by parser when a link is found. Adds the URL to the vertex data.
 * @param ids Comma separated list of ids
 * @param linkStr URL to create a link for
 */


var setLink = function setLink(ids, linkStr, target) {
  ids.split(',').forEach(function (id) {
    if (typeof vertices[id] !== 'undefined') {
      vertices[id].link = _utils__WEBPACK_IMPORTED_MODULE_1__["default"].formatUrl(linkStr, config);
      vertices[id].linkTarget = target;
    }
  });
  setClass(ids, 'clickable');
};
var getTooltip = function getTooltip(id) {
  return tooltips[id];
};
/**
 * Called by parser when a click definition is found. Registers an event handler.
 * @param ids Comma separated list of ids
 * @param functionName Function to be called on click
 * @param tooltip Tooltip for the clickable element
 */

var setClickEvent = function setClickEvent(ids, functionName, functionArgs) {
  ids.split(',').forEach(function (id) {
    setClickFun(id, functionName, functionArgs);
  });
  setClass(ids, 'clickable');
};
var bindFunctions = function bindFunctions(element) {
  funs.forEach(function (fun) {
    fun(element);
  });
};
var getDirection = function getDirection() {
  return direction.trim();
};
/**
 * Retrieval function for fetching the found nodes after parsing has completed.
 * @returns {{}|*|vertices}
 */

var getVertices = function getVertices() {
  return vertices;
};
/**
 * Retrieval function for fetching the found links after parsing has completed.
 * @returns {{}|*|edges}
 */

var getEdges = function getEdges() {
  return edges;
};
/**
 * Retrieval function for fetching the found class definitions after parsing has completed.
 * @returns {{}|*|classes}
 */

var getClasses = function getClasses() {
  return classes;
};

var setupToolTips = function setupToolTips(element) {
  var tooltipElem = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('.mermaidTooltip');

  if ((tooltipElem._groups || tooltipElem)[0][0] === null) {
    tooltipElem = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('body').append('div').attr('class', 'mermaidTooltip').style('opacity', 0);
  }

  var svg = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(element).select('svg');
  var nodes = svg.selectAll('g.node');
  nodes.on('mouseover', function () {
    var el = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(this);
    var title = el.attr('title'); // Dont try to draw a tooltip if no data is provided

    if (title === null) {
      return;
    }

    var rect = this.getBoundingClientRect();
    tooltipElem.transition().duration(200).style('opacity', '.9');
    tooltipElem.html(el.attr('title')).style('left', window.scrollX + rect.left + (rect.right - rect.left) / 2 + 'px').style('top', window.scrollY + rect.top - 14 + document.body.scrollTop + 'px');
    el.classed('hover', true);
  }).on('mouseout', function () {
    tooltipElem.transition().duration(500).style('opacity', 0);
    var el = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(this);
    el.classed('hover', false);
  });
};

funs.push(setupToolTips);
/**
 * Clears the internal graph db so that a new graph can be parsed.
 */

var clear = function clear(ver) {
  vertices = {};
  classes = {};
  edges = [];
  funs = [];
  funs.push(setupToolTips);
  subGraphs = [];
  subGraphLookup = {};
  subCount = 0;
  tooltips = [];
  firstGraphFlag = true;
  version = ver || 'gen-1';
};
var setGen = function setGen(ver) {
  version = ver || 'gen-1';
};
/**
 *
 * @returns {string}
 */

var defaultStyle = function defaultStyle() {
  return 'fill:#ffa;stroke: #f66; stroke-width: 3px; stroke-dasharray: 5, 5;fill:#ffa;stroke: #666;';
};
/**
 * Clears the internal graph db so that a new graph can be parsed.
 */

var addSubGraph = function addSubGraph(_id, list, _title) {
  // console.log('addSubGraph', _id, list, _title);
  var id = _id.trim();

  var title = _title;

  if (_id === _title && _title.match(/\s/)) {
    id = undefined;
  }

  function uniq(a) {
    var prims = {
      boolean: {},
      number: {},
      string: {}
    };
    var objs = [];
    var dir; //  = unbdefined; direction.trim();

    var nodeList = a.filter(function (item) {
      var type = _typeof(item);

      if (item.stmt && item.stmt === 'dir') {
        dir = item.value;
        return false;
      }

      if (item.trim() === '') {
        return false;
      }

      if (type in prims) {
        return prims[type].hasOwnProperty(item) ? false : prims[type][item] = true; // eslint-disable-line
      } else {
        return objs.indexOf(item) >= 0 ? false : objs.push(item);
      }
    });
    return {
      nodeList: nodeList,
      dir: dir
    };
  }

  var nodeList = [];

  var _uniq = uniq(nodeList.concat.apply(nodeList, list)),
      nl = _uniq.nodeList,
      dir = _uniq.dir;

  nodeList = nl;

  if (version === 'gen-1') {
    _logger__WEBPACK_IMPORTED_MODULE_5__["log"].warn('LOOKING UP');

    for (var i = 0; i < nodeList.length; i++) {
      nodeList[i] = lookUpDomId(nodeList[i]);
    }
  }

  id = id || 'subGraph' + subCount; // if (id[0].match(/\d/)) id = lookUpDomId(id);

  title = title || '';
  title = _common_common__WEBPACK_IMPORTED_MODULE_3__["default"].sanitizeText(title, config);
  subCount = subCount + 1;
  var subGraph = {
    id: id,
    nodes: nodeList,
    title: title.trim(),
    classes: [],
    dir: dir
  };
  _logger__WEBPACK_IMPORTED_MODULE_5__["log"].info('Adding', subGraph.id, subGraph.nodes, subGraph.dir);
  /**
   * Deletes an id from all subgraphs
   */
  // const del = _id => {
  //   subGraphs.forEach(sg => {
  //     const pos = sg.nodes.indexOf(_id);
  //     if (pos >= 0) {
  //       sg.nodes.splice(pos, 1);
  //     }
  //   });
  // };
  // // Removes the members of this subgraph from any other subgraphs, a node only belong to one subgraph
  // subGraph.nodes.forEach(_id => del(_id));
  // Remove the members in the new subgraph if they already belong to another subgraph

  subGraph.nodes = makeUniq(subGraph, subGraphs).nodes;
  subGraphs.push(subGraph);
  subGraphLookup[id] = subGraph;
  return id;
};

var getPosForId = function getPosForId(id) {
  for (var i = 0; i < subGraphs.length; i++) {
    if (subGraphs[i].id === id) {
      return i;
    }
  }

  return -1;
};

var secCount = -1;
var posCrossRef = [];

var indexNodes2 = function indexNodes2(id, pos) {
  var nodes = subGraphs[pos].nodes;
  secCount = secCount + 1;

  if (secCount > 2000) {
    return;
  }

  posCrossRef[secCount] = pos; // Check if match

  if (subGraphs[pos].id === id) {
    return {
      result: true,
      count: 0
    };
  }

  var count = 0;
  var posCount = 1;

  while (count < nodes.length) {
    var childPos = getPosForId(nodes[count]); // Ignore regular nodes (pos will be -1)

    if (childPos >= 0) {
      var res = indexNodes2(id, childPos);

      if (res.result) {
        return {
          result: true,
          count: posCount + res.count
        };
      } else {
        posCount = posCount + res.count;
      }
    }

    count = count + 1;
  }

  return {
    result: false,
    count: posCount
  };
};

var getDepthFirstPos = function getDepthFirstPos(pos) {
  return posCrossRef[pos];
};
var indexNodes = function indexNodes() {
  secCount = -1;

  if (subGraphs.length > 0) {
    indexNodes2('none', subGraphs.length - 1, 0);
  }
};
var getSubGraphs = function getSubGraphs() {
  return subGraphs;
};
var firstGraph = function firstGraph() {
  if (firstGraphFlag) {
    firstGraphFlag = false;
    return true;
  }

  return false;
};

var destructStartLink = function destructStartLink(_str) {
  var str = _str.trim();

  var type = 'arrow_open';

  switch (str[0]) {
    case '<':
      type = 'arrow_point';
      str = str.slice(1);
      break;

    case 'x':
      type = 'arrow_cross';
      str = str.slice(1);
      break;

    case 'o':
      type = 'arrow_circle';
      str = str.slice(1);
      break;
  }

  var stroke = 'normal';

  if (str.indexOf('=') !== -1) {
    stroke = 'thick';
  }

  if (str.indexOf('.') !== -1) {
    stroke = 'dotted';
  }

  return {
    type: type,
    stroke: stroke
  };
};

var countChar = function countChar(char, str) {
  var length = str.length;
  var count = 0;

  for (var i = 0; i < length; ++i) {
    if (str[i] === char) {
      ++count;
    }
  }

  return count;
};

var destructEndLink = function destructEndLink(_str) {
  var str = _str.trim();

  var line = str.slice(0, -1);
  var type = 'arrow_open';

  switch (str.slice(-1)) {
    case 'x':
      type = 'arrow_cross';

      if (str[0] === 'x') {
        type = 'double_' + type;
        line = line.slice(1);
      }

      break;

    case '>':
      type = 'arrow_point';

      if (str[0] === '<') {
        type = 'double_' + type;
        line = line.slice(1);
      }

      break;

    case 'o':
      type = 'arrow_circle';

      if (str[0] === 'o') {
        type = 'double_' + type;
        line = line.slice(1);
      }

      break;
  }

  var stroke = 'normal';
  var length = line.length - 1;

  if (line[0] === '=') {
    stroke = 'thick';
  }

  var dots = countChar('.', line);

  if (dots) {
    stroke = 'dotted';
    length = dots;
  }

  return {
    type: type,
    stroke: stroke,
    length: length
  };
};

var destructLink = function destructLink(_str, _startStr) {
  var info = destructEndLink(_str);
  var startInfo;

  if (_startStr) {
    startInfo = destructStartLink(_startStr);

    if (startInfo.stroke !== info.stroke) {
      return {
        type: 'INVALID',
        stroke: 'INVALID'
      };
    }

    if (startInfo.type === 'arrow_open') {
      // -- xyz -->  - take arrow type from ending
      startInfo.type = info.type;
    } else {
      // x-- xyz -->  - not supported
      if (startInfo.type !== info.type) return {
        type: 'INVALID',
        stroke: 'INVALID'
      };
      startInfo.type = 'double_' + startInfo.type;
    }

    if (startInfo.type === 'double_arrow') {
      startInfo.type = 'double_arrow_point';
    }

    startInfo.length = info.length;
    return startInfo;
  }

  return info;
}; // Todo optimizer this by caching existing nodes


var exists = function exists(allSgs, _id) {
  var res = false;
  allSgs.forEach(function (sg) {
    var pos = sg.nodes.indexOf(_id);

    if (pos >= 0) {
      res = true;
    }
  });
  return res;
};
/**
 * Deletes an id from all subgraphs
 */


var makeUniq = function makeUniq(sg, allSubgraphs) {
  var res = [];
  sg.nodes.forEach(function (_id, pos) {
    if (!exists(allSubgraphs, _id)) {
      res.push(sg.nodes[pos]);
    }
  });
  return {
    nodes: res
  };
};

/* harmony default export */ __webpack_exports__["default"] = ({
  parseDirective: parseDirective,
  defaultConfig: function defaultConfig() {
    return _config__WEBPACK_IMPORTED_MODULE_2__["defaultConfig"].flowchart;
  },
  addVertex: addVertex,
  lookUpDomId: lookUpDomId,
  addLink: addLink,
  updateLinkInterpolate: updateLinkInterpolate,
  updateLink: updateLink,
  addClass: addClass,
  setDirection: setDirection,
  setClass: setClass,
  setTooltip: setTooltip,
  getTooltip: getTooltip,
  setClickEvent: setClickEvent,
  setLink: setLink,
  bindFunctions: bindFunctions,
  getDirection: getDirection,
  getVertices: getVertices,
  getEdges: getEdges,
  getClasses: getClasses,
  clear: clear,
  setGen: setGen,
  defaultStyle: defaultStyle,
  addSubGraph: addSubGraph,
  getDepthFirstPos: getDepthFirstPos,
  indexNodes: indexNodes,
  getSubGraphs: getSubGraphs,
  destructLink: destructLink,
  lex: {
    firstGraph: firstGraph
  },
  exists: exists,
  makeUniq: makeUniq
});

/***/ }),

/***/ "./src/diagrams/flowchart/flowRenderer-v2.js":
/*!***************************************************!*\
  !*** ./src/diagrams/flowchart/flowRenderer-v2.js ***!
  \***************************************************/
/*! exports provided: setConf, addVertices, addEdges, getClasses, draw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConf", function() { return setConf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addVertices", function() { return addVertices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEdges", function() { return addEdges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getClasses", function() { return getClasses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return draw; });
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphlib */ "graphlib");
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(graphlib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _flowDb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flowDb */ "./src/diagrams/flowchart/flowDb.js");
/* harmony import */ var _parser_flow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parser/flow */ "./src/diagrams/flowchart/parser/flow.jison");
/* harmony import */ var _parser_flow__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_parser_flow__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/* harmony import */ var _dagre_wrapper_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../dagre-wrapper/index.js */ "./src/dagre-wrapper/index.js");
/* harmony import */ var dagre_d3_lib_label_add_html_label_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! dagre-d3/lib/label/add-html-label.js */ "dagre-d3/lib/label/add-html-label.js");
/* harmony import */ var dagre_d3_lib_label_add_html_label_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(dagre_d3_lib_label_add_html_label_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _common_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/common */ "./src/diagrams/common/common.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");










var conf = {};
var setConf = function setConf(cnf) {
  var keys = Object.keys(cnf);

  for (var i = 0; i < keys.length; i++) {
    conf[keys[i]] = cnf[keys[i]];
  }
};
/**
 * Function that adds the vertices found during parsing to the graph to be rendered.
 * @param vert Object containing the vertices.
 * @param g The graph that is to be drawn.
 */

var addVertices = function addVertices(vert, g, svgId) {
  var svg = Object(d3__WEBPACK_IMPORTED_MODULE_1__["select"])("[id=\"".concat(svgId, "\"]"));
  var keys = Object.keys(vert); // Iterate through each item in the vertex object (containing all the vertices found) in the graph definition

  keys.forEach(function (id) {
    var vertex = vert[id];
    /**
     * Variable for storing the classes for the vertex
     * @type {string}
     */

    var classStr = 'default';

    if (vertex.classes.length > 0) {
      classStr = vertex.classes.join(' ');
    }

    var styles = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["getStylesFromArray"])(vertex.styles); // Use vertex id as text in the box if no text is provided by the graph definition

    var vertexText = vertex.text !== undefined ? vertex.text : vertex.id; // We create a SVG label, either by delegating to addHtmlLabel or manually

    var vertexNode;

    if (Object(_common_common__WEBPACK_IMPORTED_MODULE_8__["evaluate"])(Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().flowchart.htmlLabels)) {
      // TODO: addHtmlLabel accepts a labelStyle. Do we possibly have that?
      var node = {
        label: vertexText.replace(/fa[lrsb]?:fa-[\w-]+/g, function (s) {
          return "<i class='".concat(s.replace(':', ' '), "'></i>");
        })
      };
      vertexNode = dagre_d3_lib_label_add_html_label_js__WEBPACK_IMPORTED_MODULE_6___default()(svg, node).node();
      vertexNode.parentNode.removeChild(vertexNode);
    } else {
      var svgLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      svgLabel.setAttribute('style', styles.labelStyle.replace('color:', 'fill:'));
      var rows = vertexText.split(_common_common__WEBPACK_IMPORTED_MODULE_8__["default"].lineBreakRegex);

      for (var j = 0; j < rows.length; j++) {
        var tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
        tspan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
        tspan.setAttribute('dy', '1em');
        tspan.setAttribute('x', '1');
        tspan.textContent = rows[j];
        svgLabel.appendChild(tspan);
      }

      vertexNode = svgLabel;
    }

    var radious = 0;
    var _shape = ''; // Set the shape based parameters

    switch (vertex.type) {
      case 'round':
        radious = 5;
        _shape = 'rect';
        break;

      case 'square':
        _shape = 'rect';
        break;

      case 'diamond':
        _shape = 'question';
        break;

      case 'hexagon':
        _shape = 'hexagon';
        break;

      case 'odd':
        _shape = 'rect_left_inv_arrow';
        break;

      case 'lean_right':
        _shape = 'lean_right';
        break;

      case 'lean_left':
        _shape = 'lean_left';
        break;

      case 'trapezoid':
        _shape = 'trapezoid';
        break;

      case 'inv_trapezoid':
        _shape = 'inv_trapezoid';
        break;

      case 'odd_right':
        _shape = 'rect_left_inv_arrow';
        break;

      case 'circle':
        _shape = 'circle';
        break;

      case 'ellipse':
        _shape = 'ellipse';
        break;

      case 'stadium':
        _shape = 'stadium';
        break;

      case 'subroutine':
        _shape = 'subroutine';
        break;

      case 'cylinder':
        _shape = 'cylinder';
        break;

      case 'group':
        _shape = 'rect';
        break;

      default:
        _shape = 'rect';
    } // Add the node


    g.setNode(vertex.id, {
      labelStyle: styles.labelStyle,
      shape: _shape,
      labelText: vertexText,
      rx: radious,
      ry: radious,
      class: classStr,
      style: styles.style,
      id: vertex.id,
      link: vertex.link,
      linkTarget: vertex.linkTarget,
      tooltip: _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].getTooltip(vertex.id) || '',
      domId: _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].lookUpDomId(vertex.id),
      haveCallback: vertex.haveCallback,
      width: vertex.type === 'group' ? 500 : undefined,
      dir: vertex.dir,
      type: vertex.type,
      padding: Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().flowchart.padding
    });
    _logger__WEBPACK_IMPORTED_MODULE_7__["log"].info('setNode', {
      labelStyle: styles.labelStyle,
      shape: _shape,
      labelText: vertexText,
      rx: radious,
      ry: radious,
      class: classStr,
      style: styles.style,
      id: vertex.id,
      domId: _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].lookUpDomId(vertex.id),
      width: vertex.type === 'group' ? 500 : undefined,
      type: vertex.type,
      dir: vertex.dir,
      padding: Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().flowchart.padding
    });
  });
};
/**
 * Add edges to graph based on parsed graph defninition
 * @param {Object} edges The edges to add to the graph
 * @param {Object} g The graph object
 */

var addEdges = function addEdges(edges, g) {
  _logger__WEBPACK_IMPORTED_MODULE_7__["log"].info('abc78 edges = ', edges);
  var cnt = 0;
  var linkIdCnt = {};
  var defaultStyle;
  var defaultLabelStyle;

  if (typeof edges.defaultStyle !== 'undefined') {
    var defaultStyles = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["getStylesFromArray"])(edges.defaultStyle);
    defaultStyle = defaultStyles.style;
    defaultLabelStyle = defaultStyles.labelStyle;
  }

  edges.forEach(function (edge) {
    cnt++; // Identify Link

    var linkIdBase = 'L-' + edge.start + '-' + edge.end; // count the links from+to the same node to give unique id

    if (typeof linkIdCnt[linkIdBase] === 'undefined') {
      linkIdCnt[linkIdBase] = 0;
      _logger__WEBPACK_IMPORTED_MODULE_7__["log"].info('abc78 new entry', linkIdBase, linkIdCnt[linkIdBase]);
    } else {
      linkIdCnt[linkIdBase]++;
      _logger__WEBPACK_IMPORTED_MODULE_7__["log"].info('abc78 new entry', linkIdBase, linkIdCnt[linkIdBase]);
    }

    var linkId = linkIdBase + '-' + linkIdCnt[linkIdBase];
    _logger__WEBPACK_IMPORTED_MODULE_7__["log"].info('abc78 new link id to be used is', linkIdBase, linkId, linkIdCnt[linkIdBase]);
    var linkNameStart = 'LS-' + edge.start;
    var linkNameEnd = 'LE-' + edge.end;
    var edgeData = {
      style: '',
      labelStyle: ''
    };
    edgeData.minlen = edge.length || 1; //edgeData.id = 'id' + cnt;
    // Set link type for rendering

    if (edge.type === 'arrow_open') {
      edgeData.arrowhead = 'none';
    } else {
      edgeData.arrowhead = 'normal';
    } // Check of arrow types, placed here in order not to break old rendering


    edgeData.arrowTypeStart = 'arrow_open';
    edgeData.arrowTypeEnd = 'arrow_open';
    /* eslint-disable no-fallthrough */

    switch (edge.type) {
      case 'double_arrow_cross':
        edgeData.arrowTypeStart = 'arrow_cross';

      case 'arrow_cross':
        edgeData.arrowTypeEnd = 'arrow_cross';
        break;

      case 'double_arrow_point':
        edgeData.arrowTypeStart = 'arrow_point';

      case 'arrow_point':
        edgeData.arrowTypeEnd = 'arrow_point';
        break;

      case 'double_arrow_circle':
        edgeData.arrowTypeStart = 'arrow_circle';

      case 'arrow_circle':
        edgeData.arrowTypeEnd = 'arrow_circle';
        break;
    }

    var style = '';
    var labelStyle = '';

    switch (edge.stroke) {
      case 'normal':
        style = 'fill:none;';

        if (typeof defaultStyle !== 'undefined') {
          style = defaultStyle;
        }

        if (typeof defaultLabelStyle !== 'undefined') {
          labelStyle = defaultLabelStyle;
        }

        edgeData.thickness = 'normal';
        edgeData.pattern = 'solid';
        break;

      case 'dotted':
        edgeData.thickness = 'normal';
        edgeData.pattern = 'dotted';
        edgeData.style = 'fill:none;stroke-width:2px;stroke-dasharray:3;';
        break;

      case 'thick':
        edgeData.thickness = 'thick';
        edgeData.pattern = 'solid';
        edgeData.style = 'stroke-width: 3.5px;fill:none;';
        break;
    }

    if (typeof edge.style !== 'undefined') {
      var styles = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["getStylesFromArray"])(edge.style);
      style = styles.style;
      labelStyle = styles.labelStyle;
    }

    edgeData.style = edgeData.style += style;
    edgeData.labelStyle = edgeData.labelStyle += labelStyle;

    if (typeof edge.interpolate !== 'undefined') {
      edgeData.curve = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["interpolateToCurve"])(edge.interpolate, d3__WEBPACK_IMPORTED_MODULE_1__["curveLinear"]);
    } else if (typeof edges.defaultInterpolate !== 'undefined') {
      edgeData.curve = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["interpolateToCurve"])(edges.defaultInterpolate, d3__WEBPACK_IMPORTED_MODULE_1__["curveLinear"]);
    } else {
      edgeData.curve = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["interpolateToCurve"])(conf.curve, d3__WEBPACK_IMPORTED_MODULE_1__["curveLinear"]);
    }

    if (typeof edge.text === 'undefined') {
      if (typeof edge.style !== 'undefined') {
        edgeData.arrowheadStyle = 'fill: #333';
      }
    } else {
      edgeData.arrowheadStyle = 'fill: #333';
      edgeData.labelpos = 'c';
    } // if (evaluate(getConfig().flowchart.htmlLabels) && false) {
    //   // eslint-disable-line
    //   edgeData.labelType = 'html';
    //   edgeData.label = `<span id="L-${linkId}" class="edgeLabel L-${linkNameStart}' L-${linkNameEnd}">${edge.text}</span>`;
    // } else {


    edgeData.labelType = 'text';
    edgeData.label = edge.text.replace(_common_common__WEBPACK_IMPORTED_MODULE_8__["default"].lineBreakRegex, '\n');

    if (typeof edge.style === 'undefined') {
      edgeData.style = edgeData.style || 'stroke: #333; stroke-width: 1.5px;fill:none;';
    }

    edgeData.labelStyle = edgeData.labelStyle.replace('color:', 'fill:'); // }

    edgeData.id = linkId;
    edgeData.classes = 'flowchart-link ' + linkNameStart + ' ' + linkNameEnd; // Add the edge to the graph

    g.setEdge(edge.start, edge.end, edgeData, cnt);
  });
};
/**
 * Returns the all the styles from classDef statements in the graph definition.
 * @returns {object} classDef styles
 */

var getClasses = function getClasses(text) {
  _logger__WEBPACK_IMPORTED_MODULE_7__["log"].info('Extracting classes');
  _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].clear();
  var parser = _parser_flow__WEBPACK_IMPORTED_MODULE_3___default.a.parser;
  parser.yy = _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"];

  try {
    // Parse the graph definition
    parser.parse(text);
  } catch (e) {
    return;
  }

  return _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].getClasses();
};
/**
 * Draws a flowchart in the tag with id: id based on the graph definition in text.
 * @param text
 * @param id
 */

var draw = function draw(text, id) {
  _logger__WEBPACK_IMPORTED_MODULE_7__["log"].info('Drawing flowchart');
  _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].clear();
  _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].setGen('gen-2');
  var parser = _parser_flow__WEBPACK_IMPORTED_MODULE_3___default.a.parser;
  parser.yy = _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"]; // Parse the graph definition
  // try {

  parser.parse(text); // } catch (err) {
  // log.debug('Parsing failed');
  // }
  // Fetch the default direction, use TD if none was found

  var dir = _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].getDirection();

  if (typeof dir === 'undefined') {
    dir = 'TD';
  }

  var conf = Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().flowchart;
  var nodeSpacing = conf.nodeSpacing || 50;
  var rankSpacing = conf.rankSpacing || 50; // Create the input mermaid.graph

  var g = new graphlib__WEBPACK_IMPORTED_MODULE_0___default.a.Graph({
    multigraph: true,
    compound: true
  }).setGraph({
    rankdir: dir,
    nodesep: nodeSpacing,
    ranksep: rankSpacing,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function () {
    return {};
  });
  var subG;
  var subGraphs = _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].getSubGraphs();
  _logger__WEBPACK_IMPORTED_MODULE_7__["log"].info('Subgraphs - ', subGraphs);

  for (var _i = subGraphs.length - 1; _i >= 0; _i--) {
    subG = subGraphs[_i];
    _logger__WEBPACK_IMPORTED_MODULE_7__["log"].info('Subgraph - ', subG);
    _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].addVertex(subG.id, subG.title, 'group', undefined, subG.classes, subG.dir);
  } // Fetch the verices/nodes and edges/links from the parsed graph definition


  var vert = _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].getVertices();
  var edges = _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].getEdges();
  _logger__WEBPACK_IMPORTED_MODULE_7__["log"].info(edges);
  var i = 0;

  for (i = subGraphs.length - 1; i >= 0; i--) {
    // for (let i = 0; i < subGraphs.length; i++) {
    subG = subGraphs[i];
    Object(d3__WEBPACK_IMPORTED_MODULE_1__["selectAll"])('cluster').append('text');

    for (var j = 0; j < subG.nodes.length; j++) {
      _logger__WEBPACK_IMPORTED_MODULE_7__["log"].info('Setting up subgraphs', subG.nodes[j], subG.id);
      g.setParent(subG.nodes[j], subG.id);
    }
  }

  addVertices(vert, g, id);
  addEdges(edges, g); // Add custom shapes
  // flowChartShapes.addToRenderV2(addShape);
  // Set up an SVG group so that we can translate the final graph.

  var svg = Object(d3__WEBPACK_IMPORTED_MODULE_1__["select"])("[id=\"".concat(id, "\"]"));
  svg.attr('xmlns:xlink', 'http://www.w3.org/1999/xlink'); // Run the renderer. This is what draws the final graph.

  var element = Object(d3__WEBPACK_IMPORTED_MODULE_1__["select"])('#' + id + ' g');
  Object(_dagre_wrapper_index_js__WEBPACK_IMPORTED_MODULE_5__["render"])(element, g, ['point', 'circle', 'cross'], 'flowchart', id);
  var padding = conf.diagramPadding;
  var svgBounds = svg.node().getBBox();
  var width = svgBounds.width + padding * 2;
  var height = svgBounds.height + padding * 2;
  _logger__WEBPACK_IMPORTED_MODULE_7__["log"].debug("new ViewBox 0 0 ".concat(width, " ").concat(height), "translate(".concat(padding - g._label.marginx, ", ").concat(padding - g._label.marginy, ")"));
  Object(_utils__WEBPACK_IMPORTED_MODULE_9__["configureSvgSize"])(svg, height, width, conf.useMaxWidth);
  svg.attr('viewBox', "0 0 ".concat(width, " ").concat(height));
  svg.select('g').attr('transform', "translate(".concat(padding - g._label.marginx, ", ").concat(padding - svgBounds.y, ")")); // Index nodes

  _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].indexNodes('subGraph' + i); // Add label rects for non html labels

  if (!conf.htmlLabels) {
    var labels = document.querySelectorAll('[id="' + id + '"] .edgeLabel .label');

    for (var k = 0; k < labels.length; k++) {
      var label = labels[k]; // Get dimensions of label

      var dim = label.getBBox();
      var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.setAttribute('rx', 0);
      rect.setAttribute('ry', 0);
      rect.setAttribute('width', dim.width);
      rect.setAttribute('height', dim.height); // rect.setAttribute('style', 'fill:#e8e8e8;');

      label.insertBefore(rect, label.firstChild);
    }
  } // If node has a link, wrap it in an anchor SVG object.


  var keys = Object.keys(vert);
  keys.forEach(function (key) {
    var vertex = vert[key];

    if (vertex.link) {
      var node = Object(d3__WEBPACK_IMPORTED_MODULE_1__["select"])('#' + id + ' [id="' + key + '"]');

      if (node) {
        var link = document.createElementNS('http://www.w3.org/2000/svg', 'a');
        link.setAttributeNS('http://www.w3.org/2000/svg', 'class', vertex.classes.join(' '));
        link.setAttributeNS('http://www.w3.org/2000/svg', 'href', vertex.link);
        link.setAttributeNS('http://www.w3.org/2000/svg', 'rel', 'noopener');

        if (vertex.linkTarget) {
          link.setAttributeNS('http://www.w3.org/2000/svg', 'target', vertex.linkTarget);
        }

        var linkNode = node.insert(function () {
          return link;
        }, ':first-child');
        var shape = node.select('.label-container');

        if (shape) {
          linkNode.append(function () {
            return shape.node();
          });
        }

        var _label = node.select('.label');

        if (_label) {
          linkNode.append(function () {
            return _label.node();
          });
        }
      }
    }
  });
};
/* harmony default export */ __webpack_exports__["default"] = ({
  setConf: setConf,
  addVertices: addVertices,
  addEdges: addEdges,
  getClasses: getClasses,
  draw: draw
});

/***/ }),

/***/ "./src/diagrams/flowchart/flowRenderer.js":
/*!************************************************!*\
  !*** ./src/diagrams/flowchart/flowRenderer.js ***!
  \************************************************/
/*! exports provided: setConf, addVertices, addEdges, getClasses, draw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConf", function() { return setConf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addVertices", function() { return addVertices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEdges", function() { return addEdges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getClasses", function() { return getClasses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return draw; });
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphlib */ "graphlib");
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(graphlib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _flowDb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flowDb */ "./src/diagrams/flowchart/flowDb.js");
/* harmony import */ var _parser_flow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parser/flow */ "./src/diagrams/flowchart/parser/flow.jison");
/* harmony import */ var _parser_flow__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_parser_flow__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/* harmony import */ var dagre_d3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! dagre-d3 */ "dagre-d3");
/* harmony import */ var dagre_d3__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(dagre_d3__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var dagre_d3_lib_label_add_html_label_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! dagre-d3/lib/label/add-html-label.js */ "dagre-d3/lib/label/add-html-label.js");
/* harmony import */ var dagre_d3_lib_label_add_html_label_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(dagre_d3_lib_label_add_html_label_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _common_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/common */ "./src/diagrams/common/common.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");
/* harmony import */ var _flowChartShapes__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./flowChartShapes */ "./src/diagrams/flowchart/flowChartShapes.js");











var conf = {};
var setConf = function setConf(cnf) {
  var keys = Object.keys(cnf);

  for (var i = 0; i < keys.length; i++) {
    conf[keys[i]] = cnf[keys[i]];
  }
};
/**
 * Function that adds the vertices found in the graph definition to the graph to be rendered.
 * @param vert Object containing the vertices.
 * @param g The graph that is to be drawn.
 */

var addVertices = function addVertices(vert, g, svgId) {
  var svg = Object(d3__WEBPACK_IMPORTED_MODULE_1__["select"])("[id=\"".concat(svgId, "\"]"));
  var keys = Object.keys(vert); // Iterate through each item in the vertex object (containing all the vertices found) in the graph definition

  keys.forEach(function (id) {
    var vertex = vert[id];
    /**
     * Variable for storing the classes for the vertex
     * @type {string}
     */

    var classStr = 'default';

    if (vertex.classes.length > 0) {
      classStr = vertex.classes.join(' ');
    }

    var styles = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["getStylesFromArray"])(vertex.styles); // Use vertex id as text in the box if no text is provided by the graph definition

    var vertexText = vertex.text !== undefined ? vertex.text : vertex.id; // We create a SVG label, either by delegating to addHtmlLabel or manually

    var vertexNode;

    if (Object(_common_common__WEBPACK_IMPORTED_MODULE_8__["evaluate"])(Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().flowchart.htmlLabels)) {
      // TODO: addHtmlLabel accepts a labelStyle. Do we possibly have that?
      var node = {
        label: vertexText.replace(/fa[lrsb]?:fa-[\w-]+/g, function (s) {
          return "<i class='".concat(s.replace(':', ' '), "'></i>");
        })
      };
      vertexNode = dagre_d3_lib_label_add_html_label_js__WEBPACK_IMPORTED_MODULE_6___default()(svg, node).node();
      vertexNode.parentNode.removeChild(vertexNode);
    } else {
      var svgLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      svgLabel.setAttribute('style', styles.labelStyle.replace('color:', 'fill:'));
      var rows = vertexText.split(_common_common__WEBPACK_IMPORTED_MODULE_8__["default"].lineBreakRegex);

      for (var j = 0; j < rows.length; j++) {
        var tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
        tspan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
        tspan.setAttribute('dy', '1em');
        tspan.setAttribute('x', '1');
        tspan.textContent = rows[j];
        svgLabel.appendChild(tspan);
      }

      vertexNode = svgLabel;
    }

    var radious = 0;
    var _shape = ''; // Set the shape based parameters

    switch (vertex.type) {
      case 'round':
        radious = 5;
        _shape = 'rect';
        break;

      case 'square':
        _shape = 'rect';
        break;

      case 'diamond':
        _shape = 'question';
        break;

      case 'hexagon':
        _shape = 'hexagon';
        break;

      case 'odd':
        _shape = 'rect_left_inv_arrow';
        break;

      case 'lean_right':
        _shape = 'lean_right';
        break;

      case 'lean_left':
        _shape = 'lean_left';
        break;

      case 'trapezoid':
        _shape = 'trapezoid';
        break;

      case 'inv_trapezoid':
        _shape = 'inv_trapezoid';
        break;

      case 'odd_right':
        _shape = 'rect_left_inv_arrow';
        break;

      case 'circle':
        _shape = 'circle';
        break;

      case 'ellipse':
        _shape = 'ellipse';
        break;

      case 'stadium':
        _shape = 'stadium';
        break;

      case 'subroutine':
        _shape = 'subroutine';
        break;

      case 'cylinder':
        _shape = 'cylinder';
        break;

      case 'group':
        _shape = 'rect';
        break;

      default:
        _shape = 'rect';
    } // Add the node


    _logger__WEBPACK_IMPORTED_MODULE_7__["log"].warn('Adding node', vertex.id, vertex.domId);
    g.setNode(_flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].lookUpDomId(vertex.id), {
      labelType: 'svg',
      labelStyle: styles.labelStyle,
      shape: _shape,
      label: vertexNode,
      rx: radious,
      ry: radious,
      class: classStr,
      style: styles.style,
      id: _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].lookUpDomId(vertex.id)
    });
  });
};
/**
 * Add edges to graph based on parsed graph defninition
 * @param {Object} edges The edges to add to the graph
 * @param {Object} g The graph object
 */

var addEdges = function addEdges(edges, g) {
  var cnt = 0;
  var defaultStyle;
  var defaultLabelStyle;

  if (typeof edges.defaultStyle !== 'undefined') {
    var defaultStyles = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["getStylesFromArray"])(edges.defaultStyle);
    defaultStyle = defaultStyles.style;
    defaultLabelStyle = defaultStyles.labelStyle;
  }

  edges.forEach(function (edge) {
    cnt++; // Identify Link

    var linkId = 'L-' + edge.start + '-' + edge.end;
    var linkNameStart = 'LS-' + edge.start;
    var linkNameEnd = 'LE-' + edge.end;
    var edgeData = {}; // Set link type for rendering

    if (edge.type === 'arrow_open') {
      edgeData.arrowhead = 'none';
    } else {
      edgeData.arrowhead = 'normal';
    }

    var style = '';
    var labelStyle = '';

    if (typeof edge.style !== 'undefined') {
      var styles = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["getStylesFromArray"])(edge.style);
      style = styles.style;
      labelStyle = styles.labelStyle;
    } else {
      switch (edge.stroke) {
        case 'normal':
          style = 'fill:none';

          if (typeof defaultStyle !== 'undefined') {
            style = defaultStyle;
          }

          if (typeof defaultLabelStyle !== 'undefined') {
            labelStyle = defaultLabelStyle;
          }

          break;

        case 'dotted':
          style = 'fill:none;stroke-width:2px;stroke-dasharray:3;';
          break;

        case 'thick':
          style = ' stroke-width: 3.5px;fill:none';
          break;
      }
    }

    edgeData.style = style;
    edgeData.labelStyle = labelStyle;

    if (typeof edge.interpolate !== 'undefined') {
      edgeData.curve = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["interpolateToCurve"])(edge.interpolate, d3__WEBPACK_IMPORTED_MODULE_1__["curveLinear"]);
    } else if (typeof edges.defaultInterpolate !== 'undefined') {
      edgeData.curve = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["interpolateToCurve"])(edges.defaultInterpolate, d3__WEBPACK_IMPORTED_MODULE_1__["curveLinear"]);
    } else {
      edgeData.curve = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["interpolateToCurve"])(conf.curve, d3__WEBPACK_IMPORTED_MODULE_1__["curveLinear"]);
    }

    if (typeof edge.text === 'undefined') {
      if (typeof edge.style !== 'undefined') {
        edgeData.arrowheadStyle = 'fill: #333';
      }
    } else {
      edgeData.arrowheadStyle = 'fill: #333';
      edgeData.labelpos = 'c';

      if (Object(_common_common__WEBPACK_IMPORTED_MODULE_8__["evaluate"])(Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().flowchart.htmlLabels)) {
        edgeData.labelType = 'html';
        edgeData.label = "<span id=\"L-".concat(linkId, "\" class=\"edgeLabel L-").concat(linkNameStart, "' L-").concat(linkNameEnd, "\">").concat(edge.text.replace(/fa[lrsb]?:fa-[\w-]+/g, function (s) {
          return "<i class='".concat(s.replace(':', ' '), "'></i>");
        }), "</span>");
      } else {
        edgeData.labelType = 'text';
        edgeData.label = edge.text.replace(_common_common__WEBPACK_IMPORTED_MODULE_8__["default"].lineBreakRegex, '\n');

        if (typeof edge.style === 'undefined') {
          edgeData.style = edgeData.style || 'stroke: #333; stroke-width: 1.5px;fill:none';
        }

        edgeData.labelStyle = edgeData.labelStyle.replace('color:', 'fill:');
      }
    }

    edgeData.id = linkId;
    edgeData.class = linkNameStart + ' ' + linkNameEnd;
    edgeData.minlen = edge.length || 1; // Add the edge to the graph

    g.setEdge(_flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].lookUpDomId(edge.start), _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].lookUpDomId(edge.end), edgeData, cnt);
  });
};
/**
 * Returns the all the styles from classDef statements in the graph definition.
 * @returns {object} classDef styles
 */

var getClasses = function getClasses(text) {
  _logger__WEBPACK_IMPORTED_MODULE_7__["log"].info('Extracting classes');
  _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].clear();

  try {
    var parser = _parser_flow__WEBPACK_IMPORTED_MODULE_3___default.a.parser;
    parser.yy = _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"]; // Parse the graph definition

    parser.parse(text);
    return _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].getClasses();
  } catch (e) {
    return;
  }
};
/**
 * Draws a flowchart in the tag with id: id based on the graph definition in text.
 * @param text
 * @param id
 */

var draw = function draw(text, id) {
  _logger__WEBPACK_IMPORTED_MODULE_7__["log"].info('Drawing flowchart');
  _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].clear();
  _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].setGen('gen-1');
  var parser = _parser_flow__WEBPACK_IMPORTED_MODULE_3___default.a.parser;
  parser.yy = _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"]; // Parse the graph definition
  // try {

  parser.parse(text); // } catch (err) {
  // log.debug('Parsing failed');
  // }
  // Fetch the default direction, use TD if none was found

  var dir = _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].getDirection();

  if (typeof dir === 'undefined') {
    dir = 'TD';
  }

  var conf = Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().flowchart;
  var nodeSpacing = conf.nodeSpacing || 50;
  var rankSpacing = conf.rankSpacing || 50; // Create the input mermaid.graph

  var g = new graphlib__WEBPACK_IMPORTED_MODULE_0___default.a.Graph({
    multigraph: true,
    compound: true
  }).setGraph({
    rankdir: dir,
    nodesep: nodeSpacing,
    ranksep: rankSpacing,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function () {
    return {};
  });
  var subG;
  var subGraphs = _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].getSubGraphs();

  for (var _i = subGraphs.length - 1; _i >= 0; _i--) {
    subG = subGraphs[_i];
    _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].addVertex(subG.id, subG.title, 'group', undefined, subG.classes);
  } // Fetch the verices/nodes and edges/links from the parsed graph definition


  var vert = _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].getVertices();
  _logger__WEBPACK_IMPORTED_MODULE_7__["log"].warn('Get vertices', vert);
  var edges = _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].getEdges();
  var i = 0;

  for (i = subGraphs.length - 1; i >= 0; i--) {
    subG = subGraphs[i];
    Object(d3__WEBPACK_IMPORTED_MODULE_1__["selectAll"])('cluster').append('text');

    for (var j = 0; j < subG.nodes.length; j++) {
      _logger__WEBPACK_IMPORTED_MODULE_7__["log"].warn('Setting subgraph', subG.nodes[j], _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].lookUpDomId(subG.nodes[j]), _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].lookUpDomId(subG.id));
      g.setParent(_flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].lookUpDomId(subG.nodes[j]), _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].lookUpDomId(subG.id));
    }
  }

  addVertices(vert, g, id);
  addEdges(edges, g); // Create the renderer

  var Render = dagre_d3__WEBPACK_IMPORTED_MODULE_5___default.a.render;
  var render = new Render(); // Add custom shapes

  _flowChartShapes__WEBPACK_IMPORTED_MODULE_10__["default"].addToRender(render); // Add our custom arrow - an empty arrowhead

  render.arrows().none = function normal(parent, id, edge, type) {
    var marker = parent.append('marker').attr('id', id).attr('viewBox', '0 0 10 10').attr('refX', 9).attr('refY', 5).attr('markerUnits', 'strokeWidth').attr('markerWidth', 8).attr('markerHeight', 6).attr('orient', 'auto');
    var path = marker.append('path').attr('d', 'M 0 0 L 0 0 L 0 0 z');
    dagre_d3__WEBPACK_IMPORTED_MODULE_5___default.a.util.applyStyle(path, edge[type + 'Style']);
  }; // Override normal arrowhead defined in d3. Remove style & add class to allow css styling.


  render.arrows().normal = function normal(parent, id) {
    var marker = parent.append('marker').attr('id', id).attr('viewBox', '0 0 10 10').attr('refX', 9).attr('refY', 5).attr('markerUnits', 'strokeWidth').attr('markerWidth', 8).attr('markerHeight', 6).attr('orient', 'auto');
    marker.append('path').attr('d', 'M 0 0 L 10 5 L 0 10 z').attr('class', 'arrowheadPath').style('stroke-width', 1).style('stroke-dasharray', '1,0');
  }; // Set up an SVG group so that we can translate the final graph.


  var svg = Object(d3__WEBPACK_IMPORTED_MODULE_1__["select"])("[id=\"".concat(id, "\"]"));
  svg.attr('xmlns:xlink', 'http://www.w3.org/1999/xlink');
  _logger__WEBPACK_IMPORTED_MODULE_7__["log"].warn(g); // Run the renderer. This is what draws the final graph.

  var element = Object(d3__WEBPACK_IMPORTED_MODULE_1__["select"])('#' + id + ' g');
  render(element, g);
  element.selectAll('g.node').attr('title', function () {
    return _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].getTooltip(this.id);
  });
  var padding = conf.diagramPadding;
  var svgBounds = svg.node().getBBox();
  var width = svgBounds.width + padding * 2;
  var height = svgBounds.height + padding * 2;
  Object(_utils__WEBPACK_IMPORTED_MODULE_9__["configureSvgSize"])(svg, height, width, conf.useMaxWidth); // Ensure the viewBox includes the whole svgBounds area with extra space for padding

  var vBox = "".concat(svgBounds.x - padding, " ").concat(svgBounds.y - padding, " ").concat(width, " ").concat(height);
  _logger__WEBPACK_IMPORTED_MODULE_7__["log"].debug("viewBox ".concat(vBox));
  svg.attr('viewBox', vBox); // Index nodes

  _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].indexNodes('subGraph' + i); // reposition labels

  for (i = 0; i < subGraphs.length; i++) {
    subG = subGraphs[i];

    if (subG.title !== 'undefined') {
      var clusterRects = document.querySelectorAll('#' + id + ' [id="' + _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].lookUpDomId(subG.id) + '"] rect');
      var clusterEl = document.querySelectorAll('#' + id + ' [id="' + _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].lookUpDomId(subG.id) + '"]');
      var xPos = clusterRects[0].x.baseVal.value;
      var yPos = clusterRects[0].y.baseVal.value;
      var _width = clusterRects[0].width.baseVal.value;
      var cluster = Object(d3__WEBPACK_IMPORTED_MODULE_1__["select"])(clusterEl[0]);
      var te = cluster.select('.label');
      te.attr('transform', "translate(".concat(xPos + _width / 2, ", ").concat(yPos + 14, ")"));
      te.attr('id', id + 'Text');

      for (var _j = 0; _j < subG.classes.length; _j++) {
        clusterEl[0].classList.add(subG.classes[_j]);
      }
    }
  } // Add label rects for non html labels


  if (!Object(_common_common__WEBPACK_IMPORTED_MODULE_8__["evaluate"])(conf.htmlLabels) || true) {
    // eslint-disable-line
    var labels = document.querySelectorAll('[id="' + id + '"] .edgeLabel .label');

    for (var k = 0; k < labels.length; k++) {
      var label = labels[k]; // Get dimensions of label

      var dim = label.getBBox();
      var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.setAttribute('rx', 0);
      rect.setAttribute('ry', 0);
      rect.setAttribute('width', dim.width);
      rect.setAttribute('height', dim.height); // rect.setAttribute('style', 'fill:#e8e8e8;');

      label.insertBefore(rect, label.firstChild);
    }
  } // If node has a link, wrap it in an anchor SVG object.


  var keys = Object.keys(vert);
  keys.forEach(function (key) {
    var vertex = vert[key];

    if (vertex.link) {
      var node = Object(d3__WEBPACK_IMPORTED_MODULE_1__["select"])('#' + id + ' [id="' + _flowDb__WEBPACK_IMPORTED_MODULE_2__["default"].lookUpDomId(key) + '"]');

      if (node) {
        var link = document.createElementNS('http://www.w3.org/2000/svg', 'a');
        link.setAttributeNS('http://www.w3.org/2000/svg', 'class', vertex.classes.join(' '));
        link.setAttributeNS('http://www.w3.org/2000/svg', 'href', vertex.link);
        link.setAttributeNS('http://www.w3.org/2000/svg', 'rel', 'noopener');

        if (vertex.linkTarget) {
          link.setAttributeNS('http://www.w3.org/2000/svg', 'target', vertex.linkTarget);
        }

        var linkNode = node.insert(function () {
          return link;
        }, ':first-child');
        var shape = node.select('.label-container');

        if (shape) {
          linkNode.append(function () {
            return shape.node();
          });
        }

        var _label = node.select('.label');

        if (_label) {
          linkNode.append(function () {
            return _label.node();
          });
        }
      }
    }
  });
};
/* harmony default export */ __webpack_exports__["default"] = ({
  setConf: setConf,
  addVertices: addVertices,
  addEdges: addEdges,
  getClasses: getClasses,
  draw: draw
});

/***/ }),

/***/ "./src/diagrams/flowchart/parser/flow.jison":
/*!**************************************************!*\
  !*** ./src/diagrams/flowchart/parser/flow.jison ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, module) {/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,9],$V1=[1,7],$V2=[1,6],$V3=[1,8],$V4=[1,20,21,22,23,38,47,76,77,78,79,80,81,95,96,99,100,101,103,104,110,111,112,113,114,115,116,117,118,119],$V5=[2,10],$V6=[1,20],$V7=[1,21],$V8=[1,22],$V9=[1,23],$Va=[1,30],$Vb=[1,59],$Vc=[1,33],$Vd=[1,34],$Ve=[1,35],$Vf=[1,36],$Vg=[1,37],$Vh=[1,53],$Vi=[1,48],$Vj=[1,50],$Vk=[1,45],$Vl=[1,49],$Vm=[1,52],$Vn=[1,56],$Vo=[1,57],$Vp=[1,38],$Vq=[1,39],$Vr=[1,40],$Vs=[1,41],$Vt=[1,58],$Vu=[1,47],$Vv=[1,51],$Vw=[1,54],$Vx=[1,55],$Vy=[1,46],$Vz=[1,62],$VA=[1,67],$VB=[1,20,21,22,23,38,42,47,76,77,78,79,80,81,95,96,99,100,101,103,104,110,111,112,113,114,115,116,117,118,119],$VC=[1,71],$VD=[1,70],$VE=[1,72],$VF=[20,21,23,70,71],$VG=[1,93],$VH=[1,98],$VI=[1,95],$VJ=[1,100],$VK=[1,103],$VL=[1,101],$VM=[1,102],$VN=[1,96],$VO=[1,108],$VP=[1,107],$VQ=[1,97],$VR=[1,99],$VS=[1,104],$VT=[1,105],$VU=[1,106],$VV=[1,109],$VW=[20,21,22,23,70,71],$VX=[20,21,22,23,48,70,71],$VY=[20,21,22,23,40,47,48,50,52,54,56,58,60,62,63,65,70,71,81,95,96,99,100,101,103,104,114,115,116,117,118,119],$VZ=[20,21,23],$V_=[20,21,23,47,70,71,81,95,96,99,100,101,103,104,114,115,116,117,118,119],$V$=[1,12,20,21,22,23,24,38,42,47,76,77,78,79,80,81,95,96,99,100,101,103,104,110,111,112,113,114,115,116,117,118,119],$V01=[47,81,95,96,99,100,101,103,104,114,115,116,117,118,119],$V11=[1,141],$V21=[1,149],$V31=[1,150],$V41=[1,151],$V51=[1,152],$V61=[1,136],$V71=[1,137],$V81=[1,133],$V91=[1,144],$Va1=[1,145],$Vb1=[1,146],$Vc1=[1,147],$Vd1=[1,148],$Ve1=[1,153],$Vf1=[1,154],$Vg1=[1,139],$Vh1=[1,142],$Vi1=[1,138],$Vj1=[1,135],$Vk1=[20,21,22,23,38,42,47,76,77,78,79,80,81,95,96,99,100,101,103,104,110,111,112,113,114,115,116,117,118,119],$Vl1=[1,157],$Vm1=[20,21,22,23,26,47,81,95,96,99,100,101,103,104,114,115,116,117,118,119],$Vn1=[20,21,22,23,24,26,38,40,41,42,47,51,53,55,57,59,61,62,64,66,70,71,72,76,77,78,79,80,81,82,85,95,96,99,100,101,103,104,105,106,114,115,116,117,118,119],$Vo1=[12,21,22,24],$Vp1=[22,96],$Vq1=[1,238],$Vr1=[1,242],$Vs1=[1,239],$Vt1=[1,236],$Vu1=[1,233],$Vv1=[1,234],$Vw1=[1,235],$Vx1=[1,237],$Vy1=[1,240],$Vz1=[1,241],$VA1=[1,243],$VB1=[1,260],$VC1=[20,21,23,96],$VD1=[20,21,22,23,76,92,95,96,99,100,101,102,103,104,105];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"start":3,"mermaidDoc":4,"directive":5,"openDirective":6,"typeDirective":7,"closeDirective":8,"separator":9,":":10,"argDirective":11,"open_directive":12,"type_directive":13,"arg_directive":14,"close_directive":15,"graphConfig":16,"document":17,"line":18,"statement":19,"SEMI":20,"NEWLINE":21,"SPACE":22,"EOF":23,"GRAPH":24,"NODIR":25,"DIR":26,"FirstStmtSeperator":27,"ending":28,"endToken":29,"spaceList":30,"spaceListNewline":31,"verticeStatement":32,"styleStatement":33,"linkStyleStatement":34,"classDefStatement":35,"classStatement":36,"clickStatement":37,"subgraph":38,"text":39,"SQS":40,"SQE":41,"end":42,"direction":43,"link":44,"node":45,"vertex":46,"AMP":47,"STYLE_SEPARATOR":48,"idString":49,"PS":50,"PE":51,"(-":52,"-)":53,"STADIUMSTART":54,"STADIUMEND":55,"SUBROUTINESTART":56,"SUBROUTINEEND":57,"CYLINDERSTART":58,"CYLINDEREND":59,"DIAMOND_START":60,"DIAMOND_STOP":61,"TAGEND":62,"TRAPSTART":63,"TRAPEND":64,"INVTRAPSTART":65,"INVTRAPEND":66,"linkStatement":67,"arrowText":68,"TESTSTR":69,"START_LINK":70,"LINK":71,"PIPE":72,"textToken":73,"STR":74,"keywords":75,"STYLE":76,"LINKSTYLE":77,"CLASSDEF":78,"CLASS":79,"CLICK":80,"DOWN":81,"UP":82,"textNoTags":83,"textNoTagsToken":84,"DEFAULT":85,"stylesOpt":86,"alphaNum":87,"CALLBACKNAME":88,"CALLBACKARGS":89,"HREF":90,"LINK_TARGET":91,"HEX":92,"numList":93,"INTERPOLATE":94,"NUM":95,"COMMA":96,"style":97,"styleComponent":98,"ALPHA":99,"COLON":100,"MINUS":101,"UNIT":102,"BRKT":103,"DOT":104,"PCT":105,"TAGSTART":106,"alphaNumToken":107,"idStringToken":108,"alphaNumStatement":109,"direction_tb":110,"direction_bt":111,"direction_rl":112,"direction_lr":113,"PUNCTUATION":114,"UNICODE_TEXT":115,"PLUS":116,"EQUALS":117,"MULT":118,"UNDERSCORE":119,"graphCodeTokens":120,"ARROW_CROSS":121,"ARROW_POINT":122,"ARROW_CIRCLE":123,"ARROW_OPEN":124,"QUOTE":125,"$accept":0,"$end":1},
terminals_: {2:"error",10:":",12:"open_directive",13:"type_directive",14:"arg_directive",15:"close_directive",20:"SEMI",21:"NEWLINE",22:"SPACE",23:"EOF",24:"GRAPH",25:"NODIR",26:"DIR",38:"subgraph",40:"SQS",41:"SQE",42:"end",47:"AMP",48:"STYLE_SEPARATOR",50:"PS",51:"PE",52:"(-",53:"-)",54:"STADIUMSTART",55:"STADIUMEND",56:"SUBROUTINESTART",57:"SUBROUTINEEND",58:"CYLINDERSTART",59:"CYLINDEREND",60:"DIAMOND_START",61:"DIAMOND_STOP",62:"TAGEND",63:"TRAPSTART",64:"TRAPEND",65:"INVTRAPSTART",66:"INVTRAPEND",69:"TESTSTR",70:"START_LINK",71:"LINK",72:"PIPE",74:"STR",76:"STYLE",77:"LINKSTYLE",78:"CLASSDEF",79:"CLASS",80:"CLICK",81:"DOWN",82:"UP",85:"DEFAULT",88:"CALLBACKNAME",89:"CALLBACKARGS",90:"HREF",91:"LINK_TARGET",92:"HEX",94:"INTERPOLATE",95:"NUM",96:"COMMA",99:"ALPHA",100:"COLON",101:"MINUS",102:"UNIT",103:"BRKT",104:"DOT",105:"PCT",106:"TAGSTART",110:"direction_tb",111:"direction_bt",112:"direction_rl",113:"direction_lr",114:"PUNCTUATION",115:"UNICODE_TEXT",116:"PLUS",117:"EQUALS",118:"MULT",119:"UNDERSCORE",121:"ARROW_CROSS",122:"ARROW_POINT",123:"ARROW_CIRCLE",124:"ARROW_OPEN",125:"QUOTE"},
productions_: [0,[3,1],[3,2],[5,4],[5,6],[6,1],[7,1],[11,1],[8,1],[4,2],[17,0],[17,2],[18,1],[18,1],[18,1],[18,1],[18,1],[16,2],[16,2],[16,2],[16,3],[28,2],[28,1],[29,1],[29,1],[29,1],[27,1],[27,1],[27,2],[31,2],[31,2],[31,1],[31,1],[30,2],[30,1],[19,2],[19,2],[19,2],[19,2],[19,2],[19,2],[19,9],[19,6],[19,4],[19,1],[9,1],[9,1],[9,1],[32,3],[32,4],[32,2],[32,1],[45,1],[45,5],[45,3],[46,4],[46,6],[46,4],[46,4],[46,4],[46,4],[46,4],[46,4],[46,6],[46,4],[46,4],[46,4],[46,4],[46,4],[46,1],[44,2],[44,3],[44,3],[44,1],[44,3],[67,1],[68,3],[39,1],[39,2],[39,1],[75,1],[75,1],[75,1],[75,1],[75,1],[75,1],[75,1],[75,1],[75,1],[75,1],[75,1],[83,1],[83,2],[35,5],[35,5],[36,5],[37,2],[37,4],[37,3],[37,5],[37,2],[37,4],[37,4],[37,6],[37,2],[37,4],[37,2],[37,4],[37,4],[37,6],[33,5],[33,5],[34,5],[34,5],[34,9],[34,9],[34,7],[34,7],[93,1],[93,3],[86,1],[86,3],[97,1],[97,2],[98,1],[98,1],[98,1],[98,1],[98,1],[98,1],[98,1],[98,1],[98,1],[98,1],[98,1],[73,1],[73,1],[73,1],[73,1],[73,1],[73,1],[84,1],[84,1],[84,1],[84,1],[49,1],[49,2],[87,1],[87,2],[109,1],[109,1],[109,1],[109,1],[43,1],[43,1],[43,1],[43,1],[107,1],[107,1],[107,1],[107,1],[107,1],[107,1],[107,1],[107,1],[107,1],[107,1],[107,1],[107,1],[107,1],[108,1],[108,1],[108,1],[108,1],[108,1],[108,1],[108,1],[108,1],[108,1],[108,1],[108,1],[108,1],[108,1],[108,1],[108,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1],[120,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 5:
 yy.parseDirective('%%{', 'open_directive'); 
break;
case 6:
 yy.parseDirective($$[$0], 'type_directive'); 
break;
case 7:
 $$[$0] = $$[$0].trim().replace(/'/g, '"'); yy.parseDirective($$[$0], 'arg_directive'); 
break;
case 8:
 yy.parseDirective('}%%', 'close_directive', 'flowchart'); 
break;
case 10:
 this.$ = [];
break;
case 11:

	    if($$[$0] !== []){
	        $$[$0-1].push($$[$0]);
	    }
	    this.$=$$[$0-1];
break;
case 12: case 77: case 79: case 91: case 147: case 149: case 150:
this.$=$$[$0];
break;
case 19:
 yy.setDirection('TB');this.$ = 'TB';
break;
case 20:
 yy.setDirection($$[$0-1]);this.$ = $$[$0-1];
break;
case 35:
 /* console.warn('finat vs', $$[$0-1].nodes); */ this.$=$$[$0-1].nodes
break;
case 36: case 37: case 38: case 39: case 40:
this.$=[];
break;
case 41:
this.$=yy.addSubGraph($$[$0-6],$$[$0-1],$$[$0-4]);
break;
case 42:
this.$=yy.addSubGraph($$[$0-3],$$[$0-1],$$[$0-3]);
break;
case 43:
this.$=yy.addSubGraph(undefined,$$[$0-1],undefined);
break;
case 48:
 /* console.warn('vs',$$[$0-2].stmt,$$[$0]); */ yy.addLink($$[$0-2].stmt,$$[$0],$$[$0-1]); this.$ = { stmt: $$[$0], nodes: $$[$0].concat($$[$0-2].nodes) } 
break;
case 49:
 /* console.warn('vs',$$[$0-3].stmt,$$[$0-1]); */ yy.addLink($$[$0-3].stmt,$$[$0-1],$$[$0-2]); this.$ = { stmt: $$[$0-1], nodes: $$[$0-1].concat($$[$0-3].nodes) } 
break;
case 50:
/*console.warn('noda', $$[$0-1]);*/ this.$ = {stmt: $$[$0-1], nodes:$$[$0-1] }
break;
case 51:
 /*console.warn('noda', $$[$0]);*/ this.$ = {stmt: $$[$0], nodes:$$[$0] }
break;
case 52:
 /* console.warn('nod', $$[$0]); */ this.$ = [$$[$0]];
break;
case 53:
 this.$ = $$[$0-4].concat($$[$0]); /* console.warn('pip', $$[$0-4][0], $$[$0], this.$); */ 
break;
case 54:
this.$ = [$$[$0-2]];yy.setClass($$[$0-2],$$[$0])
break;
case 55:
this.$ = $$[$0-3];yy.addVertex($$[$0-3],$$[$0-1],'square');
break;
case 56:
this.$ = $$[$0-5];yy.addVertex($$[$0-5],$$[$0-2],'circle');
break;
case 57:
this.$ = $$[$0-3];yy.addVertex($$[$0-3],$$[$0-1],'ellipse');
break;
case 58:
this.$ = $$[$0-3];yy.addVertex($$[$0-3],$$[$0-1],'stadium');
break;
case 59:
this.$ = $$[$0-3];yy.addVertex($$[$0-3],$$[$0-1],'subroutine');
break;
case 60:
this.$ = $$[$0-3];yy.addVertex($$[$0-3],$$[$0-1],'cylinder');
break;
case 61:
this.$ = $$[$0-3];yy.addVertex($$[$0-3],$$[$0-1],'round');
break;
case 62:
this.$ = $$[$0-3];yy.addVertex($$[$0-3],$$[$0-1],'diamond');
break;
case 63:
this.$ = $$[$0-5];yy.addVertex($$[$0-5],$$[$0-2],'hexagon');
break;
case 64:
this.$ = $$[$0-3];yy.addVertex($$[$0-3],$$[$0-1],'odd');
break;
case 65:
this.$ = $$[$0-3];yy.addVertex($$[$0-3],$$[$0-1],'trapezoid');
break;
case 66:
this.$ = $$[$0-3];yy.addVertex($$[$0-3],$$[$0-1],'inv_trapezoid');
break;
case 67:
this.$ = $$[$0-3];yy.addVertex($$[$0-3],$$[$0-1],'lean_right');
break;
case 68:
this.$ = $$[$0-3];yy.addVertex($$[$0-3],$$[$0-1],'lean_left');
break;
case 69:
 /*console.warn('h: ', $$[$0]);*/this.$ = $$[$0];yy.addVertex($$[$0]);
break;
case 70:
$$[$0-1].text = $$[$0];this.$ = $$[$0-1];
break;
case 71: case 72:
$$[$0-2].text = $$[$0-1];this.$ = $$[$0-2];
break;
case 73:
this.$ = $$[$0];
break;
case 74:
var inf = yy.destructLink($$[$0], $$[$0-2]); this.$ = {"type":inf.type,"stroke":inf.stroke,"length":inf.length,"text":$$[$0-1]};
break;
case 75:
var inf = yy.destructLink($$[$0]);this.$ = {"type":inf.type,"stroke":inf.stroke,"length":inf.length};
break;
case 76:
this.$ = $$[$0-1];
break;
case 78: case 92: case 148:
this.$=$$[$0-1]+''+$$[$0];
break;
case 93: case 94:
this.$ = $$[$0-4];yy.addClass($$[$0-2],$$[$0]);
break;
case 95:
this.$ = $$[$0-4];yy.setClass($$[$0-2], $$[$0]);
break;
case 96: case 104:
this.$ = $$[$0-1];yy.setClickEvent($$[$0-1], $$[$0]);
break;
case 97: case 105:
this.$ = $$[$0-3];yy.setClickEvent($$[$0-3], $$[$0-2]);yy.setTooltip($$[$0-3], $$[$0]);
break;
case 98:
this.$ = $$[$0-2];yy.setClickEvent($$[$0-2], $$[$0-1], $$[$0]);
break;
case 99:
this.$ = $$[$0-4];yy.setClickEvent($$[$0-4], $$[$0-3], $$[$0-2]);yy.setTooltip($$[$0-4], $$[$0]);
break;
case 100: case 106:
this.$ = $$[$0-1];yy.setLink($$[$0-1], $$[$0]);
break;
case 101: case 107:
this.$ = $$[$0-3];yy.setLink($$[$0-3], $$[$0-2]);yy.setTooltip($$[$0-3], $$[$0]);
break;
case 102: case 108:
this.$ = $$[$0-3];yy.setLink($$[$0-3], $$[$0-2], $$[$0]);
break;
case 103: case 109:
this.$ = $$[$0-5];yy.setLink($$[$0-5], $$[$0-4], $$[$0]);yy.setTooltip($$[$0-5], $$[$0-2]);
break;
case 110:
this.$ = $$[$0-4];yy.addVertex($$[$0-2],undefined,undefined,$$[$0]);
break;
case 111: case 113:
this.$ = $$[$0-4];yy.updateLink($$[$0-2],$$[$0]);
break;
case 112:
this.$ = $$[$0-4];yy.updateLink([$$[$0-2]],$$[$0]);
break;
case 114:
this.$ = $$[$0-8];yy.updateLinkInterpolate([$$[$0-6]],$$[$0-2]);yy.updateLink([$$[$0-6]],$$[$0]);
break;
case 115:
this.$ = $$[$0-8];yy.updateLinkInterpolate($$[$0-6],$$[$0-2]);yy.updateLink($$[$0-6],$$[$0]);
break;
case 116:
this.$ = $$[$0-6];yy.updateLinkInterpolate([$$[$0-4]],$$[$0]);
break;
case 117:
this.$ = $$[$0-6];yy.updateLinkInterpolate($$[$0-4],$$[$0]);
break;
case 118: case 120:
this.$ = [$$[$0]]
break;
case 119: case 121:
$$[$0-2].push($$[$0]);this.$ = $$[$0-2];
break;
case 123:
this.$ = $$[$0-1] + $$[$0];
break;
case 145:
this.$=$$[$0]
break;
case 146:
this.$=$$[$0-1]+''+$$[$0]
break;
case 151:
this.$='v';
break;
case 152:
this.$='-';
break;
case 153:
 this.$={stmt:'dir', value:'TB'};
break;
case 154:
 this.$={stmt:'dir', value:'BT'};
break;
case 155:
 this.$={stmt:'dir', value:'RL'};
break;
case 156:
 this.$={stmt:'dir', value:'LR'};
break;
}
},
table: [{3:1,4:2,5:3,6:5,12:$V0,16:4,21:$V1,22:$V2,24:$V3},{1:[3]},{1:[2,1]},{3:10,4:2,5:3,6:5,12:$V0,16:4,21:$V1,22:$V2,24:$V3},o($V4,$V5,{17:11}),{7:12,13:[1,13]},{16:14,21:$V1,22:$V2,24:$V3},{16:15,21:$V1,22:$V2,24:$V3},{25:[1,16],26:[1,17]},{13:[2,5]},{1:[2,2]},{1:[2,9],18:18,19:19,20:$V6,21:$V7,22:$V8,23:$V9,32:24,33:25,34:26,35:27,36:28,37:29,38:$Va,43:31,45:32,46:42,47:$Vb,49:43,76:$Vc,77:$Vd,78:$Ve,79:$Vf,80:$Vg,81:$Vh,95:$Vi,96:$Vj,99:$Vk,100:$Vl,101:$Vm,103:$Vn,104:$Vo,108:44,110:$Vp,111:$Vq,112:$Vr,113:$Vs,114:$Vt,115:$Vu,116:$Vv,117:$Vw,118:$Vx,119:$Vy},{8:60,10:[1,61],15:$Vz},o([10,15],[2,6]),o($V4,[2,17]),o($V4,[2,18]),o($V4,[2,19]),{20:[1,64],21:[1,65],22:$VA,27:63,30:66},o($VB,[2,11]),o($VB,[2,12]),o($VB,[2,13]),o($VB,[2,14]),o($VB,[2,15]),o($VB,[2,16]),{9:68,20:$VC,21:$VD,23:$VE,44:69,67:73,70:[1,74],71:[1,75]},{9:76,20:$VC,21:$VD,23:$VE},{9:77,20:$VC,21:$VD,23:$VE},{9:78,20:$VC,21:$VD,23:$VE},{9:79,20:$VC,21:$VD,23:$VE},{9:80,20:$VC,21:$VD,23:$VE},{9:82,20:$VC,21:$VD,22:[1,81],23:$VE},o($VB,[2,44]),o($VF,[2,51],{30:83,22:$VA}),{22:[1,84]},{22:[1,85]},{22:[1,86]},{22:[1,87]},{26:$VG,47:$VH,74:[1,91],81:$VI,87:90,88:[1,88],90:[1,89],95:$VJ,96:$VK,99:$VL,100:$VM,101:$VN,103:$VO,104:$VP,107:94,109:92,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},o($VB,[2,153]),o($VB,[2,154]),o($VB,[2,155]),o($VB,[2,156]),o($VW,[2,52],{48:[1,110]}),o($VX,[2,69],{108:121,40:[1,111],47:$Vb,50:[1,112],52:[1,113],54:[1,114],56:[1,115],58:[1,116],60:[1,117],62:[1,118],63:[1,119],65:[1,120],81:$Vh,95:$Vi,96:$Vj,99:$Vk,100:$Vl,101:$Vm,103:$Vn,104:$Vo,114:$Vt,115:$Vu,116:$Vv,117:$Vw,118:$Vx,119:$Vy}),o($VY,[2,145]),o($VY,[2,170]),o($VY,[2,171]),o($VY,[2,172]),o($VY,[2,173]),o($VY,[2,174]),o($VY,[2,175]),o($VY,[2,176]),o($VY,[2,177]),o($VY,[2,178]),o($VY,[2,179]),o($VY,[2,180]),o($VY,[2,181]),o($VY,[2,182]),o($VY,[2,183]),o($VY,[2,184]),{9:122,20:$VC,21:$VD,23:$VE},{11:123,14:[1,124]},o($VZ,[2,8]),o($V4,[2,20]),o($V4,[2,26]),o($V4,[2,27]),{21:[1,125]},o($V_,[2,34],{30:126,22:$VA}),o($VB,[2,35]),{45:127,46:42,47:$Vb,49:43,81:$Vh,95:$Vi,96:$Vj,99:$Vk,100:$Vl,101:$Vm,103:$Vn,104:$Vo,108:44,114:$Vt,115:$Vu,116:$Vv,117:$Vw,118:$Vx,119:$Vy},o($V$,[2,45]),o($V$,[2,46]),o($V$,[2,47]),o($V01,[2,73],{68:128,69:[1,129],72:[1,130]}),{22:$V11,24:$V21,26:$V31,38:$V41,39:131,42:$V51,47:$VH,62:$V61,70:$V71,73:132,74:$V81,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},o([47,69,72,81,95,96,99,100,101,103,104,114,115,116,117,118,119],[2,75]),o($VB,[2,36]),o($VB,[2,37]),o($VB,[2,38]),o($VB,[2,39]),o($VB,[2,40]),{22:$V11,24:$V21,26:$V31,38:$V41,39:155,42:$V51,47:$VH,62:$V61,70:$V71,73:132,74:$V81,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},o($Vk1,$V5,{17:156}),o($VF,[2,50],{47:$Vl1}),{26:$VG,47:$VH,81:$VI,87:158,92:[1,159],95:$VJ,96:$VK,99:$VL,100:$VM,101:$VN,103:$VO,104:$VP,107:94,109:92,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{85:[1,160],93:161,95:[1,162]},{26:$VG,47:$VH,81:$VI,85:[1,163],87:164,95:$VJ,96:$VK,99:$VL,100:$VM,101:$VN,103:$VO,104:$VP,107:94,109:92,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{26:$VG,47:$VH,81:$VI,87:165,95:$VJ,96:$VK,99:$VL,100:$VM,101:$VN,103:$VO,104:$VP,107:94,109:92,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},o($VZ,[2,96],{22:[1,166],89:[1,167]}),o($VZ,[2,100],{22:[1,168]}),o($VZ,[2,104],{107:94,109:170,22:[1,169],26:$VG,47:$VH,81:$VI,95:$VJ,96:$VK,99:$VL,100:$VM,101:$VN,103:$VO,104:$VP,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV}),o($VZ,[2,106],{22:[1,171]}),o($Vm1,[2,147]),o($Vm1,[2,149]),o($Vm1,[2,150]),o($Vm1,[2,151]),o($Vm1,[2,152]),o($Vn1,[2,157]),o($Vn1,[2,158]),o($Vn1,[2,159]),o($Vn1,[2,160]),o($Vn1,[2,161]),o($Vn1,[2,162]),o($Vn1,[2,163]),o($Vn1,[2,164]),o($Vn1,[2,165]),o($Vn1,[2,166]),o($Vn1,[2,167]),o($Vn1,[2,168]),o($Vn1,[2,169]),{47:$Vb,49:172,81:$Vh,95:$Vi,96:$Vj,99:$Vk,100:$Vl,101:$Vm,103:$Vn,104:$Vo,108:44,114:$Vt,115:$Vu,116:$Vv,117:$Vw,118:$Vx,119:$Vy},{22:$V11,24:$V21,26:$V31,38:$V41,39:173,42:$V51,47:$VH,62:$V61,70:$V71,73:132,74:$V81,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,39:175,42:$V51,47:$VH,50:[1,174],62:$V61,70:$V71,73:132,74:$V81,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,39:176,42:$V51,47:$VH,62:$V61,70:$V71,73:132,74:$V81,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,39:177,42:$V51,47:$VH,62:$V61,70:$V71,73:132,74:$V81,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,39:178,42:$V51,47:$VH,62:$V61,70:$V71,73:132,74:$V81,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,39:179,42:$V51,47:$VH,62:$V61,70:$V71,73:132,74:$V81,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,39:180,42:$V51,47:$VH,60:[1,181],62:$V61,70:$V71,73:132,74:$V81,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,39:182,42:$V51,47:$VH,62:$V61,70:$V71,73:132,74:$V81,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,39:183,42:$V51,47:$VH,62:$V61,70:$V71,73:132,74:$V81,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,39:184,42:$V51,47:$VH,62:$V61,70:$V71,73:132,74:$V81,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},o($VY,[2,146]),o($Vo1,[2,3]),{8:185,15:$Vz},{15:[2,7]},o($V4,[2,28]),o($V_,[2,33]),o($VF,[2,48],{30:186,22:$VA}),o($V01,[2,70],{22:[1,187]}),{22:[1,188]},{22:$V11,24:$V21,26:$V31,38:$V41,39:189,42:$V51,47:$VH,62:$V61,70:$V71,73:132,74:$V81,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,42:$V51,47:$VH,62:$V61,70:$V71,71:[1,190],73:191,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},o($Vn1,[2,77]),o($Vn1,[2,79]),o($Vn1,[2,135]),o($Vn1,[2,136]),o($Vn1,[2,137]),o($Vn1,[2,138]),o($Vn1,[2,139]),o($Vn1,[2,140]),o($Vn1,[2,141]),o($Vn1,[2,142]),o($Vn1,[2,143]),o($Vn1,[2,144]),o($Vn1,[2,80]),o($Vn1,[2,81]),o($Vn1,[2,82]),o($Vn1,[2,83]),o($Vn1,[2,84]),o($Vn1,[2,85]),o($Vn1,[2,86]),o($Vn1,[2,87]),o($Vn1,[2,88]),o($Vn1,[2,89]),o($Vn1,[2,90]),{9:193,20:$VC,21:$VD,22:$V11,23:$VE,24:$V21,26:$V31,38:$V41,40:[1,192],42:$V51,47:$VH,62:$V61,70:$V71,73:191,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{18:18,19:19,20:$V6,21:$V7,22:$V8,23:$V9,32:24,33:25,34:26,35:27,36:28,37:29,38:$Va,42:[1,194],43:31,45:32,46:42,47:$Vb,49:43,76:$Vc,77:$Vd,78:$Ve,79:$Vf,80:$Vg,81:$Vh,95:$Vi,96:$Vj,99:$Vk,100:$Vl,101:$Vm,103:$Vn,104:$Vo,108:44,110:$Vp,111:$Vq,112:$Vr,113:$Vs,114:$Vt,115:$Vu,116:$Vv,117:$Vw,118:$Vx,119:$Vy},{22:$VA,30:195},{22:[1,196],26:$VG,47:$VH,81:$VI,95:$VJ,96:$VK,99:$VL,100:$VM,101:$VN,103:$VO,104:$VP,107:94,109:170,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:[1,197]},{22:[1,198]},{22:[1,199],96:[1,200]},o($Vp1,[2,118]),{22:[1,201]},{22:[1,202],26:$VG,47:$VH,81:$VI,95:$VJ,96:$VK,99:$VL,100:$VM,101:$VN,103:$VO,104:$VP,107:94,109:170,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:[1,203],26:$VG,47:$VH,81:$VI,95:$VJ,96:$VK,99:$VL,100:$VM,101:$VN,103:$VO,104:$VP,107:94,109:170,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{74:[1,204]},o($VZ,[2,98],{22:[1,205]}),{74:[1,206],91:[1,207]},{74:[1,208]},o($Vm1,[2,148]),{74:[1,209],91:[1,210]},o($VW,[2,54],{108:121,47:$Vb,81:$Vh,95:$Vi,96:$Vj,99:$Vk,100:$Vl,101:$Vm,103:$Vn,104:$Vo,114:$Vt,115:$Vu,116:$Vv,117:$Vw,118:$Vx,119:$Vy}),{22:$V11,24:$V21,26:$V31,38:$V41,41:[1,211],42:$V51,47:$VH,62:$V61,70:$V71,73:191,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,39:212,42:$V51,47:$VH,62:$V61,70:$V71,73:132,74:$V81,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,42:$V51,47:$VH,51:[1,213],62:$V61,70:$V71,73:191,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,42:$V51,47:$VH,53:[1,214],62:$V61,70:$V71,73:191,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,42:$V51,47:$VH,55:[1,215],62:$V61,70:$V71,73:191,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,42:$V51,47:$VH,57:[1,216],62:$V61,70:$V71,73:191,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,42:$V51,47:$VH,59:[1,217],62:$V61,70:$V71,73:191,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,42:$V51,47:$VH,61:[1,218],62:$V61,70:$V71,73:191,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,39:219,42:$V51,47:$VH,62:$V61,70:$V71,73:132,74:$V81,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,41:[1,220],42:$V51,47:$VH,62:$V61,70:$V71,73:191,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,42:$V51,47:$VH,62:$V61,64:[1,221],66:[1,222],70:$V71,73:191,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{22:$V11,24:$V21,26:$V31,38:$V41,42:$V51,47:$VH,62:$V61,64:[1,224],66:[1,223],70:$V71,73:191,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{9:225,20:$VC,21:$VD,23:$VE},o($VF,[2,49],{47:$Vl1}),o($V01,[2,72]),o($V01,[2,71]),{22:$V11,24:$V21,26:$V31,38:$V41,42:$V51,47:$VH,62:$V61,70:$V71,72:[1,226],73:191,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},o($V01,[2,74]),o($Vn1,[2,78]),{22:$V11,24:$V21,26:$V31,38:$V41,39:227,42:$V51,47:$VH,62:$V61,70:$V71,73:132,74:$V81,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},o($Vk1,$V5,{17:228}),o($VB,[2,43]),{46:229,47:$Vb,49:43,81:$Vh,95:$Vi,96:$Vj,99:$Vk,100:$Vl,101:$Vm,103:$Vn,104:$Vo,108:44,114:$Vt,115:$Vu,116:$Vv,117:$Vw,118:$Vx,119:$Vy},{22:$Vq1,76:$Vr1,86:230,92:$Vs1,95:$Vt1,97:231,98:232,99:$Vu1,100:$Vv1,101:$Vw1,102:$Vx1,103:$Vy1,104:$Vz1,105:$VA1},{22:$Vq1,76:$Vr1,86:244,92:$Vs1,95:$Vt1,97:231,98:232,99:$Vu1,100:$Vv1,101:$Vw1,102:$Vx1,103:$Vy1,104:$Vz1,105:$VA1},{22:$Vq1,76:$Vr1,86:245,92:$Vs1,94:[1,246],95:$Vt1,97:231,98:232,99:$Vu1,100:$Vv1,101:$Vw1,102:$Vx1,103:$Vy1,104:$Vz1,105:$VA1},{22:$Vq1,76:$Vr1,86:247,92:$Vs1,94:[1,248],95:$Vt1,97:231,98:232,99:$Vu1,100:$Vv1,101:$Vw1,102:$Vx1,103:$Vy1,104:$Vz1,105:$VA1},{95:[1,249]},{22:$Vq1,76:$Vr1,86:250,92:$Vs1,95:$Vt1,97:231,98:232,99:$Vu1,100:$Vv1,101:$Vw1,102:$Vx1,103:$Vy1,104:$Vz1,105:$VA1},{22:$Vq1,76:$Vr1,86:251,92:$Vs1,95:$Vt1,97:231,98:232,99:$Vu1,100:$Vv1,101:$Vw1,102:$Vx1,103:$Vy1,104:$Vz1,105:$VA1},{26:$VG,47:$VH,81:$VI,87:252,95:$VJ,96:$VK,99:$VL,100:$VM,101:$VN,103:$VO,104:$VP,107:94,109:92,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},o($VZ,[2,97]),{74:[1,253]},o($VZ,[2,101],{22:[1,254]}),o($VZ,[2,102]),o($VZ,[2,105]),o($VZ,[2,107],{22:[1,255]}),o($VZ,[2,108]),o($VX,[2,55]),{22:$V11,24:$V21,26:$V31,38:$V41,42:$V51,47:$VH,51:[1,256],62:$V61,70:$V71,73:191,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},o($VX,[2,61]),o($VX,[2,57]),o($VX,[2,58]),o($VX,[2,59]),o($VX,[2,60]),o($VX,[2,62]),{22:$V11,24:$V21,26:$V31,38:$V41,42:$V51,47:$VH,61:[1,257],62:$V61,70:$V71,73:191,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},o($VX,[2,64]),o($VX,[2,65]),o($VX,[2,67]),o($VX,[2,66]),o($VX,[2,68]),o($Vo1,[2,4]),o([22,47,81,95,96,99,100,101,103,104,114,115,116,117,118,119],[2,76]),{22:$V11,24:$V21,26:$V31,38:$V41,41:[1,258],42:$V51,47:$VH,62:$V61,70:$V71,73:191,75:143,76:$V91,77:$Va1,78:$Vb1,79:$Vc1,80:$Vd1,81:$Ve1,82:$Vf1,84:134,85:$Vg1,95:$VJ,96:$VK,99:$VL,100:$VM,101:$Vh1,103:$VO,104:$VP,105:$Vi1,106:$Vj1,107:140,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{18:18,19:19,20:$V6,21:$V7,22:$V8,23:$V9,32:24,33:25,34:26,35:27,36:28,37:29,38:$Va,42:[1,259],43:31,45:32,46:42,47:$Vb,49:43,76:$Vc,77:$Vd,78:$Ve,79:$Vf,80:$Vg,81:$Vh,95:$Vi,96:$Vj,99:$Vk,100:$Vl,101:$Vm,103:$Vn,104:$Vo,108:44,110:$Vp,111:$Vq,112:$Vr,113:$Vs,114:$Vt,115:$Vu,116:$Vv,117:$Vw,118:$Vx,119:$Vy},o($VW,[2,53]),o($VZ,[2,110],{96:$VB1}),o($VC1,[2,120],{98:261,22:$Vq1,76:$Vr1,92:$Vs1,95:$Vt1,99:$Vu1,100:$Vv1,101:$Vw1,102:$Vx1,103:$Vy1,104:$Vz1,105:$VA1}),o($VD1,[2,122]),o($VD1,[2,124]),o($VD1,[2,125]),o($VD1,[2,126]),o($VD1,[2,127]),o($VD1,[2,128]),o($VD1,[2,129]),o($VD1,[2,130]),o($VD1,[2,131]),o($VD1,[2,132]),o($VD1,[2,133]),o($VD1,[2,134]),o($VZ,[2,111],{96:$VB1}),o($VZ,[2,112],{96:$VB1}),{22:[1,262]},o($VZ,[2,113],{96:$VB1}),{22:[1,263]},o($Vp1,[2,119]),o($VZ,[2,93],{96:$VB1}),o($VZ,[2,94],{96:$VB1}),o($VZ,[2,95],{107:94,109:170,26:$VG,47:$VH,81:$VI,95:$VJ,96:$VK,99:$VL,100:$VM,101:$VN,103:$VO,104:$VP,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV}),o($VZ,[2,99]),{91:[1,264]},{91:[1,265]},{51:[1,266]},{61:[1,267]},{9:268,20:$VC,21:$VD,23:$VE},o($VB,[2,42]),{22:$Vq1,76:$Vr1,92:$Vs1,95:$Vt1,97:269,98:232,99:$Vu1,100:$Vv1,101:$Vw1,102:$Vx1,103:$Vy1,104:$Vz1,105:$VA1},o($VD1,[2,123]),{26:$VG,47:$VH,81:$VI,87:270,95:$VJ,96:$VK,99:$VL,100:$VM,101:$VN,103:$VO,104:$VP,107:94,109:92,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},{26:$VG,47:$VH,81:$VI,87:271,95:$VJ,96:$VK,99:$VL,100:$VM,101:$VN,103:$VO,104:$VP,107:94,109:92,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV},o($VZ,[2,103]),o($VZ,[2,109]),o($VX,[2,56]),o($VX,[2,63]),o($Vk1,$V5,{17:272}),o($VC1,[2,121],{98:261,22:$Vq1,76:$Vr1,92:$Vs1,95:$Vt1,99:$Vu1,100:$Vv1,101:$Vw1,102:$Vx1,103:$Vy1,104:$Vz1,105:$VA1}),o($VZ,[2,116],{107:94,109:170,22:[1,273],26:$VG,47:$VH,81:$VI,95:$VJ,96:$VK,99:$VL,100:$VM,101:$VN,103:$VO,104:$VP,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV}),o($VZ,[2,117],{107:94,109:170,22:[1,274],26:$VG,47:$VH,81:$VI,95:$VJ,96:$VK,99:$VL,100:$VM,101:$VN,103:$VO,104:$VP,114:$VQ,115:$VR,116:$VS,117:$VT,118:$VU,119:$VV}),{18:18,19:19,20:$V6,21:$V7,22:$V8,23:$V9,32:24,33:25,34:26,35:27,36:28,37:29,38:$Va,42:[1,275],43:31,45:32,46:42,47:$Vb,49:43,76:$Vc,77:$Vd,78:$Ve,79:$Vf,80:$Vg,81:$Vh,95:$Vi,96:$Vj,99:$Vk,100:$Vl,101:$Vm,103:$Vn,104:$Vo,108:44,110:$Vp,111:$Vq,112:$Vr,113:$Vs,114:$Vt,115:$Vu,116:$Vv,117:$Vw,118:$Vx,119:$Vy},{22:$Vq1,76:$Vr1,86:276,92:$Vs1,95:$Vt1,97:231,98:232,99:$Vu1,100:$Vv1,101:$Vw1,102:$Vx1,103:$Vy1,104:$Vz1,105:$VA1},{22:$Vq1,76:$Vr1,86:277,92:$Vs1,95:$Vt1,97:231,98:232,99:$Vu1,100:$Vv1,101:$Vw1,102:$Vx1,103:$Vy1,104:$Vz1,105:$VA1},o($VB,[2,41]),o($VZ,[2,114],{96:$VB1}),o($VZ,[2,115],{96:$VB1})],
defaultActions: {2:[2,1],9:[2,5],10:[2,2],124:[2,7]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
            function lex() {
            var token;
            token = tstack.pop() || lexer.lex() || EOF;
            if (typeof token !== 'number') {
                if (token instanceof Array) {
                    tstack = token;
                    token = tstack.pop();
                }
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
        if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];
            for (p in table[state]) {
                if (this.terminals_[p] && p > TERROR) {
                    expected.push('\'' + this.terminals_[p] + '\'');
                }
            }
            if (lexer.showPosition) {
                errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
                errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }
            this.parseError(errStr, {
                text: lexer.match,
                token: this.terminals_[symbol] || symbol,
                line: lexer.yylineno,
                loc: yyloc,
                expected: expected
            });
        }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0: this.begin('open_directive'); return 12; 
break;
case 1: this.begin('type_directive'); return 13; 
break;
case 2: this.popState(); this.begin('arg_directive'); return 10; 
break;
case 3: this.popState(); this.popState(); return 15; 
break;
case 4:return 14;
break;
case 5:/* skip comments */
break;
case 6:/* skip comments */
break;
case 7:this.begin("string");
break;
case 8:this.popState();
break;
case 9:return "STR";
break;
case 10:return 76;
break;
case 11:return 85;
break;
case 12:return 77;
break;
case 13:return 94;
break;
case 14:return 78;
break;
case 15:return 79;
break;
case 16:this.begin("href");
break;
case 17:this.popState();
break;
case 18:return 90;
break;
case 19:this.begin("callbackname");
break;
case 20:this.popState();
break;
case 21:this.popState(); this.begin("callbackargs");
break;
case 22:return 88;
break;
case 23:this.popState();
break;
case 24:return 89;
break;
case 25:this.begin("click");
break;
case 26:this.popState();
break;
case 27:return 80;
break;
case 28:if(yy.lex.firstGraph()){this.begin("dir");}  return 24;
break;
case 29:if(yy.lex.firstGraph()){this.begin("dir");}  return 24;
break;
case 30:return 38;
break;
case 31:return 42;
break;
case 32:return 91;
break;
case 33:return 91;
break;
case 34:return 91;
break;
case 35:return 91;
break;
case 36:   this.popState();  return 25; 
break;
case 37:   this.popState();  return 26; 
break;
case 38:   this.popState();  return 26; 
break;
case 39:   this.popState();  return 26; 
break;
case 40:   this.popState();  return 26; 
break;
case 41:   this.popState();  return 26; 
break;
case 42:   this.popState();  return 26; 
break;
case 43:   this.popState();  return 26; 
break;
case 44:   this.popState();  return 26; 
break;
case 45:   this.popState();  return 26; 
break;
case 46:   this.popState();  return 26; 
break;
case 47:return 110;
break;
case 48:return 111;
break;
case 49:return 112;
break;
case 50:return 113;
break;
case 51: return 95;
break;
case 52:return 103;
break;
case 53:return 48;
break;
case 54:return 100;
break;
case 55:return 47;
break;
case 56:return 20;
break;
case 57:return 96;
break;
case 58:return 118;
break;
case 59:return 71;
break;
case 60:return 71;
break;
case 61:return 71;
break;
case 62:return 70;
break;
case 63:return 70;
break;
case 64:return 70;
break;
case 65:return 52;
break;
case 66:return 53;
break;
case 67:return 54;
break;
case 68:return 55;
break;
case 69:return 56;
break;
case 70:return 57;
break;
case 71:return 58;
break;
case 72:return 59;
break;
case 73:return 101;
break;
case 74:return 104;
break;
case 75:return 119;
break;
case 76:return 116;
break;
case 77:return 105;
break;
case 78:return 117;
break;
case 79:return 117;
break;
case 80:return 106;
break;
case 81:return 62;
break;
case 82:return 82;
break;
case 83:return 'SEP';
break;
case 84:return 81;
break;
case 85:return 99;
break;
case 86:return 64;
break;
case 87:return 63;
break;
case 88:return 66;
break;
case 89:return 65;
break;
case 90:return 114;
break;
case 91:return 115;
break;
case 92:return 72;
break;
case 93:return 50;
break;
case 94:return 51;
break;
case 95:return 40;
break;
case 96:return 41;
break;
case 97:return 60
break;
case 98:return 61
break;
case 99:return 125;
break;
case 100:return 21;
break;
case 101:return 22;
break;
case 102:return 23;
break;
}
},
rules: [/^(?:%%\{)/,/^(?:((?:(?!\}%%)[^:.])*))/,/^(?::)/,/^(?:\}%%)/,/^(?:((?:(?!\}%%).|\n)*))/,/^(?:%%(?!\{)[^\n]*)/,/^(?:[^\}]%%[^\n]*)/,/^(?:["])/,/^(?:["])/,/^(?:[^"]*)/,/^(?:style\b)/,/^(?:default\b)/,/^(?:linkStyle\b)/,/^(?:interpolate\b)/,/^(?:classDef\b)/,/^(?:class\b)/,/^(?:href[\s]+["])/,/^(?:["])/,/^(?:[^"]*)/,/^(?:call[\s]+)/,/^(?:\([\s]*\))/,/^(?:\()/,/^(?:[^(]*)/,/^(?:\))/,/^(?:[^)]*)/,/^(?:click[\s]+)/,/^(?:[\s\n])/,/^(?:[^\s\n]*)/,/^(?:graph\b)/,/^(?:flowchart\b)/,/^(?:subgraph\b)/,/^(?:end\b\s*)/,/^(?:_self\b)/,/^(?:_blank\b)/,/^(?:_parent\b)/,/^(?:_top\b)/,/^(?:(\r?\n)*\s*\n)/,/^(?:\s*LR\b)/,/^(?:\s*RL\b)/,/^(?:\s*TB\b)/,/^(?:\s*BT\b)/,/^(?:\s*TD\b)/,/^(?:\s*BR\b)/,/^(?:\s*<)/,/^(?:\s*>)/,/^(?:\s*\^)/,/^(?:\s*v\b)/,/^(?:.*direction\s+TB[^\n]*)/,/^(?:.*direction\s+BT[^\n]*)/,/^(?:.*direction\s+RL[^\n]*)/,/^(?:.*direction\s+LR[^\n]*)/,/^(?:[0-9]+)/,/^(?:#)/,/^(?::::)/,/^(?::)/,/^(?:&)/,/^(?:;)/,/^(?:,)/,/^(?:\*)/,/^(?:\s*[xo<]?--+[-xo>]\s*)/,/^(?:\s*[xo<]?==+[=xo>]\s*)/,/^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/,/^(?:\s*[xo<]?--\s*)/,/^(?:\s*[xo<]?==\s*)/,/^(?:\s*[xo<]?-\.\s*)/,/^(?:\(-)/,/^(?:-\))/,/^(?:\(\[)/,/^(?:\]\))/,/^(?:\[\[)/,/^(?:\]\])/,/^(?:\[\()/,/^(?:\)\])/,/^(?:-)/,/^(?:\.)/,/^(?:[\_])/,/^(?:\+)/,/^(?:%)/,/^(?:=)/,/^(?:=)/,/^(?:<)/,/^(?:>)/,/^(?:\^)/,/^(?:\\\|)/,/^(?:v\b)/,/^(?:[A-Za-z]+)/,/^(?:\\\])/,/^(?:\[\/)/,/^(?:\/\])/,/^(?:\[\\)/,/^(?:[!"#$%&'*+,-.`?\\_/])/,/^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/,/^(?:\|)/,/^(?:\()/,/^(?:\))/,/^(?:\[)/,/^(?:\])/,/^(?:\{)/,/^(?:\})/,/^(?:")/,/^(?:(\r?\n)+)/,/^(?:\s)/,/^(?:$)/],
conditions: {"close_directive":{"rules":[],"inclusive":false},"arg_directive":{"rules":[3,4],"inclusive":false},"type_directive":{"rules":[2,3],"inclusive":false},"open_directive":{"rules":[1],"inclusive":false},"callbackargs":{"rules":[23,24],"inclusive":false},"callbackname":{"rules":[20,21,22],"inclusive":false},"href":{"rules":[17,18],"inclusive":false},"click":{"rules":[26,27],"inclusive":false},"vertex":{"rules":[],"inclusive":false},"dir":{"rules":[36,37,38,39,40,41,42,43,44,45,46],"inclusive":false},"string":{"rules":[8,9],"inclusive":false},"INITIAL":{"rules":[0,5,6,7,10,11,12,13,14,15,16,19,25,28,29,30,31,32,33,34,35,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (true) {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js").readFileSync(__webpack_require__(/*! path */ "./node_modules/path-browserify/index.js").normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if ( true && __webpack_require__.c[__webpack_require__.s] === module) {
  exports.main(process.argv.slice(1));
}
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/diagrams/flowchart/styles.js":
/*!******************************************!*\
  !*** ./src/diagrams/flowchart/styles.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var getStyles = function getStyles(options) {
  return ".label {\n    font-family: ".concat(options.fontFamily, ";\n    color: ").concat(options.nodeTextColor || options.textColor, ";\n  }\n  .cluster-label text {\n    fill: ").concat(options.titleColor, ";\n  }\n  .cluster-label span {\n    color: ").concat(options.titleColor, ";\n  }\n\n  .label text,span {\n    fill: ").concat(options.nodeTextColor || options.textColor, ";\n    color: ").concat(options.nodeTextColor || options.textColor, ";\n  }\n\n  .node rect,\n  .node circle,\n  .node ellipse,\n  .node polygon,\n  .node path {\n    fill: ").concat(options.mainBkg, ";\n    stroke: ").concat(options.nodeBorder, ";\n    stroke-width: 1px;\n  }\n\n  .node .label {\n    text-align: center;\n  }\n  .node.clickable {\n    cursor: pointer;\n  }\n\n  .arrowheadPath {\n    fill: ").concat(options.arrowheadColor, ";\n  }\n\n  .edgePath .path {\n    stroke: ").concat(options.lineColor, ";\n    stroke-width: 2.0px;\n  }\n\n  .flowchart-link {\n    stroke: ").concat(options.lineColor, ";\n    fill: none;\n  }\n\n  .edgeLabel {\n    background-color: ").concat(options.edgeLabelBackground, ";\n    rect {\n      opacity: 0.5;\n      background-color: ").concat(options.edgeLabelBackground, ";\n      fill: ").concat(options.edgeLabelBackground, ";\n    }\n    text-align: center;\n  }\n\n  .cluster rect {\n    fill: ").concat(options.clusterBkg, ";\n    stroke: ").concat(options.clusterBorder, ";\n    stroke-width: 1px;\n  }\n\n  .cluster text {\n    fill: ").concat(options.titleColor, ";\n  }\n\n  .cluster span {\n    color: ").concat(options.titleColor, ";\n  }\n  // .cluster div {\n  //   color: ").concat(options.titleColor, ";\n  // }\n\n  div.mermaidTooltip {\n    position: absolute;\n    text-align: center;\n    max-width: 200px;\n    padding: 2px;\n    font-family: ").concat(options.fontFamily, ";\n    font-size: 12px;\n    background: ").concat(options.tertiaryColor, ";\n    border: 1px solid ").concat(options.border2, ";\n    border-radius: 2px;\n    pointer-events: none;\n    z-index: 100;\n  }\n");
};

/* harmony default export */ __webpack_exports__["default"] = (getStyles);

/***/ }),

/***/ "./src/diagrams/gantt/ganttDb.js":
/*!***************************************!*\
  !*** ./src/diagrams/gantt/ganttDb.js ***!
  \***************************************/
/*! exports provided: parseDirective, clear, setAxisFormat, getAxisFormat, setTodayMarker, getTodayMarker, setDateFormat, enableInclusiveEndDates, endDatesAreInclusive, enableTopAxis, topAxisEnabled, getDateFormat, setExcludes, getExcludes, setTitle, getTitle, addSection, getSections, getTasks, addTask, findTaskById, addTaskOrg, setLink, setClass, setClickEvent, bindFunctions, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseDirective", function() { return parseDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxisFormat", function() { return setAxisFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAxisFormat", function() { return getAxisFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setTodayMarker", function() { return setTodayMarker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTodayMarker", function() { return getTodayMarker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDateFormat", function() { return setDateFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableInclusiveEndDates", function() { return enableInclusiveEndDates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "endDatesAreInclusive", function() { return endDatesAreInclusive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableTopAxis", function() { return enableTopAxis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "topAxisEnabled", function() { return topAxisEnabled; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDateFormat", function() { return getDateFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setExcludes", function() { return setExcludes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getExcludes", function() { return getExcludes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setTitle", function() { return setTitle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTitle", function() { return getTitle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addSection", function() { return addSection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSections", function() { return getSections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTasks", function() { return getTasks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addTask", function() { return addTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findTaskById", function() { return findTaskById; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addTaskOrg", function() { return addTaskOrg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setLink", function() { return setLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setClass", function() { return setClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setClickEvent", function() { return setClickEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindFunctions", function() { return bindFunctions; });
/* harmony import */ var moment_mini__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! moment-mini */ "moment-mini");
/* harmony import */ var moment_mini__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(moment_mini__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @braintree/sanitize-url */ "@braintree/sanitize-url");
/* harmony import */ var _braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");
/* harmony import */ var _mermaidAPI__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../mermaidAPI */ "./src/mermaidAPI.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }







var dateFormat = '';
var axisFormat = '';
var todayMarker = '';
var excludes = [];
var title = '';
var sections = [];
var tasks = [];
var currentSection = '';
var tags = ['active', 'done', 'crit', 'milestone'];
var funs = [];
var inclusiveEndDates = false;
var topAxis = false; // The serial order of the task in the script

var lastOrder = 0;
var parseDirective = function parseDirective(statement, context, type) {
  _mermaidAPI__WEBPACK_IMPORTED_MODULE_5__["default"].parseDirective(this, statement, context, type);
};
var clear = function clear() {
  sections = [];
  tasks = [];
  currentSection = '';
  funs = [];
  title = '';
  taskCnt = 0;
  lastTask = undefined;
  lastTaskID = undefined;
  rawTasks = [];
  dateFormat = '';
  axisFormat = '';
  todayMarker = '';
  excludes = [];
  inclusiveEndDates = false;
  topAxis = false;
  lastOrder = 0;
};
var setAxisFormat = function setAxisFormat(txt) {
  axisFormat = txt;
};
var getAxisFormat = function getAxisFormat() {
  return axisFormat;
};
var setTodayMarker = function setTodayMarker(txt) {
  todayMarker = txt;
};
var getTodayMarker = function getTodayMarker() {
  return todayMarker;
};
var setDateFormat = function setDateFormat(txt) {
  dateFormat = txt;
};
var enableInclusiveEndDates = function enableInclusiveEndDates() {
  inclusiveEndDates = true;
};
var endDatesAreInclusive = function endDatesAreInclusive() {
  return inclusiveEndDates;
};
var enableTopAxis = function enableTopAxis() {
  topAxis = true;
};
var topAxisEnabled = function topAxisEnabled() {
  return topAxis;
};
var getDateFormat = function getDateFormat() {
  return dateFormat;
};
var setExcludes = function setExcludes(txt) {
  excludes = txt.toLowerCase().split(/[\s,]+/);
};
var getExcludes = function getExcludes() {
  return excludes;
};
var setTitle = function setTitle(txt) {
  title = txt;
};
var getTitle = function getTitle() {
  return title;
};
var addSection = function addSection(txt) {
  currentSection = txt;
  sections.push(txt);
};
var getSections = function getSections() {
  return sections;
};
var getTasks = function getTasks() {
  var allItemsPricessed = compileTasks();
  var maxDepth = 10;
  var iterationCount = 0;

  while (!allItemsPricessed && iterationCount < maxDepth) {
    allItemsPricessed = compileTasks();
    iterationCount++;
  }

  tasks = rawTasks;
  return tasks;
};

var isInvalidDate = function isInvalidDate(date, dateFormat, excludes) {
  if (date.isoWeekday() >= 6 && excludes.indexOf('weekends') >= 0) {
    return true;
  }

  if (excludes.indexOf(date.format('dddd').toLowerCase()) >= 0) {
    return true;
  }

  return excludes.indexOf(date.format(dateFormat.trim())) >= 0;
};

var checkTaskDates = function checkTaskDates(task, dateFormat, excludes) {
  if (!excludes.length || task.manualEndTime) return;
  var startTime = moment_mini__WEBPACK_IMPORTED_MODULE_0___default()(task.startTime, dateFormat, true);
  startTime.add(1, 'd');
  var endTime = moment_mini__WEBPACK_IMPORTED_MODULE_0___default()(task.endTime, dateFormat, true);
  var renderEndTime = fixTaskDates(startTime, endTime, dateFormat, excludes);
  task.endTime = endTime.toDate();
  task.renderEndTime = renderEndTime;
};

var fixTaskDates = function fixTaskDates(startTime, endTime, dateFormat, excludes) {
  var invalid = false;
  var renderEndTime = null;

  while (startTime <= endTime) {
    if (!invalid) {
      renderEndTime = endTime.toDate();
    }

    invalid = isInvalidDate(startTime, dateFormat, excludes);

    if (invalid) {
      endTime.add(1, 'd');
    }

    startTime.add(1, 'd');
  }

  return renderEndTime;
};

var getStartDate = function getStartDate(prevTime, dateFormat, str) {
  str = str.trim(); // Test for after

  var re = /^after\s+([\d\w- ]+)/;
  var afterStatement = re.exec(str.trim());

  if (afterStatement !== null) {
    // check all after ids and take the latest
    var latestEndingTask = null;
    afterStatement[1].split(' ').forEach(function (id) {
      var task = findTaskById(id);

      if (typeof task !== 'undefined') {
        if (!latestEndingTask) {
          latestEndingTask = task;
        } else {
          if (task.endTime > latestEndingTask.endTime) {
            latestEndingTask = task;
          }
        }
      }
    });

    if (!latestEndingTask) {
      var dt = new Date();
      dt.setHours(0, 0, 0, 0);
      return dt;
    } else {
      return latestEndingTask.endTime;
    }
  } // Check for actual date set


  var mDate = moment_mini__WEBPACK_IMPORTED_MODULE_0___default()(str, dateFormat.trim(), true);

  if (mDate.isValid()) {
    return mDate.toDate();
  } else {
    _logger__WEBPACK_IMPORTED_MODULE_2__["log"].debug('Invalid date:' + str);
    _logger__WEBPACK_IMPORTED_MODULE_2__["log"].debug('With date format:' + dateFormat.trim());
  } // Default date - now


  return new Date();
};

var durationToDate = function durationToDate(durationStatement, relativeTime) {
  if (durationStatement !== null) {
    switch (durationStatement[2]) {
      case 's':
        relativeTime.add(durationStatement[1], 'seconds');
        break;

      case 'm':
        relativeTime.add(durationStatement[1], 'minutes');
        break;

      case 'h':
        relativeTime.add(durationStatement[1], 'hours');
        break;

      case 'd':
        relativeTime.add(durationStatement[1], 'days');
        break;

      case 'w':
        relativeTime.add(durationStatement[1], 'weeks');
        break;
    }
  } // Default date - now


  return relativeTime.toDate();
};

var getEndDate = function getEndDate(prevTime, dateFormat, str, inclusive) {
  inclusive = inclusive || false;
  str = str.trim(); // Check for actual date

  var mDate = moment_mini__WEBPACK_IMPORTED_MODULE_0___default()(str, dateFormat.trim(), true);

  if (mDate.isValid()) {
    if (inclusive) {
      mDate.add(1, 'd');
    }

    return mDate.toDate();
  }

  return durationToDate(/^([\d]+)([wdhms])/.exec(str.trim()), moment_mini__WEBPACK_IMPORTED_MODULE_0___default()(prevTime));
};

var taskCnt = 0;

var parseId = function parseId(idStr) {
  if (typeof idStr === 'undefined') {
    taskCnt = taskCnt + 1;
    return 'task' + taskCnt;
  }

  return idStr;
}; // id, startDate, endDate
// id, startDate, length
// id, after x, endDate
// id, after x, length
// startDate, endDate
// startDate, length
// after x, endDate
// after x, length
// endDate
// length


var compileData = function compileData(prevTask, dataStr) {
  var ds;

  if (dataStr.substr(0, 1) === ':') {
    ds = dataStr.substr(1, dataStr.length);
  } else {
    ds = dataStr;
  }

  var data = ds.split(',');
  var task = {}; // Get tags like active, done, crit and milestone

  getTaskTags(data, task, tags);

  for (var i = 0; i < data.length; i++) {
    data[i] = data[i].trim();
  }

  var endTimeData = '';

  switch (data.length) {
    case 1:
      task.id = parseId();
      task.startTime = prevTask.endTime;
      endTimeData = data[0];
      break;

    case 2:
      task.id = parseId();
      task.startTime = getStartDate(undefined, dateFormat, data[0]);
      endTimeData = data[1];
      break;

    case 3:
      task.id = parseId(data[0]);
      task.startTime = getStartDate(undefined, dateFormat, data[1]);
      endTimeData = data[2];
      break;

    default:
  }

  if (endTimeData) {
    task.endTime = getEndDate(task.startTime, dateFormat, endTimeData, inclusiveEndDates);
    task.manualEndTime = moment_mini__WEBPACK_IMPORTED_MODULE_0___default()(endTimeData, 'YYYY-MM-DD', true).isValid();
    checkTaskDates(task, dateFormat, excludes);
  }

  return task;
};

var parseData = function parseData(prevTaskId, dataStr) {
  var ds;

  if (dataStr.substr(0, 1) === ':') {
    ds = dataStr.substr(1, dataStr.length);
  } else {
    ds = dataStr;
  }

  var data = ds.split(',');
  var task = {}; // Get tags like active, done, crit and milestone

  getTaskTags(data, task, tags);

  for (var i = 0; i < data.length; i++) {
    data[i] = data[i].trim();
  }

  switch (data.length) {
    case 1:
      task.id = parseId();
      task.startTime = {
        type: 'prevTaskEnd',
        id: prevTaskId
      };
      task.endTime = {
        data: data[0]
      };
      break;

    case 2:
      task.id = parseId();
      task.startTime = {
        type: 'getStartDate',
        startData: data[0]
      };
      task.endTime = {
        data: data[1]
      };
      break;

    case 3:
      task.id = parseId(data[0]);
      task.startTime = {
        type: 'getStartDate',
        startData: data[1]
      };
      task.endTime = {
        data: data[2]
      };
      break;

    default:
  }

  return task;
};

var lastTask;
var lastTaskID;
var rawTasks = [];
var taskDb = {};
var addTask = function addTask(descr, data) {
  var rawTask = {
    section: currentSection,
    type: currentSection,
    processed: false,
    manualEndTime: false,
    renderEndTime: null,
    raw: {
      data: data
    },
    task: descr,
    classes: []
  };
  var taskInfo = parseData(lastTaskID, data);
  rawTask.raw.startTime = taskInfo.startTime;
  rawTask.raw.endTime = taskInfo.endTime;
  rawTask.id = taskInfo.id;
  rawTask.prevTaskId = lastTaskID;
  rawTask.active = taskInfo.active;
  rawTask.done = taskInfo.done;
  rawTask.crit = taskInfo.crit;
  rawTask.milestone = taskInfo.milestone;
  rawTask.order = lastOrder;
  lastOrder++;
  var pos = rawTasks.push(rawTask);
  lastTaskID = rawTask.id; // Store cross ref

  taskDb[rawTask.id] = pos - 1;
};
var findTaskById = function findTaskById(id) {
  var pos = taskDb[id];
  return rawTasks[pos];
};
var addTaskOrg = function addTaskOrg(descr, data) {
  var newTask = {
    section: currentSection,
    type: currentSection,
    description: descr,
    task: descr,
    classes: []
  };
  var taskInfo = compileData(lastTask, data);
  newTask.startTime = taskInfo.startTime;
  newTask.endTime = taskInfo.endTime;
  newTask.id = taskInfo.id;
  newTask.active = taskInfo.active;
  newTask.done = taskInfo.done;
  newTask.crit = taskInfo.crit;
  newTask.milestone = taskInfo.milestone;
  lastTask = newTask;
  tasks.push(newTask);
};

var compileTasks = function compileTasks() {
  var compileTask = function compileTask(pos) {
    var task = rawTasks[pos];
    var startTime = '';

    switch (rawTasks[pos].raw.startTime.type) {
      case 'prevTaskEnd':
        {
          var prevTask = findTaskById(task.prevTaskId);
          task.startTime = prevTask.endTime;
          break;
        }

      case 'getStartDate':
        startTime = getStartDate(undefined, dateFormat, rawTasks[pos].raw.startTime.startData);

        if (startTime) {
          rawTasks[pos].startTime = startTime;
        }

        break;
    }

    if (rawTasks[pos].startTime) {
      rawTasks[pos].endTime = getEndDate(rawTasks[pos].startTime, dateFormat, rawTasks[pos].raw.endTime.data, inclusiveEndDates);

      if (rawTasks[pos].endTime) {
        rawTasks[pos].processed = true;
        rawTasks[pos].manualEndTime = moment_mini__WEBPACK_IMPORTED_MODULE_0___default()(rawTasks[pos].raw.endTime.data, 'YYYY-MM-DD', true).isValid();
        checkTaskDates(rawTasks[pos], dateFormat, excludes);
      }
    }

    return rawTasks[pos].processed;
  };

  var allProcessed = true;

  for (var i = 0; i < rawTasks.length; i++) {
    compileTask(i);
    allProcessed = allProcessed && rawTasks[i].processed;
  }

  return allProcessed;
};
/**
 * Called by parser when a link is found. Adds the URL to the vertex data.
 * @param ids Comma separated list of ids
 * @param linkStr URL to create a link for
 */


var setLink = function setLink(ids, _linkStr) {
  var linkStr = _linkStr;

  if (_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"]().securityLevel !== 'loose') {
    linkStr = Object(_braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_1__["sanitizeUrl"])(_linkStr);
  }

  ids.split(',').forEach(function (id) {
    var rawTask = findTaskById(id);

    if (typeof rawTask !== 'undefined') {
      pushFun(id, function () {
        window.open(linkStr, '_self');
      });
    }
  });
  setClass(ids, 'clickable');
};
/**
 * Called by parser when a special node is found, e.g. a clickable element.
 * @param ids Comma separated list of ids
 * @param className Class to add
 */

var setClass = function setClass(ids, className) {
  ids.split(',').forEach(function (id) {
    var rawTask = findTaskById(id);

    if (typeof rawTask !== 'undefined') {
      rawTask.classes.push(className);
    }
  });
};

var setClickFun = function setClickFun(id, functionName, functionArgs) {
  if (_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"]().securityLevel !== 'loose') {
    return;
  }

  if (typeof functionName === 'undefined') {
    return;
  }

  var argList = [];

  if (typeof functionArgs === 'string') {
    /* Splits functionArgs by ',', ignoring all ',' in double quoted strings */
    argList = functionArgs.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);

    for (var i = 0; i < argList.length; i++) {
      var item = argList[i].trim();
      /* Removes all double quotes at the start and end of an argument */

      /* This preserves all starting and ending whitespace inside */

      if (item.charAt(0) === '"' && item.charAt(item.length - 1) === '"') {
        item = item.substr(1, item.length - 2);
      }

      argList[i] = item;
    }
  }
  /* if no arguments passed into callback, default to passing in id */


  if (argList.length === 0) {
    argList.push(id);
  }

  var rawTask = findTaskById(id);

  if (typeof rawTask !== 'undefined') {
    pushFun(id, function () {
      _utils__WEBPACK_IMPORTED_MODULE_4__["default"].runFunc.apply(_utils__WEBPACK_IMPORTED_MODULE_4__["default"], [functionName].concat(_toConsumableArray(argList)));
    });
  }
};
/**
 * The callbackFunction is executed in a click event bound to the task with the specified id or the task's assigned text
 * @param id The task's id
 * @param callbackFunction A function to be executed when clicked on the task or the task's text
 */


var pushFun = function pushFun(id, callbackFunction) {
  funs.push(function () {
    // const elem = d3.select(element).select(`[id="${id}"]`)
    var elem = document.querySelector("[id=\"".concat(id, "\"]"));

    if (elem !== null) {
      elem.addEventListener('click', function () {
        callbackFunction();
      });
    }
  });
  funs.push(function () {
    // const elem = d3.select(element).select(`[id="${id}-text"]`)
    var elem = document.querySelector("[id=\"".concat(id, "-text\"]"));

    if (elem !== null) {
      elem.addEventListener('click', function () {
        callbackFunction();
      });
    }
  });
};
/**
 * Called by parser when a click definition is found. Registers an event handler.
 * @param ids Comma separated list of ids
 * @param functionName Function to be called on click
 * @param functionArgs Function args the function should be called with
 */


var setClickEvent = function setClickEvent(ids, functionName, functionArgs) {
  ids.split(',').forEach(function (id) {
    setClickFun(id, functionName, functionArgs);
  });
  setClass(ids, 'clickable');
};
/**
 * Binds all functions previously added to fun (specified through click) to the element
 * @param element
 */

var bindFunctions = function bindFunctions(element) {
  funs.forEach(function (fun) {
    fun(element);
  });
};
/* harmony default export */ __webpack_exports__["default"] = ({
  parseDirective: parseDirective,
  getConfig: function getConfig() {
    return _config__WEBPACK_IMPORTED_MODULE_3__["getConfig"]().gantt;
  },
  clear: clear,
  setDateFormat: setDateFormat,
  getDateFormat: getDateFormat,
  enableInclusiveEndDates: enableInclusiveEndDates,
  endDatesAreInclusive: endDatesAreInclusive,
  enableTopAxis: enableTopAxis,
  topAxisEnabled: topAxisEnabled,
  setAxisFormat: setAxisFormat,
  getAxisFormat: getAxisFormat,
  setTodayMarker: setTodayMarker,
  getTodayMarker: getTodayMarker,
  setTitle: setTitle,
  getTitle: getTitle,
  addSection: addSection,
  getSections: getSections,
  getTasks: getTasks,
  addTask: addTask,
  findTaskById: findTaskById,
  addTaskOrg: addTaskOrg,
  setExcludes: setExcludes,
  getExcludes: getExcludes,
  setClickEvent: setClickEvent,
  setLink: setLink,
  bindFunctions: bindFunctions,
  durationToDate: durationToDate
});

function getTaskTags(data, task, tags) {
  var matchFound = true;

  while (matchFound) {
    matchFound = false;
    tags.forEach(function (t) {
      var pattern = '^\\s*' + t + '\\s*$';
      var regex = new RegExp(pattern);

      if (data[0].match(regex)) {
        task[t] = true;
        data.shift(1);
        matchFound = true;
      }
    });
  }
}

/***/ }),

/***/ "./src/diagrams/gantt/ganttRenderer.js":
/*!*********************************************!*\
  !*** ./src/diagrams/gantt/ganttRenderer.js ***!
  \*********************************************/
/*! exports provided: setConf, draw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConf", function() { return setConf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return draw; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _parser_gantt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parser/gantt */ "./src/diagrams/gantt/parser/gantt.jison");
/* harmony import */ var _parser_gantt__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_parser_gantt__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/common */ "./src/diagrams/common/common.js");
/* harmony import */ var _ganttDb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ganttDb */ "./src/diagrams/gantt/ganttDb.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");






_parser_gantt__WEBPACK_IMPORTED_MODULE_1__["parser"].yy = _ganttDb__WEBPACK_IMPORTED_MODULE_3__["default"];
var setConf = function setConf() {// const keys = Object.keys(cnf);
  // keys.forEach(function(key) {
  //   conf[key] = cnf[key];
  // });
};
var w;
var draw = function draw(text, id) {
  var conf = Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().gantt;
  _parser_gantt__WEBPACK_IMPORTED_MODULE_1__["parser"].yy.clear();
  _parser_gantt__WEBPACK_IMPORTED_MODULE_1__["parser"].parse(text);
  var elem = document.getElementById(id);
  w = elem.parentElement.offsetWidth;

  if (typeof w === 'undefined') {
    w = 1200;
  }

  if (typeof conf.useWidth !== 'undefined') {
    w = conf.useWidth;
  }

  var taskArray = _parser_gantt__WEBPACK_IMPORTED_MODULE_1__["parser"].yy.getTasks(); // Set height based on number of tasks

  var h = taskArray.length * (conf.barHeight + conf.barGap) + 2 * conf.topPadding; // Set viewBox

  elem.setAttribute('viewBox', '0 0 ' + w + ' ' + h);
  var svg = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])("[id=\"".concat(id, "\"]")); // Set timescale

  var timeScale = Object(d3__WEBPACK_IMPORTED_MODULE_0__["scaleTime"])().domain([Object(d3__WEBPACK_IMPORTED_MODULE_0__["min"])(taskArray, function (d) {
    return d.startTime;
  }), Object(d3__WEBPACK_IMPORTED_MODULE_0__["max"])(taskArray, function (d) {
    return d.endTime;
  })]).rangeRound([0, w - conf.leftPadding - conf.rightPadding]);
  var categories = [];

  for (var i = 0; i < taskArray.length; i++) {
    categories.push(taskArray[i].type);
  }

  var catsUnfiltered = categories; // for vert labels

  categories = checkUnique(categories);

  function taskCompare(a, b) {
    var taskA = a.startTime;
    var taskB = b.startTime;
    var result = 0;

    if (taskA > taskB) {
      result = 1;
    } else if (taskA < taskB) {
      result = -1;
    }

    return result;
  } // Sort the task array using the above taskCompare() so that
  // tasks are created based on their order of startTime


  taskArray.sort(taskCompare);
  makeGant(taskArray, w, h);
  Object(_utils__WEBPACK_IMPORTED_MODULE_5__["configureSvgSize"])(svg, h, w, conf.useMaxWidth);
  svg.append('text').text(_parser_gantt__WEBPACK_IMPORTED_MODULE_1__["parser"].yy.getTitle()).attr('x', w / 2).attr('y', conf.titleTopMargin).attr('class', 'titleText');

  function makeGant(tasks, pageWidth, pageHeight) {
    var barHeight = conf.barHeight;
    var gap = barHeight + conf.barGap;
    var topPadding = conf.topPadding;
    var leftPadding = conf.leftPadding;
    var colorScale = Object(d3__WEBPACK_IMPORTED_MODULE_0__["scaleLinear"])().domain([0, categories.length]).range(['#00B9FA', '#F95002']).interpolate(d3__WEBPACK_IMPORTED_MODULE_0__["interpolateHcl"]);
    makeGrid(leftPadding, topPadding, pageWidth, pageHeight);
    drawRects(tasks, gap, topPadding, leftPadding, barHeight, colorScale, pageWidth, pageHeight);
    vertLabels(gap, topPadding, leftPadding, barHeight, colorScale);
    drawToday(leftPadding, topPadding, pageWidth, pageHeight);
  }

  function drawRects(theArray, theGap, theTopPad, theSidePad, theBarHeight, theColorScale, w) {
    // Draw background rects covering the entire width of the graph, these form the section rows.
    svg.append('g').selectAll('rect').data(theArray).enter().append('rect').attr('x', 0).attr('y', function (d, i) {
      // Ignore the incoming i value and use our order instead
      i = d.order;
      return i * theGap + theTopPad - 2;
    }).attr('width', function () {
      return w - conf.rightPadding / 2;
    }).attr('height', theGap).attr('class', function (d) {
      for (var _i = 0; _i < categories.length; _i++) {
        if (d.type === categories[_i]) {
          return 'section section' + _i % conf.numberSectionStyles;
        }
      }

      return 'section section0';
    }); // Draw the rects representing the tasks

    var rectangles = svg.append('g').selectAll('rect').data(theArray).enter();
    rectangles.append('rect').attr('id', function (d) {
      return d.id;
    }).attr('rx', 3).attr('ry', 3).attr('x', function (d) {
      if (d.milestone) {
        return timeScale(d.startTime) + theSidePad + 0.5 * (timeScale(d.endTime) - timeScale(d.startTime)) - 0.5 * theBarHeight;
      }

      return timeScale(d.startTime) + theSidePad;
    }).attr('y', function (d, i) {
      // Ignore the incoming i value and use our order instead
      i = d.order;
      return i * theGap + theTopPad;
    }).attr('width', function (d) {
      if (d.milestone) {
        return theBarHeight;
      }

      return timeScale(d.renderEndTime || d.endTime) - timeScale(d.startTime);
    }).attr('height', theBarHeight).attr('transform-origin', function (d, i) {
      // Ignore the incoming i value and use our order instead
      i = d.order;
      return (timeScale(d.startTime) + theSidePad + 0.5 * (timeScale(d.endTime) - timeScale(d.startTime))).toString() + 'px ' + (i * theGap + theTopPad + 0.5 * theBarHeight).toString() + 'px';
    }).attr('class', function (d) {
      var res = 'task';
      var classStr = '';

      if (d.classes.length > 0) {
        classStr = d.classes.join(' ');
      }

      var secNum = 0;

      for (var _i2 = 0; _i2 < categories.length; _i2++) {
        if (d.type === categories[_i2]) {
          secNum = _i2 % conf.numberSectionStyles;
        }
      }

      var taskClass = '';

      if (d.active) {
        if (d.crit) {
          taskClass += ' activeCrit';
        } else {
          taskClass = ' active';
        }
      } else if (d.done) {
        if (d.crit) {
          taskClass = ' doneCrit';
        } else {
          taskClass = ' done';
        }
      } else {
        if (d.crit) {
          taskClass += ' crit';
        }
      }

      if (taskClass.length === 0) {
        taskClass = ' task';
      }

      if (d.milestone) {
        taskClass = ' milestone ' + taskClass;
      }

      taskClass += secNum;
      taskClass += ' ' + classStr;
      return res + taskClass;
    }); // Append task labels

    rectangles.append('text').attr('id', function (d) {
      return d.id + '-text';
    }).text(function (d) {
      return d.task;
    }).attr('font-size', conf.fontSize).attr('x', function (d) {
      var startX = timeScale(d.startTime);
      var endX = timeScale(d.renderEndTime || d.endTime);

      if (d.milestone) {
        startX += 0.5 * (timeScale(d.endTime) - timeScale(d.startTime)) - 0.5 * theBarHeight;
      }

      if (d.milestone) {
        endX = startX + theBarHeight;
      }

      var textWidth = this.getBBox().width; // Check id text width > width of rectangle

      if (textWidth > endX - startX) {
        if (endX + textWidth + 1.5 * conf.leftPadding > w) {
          return startX + theSidePad - 5;
        } else {
          return endX + theSidePad + 5;
        }
      } else {
        return (endX - startX) / 2 + startX + theSidePad;
      }
    }).attr('y', function (d, i) {
      // Ignore the incoming i value and use our order instead
      i = d.order;
      return i * theGap + conf.barHeight / 2 + (conf.fontSize / 2 - 2) + theTopPad;
    }).attr('text-height', theBarHeight).attr('class', function (d) {
      var startX = timeScale(d.startTime);
      var endX = timeScale(d.endTime);

      if (d.milestone) {
        endX = startX + theBarHeight;
      }

      var textWidth = this.getBBox().width;
      var classStr = '';

      if (d.classes.length > 0) {
        classStr = d.classes.join(' ');
      }

      var secNum = 0;

      for (var _i3 = 0; _i3 < categories.length; _i3++) {
        if (d.type === categories[_i3]) {
          secNum = _i3 % conf.numberSectionStyles;
        }
      }

      var taskType = '';

      if (d.active) {
        if (d.crit) {
          taskType = 'activeCritText' + secNum;
        } else {
          taskType = 'activeText' + secNum;
        }
      }

      if (d.done) {
        if (d.crit) {
          taskType = taskType + ' doneCritText' + secNum;
        } else {
          taskType = taskType + ' doneText' + secNum;
        }
      } else {
        if (d.crit) {
          taskType = taskType + ' critText' + secNum;
        }
      }

      if (d.milestone) {
        taskType += ' milestoneText';
      } // Check id text width > width of rectangle


      if (textWidth > endX - startX) {
        if (endX + textWidth + 1.5 * conf.leftPadding > w) {
          return classStr + ' taskTextOutsideLeft taskTextOutside' + secNum + ' ' + taskType;
        } else {
          return classStr + ' taskTextOutsideRight taskTextOutside' + secNum + ' ' + taskType + ' width-' + textWidth;
        }
      } else {
        return classStr + ' taskText taskText' + secNum + ' ' + taskType + ' width-' + textWidth;
      }
    });
  }

  function makeGrid(theSidePad, theTopPad, w, h) {
    var bottomXAxis = Object(d3__WEBPACK_IMPORTED_MODULE_0__["axisBottom"])(timeScale).tickSize(-h + theTopPad + conf.gridLineStartPadding).tickFormat(Object(d3__WEBPACK_IMPORTED_MODULE_0__["timeFormat"])(_parser_gantt__WEBPACK_IMPORTED_MODULE_1__["parser"].yy.getAxisFormat() || conf.axisFormat || '%Y-%m-%d'));
    svg.append('g').attr('class', 'grid').attr('transform', 'translate(' + theSidePad + ', ' + (h - 50) + ')').call(bottomXAxis).selectAll('text').style('text-anchor', 'middle').attr('fill', '#000').attr('stroke', 'none').attr('font-size', 10).attr('dy', '1em');

    if (_ganttDb__WEBPACK_IMPORTED_MODULE_3__["default"].topAxisEnabled() || conf.topAxis) {
      var topXAxis = Object(d3__WEBPACK_IMPORTED_MODULE_0__["axisTop"])(timeScale).tickSize(-h + theTopPad + conf.gridLineStartPadding).tickFormat(Object(d3__WEBPACK_IMPORTED_MODULE_0__["timeFormat"])(_parser_gantt__WEBPACK_IMPORTED_MODULE_1__["parser"].yy.getAxisFormat() || conf.axisFormat || '%Y-%m-%d'));
      svg.append('g').attr('class', 'grid').attr('transform', 'translate(' + theSidePad + ', ' + theTopPad + ')').call(topXAxis).selectAll('text').style('text-anchor', 'middle').attr('fill', '#000').attr('stroke', 'none').attr('font-size', 10); // .attr('dy', '1em');
    }
  }

  function vertLabels(theGap, theTopPad) {
    var numOccurances = [];
    var prevGap = 0;

    for (var _i4 = 0; _i4 < categories.length; _i4++) {
      numOccurances[_i4] = [categories[_i4], getCount(categories[_i4], catsUnfiltered)];
    }

    svg.append('g') // without doing this, impossible to put grid lines behind text
    .selectAll('text').data(numOccurances).enter().append(function (d) {
      var rows = d[0].split(_common_common__WEBPACK_IMPORTED_MODULE_2__["default"].lineBreakRegex);
      var dy = -(rows.length - 1) / 2;
      var svgLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      svgLabel.setAttribute('dy', dy + 'em');

      for (var j = 0; j < rows.length; j++) {
        var tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
        tspan.setAttribute('alignment-baseline', 'central');
        tspan.setAttribute('x', '10');
        if (j > 0) tspan.setAttribute('dy', '1em');
        tspan.textContent = rows[j];
        svgLabel.appendChild(tspan);
      }

      return svgLabel;
    }).attr('x', 10).attr('y', function (d, i) {
      if (i > 0) {
        for (var j = 0; j < i; j++) {
          prevGap += numOccurances[i - 1][1];
          return d[1] * theGap / 2 + prevGap * theGap + theTopPad;
        }
      } else {
        return d[1] * theGap / 2 + theTopPad;
      }
    }).attr('font-size', conf.sectionFontSize).attr('font-size', conf.sectionFontSize).attr('class', function (d) {
      for (var _i5 = 0; _i5 < categories.length; _i5++) {
        if (d[0] === categories[_i5]) {
          return 'sectionTitle sectionTitle' + _i5 % conf.numberSectionStyles;
        }
      }

      return 'sectionTitle';
    });
  }

  function drawToday(theSidePad, theTopPad, w, h) {
    var todayMarker = _ganttDb__WEBPACK_IMPORTED_MODULE_3__["default"].getTodayMarker();

    if (todayMarker === 'off') {
      return;
    }

    var todayG = svg.append('g').attr('class', 'today');
    var today = new Date();
    var todayLine = todayG.append('line');
    todayLine.attr('x1', timeScale(today) + theSidePad).attr('x2', timeScale(today) + theSidePad).attr('y1', conf.titleTopMargin).attr('y2', h - conf.titleTopMargin).attr('class', 'today');

    if (todayMarker !== '') {
      todayLine.attr('style', todayMarker.replace(/,/g, ';'));
    }
  } // from this stackexchange question: http://stackoverflow.com/questions/1890203/unique-for-arrays-in-javascript


  function checkUnique(arr) {
    var hash = {};
    var result = [];

    for (var _i6 = 0, l = arr.length; _i6 < l; ++_i6) {
      if (!hash.hasOwnProperty(arr[_i6])) {
        // eslint-disable-line
        // it works with objects! in FF, at least
        hash[arr[_i6]] = true;
        result.push(arr[_i6]);
      }
    }

    return result;
  } // from this stackexchange question: http://stackoverflow.com/questions/14227981/count-how-many-strings-in-an-array-have-duplicates-in-the-same-array


  function getCounts(arr) {
    var i = arr.length; // const to loop over

    var obj = {}; // obj to store results

    while (i) {
      obj[arr[--i]] = (obj[arr[i]] || 0) + 1; // count occurrences
    }

    return obj;
  } // get specific from everything


  function getCount(word, arr) {
    return getCounts(arr)[word] || 0;
  }
};
/* harmony default export */ __webpack_exports__["default"] = ({
  setConf: setConf,
  draw: draw
});

/***/ }),

/***/ "./src/diagrams/gantt/parser/gantt.jison":
/*!***********************************************!*\
  !*** ./src/diagrams/gantt/parser/gantt.jison ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, module) {/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,3],$V1=[1,5],$V2=[7,9,11,12,13,14,15,16,17,18,19,21,28,33],$V3=[1,15],$V4=[1,16],$V5=[1,17],$V6=[1,18],$V7=[1,19],$V8=[1,20],$V9=[1,21],$Va=[1,22],$Vb=[1,24],$Vc=[1,26],$Vd=[1,29],$Ve=[5,7,9,11,12,13,14,15,16,17,18,19,21,28,33];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"start":3,"directive":4,"gantt":5,"document":6,"EOF":7,"line":8,"SPACE":9,"statement":10,"NL":11,"dateFormat":12,"inclusiveEndDates":13,"topAxis":14,"axisFormat":15,"excludes":16,"todayMarker":17,"title":18,"section":19,"clickStatement":20,"taskTxt":21,"taskData":22,"openDirective":23,"typeDirective":24,"closeDirective":25,":":26,"argDirective":27,"click":28,"callbackname":29,"callbackargs":30,"href":31,"clickStatementDebug":32,"open_directive":33,"type_directive":34,"arg_directive":35,"close_directive":36,"$accept":0,"$end":1},
terminals_: {2:"error",5:"gantt",7:"EOF",9:"SPACE",11:"NL",12:"dateFormat",13:"inclusiveEndDates",14:"topAxis",15:"axisFormat",16:"excludes",17:"todayMarker",18:"title",19:"section",21:"taskTxt",22:"taskData",26:":",28:"click",29:"callbackname",30:"callbackargs",31:"href",33:"open_directive",34:"type_directive",35:"arg_directive",36:"close_directive"},
productions_: [0,[3,2],[3,3],[6,0],[6,2],[8,2],[8,1],[8,1],[8,1],[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[10,1],[10,2],[10,1],[4,4],[4,6],[20,2],[20,3],[20,3],[20,4],[20,3],[20,4],[20,2],[32,2],[32,3],[32,3],[32,4],[32,3],[32,4],[32,2],[23,1],[24,1],[27,1],[25,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 2:
 return $$[$0-1]; 
break;
case 3:
 this.$ = [] 
break;
case 4:
$$[$0-1].push($$[$0]);this.$ = $$[$0-1]
break;
case 5: case 6:
 this.$ = $$[$0] 
break;
case 7: case 8:
 this.$=[];
break;
case 9:
yy.setDateFormat($$[$0].substr(11));this.$=$$[$0].substr(11);
break;
case 10:
yy.enableInclusiveEndDates();this.$=$$[$0].substr(18);
break;
case 11:
yy.TopAxis();this.$=$$[$0].substr(8);
break;
case 12:
yy.setAxisFormat($$[$0].substr(11));this.$=$$[$0].substr(11);
break;
case 13:
yy.setExcludes($$[$0].substr(9));this.$=$$[$0].substr(9);
break;
case 14:
yy.setTodayMarker($$[$0].substr(12));this.$=$$[$0].substr(12);
break;
case 15:
yy.setTitle($$[$0].substr(6));this.$=$$[$0].substr(6);
break;
case 16:
yy.addSection($$[$0].substr(8));this.$=$$[$0].substr(8);
break;
case 18:
yy.addTask($$[$0-1],$$[$0]);this.$='task';
break;
case 22:
this.$ = $$[$0-1];yy.setClickEvent($$[$0-1], $$[$0], null);
break;
case 23:
this.$ = $$[$0-2];yy.setClickEvent($$[$0-2], $$[$0-1], $$[$0]);
break;
case 24:
this.$ = $$[$0-2];yy.setClickEvent($$[$0-2], $$[$0-1], null);yy.setLink($$[$0-2],$$[$0]);
break;
case 25:
this.$ = $$[$0-3];yy.setClickEvent($$[$0-3], $$[$0-2], $$[$0-1]);yy.setLink($$[$0-3],$$[$0]);
break;
case 26:
this.$ = $$[$0-2];yy.setClickEvent($$[$0-2], $$[$0], null);yy.setLink($$[$0-2],$$[$0-1]);
break;
case 27:
this.$ = $$[$0-3];yy.setClickEvent($$[$0-3], $$[$0-1], $$[$0]);yy.setLink($$[$0-3],$$[$0-2]);
break;
case 28:
this.$ = $$[$0-1];yy.setLink($$[$0-1], $$[$0]);
break;
case 29: case 35:
this.$=$$[$0-1] + ' ' + $$[$0];
break;
case 30: case 31: case 33:
this.$=$$[$0-2] + ' ' + $$[$0-1] + ' ' + $$[$0];
break;
case 32: case 34:
this.$=$$[$0-3] + ' ' + $$[$0-2] + ' ' + $$[$0-1] + ' ' + $$[$0];
break;
case 36:
 yy.parseDirective('%%{', 'open_directive'); 
break;
case 37:
 yy.parseDirective($$[$0], 'type_directive'); 
break;
case 38:
 $$[$0] = $$[$0].trim().replace(/'/g, '"'); yy.parseDirective($$[$0], 'arg_directive'); 
break;
case 39:
 yy.parseDirective('}%%', 'close_directive', 'gantt'); 
break;
}
},
table: [{3:1,4:2,5:$V0,23:4,33:$V1},{1:[3]},{3:6,4:2,5:$V0,23:4,33:$V1},o($V2,[2,3],{6:7}),{24:8,34:[1,9]},{34:[2,36]},{1:[2,1]},{4:25,7:[1,10],8:11,9:[1,12],10:13,11:[1,14],12:$V3,13:$V4,14:$V5,15:$V6,16:$V7,17:$V8,18:$V9,19:$Va,20:23,21:$Vb,23:4,28:$Vc,33:$V1},{25:27,26:[1,28],36:$Vd},o([26,36],[2,37]),o($V2,[2,8],{1:[2,2]}),o($V2,[2,4]),{4:25,10:30,12:$V3,13:$V4,14:$V5,15:$V6,16:$V7,17:$V8,18:$V9,19:$Va,20:23,21:$Vb,23:4,28:$Vc,33:$V1},o($V2,[2,6]),o($V2,[2,7]),o($V2,[2,9]),o($V2,[2,10]),o($V2,[2,11]),o($V2,[2,12]),o($V2,[2,13]),o($V2,[2,14]),o($V2,[2,15]),o($V2,[2,16]),o($V2,[2,17]),{22:[1,31]},o($V2,[2,19]),{29:[1,32],31:[1,33]},{11:[1,34]},{27:35,35:[1,36]},{11:[2,39]},o($V2,[2,5]),o($V2,[2,18]),o($V2,[2,22],{30:[1,37],31:[1,38]}),o($V2,[2,28],{29:[1,39]}),o($Ve,[2,20]),{25:40,36:$Vd},{36:[2,38]},o($V2,[2,23],{31:[1,41]}),o($V2,[2,24]),o($V2,[2,26],{30:[1,42]}),{11:[1,43]},o($V2,[2,25]),o($V2,[2,27]),o($Ve,[2,21])],
defaultActions: {5:[2,36],6:[2,1],29:[2,39],36:[2,38]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
            function lex() {
            var token;
            token = tstack.pop() || lexer.lex() || EOF;
            if (typeof token !== 'number') {
                if (token instanceof Array) {
                    tstack = token;
                    token = tstack.pop();
                }
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
        if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];
            for (p in table[state]) {
                if (this.terminals_[p] && p > TERROR) {
                    expected.push('\'' + this.terminals_[p] + '\'');
                }
            }
            if (lexer.showPosition) {
                errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
                errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }
            this.parseError(errStr, {
                text: lexer.match,
                token: this.terminals_[symbol] || symbol,
                line: lexer.yylineno,
                loc: yyloc,
                expected: expected
            });
        }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {"case-insensitive":true},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0: this.begin('open_directive'); return 33; 
break;
case 1: this.begin('type_directive'); return 34; 
break;
case 2: this.popState(); this.begin('arg_directive'); return 26; 
break;
case 3: this.popState(); this.popState(); return 36; 
break;
case 4:return 35;
break;
case 5:/* skip comments */
break;
case 6:/* skip comments */
break;
case 7:/* do nothing */
break;
case 8:return 11;
break;
case 9:/* skip whitespace */
break;
case 10:/* skip comments */
break;
case 11:/* skip comments */
break;
case 12:this.begin("href");
break;
case 13:this.popState();
break;
case 14:return 31;
break;
case 15:this.begin("callbackname");
break;
case 16:this.popState();
break;
case 17:this.popState(); this.begin("callbackargs");
break;
case 18:return 29;
break;
case 19:this.popState();
break;
case 20:return 30;
break;
case 21:this.begin("click");
break;
case 22:this.popState();
break;
case 23:return 28;
break;
case 24:return 5;
break;
case 25:return 12;
break;
case 26:return 13;
break;
case 27:return 14;
break;
case 28:return 15;
break;
case 29:return 16;
break;
case 30:return 17;
break;
case 31:return 'date';
break;
case 32:return 18;
break;
case 33:return 19;
break;
case 34:return 21;
break;
case 35:return 22;
break;
case 36:return 26;
break;
case 37:return 7;
break;
case 38:return 'INVALID';
break;
}
},
rules: [/^(?:%%\{)/i,/^(?:((?:(?!\}%%)[^:.])*))/i,/^(?::)/i,/^(?:\}%%)/i,/^(?:((?:(?!\}%%).|\n)*))/i,/^(?:%%(?!\{)*[^\n]*)/i,/^(?:[^\}]%%*[^\n]*)/i,/^(?:%%*[^\n]*[\n]*)/i,/^(?:[\n]+)/i,/^(?:\s+)/i,/^(?:#[^\n]*)/i,/^(?:%[^\n]*)/i,/^(?:href[\s]+["])/i,/^(?:["])/i,/^(?:[^"]*)/i,/^(?:call[\s]+)/i,/^(?:\([\s]*\))/i,/^(?:\()/i,/^(?:[^(]*)/i,/^(?:\))/i,/^(?:[^)]*)/i,/^(?:click[\s]+)/i,/^(?:[\s\n])/i,/^(?:[^\s\n]*)/i,/^(?:gantt\b)/i,/^(?:dateFormat\s[^#\n;]+)/i,/^(?:inclusiveEndDates\b)/i,/^(?:topAxis\b)/i,/^(?:axisFormat\s[^#\n;]+)/i,/^(?:excludes\s[^#\n;]+)/i,/^(?:todayMarker\s[^\n;]+)/i,/^(?:\d\d\d\d-\d\d-\d\d\b)/i,/^(?:title\s[^#\n;]+)/i,/^(?:section\s[^#:\n;]+)/i,/^(?:[^#:\n;]+)/i,/^(?::[^#\n;]+)/i,/^(?::)/i,/^(?:$)/i,/^(?:.)/i],
conditions: {"close_directive":{"rules":[],"inclusive":false},"arg_directive":{"rules":[3,4],"inclusive":false},"type_directive":{"rules":[2,3],"inclusive":false},"open_directive":{"rules":[1],"inclusive":false},"callbackargs":{"rules":[19,20],"inclusive":false},"callbackname":{"rules":[16,17,18],"inclusive":false},"href":{"rules":[13,14],"inclusive":false},"click":{"rules":[22,23],"inclusive":false},"INITIAL":{"rules":[0,5,6,7,8,9,10,11,12,15,21,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (true) {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js").readFileSync(__webpack_require__(/*! path */ "./node_modules/path-browserify/index.js").normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if ( true && __webpack_require__.c[__webpack_require__.s] === module) {
  exports.main(process.argv.slice(1));
}
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/diagrams/gantt/styles.js":
/*!**************************************!*\
  !*** ./src/diagrams/gantt/styles.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var getStyles = function getStyles(options) {
  return "\n  .mermaid-main-font {\n    font-family: \"trebuchet ms\", verdana, arial, sans-serif;\n    font-family: var(--mermaid-font-family);\n  }\n\n  .section {\n    stroke: none;\n    opacity: 0.2;\n  }\n\n  .section0 {\n    fill: ".concat(options.sectionBkgColor, ";\n  }\n\n  .section2 {\n    fill: ").concat(options.sectionBkgColor2, ";\n  }\n\n  .section1,\n  .section3 {\n    fill: ").concat(options.altSectionBkgColor, ";\n    opacity: 0.2;\n  }\n\n  .sectionTitle0 {\n    fill: ").concat(options.titleColor, ";\n  }\n\n  .sectionTitle1 {\n    fill: ").concat(options.titleColor, ";\n  }\n\n  .sectionTitle2 {\n    fill: ").concat(options.titleColor, ";\n  }\n\n  .sectionTitle3 {\n    fill: ").concat(options.titleColor, ";\n  }\n\n  .sectionTitle {\n    text-anchor: start;\n    // font-size: ").concat(options.ganttFontSize, ";\n    // text-height: 14px;\n    font-family: 'trebuchet ms', verdana, arial, sans-serif;\n    font-family: var(--mermaid-font-family);\n\n  }\n\n\n  /* Grid and axis */\n\n  .grid .tick {\n    stroke: ").concat(options.gridColor, ";\n    opacity: 0.8;\n    shape-rendering: crispEdges;\n    text {\n      font-family: ").concat(options.fontFamily, ";\n      fill: ").concat(options.textColor, ";\n    }\n  }\n\n  .grid path {\n    stroke-width: 0;\n  }\n\n\n  /* Today line */\n\n  .today {\n    fill: none;\n    stroke: ").concat(options.todayLineColor, ";\n    stroke-width: 2px;\n  }\n\n\n  /* Task styling */\n\n  /* Default task */\n\n  .task {\n    stroke-width: 2;\n  }\n\n  .taskText {\n    text-anchor: middle;\n    font-family: 'trebuchet ms', verdana, arial, sans-serif;\n    font-family: var(--mermaid-font-family);\n  }\n\n  // .taskText:not([font-size]) {\n  //   font-size: ").concat(options.ganttFontSize, ";\n  // }\n\n  .taskTextOutsideRight {\n    fill: ").concat(options.taskTextDarkColor, ";\n    text-anchor: start;\n    // font-size: ").concat(options.ganttFontSize, ";\n    font-family: 'trebuchet ms', verdana, arial, sans-serif;\n    font-family: var(--mermaid-font-family);\n\n  }\n\n  .taskTextOutsideLeft {\n    fill: ").concat(options.taskTextDarkColor, ";\n    text-anchor: end;\n    // font-size: ").concat(options.ganttFontSize, ";\n  }\n\n  /* Special case clickable */\n  .task.clickable {\n    cursor: pointer;\n  }\n  .taskText.clickable {\n    cursor: pointer;\n    fill: ").concat(options.taskTextClickableColor, " !important;\n    font-weight: bold;\n  }\n\n  .taskTextOutsideLeft.clickable {\n    cursor: pointer;\n    fill: ").concat(options.taskTextClickableColor, " !important;\n    font-weight: bold;\n  }\n\n  .taskTextOutsideRight.clickable {\n    cursor: pointer;\n    fill: ").concat(options.taskTextClickableColor, " !important;\n    font-weight: bold;\n  }\n\n  /* Specific task settings for the sections*/\n\n  .taskText0,\n  .taskText1,\n  .taskText2,\n  .taskText3 {\n    fill: ").concat(options.taskTextColor, ";\n  }\n\n  .task0,\n  .task1,\n  .task2,\n  .task3 {\n    fill: ").concat(options.taskBkgColor, ";\n    stroke: ").concat(options.taskBorderColor, ";\n  }\n\n  .taskTextOutside0,\n  .taskTextOutside2\n  {\n    fill: ").concat(options.taskTextOutsideColor, ";\n  }\n\n  .taskTextOutside1,\n  .taskTextOutside3 {\n    fill: ").concat(options.taskTextOutsideColor, ";\n  }\n\n\n  /* Active task */\n\n  .active0,\n  .active1,\n  .active2,\n  .active3 {\n    fill: ").concat(options.activeTaskBkgColor, ";\n    stroke: ").concat(options.activeTaskBorderColor, ";\n  }\n\n  .activeText0,\n  .activeText1,\n  .activeText2,\n  .activeText3 {\n    fill: ").concat(options.taskTextDarkColor, " !important;\n  }\n\n\n  /* Completed task */\n\n  .done0,\n  .done1,\n  .done2,\n  .done3 {\n    stroke: ").concat(options.doneTaskBorderColor, ";\n    fill: ").concat(options.doneTaskBkgColor, ";\n    stroke-width: 2;\n  }\n\n  .doneText0,\n  .doneText1,\n  .doneText2,\n  .doneText3 {\n    fill: ").concat(options.taskTextDarkColor, " !important;\n  }\n\n\n  /* Tasks on the critical line */\n\n  .crit0,\n  .crit1,\n  .crit2,\n  .crit3 {\n    stroke: ").concat(options.critBorderColor, ";\n    fill: ").concat(options.critBkgColor, ";\n    stroke-width: 2;\n  }\n\n  .activeCrit0,\n  .activeCrit1,\n  .activeCrit2,\n  .activeCrit3 {\n    stroke: ").concat(options.critBorderColor, ";\n    fill: ").concat(options.activeTaskBkgColor, ";\n    stroke-width: 2;\n  }\n\n  .doneCrit0,\n  .doneCrit1,\n  .doneCrit2,\n  .doneCrit3 {\n    stroke: ").concat(options.critBorderColor, ";\n    fill: ").concat(options.doneTaskBkgColor, ";\n    stroke-width: 2;\n    cursor: pointer;\n    shape-rendering: crispEdges;\n  }\n\n  .milestone {\n    transform: rotate(45deg) scale(0.8,0.8);\n  }\n\n  .milestoneText {\n    font-style: italic;\n  }\n  .doneCritText0,\n  .doneCritText1,\n  .doneCritText2,\n  .doneCritText3 {\n    fill: ").concat(options.taskTextDarkColor, " !important;\n  }\n\n  .activeCritText0,\n  .activeCritText1,\n  .activeCritText2,\n  .activeCritText3 {\n    fill: ").concat(options.taskTextDarkColor, " !important;\n  }\n\n  .titleText {\n    text-anchor: middle;\n    font-size: 18px;\n    fill: ").concat(options.textColor, "    ;\n    font-family: 'trebuchet ms', verdana, arial, sans-serif;\n    font-family: var(--mermaid-font-family);\n  }\n");
};

/* harmony default export */ __webpack_exports__["default"] = (getStyles);

/***/ }),

/***/ "./src/diagrams/git/gitGraphAst.js":
/*!*****************************************!*\
  !*** ./src/diagrams/git/gitGraphAst.js ***!
  \*****************************************/
/*! exports provided: setDirection, setOptions, getOptions, commit, branch, merge, checkout, reset, prettyPrint, clear, getBranchesAsObjArray, getBranches, getCommits, getCommitsArray, getCurrentBranch, getDirection, getHead, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDirection", function() { return setDirection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setOptions", function() { return setOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOptions", function() { return getOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "commit", function() { return commit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "branch", function() { return branch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkout", function() { return checkout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reset", function() { return reset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prettyPrint", function() { return prettyPrint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBranchesAsObjArray", function() { return getBranchesAsObjArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBranches", function() { return getBranches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCommits", function() { return getCommits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCommitsArray", function() { return getCommitsArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCurrentBranch", function() { return getCurrentBranch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDirection", function() { return getDirection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHead", function() { return getHead; });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");


var commits = {};
var head = null;
var branches = {
  master: head
};
var curBranch = 'master';
var direction = 'LR';
var seq = 0;

function getId() {
  return Object(_utils__WEBPACK_IMPORTED_MODULE_1__["random"])({
    length: 7
  });
}

function isfastforwardable(currentCommit, otherCommit) {
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Entering isfastforwardable:', currentCommit.id, otherCommit.id);

  while (currentCommit.seq <= otherCommit.seq && currentCommit !== otherCommit) {
    // only if other branch has more commits
    if (otherCommit.parent == null) break;

    if (Array.isArray(otherCommit.parent)) {
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('In merge commit:', otherCommit.parent);
      return isfastforwardable(currentCommit, commits[otherCommit.parent[0]]) || isfastforwardable(currentCommit, commits[otherCommit.parent[1]]);
    } else {
      otherCommit = commits[otherCommit.parent];
    }
  }

  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug(currentCommit.id, otherCommit.id);
  return currentCommit.id === otherCommit.id;
}

function isReachableFrom(currentCommit, otherCommit) {
  var currentSeq = currentCommit.seq;
  var otherSeq = otherCommit.seq;
  if (currentSeq > otherSeq) return isfastforwardable(otherCommit, currentCommit);
  return false;
}

function uniqBy(list, fn) {
  var recordMap = Object.create(null);
  return list.reduce(function (out, item) {
    var key = fn(item);

    if (!recordMap[key]) {
      recordMap[key] = true;
      out.push(item);
    }

    return out;
  }, []);
}

var setDirection = function setDirection(dir) {
  direction = dir;
};
var options = {};
var setOptions = function setOptions(rawOptString) {
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('options str', rawOptString);
  rawOptString = rawOptString && rawOptString.trim();
  rawOptString = rawOptString || '{}';

  try {
    options = JSON.parse(rawOptString);
  } catch (e) {
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].error('error while parsing gitGraph options', e.message);
  }
};
var getOptions = function getOptions() {
  return options;
};
var commit = function commit(msg) {
  var commit = {
    id: getId(),
    message: msg,
    seq: seq++,
    parent: head == null ? null : head.id
  };
  head = commit;
  commits[commit.id] = commit;
  branches[curBranch] = commit.id;
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('in pushCommit ' + commit.id);
};
var branch = function branch(name) {
  branches[name] = head != null ? head.id : null;
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('in createBranch');
};
var merge = function merge(otherBranch) {
  var currentCommit = commits[branches[curBranch]];
  var otherCommit = commits[branches[otherBranch]];

  if (isReachableFrom(currentCommit, otherCommit)) {
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Already merged');
    return;
  }

  if (isfastforwardable(currentCommit, otherCommit)) {
    branches[curBranch] = branches[otherBranch];
    head = commits[branches[curBranch]];
  } else {
    // create merge commit
    var _commit = {
      id: getId(),
      message: 'merged branch ' + otherBranch + ' into ' + curBranch,
      seq: seq++,
      parent: [head == null ? null : head.id, branches[otherBranch]]
    };
    head = _commit;
    commits[_commit.id] = _commit;
    branches[curBranch] = _commit.id;
  }

  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug(branches);
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('in mergeBranch');
};
var checkout = function checkout(branch) {
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('in checkout');
  curBranch = branch;
  var id = branches[curBranch];
  head = commits[id];
};
var reset = function reset(commitRef) {
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('in reset', commitRef);
  var ref = commitRef.split(':')[0];
  var parentCount = parseInt(commitRef.split(':')[1]);
  var commit = ref === 'HEAD' ? head : commits[branches[ref]];
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug(commit, parentCount);

  while (parentCount > 0) {
    commit = commits[commit.parent];
    parentCount--;

    if (!commit) {
      var err = 'Critical error - unique parent commit not found during reset';
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].error(err);
      throw err;
    }
  }

  head = commit;
  branches[curBranch] = commit.id;
};

function upsert(arr, key, newval) {
  var index = arr.indexOf(key);

  if (index === -1) {
    arr.push(newval);
  } else {
    arr.splice(index, 1, newval);
  }
}

function prettyPrintCommitHistory(commitArr) {
  var commit = commitArr.reduce(function (out, commit) {
    if (out.seq > commit.seq) return out;
    return commit;
  }, commitArr[0]);
  var line = '';
  commitArr.forEach(function (c) {
    if (c === commit) {
      line += '\t*';
    } else {
      line += '\t|';
    }
  });
  var label = [line, commit.id, commit.seq];

  for (var _branch in branches) {
    if (branches[_branch] === commit.id) label.push(_branch);
  }

  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug(label.join(' '));

  if (Array.isArray(commit.parent)) {
    var newCommit = commits[commit.parent[0]];
    upsert(commitArr, commit, newCommit);
    commitArr.push(commits[commit.parent[1]]);
  } else if (commit.parent == null) {
    return;
  } else {
    var nextCommit = commits[commit.parent];
    upsert(commitArr, commit, nextCommit);
  }

  commitArr = uniqBy(commitArr, function (c) {
    return c.id;
  });
  prettyPrintCommitHistory(commitArr);
}

var prettyPrint = function prettyPrint() {
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug(commits);
  var node = getCommitsArray()[0];
  prettyPrintCommitHistory([node]);
};
var clear = function clear() {
  commits = {};
  head = null;
  branches = {
    master: head
  };
  curBranch = 'master';
  seq = 0;
};
var getBranchesAsObjArray = function getBranchesAsObjArray() {
  var branchArr = [];

  for (var _branch2 in branches) {
    branchArr.push({
      name: _branch2,
      commit: commits[branches[_branch2]]
    });
  }

  return branchArr;
};
var getBranches = function getBranches() {
  return branches;
};
var getCommits = function getCommits() {
  return commits;
};
var getCommitsArray = function getCommitsArray() {
  var commitArr = Object.keys(commits).map(function (key) {
    return commits[key];
  });
  commitArr.forEach(function (o) {
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug(o.id);
  });
  commitArr.sort(function (a, b) {
    return b.seq - a.seq;
  });
  return commitArr;
};
var getCurrentBranch = function getCurrentBranch() {
  return curBranch;
};
var getDirection = function getDirection() {
  return direction;
};
var getHead = function getHead() {
  return head;
};
/* harmony default export */ __webpack_exports__["default"] = ({
  setDirection: setDirection,
  setOptions: setOptions,
  getOptions: getOptions,
  commit: commit,
  branch: branch,
  merge: merge,
  checkout: checkout,
  reset: reset,
  prettyPrint: prettyPrint,
  clear: clear,
  getBranchesAsObjArray: getBranchesAsObjArray,
  getBranches: getBranches,
  getCommits: getCommits,
  getCommitsArray: getCommitsArray,
  getCurrentBranch: getCurrentBranch,
  getDirection: getDirection,
  getHead: getHead
});

/***/ }),

/***/ "./src/diagrams/git/gitGraphRenderer.js":
/*!**********************************************!*\
  !*** ./src/diagrams/git/gitGraphRenderer.js ***!
  \**********************************************/
/*! exports provided: setConf, draw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConf", function() { return setConf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return draw; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _gitGraphAst__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gitGraphAst */ "./src/diagrams/git/gitGraphAst.js");
/* harmony import */ var _parser_gitGraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parser/gitGraph */ "./src/diagrams/git/parser/gitGraph.jison");
/* harmony import */ var _parser_gitGraph__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_parser_gitGraph__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");





var allCommitsDict = {};
var branchNum;
var config = {
  nodeSpacing: 150,
  nodeFillColor: 'yellow',
  nodeStrokeWidth: 2,
  nodeStrokeColor: 'grey',
  lineStrokeWidth: 4,
  branchOffset: 50,
  lineColor: 'grey',
  leftMargin: 50,
  branchColors: ['#442f74', '#983351', '#609732', '#AA9A39'],
  nodeRadius: 10,
  nodeLabel: {
    width: 75,
    height: 100,
    x: -25,
    y: 0
  }
};
var apiConfig = {};
var setConf = function setConf(c) {
  apiConfig = c;
};

function svgCreateDefs(svg) {
  svg.append('defs').append('g').attr('id', 'def-commit').append('circle').attr('r', config.nodeRadius).attr('cx', 0).attr('cy', 0);
  svg.select('#def-commit').append('foreignObject').attr('width', config.nodeLabel.width).attr('height', config.nodeLabel.height).attr('x', config.nodeLabel.x).attr('y', config.nodeLabel.y).attr('class', 'node-label').attr('requiredFeatures', 'http://www.w3.org/TR/SVG11/feature#Extensibility').append('p').html('');
}

function svgDrawLine(svg, points, colorIdx, interpolate) {
  var curve = Object(_utils__WEBPACK_IMPORTED_MODULE_4__["interpolateToCurve"])(interpolate, d3__WEBPACK_IMPORTED_MODULE_0__["curveBasis"]);
  var color = config.branchColors[colorIdx % config.branchColors.length];
  var lineGen = Object(d3__WEBPACK_IMPORTED_MODULE_0__["line"])().x(function (d) {
    return Math.round(d.x);
  }).y(function (d) {
    return Math.round(d.y);
  }).curve(curve);
  svg.append('svg:path').attr('d', lineGen(points)).style('stroke', color).style('stroke-width', config.lineStrokeWidth).style('fill', 'none');
} // Pass in the element and its pre-transform coords


function getElementCoords(element, coords) {
  coords = coords || element.node().getBBox();
  var ctm = element.node().getCTM();
  var xn = ctm.e + coords.x * ctm.a;
  var yn = ctm.f + coords.y * ctm.d;
  return {
    left: xn,
    top: yn,
    width: coords.width,
    height: coords.height
  };
}

function svgDrawLineForCommits(svg, fromId, toId, direction, color) {
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('svgDrawLineForCommits: ', fromId, toId);
  var fromBbox = getElementCoords(svg.select('#node-' + fromId + ' circle'));
  var toBbox = getElementCoords(svg.select('#node-' + toId + ' circle'));

  switch (direction) {
    case 'LR':
      // (toBbox)
      //  +--------
      //          + (fromBbox)
      if (fromBbox.left - toBbox.left > config.nodeSpacing) {
        var lineStart = {
          x: fromBbox.left - config.nodeSpacing,
          y: toBbox.top + toBbox.height / 2
        };
        var lineEnd = {
          x: toBbox.left + toBbox.width,
          y: toBbox.top + toBbox.height / 2
        };
        svgDrawLine(svg, [lineStart, lineEnd], color, 'linear');
        svgDrawLine(svg, [{
          x: fromBbox.left,
          y: fromBbox.top + fromBbox.height / 2
        }, {
          x: fromBbox.left - config.nodeSpacing / 2,
          y: fromBbox.top + fromBbox.height / 2
        }, {
          x: fromBbox.left - config.nodeSpacing / 2,
          y: lineStart.y
        }, lineStart], color);
      } else {
        svgDrawLine(svg, [{
          x: fromBbox.left,
          y: fromBbox.top + fromBbox.height / 2
        }, {
          x: fromBbox.left - config.nodeSpacing / 2,
          y: fromBbox.top + fromBbox.height / 2
        }, {
          x: fromBbox.left - config.nodeSpacing / 2,
          y: toBbox.top + toBbox.height / 2
        }, {
          x: toBbox.left + toBbox.width,
          y: toBbox.top + toBbox.height / 2
        }], color);
      }

      break;

    case 'BT':
      //      +           (fromBbox)
      //      |
      //      |
      //              +   (toBbox)
      if (toBbox.top - fromBbox.top > config.nodeSpacing) {
        var _lineStart = {
          x: toBbox.left + toBbox.width / 2,
          y: fromBbox.top + fromBbox.height + config.nodeSpacing
        };
        var _lineEnd = {
          x: toBbox.left + toBbox.width / 2,
          y: toBbox.top
        };
        svgDrawLine(svg, [_lineStart, _lineEnd], color, 'linear');
        svgDrawLine(svg, [{
          x: fromBbox.left + fromBbox.width / 2,
          y: fromBbox.top + fromBbox.height
        }, {
          x: fromBbox.left + fromBbox.width / 2,
          y: fromBbox.top + fromBbox.height + config.nodeSpacing / 2
        }, {
          x: toBbox.left + toBbox.width / 2,
          y: _lineStart.y - config.nodeSpacing / 2
        }, _lineStart], color);
      } else {
        svgDrawLine(svg, [{
          x: fromBbox.left + fromBbox.width / 2,
          y: fromBbox.top + fromBbox.height
        }, {
          x: fromBbox.left + fromBbox.width / 2,
          y: fromBbox.top + config.nodeSpacing / 2
        }, {
          x: toBbox.left + toBbox.width / 2,
          y: toBbox.top - config.nodeSpacing / 2
        }, {
          x: toBbox.left + toBbox.width / 2,
          y: toBbox.top
        }], color);
      }

      break;
  }
}

function cloneNode(svg, selector) {
  return svg.select(selector).node().cloneNode(true);
}

function renderCommitHistory(svg, commitid, branches, direction) {
  var commit;
  var numCommits = Object.keys(allCommitsDict).length;

  if (typeof commitid === 'string') {
    do {
      commit = allCommitsDict[commitid];
      _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('in renderCommitHistory', commit.id, commit.seq);

      if (svg.select('#node-' + commitid).size() > 0) {
        return;
      }

      svg.append(function () {
        return cloneNode(svg, '#def-commit');
      }).attr('class', 'commit').attr('id', function () {
        return 'node-' + commit.id;
      }).attr('transform', function () {
        switch (direction) {
          case 'LR':
            return 'translate(' + (commit.seq * config.nodeSpacing + config.leftMargin) + ', ' + branchNum * config.branchOffset + ')';

          case 'BT':
            return 'translate(' + (branchNum * config.branchOffset + config.leftMargin) + ', ' + (numCommits - commit.seq) * config.nodeSpacing + ')';
        }
      }).attr('fill', config.nodeFillColor).attr('stroke', config.nodeStrokeColor).attr('stroke-width', config.nodeStrokeWidth);
      var branch = void 0;

      for (var branchName in branches) {
        if (branches[branchName].commit === commit) {
          branch = branches[branchName];
          break;
        }
      }

      if (branch) {
        _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('found branch ', branch.name);
        svg.select('#node-' + commit.id + ' p').append('xhtml:span').attr('class', 'branch-label').text(branch.name + ', ');
      }

      svg.select('#node-' + commit.id + ' p').append('xhtml:span').attr('class', 'commit-id').text(commit.id);

      if (commit.message !== '' && direction === 'BT') {
        svg.select('#node-' + commit.id + ' p').append('xhtml:span').attr('class', 'commit-msg').text(', ' + commit.message);
      }

      commitid = commit.parent;
    } while (commitid && allCommitsDict[commitid]);
  }

  if (Array.isArray(commitid)) {
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('found merge commmit', commitid);
    renderCommitHistory(svg, commitid[0], branches, direction);
    branchNum++;
    renderCommitHistory(svg, commitid[1], branches, direction);
    branchNum--;
  }
}

function renderLines(svg, commit, direction, branchColor) {
  branchColor = branchColor || 0;

  while (commit.seq > 0 && !commit.lineDrawn) {
    if (typeof commit.parent === 'string') {
      svgDrawLineForCommits(svg, commit.id, commit.parent, direction, branchColor);
      commit.lineDrawn = true;
      commit = allCommitsDict[commit.parent];
    } else if (Array.isArray(commit.parent)) {
      svgDrawLineForCommits(svg, commit.id, commit.parent[0], direction, branchColor);
      svgDrawLineForCommits(svg, commit.id, commit.parent[1], direction, branchColor + 1);
      renderLines(svg, allCommitsDict[commit.parent[1]], direction, branchColor + 1);
      commit.lineDrawn = true;
      commit = allCommitsDict[commit.parent[0]];
    }
  }
}

var draw = function draw(txt, id, ver) {
  try {
    var parser = _parser_gitGraph__WEBPACK_IMPORTED_MODULE_2___default.a.parser;
    parser.yy = _gitGraphAst__WEBPACK_IMPORTED_MODULE_1__["default"];
    parser.yy.clear();
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('in gitgraph renderer', txt + '\n', 'id:', id, ver); // Parse the graph definition

    parser.parse(txt + '\n');
    config = Object.assign(config, apiConfig, _gitGraphAst__WEBPACK_IMPORTED_MODULE_1__["default"].getOptions());
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('effective options', config);
    var direction = _gitGraphAst__WEBPACK_IMPORTED_MODULE_1__["default"].getDirection();
    allCommitsDict = _gitGraphAst__WEBPACK_IMPORTED_MODULE_1__["default"].getCommits();
    var branches = _gitGraphAst__WEBPACK_IMPORTED_MODULE_1__["default"].getBranchesAsObjArray();

    if (direction === 'BT') {
      config.nodeLabel.x = branches.length * config.branchOffset;
      config.nodeLabel.width = '100%';
      config.nodeLabel.y = -1 * 2 * config.nodeRadius;
    }

    var svg = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])("[id=\"".concat(id, "\"]"));
    svgCreateDefs(svg);
    branchNum = 1;

    for (var branch in branches) {
      var v = branches[branch];
      renderCommitHistory(svg, v.commit.id, branches, direction);
      renderLines(svg, v.commit, direction);
      branchNum++;
    }

    svg.attr('height', function () {
      if (direction === 'BT') return Object.keys(allCommitsDict).length * config.nodeSpacing;
      return (branches.length + 1) * config.branchOffset;
    });
  } catch (e) {
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].error('Error while rendering gitgraph');
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].error(e.message);
  }
};
/* harmony default export */ __webpack_exports__["default"] = ({
  setConf: setConf,
  draw: draw
});

/***/ }),

/***/ "./src/diagrams/git/parser/gitGraph.jison":
/*!************************************************!*\
  !*** ./src/diagrams/git/parser/gitGraph.jison ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, module) {/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[2,3],$V1=[1,7],$V2=[7,12,15,17,19,20,21],$V3=[7,11,12,15,17,19,20,21],$V4=[2,20],$V5=[1,32];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"start":3,"GG":4,":":5,"document":6,"EOF":7,"DIR":8,"options":9,"body":10,"OPT":11,"NL":12,"line":13,"statement":14,"COMMIT":15,"commit_arg":16,"BRANCH":17,"ID":18,"CHECKOUT":19,"MERGE":20,"RESET":21,"reset_arg":22,"STR":23,"HEAD":24,"reset_parents":25,"CARET":26,"$accept":0,"$end":1},
terminals_: {2:"error",4:"GG",5:":",7:"EOF",8:"DIR",11:"OPT",12:"NL",15:"COMMIT",17:"BRANCH",18:"ID",19:"CHECKOUT",20:"MERGE",21:"RESET",23:"STR",24:"HEAD",26:"CARET"},
productions_: [0,[3,4],[3,5],[6,0],[6,2],[9,2],[9,1],[10,0],[10,2],[13,2],[13,1],[14,2],[14,2],[14,2],[14,2],[14,2],[16,0],[16,1],[22,2],[22,2],[25,0],[25,2]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
 return $$[$0-1]; 
break;
case 2:
yy.setDirection($$[$0-3]); return $$[$0-1];
break;
case 4:
 yy.setOptions($$[$0-1]); this.$ = $$[$0]
break;
case 5:
$$[$0-1] +=$$[$0]; this.$=$$[$0-1]
break;
case 7:
this.$ = []
break;
case 8:
$$[$0-1].push($$[$0]); this.$=$$[$0-1];
break;
case 9:
this.$ =$$[$0-1]
break;
case 11:
yy.commit($$[$0])
break;
case 12:
yy.branch($$[$0])
break;
case 13:
yy.checkout($$[$0])
break;
case 14:
yy.merge($$[$0])
break;
case 15:
yy.reset($$[$0])
break;
case 16:
this.$ = ""
break;
case 17:
this.$=$$[$0]
break;
case 18:
this.$ = $$[$0-1]+ ":" + $$[$0] 
break;
case 19:
this.$ = $$[$0-1]+ ":"  + yy.count; yy.count = 0
break;
case 20:
yy.count = 0
break;
case 21:
 yy.count += 1 
break;
}
},
table: [{3:1,4:[1,2]},{1:[3]},{5:[1,3],8:[1,4]},{6:5,7:$V0,9:6,12:$V1},{5:[1,8]},{7:[1,9]},o($V2,[2,7],{10:10,11:[1,11]}),o($V3,[2,6]),{6:12,7:$V0,9:6,12:$V1},{1:[2,1]},{7:[2,4],12:[1,15],13:13,14:14,15:[1,16],17:[1,17],19:[1,18],20:[1,19],21:[1,20]},o($V3,[2,5]),{7:[1,21]},o($V2,[2,8]),{12:[1,22]},o($V2,[2,10]),{12:[2,16],16:23,23:[1,24]},{18:[1,25]},{18:[1,26]},{18:[1,27]},{18:[1,30],22:28,24:[1,29]},{1:[2,2]},o($V2,[2,9]),{12:[2,11]},{12:[2,17]},{12:[2,12]},{12:[2,13]},{12:[2,14]},{12:[2,15]},{12:$V4,25:31,26:$V5},{12:$V4,25:33,26:$V5},{12:[2,18]},{12:$V4,25:34,26:$V5},{12:[2,19]},{12:[2,21]}],
defaultActions: {9:[2,1],21:[2,2],23:[2,11],24:[2,17],25:[2,12],26:[2,13],27:[2,14],28:[2,15],31:[2,18],33:[2,19],34:[2,21]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
            function lex() {
            var token;
            token = tstack.pop() || lexer.lex() || EOF;
            if (typeof token !== 'number') {
                if (token instanceof Array) {
                    tstack = token;
                    token = tstack.pop();
                }
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
        if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];
            for (p in table[state]) {
                if (this.terminals_[p] && p > TERROR) {
                    expected.push('\'' + this.terminals_[p] + '\'');
                }
            }
            if (lexer.showPosition) {
                errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
                errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }
            this.parseError(errStr, {
                text: lexer.match,
                token: this.terminals_[symbol] || symbol,
                line: lexer.yylineno,
                loc: yyloc,
                expected: expected
            });
        }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {"case-insensitive":true},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:return 12;
break;
case 1:/* skip all whitespace */
break;
case 2:/* skip comments */
break;
case 3:/* skip comments */
break;
case 4:return 4;
break;
case 5:return 15;
break;
case 6:return 17;
break;
case 7:return 20;
break;
case 8:return 21;
break;
case 9:return 19;
break;
case 10:return 8;
break;
case 11:return 8;
break;
case 12:return 5;
break;
case 13:return 26
break;
case 14:this.begin("options");
break;
case 15:this.popState();
break;
case 16:return 11;
break;
case 17:this.begin("string");
break;
case 18:this.popState();
break;
case 19:return 23;
break;
case 20:return 18;
break;
case 21:return 7;
break;
}
},
rules: [/^(?:(\r?\n)+)/i,/^(?:\s+)/i,/^(?:#[^\n]*)/i,/^(?:%[^\n]*)/i,/^(?:gitGraph\b)/i,/^(?:commit\b)/i,/^(?:branch\b)/i,/^(?:merge\b)/i,/^(?:reset\b)/i,/^(?:checkout\b)/i,/^(?:LR\b)/i,/^(?:BT\b)/i,/^(?::)/i,/^(?:\^)/i,/^(?:options\r?\n)/i,/^(?:end\r?\n)/i,/^(?:[^\n]+\r?\n)/i,/^(?:["])/i,/^(?:["])/i,/^(?:[^"]*)/i,/^(?:[a-zA-Z][-_\.a-zA-Z0-9]*[-_a-zA-Z0-9])/i,/^(?:$)/i],
conditions: {"options":{"rules":[15,16],"inclusive":false},"string":{"rules":[18,19],"inclusive":false},"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,17,20,21],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (true) {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js").readFileSync(__webpack_require__(/*! path */ "./node_modules/path-browserify/index.js").normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if ( true && __webpack_require__.c[__webpack_require__.s] === module) {
  exports.main(process.argv.slice(1));
}
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/diagrams/git/styles.js":
/*!************************************!*\
  !*** ./src/diagrams/git/styles.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var getStyles = function getStyles() {
  return "\n  .commit-id,\n  .commit-msg,\n  .branch-label {\n    fill: lightgrey;\n    color: lightgrey;\n    font-family: 'trebuchet ms', verdana, arial, sans-serif;\n    font-family: var(--mermaid-font-family);\n  }\n";
};

/* harmony default export */ __webpack_exports__["default"] = (getStyles);

/***/ }),

/***/ "./src/diagrams/info/infoDb.js":
/*!*************************************!*\
  !*** ./src/diagrams/info/infoDb.js ***!
  \*************************************/
/*! exports provided: setMessage, getMessage, setInfo, getInfo, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMessage", function() { return setMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMessage", function() { return getMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setInfo", function() { return setInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInfo", function() { return getInfo; });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/**
 * Created by knut on 15-01-14.
 */

var message = '';
var info = false;
var setMessage = function setMessage(txt) {
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Setting message to: ' + txt);
  message = txt;
};
var getMessage = function getMessage() {
  return message;
};
var setInfo = function setInfo(inf) {
  info = inf;
};
var getInfo = function getInfo() {
  return info;
}; // export const parseError = (err, hash) => {
//   global.mermaidAPI.parseError(err, hash)
// }

/* harmony default export */ __webpack_exports__["default"] = ({
  setMessage: setMessage,
  getMessage: getMessage,
  setInfo: setInfo,
  getInfo: getInfo // parseError

});

/***/ }),

/***/ "./src/diagrams/info/infoRenderer.js":
/*!*******************************************!*\
  !*** ./src/diagrams/info/infoRenderer.js ***!
  \*******************************************/
/*! exports provided: setConf, draw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConf", function() { return setConf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return draw; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _infoDb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./infoDb */ "./src/diagrams/info/infoDb.js");
/* harmony import */ var _parser_info__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parser/info */ "./src/diagrams/info/parser/info.jison");
/* harmony import */ var _parser_info__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_parser_info__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/**
 * Created by knut on 14-12-11.
 */




var conf = {};
var setConf = function setConf(cnf) {
  var keys = Object.keys(cnf);
  keys.forEach(function (key) {
    conf[key] = cnf[key];
  });
};
/**
 * Draws a an info picture in the tag with id: id based on the graph definition in text.
 * @param text
 * @param id
 */

var draw = function draw(txt, id, ver) {
  try {
    var parser = _parser_info__WEBPACK_IMPORTED_MODULE_2___default.a.parser;
    parser.yy = _infoDb__WEBPACK_IMPORTED_MODULE_1__["default"];
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('Renering info diagram\n' + txt); // Parse the graph definition

    parser.parse(txt);
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('Parsed info diagram'); // Fetch the default direction, use TD if none was found

    var svg = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('#' + id);
    var g = svg.append('g');
    g.append('text') // text label for the x axis
    .attr('x', 100).attr('y', 40).attr('class', 'version').attr('font-size', '32px').style('text-anchor', 'middle').text('v ' + ver);
    svg.attr('height', 100);
    svg.attr('width', 400); // svg.attr('viewBox', '0 0 300 150');
  } catch (e) {
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].error('Error while rendering info diagram');
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].error(e.message);
  }
};
/* harmony default export */ __webpack_exports__["default"] = ({
  setConf: setConf,
  draw: draw
});

/***/ }),

/***/ "./src/diagrams/info/parser/info.jison":
/*!*********************************************!*\
  !*** ./src/diagrams/info/parser/info.jison ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, module) {/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[6,9,10];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"start":3,"info":4,"document":5,"EOF":6,"line":7,"statement":8,"NL":9,"showInfo":10,"$accept":0,"$end":1},
terminals_: {2:"error",4:"info",6:"EOF",9:"NL",10:"showInfo"},
productions_: [0,[3,3],[5,0],[5,2],[7,1],[7,1],[8,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
 return yy; 
break;
case 4:
 
break;
case 6:
 yy.setInfo(true);  
break;
}
},
table: [{3:1,4:[1,2]},{1:[3]},o($V0,[2,2],{5:3}),{6:[1,4],7:5,8:6,9:[1,7],10:[1,8]},{1:[2,1]},o($V0,[2,3]),o($V0,[2,4]),o($V0,[2,5]),o($V0,[2,6])],
defaultActions: {4:[2,1]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
            function lex() {
            var token;
            token = tstack.pop() || lexer.lex() || EOF;
            if (typeof token !== 'number') {
                if (token instanceof Array) {
                    tstack = token;
                    token = tstack.pop();
                }
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
        if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];
            for (p in table[state]) {
                if (this.terminals_[p] && p > TERROR) {
                    expected.push('\'' + this.terminals_[p] + '\'');
                }
            }
            if (lexer.showPosition) {
                errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
                errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }
            this.parseError(errStr, {
                text: lexer.match,
                token: this.terminals_[symbol] || symbol,
                line: lexer.yylineno,
                loc: yyloc,
                expected: expected
            });
        }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {"case-insensitive":true},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
	// Pre-lexer code can go here

var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:return 4    ;
break;
case 1:return 9      ;
break;
case 2:return 'space';
break;
case 3:return 10;
break;
case 4:return 6     ;
break;
case 5:return 'TXT' ;
break;
}
},
rules: [/^(?:info\b)/i,/^(?:[\s\n\r]+)/i,/^(?:[\s]+)/i,/^(?:showInfo\b)/i,/^(?:$)/i,/^(?:.)/i],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (true) {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js").readFileSync(__webpack_require__(/*! path */ "./node_modules/path-browserify/index.js").normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if ( true && __webpack_require__.c[__webpack_require__.s] === module) {
  exports.main(process.argv.slice(1));
}
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/diagrams/info/styles.js":
/*!*************************************!*\
  !*** ./src/diagrams/info/styles.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var getStyles = function getStyles() {
  return "";
};

/* harmony default export */ __webpack_exports__["default"] = (getStyles);

/***/ }),

/***/ "./src/diagrams/pie/parser/pie.jison":
/*!*******************************************!*\
  !*** ./src/diagrams/pie/parser/pie.jison ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, module) {/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,4],$V1=[1,5],$V2=[1,6],$V3=[1,7],$V4=[1,9],$V5=[1,11,13,20,21,22,23],$V6=[2,5],$V7=[1,6,11,13,20,21,22,23],$V8=[20,21,22],$V9=[2,8],$Va=[1,18],$Vb=[1,19],$Vc=[1,24],$Vd=[6,20,21,22,23];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"start":3,"eol":4,"directive":5,"PIE":6,"document":7,"showData":8,"line":9,"statement":10,"txt":11,"value":12,"title":13,"title_value":14,"openDirective":15,"typeDirective":16,"closeDirective":17,":":18,"argDirective":19,"NEWLINE":20,";":21,"EOF":22,"open_directive":23,"type_directive":24,"arg_directive":25,"close_directive":26,"$accept":0,"$end":1},
terminals_: {2:"error",6:"PIE",8:"showData",11:"txt",12:"value",13:"title",14:"title_value",18:":",20:"NEWLINE",21:";",22:"EOF",23:"open_directive",24:"type_directive",25:"arg_directive",26:"close_directive"},
productions_: [0,[3,2],[3,2],[3,2],[3,3],[7,0],[7,2],[9,2],[10,0],[10,2],[10,2],[10,1],[5,3],[5,5],[4,1],[4,1],[4,1],[15,1],[16,1],[19,1],[17,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 4:
yy.setShowData(true);
break;
case 7:
 this.$ = $$[$0-1] 
break;
case 9:
 yy.addSection($$[$0-1],yy.cleanupValue($$[$0])); 
break;
case 10:
 this.$=$$[$0].trim();yy.setTitle(this.$); 
break;
case 17:
 yy.parseDirective('%%{', 'open_directive'); 
break;
case 18:
 yy.parseDirective($$[$0], 'type_directive'); 
break;
case 19:
 $$[$0] = $$[$0].trim().replace(/'/g, '"'); yy.parseDirective($$[$0], 'arg_directive'); 
break;
case 20:
 yy.parseDirective('}%%', 'close_directive', 'pie'); 
break;
}
},
table: [{3:1,4:2,5:3,6:$V0,15:8,20:$V1,21:$V2,22:$V3,23:$V4},{1:[3]},{3:10,4:2,5:3,6:$V0,15:8,20:$V1,21:$V2,22:$V3,23:$V4},{3:11,4:2,5:3,6:$V0,15:8,20:$V1,21:$V2,22:$V3,23:$V4},o($V5,$V6,{7:12,8:[1,13]}),o($V7,[2,14]),o($V7,[2,15]),o($V7,[2,16]),{16:14,24:[1,15]},{24:[2,17]},{1:[2,1]},{1:[2,2]},o($V8,$V9,{15:8,9:16,10:17,5:20,1:[2,3],11:$Va,13:$Vb,23:$V4}),o($V5,$V6,{7:21}),{17:22,18:[1,23],26:$Vc},o([18,26],[2,18]),o($V5,[2,6]),{4:25,20:$V1,21:$V2,22:$V3},{12:[1,26]},{14:[1,27]},o($V8,[2,11]),o($V8,$V9,{15:8,9:16,10:17,5:20,1:[2,4],11:$Va,13:$Vb,23:$V4}),o($Vd,[2,12]),{19:28,25:[1,29]},o($Vd,[2,20]),o($V5,[2,7]),o($V8,[2,9]),o($V8,[2,10]),{17:30,26:$Vc},{26:[2,19]},o($Vd,[2,13])],
defaultActions: {9:[2,17],10:[2,1],11:[2,2],29:[2,19]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
            function lex() {
            var token;
            token = tstack.pop() || lexer.lex() || EOF;
            if (typeof token !== 'number') {
                if (token instanceof Array) {
                    tstack = token;
                    token = tstack.pop();
                }
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
        if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];
            for (p in table[state]) {
                if (this.terminals_[p] && p > TERROR) {
                    expected.push('\'' + this.terminals_[p] + '\'');
                }
            }
            if (lexer.showPosition) {
                errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
                errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }
            this.parseError(errStr, {
                text: lexer.match,
                token: this.terminals_[symbol] || symbol,
                line: lexer.yylineno,
                loc: yyloc,
                expected: expected
            });
        }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {"case-insensitive":true},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0: this.begin('open_directive'); return 23; 
break;
case 1: this.begin('type_directive'); return 24; 
break;
case 2: this.popState(); this.begin('arg_directive'); return 18; 
break;
case 3: this.popState(); this.popState(); return 26; 
break;
case 4:return 25;
break;
case 5:/* skip comments */
break;
case 6:/* skip comments */{ /*console.log('');*/ }
break;
case 7:return 20;
break;
case 8:/* do nothing */
break;
case 9:/* ignore */
break;
case 10: this.begin("title");return 13; 
break;
case 11: this.popState(); return "title_value"; 
break;
case 12: this.begin("string"); 
break;
case 13: this.popState(); 
break;
case 14: return "txt"; 
break;
case 15:return 6;
break;
case 16:return 8;
break;
case 17:return "value";
break;
case 18:return 22;
break;
}
},
rules: [/^(?:%%\{)/i,/^(?:((?:(?!\}%%)[^:.])*))/i,/^(?::)/i,/^(?:\}%%)/i,/^(?:((?:(?!\}%%).|\n)*))/i,/^(?:%%(?!\{)[^\n]*)/i,/^(?:[^\}]%%[^\n]*)/i,/^(?:[\n\r]+)/i,/^(?:%%[^\n]*)/i,/^(?:[\s]+)/i,/^(?:title\b)/i,/^(?:(?!\n||)*[^\n]*)/i,/^(?:["])/i,/^(?:["])/i,/^(?:[^"]*)/i,/^(?:pie\b)/i,/^(?:showData\b)/i,/^(?::[\s]*[\d]+(?:\.[\d]+)?)/i,/^(?:$)/i],
conditions: {"close_directive":{"rules":[],"inclusive":false},"arg_directive":{"rules":[3,4],"inclusive":false},"type_directive":{"rules":[2,3],"inclusive":false},"open_directive":{"rules":[1],"inclusive":false},"title":{"rules":[11],"inclusive":false},"string":{"rules":[13,14],"inclusive":false},"INITIAL":{"rules":[0,5,6,7,8,9,10,12,15,16,17,18],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (true) {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js").readFileSync(__webpack_require__(/*! path */ "./node_modules/path-browserify/index.js").normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if ( true && __webpack_require__.c[__webpack_require__.s] === module) {
  exports.main(process.argv.slice(1));
}
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/diagrams/pie/pieDb.js":
/*!***********************************!*\
  !*** ./src/diagrams/pie/pieDb.js ***!
  \***********************************/
/*! exports provided: parseDirective, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseDirective", function() { return parseDirective; });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _mermaidAPI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mermaidAPI */ "./src/mermaidAPI.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/**
 *
 */



var sections = {};
var title = '';
var showData = false;
var parseDirective = function parseDirective(statement, context, type) {
  _mermaidAPI__WEBPACK_IMPORTED_MODULE_1__["default"].parseDirective(this, statement, context, type);
};

var addSection = function addSection(id, value) {
  if (typeof sections[id] === 'undefined') {
    sections[id] = value;
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Added new section :', id);
  }
};

var getSections = function getSections() {
  return sections;
};

var setTitle = function setTitle(txt) {
  title = txt;
};

var setShowData = function setShowData(toggle) {
  showData = toggle;
};

var getShowData = function getShowData() {
  return showData;
};

var getTitle = function getTitle() {
  return title;
};

var cleanupValue = function cleanupValue(value) {
  if (value.substring(0, 1) === ':') {
    value = value.substring(1).trim();
    return Number(value.trim());
  } else {
    return Number(value.trim());
  }
};

var clear = function clear() {
  sections = {};
  title = '';
  showData = false;
}; // export const parseError = (err, hash) => {
//   global.mermaidAPI.parseError(err, hash)
// }


/* harmony default export */ __webpack_exports__["default"] = ({
  parseDirective: parseDirective,
  getConfig: function getConfig() {
    return _config__WEBPACK_IMPORTED_MODULE_2__["getConfig"]().pie;
  },
  addSection: addSection,
  getSections: getSections,
  cleanupValue: cleanupValue,
  clear: clear,
  setTitle: setTitle,
  getTitle: getTitle,
  setShowData: setShowData,
  getShowData: getShowData // parseError

});

/***/ }),

/***/ "./src/diagrams/pie/pieRenderer.js":
/*!*****************************************!*\
  !*** ./src/diagrams/pie/pieRenderer.js ***!
  \*****************************************/
/*! exports provided: draw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return draw; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _pieDb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pieDb */ "./src/diagrams/pie/pieDb.js");
/* harmony import */ var _parser_pie__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parser/pie */ "./src/diagrams/pie/parser/pie.jison");
/* harmony import */ var _parser_pie__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_parser_pie__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/**
 * Created by AshishJ on 11-09-2019.
 */






var conf = _config__WEBPACK_IMPORTED_MODULE_5__["getConfig"]();
/**
 * Draws a Pie Chart with the data given in text.
 * @param text
 * @param id
 */

var width;
var height = 450;
var draw = function draw(txt, id) {
  try {
    conf = _config__WEBPACK_IMPORTED_MODULE_5__["getConfig"]();
    var parser = _parser_pie__WEBPACK_IMPORTED_MODULE_2___default.a.parser;
    parser.yy = _pieDb__WEBPACK_IMPORTED_MODULE_1__["default"];
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('Rendering info diagram\n' + txt); // Parse the Pie Chart definition

    parser.yy.clear();
    parser.parse(txt);
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('Parsed info diagram');
    var elem = document.getElementById(id);
    width = elem.parentElement.offsetWidth;

    if (typeof width === 'undefined') {
      width = 1200;
    }

    if (typeof conf.useWidth !== 'undefined') {
      width = conf.useWidth;
    }

    if (typeof conf.pie.useWidth !== 'undefined') {
      width = conf.pie.useWidth;
    }

    var diagram = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('#' + id);
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["configureSvgSize"])(diagram, height, width, conf.pie.useMaxWidth); // Set viewBox

    elem.setAttribute('viewBox', '0 0 ' + width + ' ' + height); // Fetch the default direction, use TD if none was found

    var margin = 40;
    var legendRectSize = 18;
    var legendSpacing = 4;
    var radius = Math.min(width, height) / 2 - margin;
    var svg = diagram.append('g').attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');
    var data = _pieDb__WEBPACK_IMPORTED_MODULE_1__["default"].getSections();
    var sum = 0;
    Object.keys(data).forEach(function (key) {
      sum += data[key];
    });
    var themeVariables = conf.themeVariables;
    var myGeneratedColors = [themeVariables.pie1, themeVariables.pie2, themeVariables.pie3, themeVariables.pie4, themeVariables.pie5, themeVariables.pie6, themeVariables.pie7, themeVariables.pie8, themeVariables.pie9, themeVariables.pie10, themeVariables.pie11, themeVariables.pie12]; // Set the color scale

    var color = Object(d3__WEBPACK_IMPORTED_MODULE_0__["scaleOrdinal"])().range(myGeneratedColors); // Compute the position of each group on the pie:

    var pie = Object(d3__WEBPACK_IMPORTED_MODULE_0__["pie"])().value(function (d) {
      return d[1];
    });
    var dataReady = pie(Object.entries(data)); // Shape helper to build arcs:

    var arcGenerator = Object(d3__WEBPACK_IMPORTED_MODULE_0__["arc"])().innerRadius(0).outerRadius(radius); // Build the pie chart: each part of the pie is a path that we build using the arc function.

    svg.selectAll('mySlices').data(dataReady).enter().append('path').attr('d', arcGenerator).attr('fill', function (d) {
      return color(d.data[0]);
    }).attr('class', 'pieCircle'); // Now add the percentage.
    // Use the centroid method to get the best coordinates.

    svg.selectAll('mySlices').data(dataReady).enter().append('text').text(function (d) {
      return (d.data[1] / sum * 100).toFixed(0) + '%';
    }).attr('transform', function (d) {
      return 'translate(' + arcGenerator.centroid(d) + ')';
    }).style('text-anchor', 'middle').attr('class', 'slice');
    svg.append('text').text(parser.yy.getTitle()).attr('x', 0).attr('y', -(height - 50) / 2).attr('class', 'pieTitleText'); // Add the legends/annotations for each section

    var legend = svg.selectAll('.legend').data(color.domain()).enter().append('g').attr('class', 'legend').attr('transform', function (d, i) {
      var height = legendRectSize + legendSpacing;
      var offset = height * color.domain().length / 2;
      var horz = 12 * legendRectSize;
      var vert = i * height - offset;
      return 'translate(' + horz + ',' + vert + ')';
    });
    legend.append('rect').attr('width', legendRectSize).attr('height', legendRectSize).style('fill', color).style('stroke', color);
    legend.data(dataReady).append('text').attr('x', legendRectSize + legendSpacing).attr('y', legendRectSize - legendSpacing).text(function (d) {
      if (parser.yy.getShowData() || conf.showData || conf.pie.showData) {
        return d.data[0] + ' [' + d.data[1] + ']';
      } else {
        return d.data[0];
      }
    });
  } catch (e) {
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].error('Error while rendering info diagram');
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].error(e);
  }
};
/* harmony default export */ __webpack_exports__["default"] = ({
  draw: draw
});

/***/ }),

/***/ "./src/diagrams/pie/styles.js":
/*!************************************!*\
  !*** ./src/diagrams/pie/styles.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var getStyles = function getStyles(options) {
  return "\n  .pieCircle{\n    stroke: ".concat(options.pieStrokeColor, ";\n    stroke-width : ").concat(options.pieStrokeWidth, ";\n    opacity : ").concat(options.pieOpacity, ";\n  }\n  .pieTitleText {\n    text-anchor: middle;\n    font-size: ").concat(options.pieTitleTextSize, ";\n    fill: ").concat(options.pieTitleTextColor, ";\n    font-family: ").concat(options.fontFamily, ";\n  }\n  .slice {\n    font-family: ").concat(options.fontFamily, ";\n    fill: ").concat(options.pieSectionTextColor, ";\n    font-size:").concat(options.pieSectionTextSize, ";\n    // fill: white;\n  }\n  .legend text {\n    fill: ").concat(options.pieLegendTextColor, ";\n    font-family: ").concat(options.fontFamily, ";\n    font-size: ").concat(options.pieLegendTextSize, ";\n  }\n");
};

/* harmony default export */ __webpack_exports__["default"] = (getStyles);

/***/ }),

/***/ "./src/diagrams/requirement/parser/requirementDiagram.jison":
/*!******************************************************************!*\
  !*** ./src/diagrams/requirement/parser/requirementDiagram.jison ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, module) {/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,3],$V1=[1,5],$V2=[1,17],$V3=[2,10],$V4=[1,21],$V5=[1,22],$V6=[1,23],$V7=[1,24],$V8=[1,25],$V9=[1,26],$Va=[1,19],$Vb=[1,27],$Vc=[1,28],$Vd=[1,31],$Ve=[66,67],$Vf=[5,8,14,35,36,37,38,39,40,48,55,57,66,67],$Vg=[5,6,8,14,35,36,37,38,39,40,48,66,67],$Vh=[1,51],$Vi=[1,52],$Vj=[1,53],$Vk=[1,54],$Vl=[1,55],$Vm=[1,56],$Vn=[1,57],$Vo=[57,58],$Vp=[1,69],$Vq=[1,65],$Vr=[1,66],$Vs=[1,67],$Vt=[1,68],$Vu=[1,70],$Vv=[1,74],$Vw=[1,75],$Vx=[1,72],$Vy=[1,73],$Vz=[5,8,14,35,36,37,38,39,40,48,66,67];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"start":3,"directive":4,"NEWLINE":5,"RD":6,"diagram":7,"EOF":8,"openDirective":9,"typeDirective":10,"closeDirective":11,":":12,"argDirective":13,"open_directive":14,"type_directive":15,"arg_directive":16,"close_directive":17,"requirementDef":18,"elementDef":19,"relationshipDef":20,"requirementType":21,"requirementName":22,"STRUCT_START":23,"requirementBody":24,"ID":25,"COLONSEP":26,"id":27,"TEXT":28,"text":29,"RISK":30,"riskLevel":31,"VERIFYMTHD":32,"verifyType":33,"STRUCT_STOP":34,"REQUIREMENT":35,"FUNCTIONAL_REQUIREMENT":36,"INTERFACE_REQUIREMENT":37,"PERFORMANCE_REQUIREMENT":38,"PHYSICAL_REQUIREMENT":39,"DESIGN_CONSTRAINT":40,"LOW_RISK":41,"MED_RISK":42,"HIGH_RISK":43,"VERIFY_ANALYSIS":44,"VERIFY_DEMONSTRATION":45,"VERIFY_INSPECTION":46,"VERIFY_TEST":47,"ELEMENT":48,"elementName":49,"elementBody":50,"TYPE":51,"type":52,"DOCREF":53,"ref":54,"END_ARROW_L":55,"relationship":56,"LINE":57,"END_ARROW_R":58,"CONTAINS":59,"COPIES":60,"DERIVES":61,"SATISFIES":62,"VERIFIES":63,"REFINES":64,"TRACES":65,"unqString":66,"qString":67,"$accept":0,"$end":1},
terminals_: {2:"error",5:"NEWLINE",6:"RD",8:"EOF",12:":",14:"open_directive",15:"type_directive",16:"arg_directive",17:"close_directive",23:"STRUCT_START",25:"ID",26:"COLONSEP",28:"TEXT",30:"RISK",32:"VERIFYMTHD",34:"STRUCT_STOP",35:"REQUIREMENT",36:"FUNCTIONAL_REQUIREMENT",37:"INTERFACE_REQUIREMENT",38:"PERFORMANCE_REQUIREMENT",39:"PHYSICAL_REQUIREMENT",40:"DESIGN_CONSTRAINT",41:"LOW_RISK",42:"MED_RISK",43:"HIGH_RISK",44:"VERIFY_ANALYSIS",45:"VERIFY_DEMONSTRATION",46:"VERIFY_INSPECTION",47:"VERIFY_TEST",48:"ELEMENT",51:"TYPE",53:"DOCREF",55:"END_ARROW_L",57:"LINE",58:"END_ARROW_R",59:"CONTAINS",60:"COPIES",61:"DERIVES",62:"SATISFIES",63:"VERIFIES",64:"REFINES",65:"TRACES",66:"unqString",67:"qString"},
productions_: [0,[3,3],[3,2],[3,4],[4,3],[4,5],[9,1],[10,1],[13,1],[11,1],[7,0],[7,2],[7,2],[7,2],[7,2],[7,2],[18,5],[24,5],[24,5],[24,5],[24,5],[24,2],[24,1],[21,1],[21,1],[21,1],[21,1],[21,1],[21,1],[31,1],[31,1],[31,1],[33,1],[33,1],[33,1],[33,1],[19,5],[50,5],[50,5],[50,2],[50,1],[20,5],[20,5],[56,1],[56,1],[56,1],[56,1],[56,1],[56,1],[56,1],[22,1],[22,1],[27,1],[27,1],[29,1],[29,1],[49,1],[49,1],[52,1],[52,1],[54,1],[54,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 6:
 yy.parseDirective('%%{', 'open_directive'); 
break;
case 7:
 yy.parseDirective($$[$0], 'type_directive'); 
break;
case 8:
 $$[$0] = $$[$0].trim().replace(/'/g, '"'); yy.parseDirective($$[$0], 'arg_directive'); 
break;
case 9:
 yy.parseDirective('}%%', 'close_directive', 'pie'); 
break;
case 10:
 this.$ = [] 
break;
case 16:
 yy.addRequirement($$[$0-3], $$[$0-4]) 
break;
case 17:
 yy.setNewReqId($$[$0-2]); 
break;
case 18:
 yy.setNewReqText($$[$0-2]); 
break;
case 19:
 yy.setNewReqRisk($$[$0-2]); 
break;
case 20:
 yy.setNewReqVerifyMethod($$[$0-2]); 
break;
case 23:
 this.$=yy.RequirementType.REQUIREMENT;
break;
case 24:
 this.$=yy.RequirementType.FUNCTIONAL_REQUIREMENT;
break;
case 25:
 this.$=yy.RequirementType.INTERFACE_REQUIREMENT;
break;
case 26:
 this.$=yy.RequirementType.PERFORMANCE_REQUIREMENT;
break;
case 27:
 this.$=yy.RequirementType.PHYSICAL_REQUIREMENT;
break;
case 28:
 this.$=yy.RequirementType.DESIGN_CONSTRAINT;
break;
case 29:
 this.$=yy.RiskLevel.LOW_RISK;
break;
case 30:
 this.$=yy.RiskLevel.MED_RISK;
break;
case 31:
 this.$=yy.RiskLevel.HIGH_RISK;
break;
case 32:
 this.$=yy.VerifyType.VERIFY_ANALYSIS;
break;
case 33:
 this.$=yy.VerifyType.VERIFY_DEMONSTRATION;
break;
case 34:
 this.$=yy.VerifyType.VERIFY_INSPECTION;
break;
case 35:
 this.$=yy.VerifyType.VERIFY_TEST;
break;
case 36:
 yy.addElement($$[$0-3]) 
break;
case 37:
 yy.setNewElementType($$[$0-2]); 
break;
case 38:
 yy.setNewElementDocRef($$[$0-2]); 
break;
case 41:
  yy.addRelationship($$[$0-2], $$[$0], $$[$0-4]) 
break;
case 42:
 yy.addRelationship($$[$0-2], $$[$0-4], $$[$0]) 
break;
case 43:
 this.$=yy.Relationships.CONTAINS;
break;
case 44:
 this.$=yy.Relationships.COPIES;
break;
case 45:
 this.$=yy.Relationships.DERIVES;
break;
case 46:
 this.$=yy.Relationships.SATISFIES;
break;
case 47:
 this.$=yy.Relationships.VERIFIES;
break;
case 48:
 this.$=yy.Relationships.REFINES;
break;
case 49:
 this.$=yy.Relationships.TRACES;
break;
}
},
table: [{3:1,4:2,6:$V0,9:4,14:$V1},{1:[3]},{3:7,4:2,5:[1,6],6:$V0,9:4,14:$V1},{5:[1,8]},{10:9,15:[1,10]},{15:[2,6]},{3:11,4:2,6:$V0,9:4,14:$V1},{1:[2,2]},{4:16,5:$V2,7:12,8:$V3,9:4,14:$V1,18:13,19:14,20:15,21:18,27:20,35:$V4,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,48:$Va,66:$Vb,67:$Vc},{11:29,12:[1,30],17:$Vd},o([12,17],[2,7]),{1:[2,1]},{8:[1,32]},{4:16,5:$V2,7:33,8:$V3,9:4,14:$V1,18:13,19:14,20:15,21:18,27:20,35:$V4,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,48:$Va,66:$Vb,67:$Vc},{4:16,5:$V2,7:34,8:$V3,9:4,14:$V1,18:13,19:14,20:15,21:18,27:20,35:$V4,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,48:$Va,66:$Vb,67:$Vc},{4:16,5:$V2,7:35,8:$V3,9:4,14:$V1,18:13,19:14,20:15,21:18,27:20,35:$V4,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,48:$Va,66:$Vb,67:$Vc},{4:16,5:$V2,7:36,8:$V3,9:4,14:$V1,18:13,19:14,20:15,21:18,27:20,35:$V4,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,48:$Va,66:$Vb,67:$Vc},{4:16,5:$V2,7:37,8:$V3,9:4,14:$V1,18:13,19:14,20:15,21:18,27:20,35:$V4,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,48:$Va,66:$Vb,67:$Vc},{22:38,66:[1,39],67:[1,40]},{49:41,66:[1,42],67:[1,43]},{55:[1,44],57:[1,45]},o($Ve,[2,23]),o($Ve,[2,24]),o($Ve,[2,25]),o($Ve,[2,26]),o($Ve,[2,27]),o($Ve,[2,28]),o($Vf,[2,52]),o($Vf,[2,53]),o($Vg,[2,4]),{13:46,16:[1,47]},o($Vg,[2,9]),{1:[2,3]},{8:[2,11]},{8:[2,12]},{8:[2,13]},{8:[2,14]},{8:[2,15]},{23:[1,48]},{23:[2,50]},{23:[2,51]},{23:[1,49]},{23:[2,56]},{23:[2,57]},{56:50,59:$Vh,60:$Vi,61:$Vj,62:$Vk,63:$Vl,64:$Vm,65:$Vn},{56:58,59:$Vh,60:$Vi,61:$Vj,62:$Vk,63:$Vl,64:$Vm,65:$Vn},{11:59,17:$Vd},{17:[2,8]},{5:[1,60]},{5:[1,61]},{57:[1,62]},o($Vo,[2,43]),o($Vo,[2,44]),o($Vo,[2,45]),o($Vo,[2,46]),o($Vo,[2,47]),o($Vo,[2,48]),o($Vo,[2,49]),{58:[1,63]},o($Vg,[2,5]),{5:$Vp,24:64,25:$Vq,28:$Vr,30:$Vs,32:$Vt,34:$Vu},{5:$Vv,34:$Vw,50:71,51:$Vx,53:$Vy},{27:76,66:$Vb,67:$Vc},{27:77,66:$Vb,67:$Vc},o($Vz,[2,16]),{26:[1,78]},{26:[1,79]},{26:[1,80]},{26:[1,81]},{5:$Vp,24:82,25:$Vq,28:$Vr,30:$Vs,32:$Vt,34:$Vu},o($Vz,[2,22]),o($Vz,[2,36]),{26:[1,83]},{26:[1,84]},{5:$Vv,34:$Vw,50:85,51:$Vx,53:$Vy},o($Vz,[2,40]),o($Vz,[2,41]),o($Vz,[2,42]),{27:86,66:$Vb,67:$Vc},{29:87,66:[1,88],67:[1,89]},{31:90,41:[1,91],42:[1,92],43:[1,93]},{33:94,44:[1,95],45:[1,96],46:[1,97],47:[1,98]},o($Vz,[2,21]),{52:99,66:[1,100],67:[1,101]},{54:102,66:[1,103],67:[1,104]},o($Vz,[2,39]),{5:[1,105]},{5:[1,106]},{5:[2,54]},{5:[2,55]},{5:[1,107]},{5:[2,29]},{5:[2,30]},{5:[2,31]},{5:[1,108]},{5:[2,32]},{5:[2,33]},{5:[2,34]},{5:[2,35]},{5:[1,109]},{5:[2,58]},{5:[2,59]},{5:[1,110]},{5:[2,60]},{5:[2,61]},{5:$Vp,24:111,25:$Vq,28:$Vr,30:$Vs,32:$Vt,34:$Vu},{5:$Vp,24:112,25:$Vq,28:$Vr,30:$Vs,32:$Vt,34:$Vu},{5:$Vp,24:113,25:$Vq,28:$Vr,30:$Vs,32:$Vt,34:$Vu},{5:$Vp,24:114,25:$Vq,28:$Vr,30:$Vs,32:$Vt,34:$Vu},{5:$Vv,34:$Vw,50:115,51:$Vx,53:$Vy},{5:$Vv,34:$Vw,50:116,51:$Vx,53:$Vy},o($Vz,[2,17]),o($Vz,[2,18]),o($Vz,[2,19]),o($Vz,[2,20]),o($Vz,[2,37]),o($Vz,[2,38])],
defaultActions: {5:[2,6],7:[2,2],11:[2,1],32:[2,3],33:[2,11],34:[2,12],35:[2,13],36:[2,14],37:[2,15],39:[2,50],40:[2,51],42:[2,56],43:[2,57],47:[2,8],88:[2,54],89:[2,55],91:[2,29],92:[2,30],93:[2,31],95:[2,32],96:[2,33],97:[2,34],98:[2,35],100:[2,58],101:[2,59],103:[2,60],104:[2,61]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
            function lex() {
            var token;
            token = tstack.pop() || lexer.lex() || EOF;
            if (typeof token !== 'number') {
                if (token instanceof Array) {
                    tstack = token;
                    token = tstack.pop();
                }
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
        if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];
            for (p in table[state]) {
                if (this.terminals_[p] && p > TERROR) {
                    expected.push('\'' + this.terminals_[p] + '\'');
                }
            }
            if (lexer.showPosition) {
                errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
                errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }
            this.parseError(errStr, {
                text: lexer.match,
                token: this.terminals_[symbol] || symbol,
                line: lexer.yylineno,
                loc: yyloc,
                expected: expected
            });
        }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {"case-insensitive":true},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0: this.begin('open_directive'); return 14; 
break;
case 1: this.begin('type_directive'); return 15; 
break;
case 2: this.popState(); this.begin('arg_directive'); return 12; 
break;
case 3: this.popState(); this.popState(); return 17; 
break;
case 4:return 16;
break;
case 5:return 5;
break;
case 6:/* skip all whitespace */
break;
case 7:/* skip comments */
break;
case 8:/* skip comments */
break;
case 9:return 8;
break;
case 10:return 6;
break;
case 11:return 23;
break;
case 12:return 34;
break;
case 13:return 26;
break;
case 14:return 25;
break;
case 15:return 28;
break;
case 16:return 30;
break;
case 17:return 32;
break;
case 18:return 35;
break;
case 19:return 36;
break;
case 20:return 37;
break;
case 21:return 38;
break;
case 22:return 39;
break;
case 23:return 40;
break;
case 24:return 41;
break;
case 25:return 42;
break;
case 26:return 43;
break;
case 27:return 44;
break;
case 28:return 45;
break;
case 29:return 46;
break;
case 30:return 47;
break;
case 31:return 48;
break;
case 32:return 59;
break;
case 33:return 60;
break;
case 34:return 61;
break;
case 35:return 62;
break;
case 36:return 63;
break;
case 37:return 64;
break;
case 38:return 65;
break;
case 39:return 51;
break;
case 40:return 53;
break;
case 41:return 55;
break;
case 42:return 58;
break;
case 43:return 57;
break;
case 44: this.begin("string"); 
break;
case 45: this.popState(); 
break;
case 46: return "qString"; 
break;
case 47: yy_.yytext = yy_.yytext.trim(); return 66;
break;
}
},
rules: [/^(?:%%\{)/i,/^(?:((?:(?!\}%%)[^:.])*))/i,/^(?::)/i,/^(?:\}%%)/i,/^(?:((?:(?!\}%%).|\n)*))/i,/^(?:(\r?\n)+)/i,/^(?:\s+)/i,/^(?:#[^\n]*)/i,/^(?:%[^\n]*)/i,/^(?:$)/i,/^(?:requirementDiagram\b)/i,/^(?:\{)/i,/^(?:\})/i,/^(?::)/i,/^(?:id\b)/i,/^(?:text\b)/i,/^(?:risk\b)/i,/^(?:verifyMethod\b)/i,/^(?:requirement\b)/i,/^(?:functionalRequirement\b)/i,/^(?:interfaceRequirement\b)/i,/^(?:performanceRequirement\b)/i,/^(?:physicalRequirement\b)/i,/^(?:designConstraint\b)/i,/^(?:low\b)/i,/^(?:medium\b)/i,/^(?:high\b)/i,/^(?:analysis\b)/i,/^(?:demonstration\b)/i,/^(?:inspection\b)/i,/^(?:test\b)/i,/^(?:element\b)/i,/^(?:contains\b)/i,/^(?:copies\b)/i,/^(?:derives\b)/i,/^(?:satisfies\b)/i,/^(?:verifies\b)/i,/^(?:refines\b)/i,/^(?:traces\b)/i,/^(?:type\b)/i,/^(?:docref\b)/i,/^(?:<-)/i,/^(?:->)/i,/^(?:-)/i,/^(?:["])/i,/^(?:["])/i,/^(?:[^"]*)/i,/^(?:[\w][^\r\n\{\<\>\-\=]*)/i],
conditions: {"close_directive":{"rules":[],"inclusive":false},"arg_directive":{"rules":[3,4],"inclusive":false},"type_directive":{"rules":[2,3],"inclusive":false},"open_directive":{"rules":[1],"inclusive":false},"unqString":{"rules":[],"inclusive":false},"token":{"rules":[],"inclusive":false},"string":{"rules":[45,46],"inclusive":false},"INITIAL":{"rules":[0,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,47],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (true) {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js").readFileSync(__webpack_require__(/*! path */ "./node_modules/path-browserify/index.js").normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if ( true && __webpack_require__.c[__webpack_require__.s] === module) {
  exports.main(process.argv.slice(1));
}
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/diagrams/requirement/requirementDb.js":
/*!***************************************************!*\
  !*** ./src/diagrams/requirement/requirementDb.js ***!
  \***************************************************/
/*! exports provided: parseDirective, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseDirective", function() { return parseDirective; });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _mermaidAPI__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mermaidAPI */ "./src/mermaidAPI.js");



var relations = [];
var latestRequirement = {};
var requirements = {};
var latestElement = {};
var elements = {};
var RequirementType = {
  REQUIREMENT: 'Requirement',
  FUNCTIONAL_REQUIREMENT: 'Functional Requirement',
  INTERFACE_REQUIREMENT: 'Interface Requirement',
  PERFORMANCE_REQUIREMENT: 'Performance Requirement',
  PHYSICAL_REQUIREMENT: 'Physical Requirement',
  DESIGN_CONSTRAINT: 'Design Constraint'
};
var RiskLevel = {
  LOW_RISK: 'Low',
  MED_RISK: 'Medium',
  HIGH_RISK: 'High'
};
var VerifyType = {
  VERIFY_ANALYSIS: 'Analysis',
  VERIFY_DEMONSTRATION: 'Demonstration',
  VERIFY_INSPECTION: 'Inspection',
  VERIFY_TEST: 'Test'
};
var Relationships = {
  CONTAINS: 'contains',
  COPIES: 'copies',
  DERIVES: 'derives',
  SATISFIES: 'satisfies',
  VERIFIES: 'verifies',
  REFINES: 'refines',
  TRACES: 'traces'
};
var parseDirective = function parseDirective(statement, context, type) {
  _mermaidAPI__WEBPACK_IMPORTED_MODULE_2__["default"].parseDirective(this, statement, context, type);
};

var addRequirement = function addRequirement(name, type) {
  if (typeof requirements[name] === 'undefined') {
    requirements[name] = {
      name: name,
      type: type,
      id: latestRequirement.id,
      text: latestRequirement.text,
      risk: latestRequirement.risk,
      verifyMethod: latestRequirement.verifyMethod
    };
  }

  latestRequirement = {};
  return requirements[name];
};

var getRequirements = function getRequirements() {
  return requirements;
};

var setNewReqId = function setNewReqId(id) {
  if (typeof latestRequirement != 'undefined') {
    latestRequirement.id = id;
  }
};

var setNewReqText = function setNewReqText(text) {
  if (typeof latestRequirement != 'undefined') {
    latestRequirement.text = text;
  }
};

var setNewReqRisk = function setNewReqRisk(risk) {
  if (typeof latestRequirement != 'undefined') {
    latestRequirement.risk = risk;
  }
};

var setNewReqVerifyMethod = function setNewReqVerifyMethod(verifyMethod) {
  if (typeof latestRequirement != 'undefined') {
    latestRequirement.verifyMethod = verifyMethod;
  }
};

var addElement = function addElement(name) {
  if (typeof elements[name] === 'undefined') {
    elements[name] = {
      name: name,
      type: latestElement.type,
      docRef: latestElement.docRef
    };
    _logger__WEBPACK_IMPORTED_MODULE_1__["log"].info('Added new requirement: ', name);
  }

  latestElement = {};
  return elements[name];
};

var getElements = function getElements() {
  return elements;
};

var setNewElementType = function setNewElementType(type) {
  if (typeof latestElement != 'undefined') {
    latestElement.type = type;
  }
};

var setNewElementDocRef = function setNewElementDocRef(docRef) {
  if (typeof latestElement != 'undefined') {
    latestElement.docRef = docRef;
  }
};

var addRelationship = function addRelationship(type, src, dst) {
  relations.push({
    type: type,
    src: src,
    dst: dst
  });
};

var getRelationships = function getRelationships() {
  return relations;
};

var clear = function clear() {
  relations = [];
  latestRequirement = {};
  requirements = {};
  latestElement = {};
  elements = {};
};

/* harmony default export */ __webpack_exports__["default"] = ({
  RequirementType: RequirementType,
  RiskLevel: RiskLevel,
  VerifyType: VerifyType,
  Relationships: Relationships,
  parseDirective: parseDirective,
  getConfig: function getConfig() {
    return _config__WEBPACK_IMPORTED_MODULE_0__["getConfig"]().req;
  },
  addRequirement: addRequirement,
  getRequirements: getRequirements,
  setNewReqId: setNewReqId,
  setNewReqText: setNewReqText,
  setNewReqRisk: setNewReqRisk,
  setNewReqVerifyMethod: setNewReqVerifyMethod,
  addElement: addElement,
  getElements: getElements,
  setNewElementType: setNewElementType,
  setNewElementDocRef: setNewElementDocRef,
  addRelationship: addRelationship,
  getRelationships: getRelationships,
  clear: clear
});

/***/ }),

/***/ "./src/diagrams/requirement/requirementMarkers.js":
/*!********************************************************!*\
  !*** ./src/diagrams/requirement/requirementMarkers.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var ReqMarkers = {
  CONTAINS: 'contains',
  ARROW: 'arrow'
};

var insertLineEndings = function insertLineEndings(parentNode, conf) {
  var containsNode = parentNode.append('defs').append('marker').attr('id', ReqMarkers.CONTAINS + '_line_ending').attr('refX', 0).attr('refY', conf.line_height / 2).attr('markerWidth', conf.line_height).attr('markerHeight', conf.line_height).attr('orient', 'auto').append('g');
  containsNode.append('circle').attr('cx', conf.line_height / 2).attr('cy', conf.line_height / 2).attr('r', conf.line_height / 2) // .attr('stroke', conf.rect_border_color)
  // .attr('stroke-width', 1)
  .attr('fill', 'none');
  containsNode.append('line').attr('x1', 0).attr('x2', conf.line_height).attr('y1', conf.line_height / 2).attr('y2', conf.line_height / 2) // .attr('stroke', conf.rect_border_color)
  .attr('stroke-width', 1);
  containsNode.append('line').attr('y1', 0).attr('y2', conf.line_height).attr('x1', conf.line_height / 2).attr('x2', conf.line_height / 2) // .attr('stroke', conf.rect_border_color)
  .attr('stroke-width', 1);
  parentNode.append('defs').append('marker').attr('id', ReqMarkers.ARROW + '_line_ending').attr('refX', conf.line_height).attr('refY', 0.5 * conf.line_height).attr('markerWidth', conf.line_height).attr('markerHeight', conf.line_height).attr('orient', 'auto').append('path').attr('d', "M0,0\n      L".concat(conf.line_height, ",").concat(conf.line_height / 2, "\n      M").concat(conf.line_height, ",").concat(conf.line_height / 2, "\n      L0,").concat(conf.line_height)).attr('stroke-width', 1); // .attr('stroke', conf.rect_border_color);
};

/* harmony default export */ __webpack_exports__["default"] = ({
  ReqMarkers: ReqMarkers,
  insertLineEndings: insertLineEndings
});

/***/ }),

/***/ "./src/diagrams/requirement/requirementRenderer.js":
/*!*********************************************************!*\
  !*** ./src/diagrams/requirement/requirementRenderer.js ***!
  \*********************************************************/
/*! exports provided: setConf, drawReqs, drawElements, draw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConf", function() { return setConf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawReqs", function() { return drawReqs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawElements", function() { return drawElements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return draw; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var dagre__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dagre */ "dagre");
/* harmony import */ var dagre__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dagre__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! graphlib */ "graphlib");
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(graphlib__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");
/* harmony import */ var _common_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/common */ "./src/diagrams/common/common.js");
/* harmony import */ var _parser_requirementDiagram__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parser/requirementDiagram */ "./src/diagrams/requirement/parser/requirementDiagram.jison");
/* harmony import */ var _parser_requirementDiagram__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_parser_requirementDiagram__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _requirementDb__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./requirementDb */ "./src/diagrams/requirement/requirementDb.js");
/* harmony import */ var _requirementMarkers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./requirementMarkers */ "./src/diagrams/requirement/requirementMarkers.js");


 // import * as configApi from '../../config';







var conf = {};
var relCnt = 0;
var setConf = function setConf(cnf) {
  if (typeof cnf === 'undefined') {
    return;
  }

  var keys = Object.keys(cnf);

  for (var i = 0; i < keys.length; i++) {
    conf[keys[i]] = cnf[keys[i]];
  }
};

var newRectNode = function newRectNode(parentNode, id) {
  return parentNode.insert('rect', '#' + id).attr('class', 'req reqBox').attr('x', 0).attr('y', 0).attr('width', conf.rect_min_width + 'px').attr('height', conf.rect_min_height + 'px');
};

var newTitleNode = function newTitleNode(parentNode, id, txts) {
  var x = conf.rect_min_width / 2;
  var title = parentNode.append('text').attr('class', 'req reqLabel reqTitle').attr('id', id).attr('x', x).attr('y', conf.rect_padding).attr('dominant-baseline', 'hanging'); // .attr(
  //   'style',
  //   'font-family: ' + configApi.getConfig().fontFamily + '; font-size: ' + conf.fontSize + 'px'
  // )

  var i = 0;
  txts.forEach(function (textStr) {
    if (i == 0) {
      title.append('tspan').attr('text-anchor', 'middle').attr('x', conf.rect_min_width / 2).attr('dy', 0).text(textStr);
    } else {
      title.append('tspan').attr('text-anchor', 'middle').attr('x', conf.rect_min_width / 2).attr('dy', conf.line_height * 0.75).text(textStr);
    }

    i++;
  });
  var yPadding = 1.5 * conf.rect_padding;
  var linePadding = i * conf.line_height * 0.75;
  var totalY = yPadding + linePadding;
  parentNode.append('line').attr('class', 'req-title-line').attr('x1', '0').attr('x2', conf.rect_min_width).attr('y1', totalY).attr('y2', totalY);
  return {
    titleNode: title,
    y: totalY
  };
};

var newBodyNode = function newBodyNode(parentNode, id, txts, yStart) {
  var body = parentNode.append('text').attr('class', 'req reqLabel').attr('id', id).attr('x', conf.rect_padding).attr('y', yStart).attr('dominant-baseline', 'hanging'); // .attr(
  //   'style',
  //   'font-family: ' + configApi.getConfig().fontFamily + '; font-size: ' + conf.fontSize + 'px'
  // );

  var currentRow = 0;
  var charLimit = 30;
  var wrappedTxts = [];
  txts.forEach(function (textStr) {
    var currentTextLen = textStr.length;

    while (currentTextLen > charLimit && currentRow < 3) {
      var firstPart = textStr.substring(0, charLimit);
      textStr = textStr.substring(charLimit, textStr.length);
      currentTextLen = textStr.length;
      wrappedTxts[wrappedTxts.length] = firstPart;
      currentRow++;
    }

    if (currentRow == 3) {
      var lastStr = wrappedTxts[wrappedTxts.length - 1];
      wrappedTxts[wrappedTxts.length - 1] = lastStr.substring(0, lastStr.length - 4) + '...';
    } else {
      wrappedTxts[wrappedTxts.length] = textStr;
    }

    currentRow = 0;
  });
  wrappedTxts.forEach(function (textStr) {
    body.append('tspan').attr('x', conf.rect_padding).attr('dy', conf.line_height).text(textStr);
  });
  return body;
};

var addEdgeLabel = function addEdgeLabel(parentNode, svgPath, conf, txt) {
  // Find the half-way point
  var len = svgPath.node().getTotalLength();
  var labelPoint = svgPath.node().getPointAtLength(len * 0.5); // Append a text node containing the label

  var labelId = 'rel' + relCnt;
  relCnt++;
  var labelNode = parentNode.append('text').attr('class', 'req relationshipLabel').attr('id', labelId).attr('x', labelPoint.x).attr('y', labelPoint.y).attr('text-anchor', 'middle').attr('dominant-baseline', 'middle') // .attr('style', 'font-family: ' + conf.fontFamily + '; font-size: ' + conf.fontSize + 'px')
  .text(txt); // Figure out how big the opaque 'container' rectangle needs to be

  var labelBBox = labelNode.node().getBBox(); // Insert the opaque rectangle before the text label

  parentNode.insert('rect', '#' + labelId).attr('class', 'req reqLabelBox').attr('x', labelPoint.x - labelBBox.width / 2).attr('y', labelPoint.y - labelBBox.height / 2).attr('width', labelBBox.width).attr('height', labelBBox.height).attr('fill', 'white').attr('fill-opacity', '85%');
};

var drawRelationshipFromLayout = function drawRelationshipFromLayout(svg, rel, g, insert) {
  // Find the edge relating to this relationship
  var edge = g.edge(elementString(rel.src), elementString(rel.dst)); // Get a function that will generate the line path

  var lineFunction = Object(d3__WEBPACK_IMPORTED_MODULE_0__["line"])().x(function (d) {
    return d.x;
  }).y(function (d) {
    return d.y;
  }); // Insert the line at the right place

  var svgPath = svg.insert('path', '#' + insert).attr('class', 'er relationshipLine').attr('d', lineFunction(edge.points)).attr('fill', 'none');

  if (rel.type == _requirementDb__WEBPACK_IMPORTED_MODULE_7__["default"].Relationships.CONTAINS) {
    svgPath.attr('marker-start', 'url(' + _common_common__WEBPACK_IMPORTED_MODULE_5__["default"].getUrl(conf.arrowMarkerAbsolute) + '#' + rel.type + '_line_ending' + ')');
  } else {
    svgPath.attr('stroke-dasharray', '10,7');
    svgPath.attr('marker-end', 'url(' + _common_common__WEBPACK_IMPORTED_MODULE_5__["default"].getUrl(conf.arrowMarkerAbsolute) + '#' + _requirementMarkers__WEBPACK_IMPORTED_MODULE_8__["default"].ReqMarkers.ARROW + '_line_ending' + ')');
  }

  addEdgeLabel(svg, svgPath, conf, "<<".concat(rel.type, ">>"));
  return;
};

var drawReqs = function drawReqs(reqs, graph, svgNode) {
  Object.keys(reqs).forEach(function (reqName) {
    var req = reqs[reqName];
    reqName = elementString(reqName);
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].info('Added new requirement: ', reqName);
    var groupNode = svgNode.append('g').attr('id', reqName);
    var textId = 'req-' + reqName;
    var rectNode = newRectNode(groupNode, textId);
    var nodes = [];
    var titleNodeInfo = newTitleNode(groupNode, reqName + '_title', ["<<".concat(req.type, ">>"), "".concat(req.name)]);
    nodes.push(titleNodeInfo.titleNode);
    var bodyNode = newBodyNode(groupNode, reqName + '_body', ["Id: ".concat(req.id), "Text: ".concat(req.text), "Risk: ".concat(req.risk), "Verification: ".concat(req.verifyMethod)], titleNodeInfo.y);
    nodes.push(bodyNode);
    var rectBBox = rectNode.node().getBBox(); // Add the entity to the graph

    graph.setNode(reqName, {
      width: rectBBox.width,
      height: rectBBox.height,
      shape: 'rect',
      id: reqName
    });
  });
};
var drawElements = function drawElements(els, graph, svgNode) {
  Object.keys(els).forEach(function (elName) {
    var el = els[elName];
    var id = elementString(elName);
    var groupNode = svgNode.append('g').attr('id', id);
    var textId = 'element-' + id;
    var rectNode = newRectNode(groupNode, textId);
    var nodes = [];
    var titleNodeInfo = newTitleNode(groupNode, textId + '_title', ["<<Element>>", "".concat(elName)]);
    nodes.push(titleNodeInfo.titleNode);
    var bodyNode = newBodyNode(groupNode, textId + '_body', ["Type: ".concat(el.type || 'Not Specified'), "Doc Ref: ".concat(el.docRef || 'None')], titleNodeInfo.y);
    nodes.push(bodyNode);
    var rectBBox = rectNode.node().getBBox(); // Add the entity to the graph

    graph.setNode(id, {
      width: rectBBox.width,
      height: rectBBox.height,
      shape: 'rect',
      id: id
    });
  });
};

var addRelationships = function addRelationships(relationships, g) {
  relationships.forEach(function (r) {
    var src = elementString(r.src);
    var dst = elementString(r.dst);
    g.setEdge(src, dst, {
      relationship: r
    });
  });
  return relationships;
};

var adjustEntities = function adjustEntities(svgNode, graph) {
  graph.nodes().forEach(function (v) {
    if (typeof v !== 'undefined' && typeof graph.node(v) !== 'undefined') {
      svgNode.select('#' + v);
      svgNode.select('#' + v).attr('transform', 'translate(' + (graph.node(v).x - graph.node(v).width / 2) + ',' + (graph.node(v).y - graph.node(v).height / 2) + ' )');
    }
  });
  return;
};

var elementString = function elementString(str) {
  return str.replace(/\s/g, '').replace(/\./g, '_');
};

var draw = function draw(text, id) {
  _parser_requirementDiagram__WEBPACK_IMPORTED_MODULE_6__["parser"].yy = _requirementDb__WEBPACK_IMPORTED_MODULE_7__["default"];
  _parser_requirementDiagram__WEBPACK_IMPORTED_MODULE_6__["parser"].yy.clear();
  _parser_requirementDiagram__WEBPACK_IMPORTED_MODULE_6__["parser"].parse(text);
  var svg = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])("[id='".concat(id, "']"));
  _requirementMarkers__WEBPACK_IMPORTED_MODULE_8__["default"].insertLineEndings(svg, conf);
  var g = new graphlib__WEBPACK_IMPORTED_MODULE_2___default.a.Graph({
    multigraph: false,
    compound: false,
    directed: true
  }).setGraph({
    rankdir: conf.layoutDirection,
    marginx: 20,
    marginy: 20,
    nodesep: 100,
    edgesep: 100,
    ranksep: 100
  }).setDefaultEdgeLabel(function () {
    return {};
  });
  var requirements = _requirementDb__WEBPACK_IMPORTED_MODULE_7__["default"].getRequirements();
  var elements = _requirementDb__WEBPACK_IMPORTED_MODULE_7__["default"].getElements();
  var relationships = _requirementDb__WEBPACK_IMPORTED_MODULE_7__["default"].getRelationships();
  drawReqs(requirements, g, svg);
  drawElements(elements, g, svg);
  addRelationships(relationships, g);
  dagre__WEBPACK_IMPORTED_MODULE_1___default.a.layout(g);
  adjustEntities(svg, g);
  relationships.forEach(function (rel) {
    drawRelationshipFromLayout(svg, rel, g, id);
  }); // svg.attr('height', '500px');

  var padding = conf.rect_padding;
  var svgBounds = svg.node().getBBox();
  var width = svgBounds.width + padding * 2;
  var height = svgBounds.height + padding * 2;
  Object(_utils__WEBPACK_IMPORTED_MODULE_4__["configureSvgSize"])(svg, height, width, conf.useMaxWidth);
  svg.attr('viewBox', "".concat(svgBounds.x - padding, " ").concat(svgBounds.y - padding, " ").concat(width, " ").concat(height));
};
/* harmony default export */ __webpack_exports__["default"] = ({
  setConf: setConf,
  draw: draw
});

/***/ }),

/***/ "./src/diagrams/requirement/styles.js":
/*!********************************************!*\
  !*** ./src/diagrams/requirement/styles.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var getStyles = function getStyles(options) {
  return "\n\n  marker {\n    fill: ".concat(options.relationColor, ";\n    stroke: ").concat(options.relationColor, ";\n  }\n\n  marker.cross {\n    stroke: ").concat(options.lineColor, ";\n  }\n\n  svg {\n    font-family: ").concat(options.fontFamily, ";\n    font-size: ").concat(options.fontSize, ";\n  }\n\n  .reqBox {\n    fill: ").concat(options.requirementBackground, ";\n    fill-opacity: 100%;\n    stroke: ").concat(options.requirementBorderColor, ";\n    stroke-width: ").concat(options.requirementBorderSize, ";\n  }\n  \n  .reqTitle, .reqLabel{\n    fill:  ").concat(options.requirementTextColor, ";\n  }\n  .reqLabelBox {\n    fill: ").concat(options.relationLabelBackground, ";\n    fill-opacity: 100%;\n  }\n\n  .req-title-line {\n    stroke: ").concat(options.requirementBorderColor, ";\n    stroke-width: ").concat(options.requirementBorderSize, ";\n  }\n  .relationshipLine {\n    stroke: ").concat(options.relationColor, ";\n    stroke-width: 1;\n  }\n  .relationshipLabel {\n    fill: ").concat(options.relationLabelColor, ";\n  }\n\n");
}; // fill', conf.rect_fill)


/* harmony default export */ __webpack_exports__["default"] = (getStyles);

/***/ }),

/***/ "./src/diagrams/sequence/parser/sequenceDiagram.jison":
/*!************************************************************!*\
  !*** ./src/diagrams/sequence/parser/sequenceDiagram.jison ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, module) {/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,2],$V1=[1,3],$V2=[1,5],$V3=[1,7],$V4=[2,5],$V5=[1,15],$V6=[1,17],$V7=[1,18],$V8=[1,20],$V9=[1,21],$Va=[1,22],$Vb=[1,24],$Vc=[1,25],$Vd=[1,26],$Ve=[1,27],$Vf=[1,28],$Vg=[1,29],$Vh=[1,32],$Vi=[1,33],$Vj=[1,36],$Vk=[1,4,5,16,21,22,23,25,27,28,29,30,31,33,35,36,37,48,58],$Vl=[1,44],$Vm=[4,5,16,21,22,23,25,27,28,29,30,31,33,37,48,58],$Vn=[4,5,16,21,22,23,25,27,28,29,30,31,33,36,37,48,58],$Vo=[4,5,16,21,22,23,25,27,28,29,30,31,33,35,37,48,58],$Vp=[46,47,48],$Vq=[1,4,5,7,16,21,22,23,25,27,28,29,30,31,33,35,36,37,48,58];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"start":3,"SPACE":4,"NEWLINE":5,"directive":6,"SD":7,"document":8,"line":9,"statement":10,"openDirective":11,"typeDirective":12,"closeDirective":13,":":14,"argDirective":15,"participant":16,"actor":17,"AS":18,"restOfLine":19,"signal":20,"autonumber":21,"activate":22,"deactivate":23,"note_statement":24,"title":25,"text2":26,"loop":27,"end":28,"rect":29,"opt":30,"alt":31,"else_sections":32,"par":33,"par_sections":34,"and":35,"else":36,"note":37,"placement":38,"over":39,"actor_pair":40,"spaceList":41,",":42,"left_of":43,"right_of":44,"signaltype":45,"+":46,"-":47,"ACTOR":48,"SOLID_OPEN_ARROW":49,"DOTTED_OPEN_ARROW":50,"SOLID_ARROW":51,"DOTTED_ARROW":52,"SOLID_CROSS":53,"DOTTED_CROSS":54,"SOLID_POINT":55,"DOTTED_POINT":56,"TXT":57,"open_directive":58,"type_directive":59,"arg_directive":60,"close_directive":61,"$accept":0,"$end":1},
terminals_: {2:"error",4:"SPACE",5:"NEWLINE",7:"SD",14:":",16:"participant",18:"AS",19:"restOfLine",21:"autonumber",22:"activate",23:"deactivate",25:"title",27:"loop",28:"end",29:"rect",30:"opt",31:"alt",33:"par",35:"and",36:"else",37:"note",39:"over",42:",",43:"left_of",44:"right_of",46:"+",47:"-",48:"ACTOR",49:"SOLID_OPEN_ARROW",50:"DOTTED_OPEN_ARROW",51:"SOLID_ARROW",52:"DOTTED_ARROW",53:"SOLID_CROSS",54:"DOTTED_CROSS",55:"SOLID_POINT",56:"DOTTED_POINT",57:"TXT",58:"open_directive",59:"type_directive",60:"arg_directive",61:"close_directive"},
productions_: [0,[3,2],[3,2],[3,2],[3,2],[8,0],[8,2],[9,2],[9,1],[9,1],[6,4],[6,6],[10,5],[10,3],[10,2],[10,1],[10,3],[10,3],[10,2],[10,3],[10,4],[10,4],[10,4],[10,4],[10,4],[10,1],[34,1],[34,4],[32,1],[32,4],[24,4],[24,4],[41,2],[41,1],[40,3],[40,1],[38,1],[38,1],[20,5],[20,5],[20,4],[17,1],[45,1],[45,1],[45,1],[45,1],[45,1],[45,1],[45,1],[45,1],[26,1],[11,1],[12,1],[15,1],[13,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 4:
 yy.apply($$[$0]);return $$[$0]; 
break;
case 5:
 this.$ = [] 
break;
case 6:
$$[$0-1].push($$[$0]);this.$ = $$[$0-1]
break;
case 7: case 8:
 this.$ = $$[$0] 
break;
case 9:
 this.$=[]; 
break;
case 12:
$$[$0-3].description=yy.parseMessage($$[$0-1]); this.$=$$[$0-3];
break;
case 13:
this.$=$$[$0-1];
break;
case 15:
yy.enableSequenceNumbers()
break;
case 16:
this.$={type: 'activeStart', signalType: yy.LINETYPE.ACTIVE_START, actor: $$[$0-1]};
break;
case 17:
this.$={type: 'activeEnd', signalType: yy.LINETYPE.ACTIVE_END, actor: $$[$0-1]};
break;
case 19:
this.$=[{type:'setTitle', text:$$[$0-1]}]
break;
case 20:

		$$[$0-1].unshift({type: 'loopStart', loopText:yy.parseMessage($$[$0-2]), signalType: yy.LINETYPE.LOOP_START});
		$$[$0-1].push({type: 'loopEnd', loopText:$$[$0-2], signalType: yy.LINETYPE.LOOP_END});
		this.$=$$[$0-1];
break;
case 21:

		$$[$0-1].unshift({type: 'rectStart', color:yy.parseMessage($$[$0-2]), signalType: yy.LINETYPE.RECT_START });
		$$[$0-1].push({type: 'rectEnd', color:yy.parseMessage($$[$0-2]), signalType: yy.LINETYPE.RECT_END });
		this.$=$$[$0-1];
break;
case 22:

		$$[$0-1].unshift({type: 'optStart', optText:yy.parseMessage($$[$0-2]), signalType: yy.LINETYPE.OPT_START});
		$$[$0-1].push({type: 'optEnd', optText:yy.parseMessage($$[$0-2]), signalType: yy.LINETYPE.OPT_END});
		this.$=$$[$0-1];
break;
case 23:

		// Alt start
		$$[$0-1].unshift({type: 'altStart', altText:yy.parseMessage($$[$0-2]), signalType: yy.LINETYPE.ALT_START});
		// Content in alt is already in $$[$0-1]
		// End
		$$[$0-1].push({type: 'altEnd', signalType: yy.LINETYPE.ALT_END});
		this.$=$$[$0-1];
break;
case 24:

		// Parallel start
		$$[$0-1].unshift({type: 'parStart', parText:yy.parseMessage($$[$0-2]), signalType: yy.LINETYPE.PAR_START});
		// Content in par is already in $$[$0-1]
		// End
		$$[$0-1].push({type: 'parEnd', signalType: yy.LINETYPE.PAR_END});
		this.$=$$[$0-1];
break;
case 27:
 this.$ = $$[$0-3].concat([{type: 'and', parText:yy.parseMessage($$[$0-1]), signalType: yy.LINETYPE.PAR_AND}, $$[$0]]); 
break;
case 29:
 this.$ = $$[$0-3].concat([{type: 'else', altText:yy.parseMessage($$[$0-1]), signalType: yy.LINETYPE.ALT_ELSE}, $$[$0]]); 
break;
case 30:

		this.$ = [$$[$0-1], {type:'addNote', placement:$$[$0-2], actor:$$[$0-1].actor, text:$$[$0]}];
break;
case 31:

		// Coerce actor_pair into a [to, from, ...] array
		$$[$0-2] = [].concat($$[$0-1], $$[$0-1]).slice(0, 2);
		$$[$0-2][0] = $$[$0-2][0].actor;
		$$[$0-2][1] = $$[$0-2][1].actor;
		this.$ = [$$[$0-1], {type:'addNote', placement:yy.PLACEMENT.OVER, actor:$$[$0-2].slice(0, 2), text:$$[$0]}];
break;
case 34:
 this.$ = [$$[$0-2], $$[$0]]; 
break;
case 35:
 this.$ = $$[$0]; 
break;
case 36:
 this.$ = yy.PLACEMENT.LEFTOF; 
break;
case 37:
 this.$ = yy.PLACEMENT.RIGHTOF; 
break;
case 38:
 this.$ = [$$[$0-4],$$[$0-1],{type: 'addMessage', from:$$[$0-4].actor, to:$$[$0-1].actor, signalType:$$[$0-3], msg:$$[$0]},
	              {type: 'activeStart', signalType: yy.LINETYPE.ACTIVE_START, actor: $$[$0-1]}
	             ]
break;
case 39:
 this.$ = [$$[$0-4],$$[$0-1],{type: 'addMessage', from:$$[$0-4].actor, to:$$[$0-1].actor, signalType:$$[$0-3], msg:$$[$0]},
	             {type: 'activeEnd', signalType: yy.LINETYPE.ACTIVE_END, actor: $$[$0-4]}
	             ]
break;
case 40:
 this.$ = [$$[$0-3],$$[$0-1],{type: 'addMessage', from:$$[$0-3].actor, to:$$[$0-1].actor, signalType:$$[$0-2], msg:$$[$0]}]
break;
case 41:
this.$={type: 'addActor', actor:$$[$0]}
break;
case 42:
 this.$ = yy.LINETYPE.SOLID_OPEN; 
break;
case 43:
 this.$ = yy.LINETYPE.DOTTED_OPEN; 
break;
case 44:
 this.$ = yy.LINETYPE.SOLID; 
break;
case 45:
 this.$ = yy.LINETYPE.DOTTED; 
break;
case 46:
 this.$ = yy.LINETYPE.SOLID_CROSS; 
break;
case 47:
 this.$ = yy.LINETYPE.DOTTED_CROSS; 
break;
case 48:
 this.$ = yy.LINETYPE.SOLID_POINT; 
break;
case 49:
 this.$ = yy.LINETYPE.DOTTED_POINT; 
break;
case 50:
this.$ = yy.parseMessage($$[$0].trim().substring(1)) 
break;
case 51:
 yy.parseDirective('%%{', 'open_directive'); 
break;
case 52:
 yy.parseDirective($$[$0], 'type_directive'); 
break;
case 53:
 $$[$0] = $$[$0].trim().replace(/'/g, '"'); yy.parseDirective($$[$0], 'arg_directive'); 
break;
case 54:
 yy.parseDirective('}%%', 'close_directive', 'sequence'); 
break;
}
},
table: [{3:1,4:$V0,5:$V1,6:4,7:$V2,11:6,58:$V3},{1:[3]},{3:8,4:$V0,5:$V1,6:4,7:$V2,11:6,58:$V3},{3:9,4:$V0,5:$V1,6:4,7:$V2,11:6,58:$V3},{3:10,4:$V0,5:$V1,6:4,7:$V2,11:6,58:$V3},o([1,4,5,16,21,22,23,25,27,29,30,31,33,37,48,58],$V4,{8:11}),{12:12,59:[1,13]},{59:[2,51]},{1:[2,1]},{1:[2,2]},{1:[2,3]},{1:[2,4],4:$V5,5:$V6,6:30,9:14,10:16,11:6,16:$V7,17:31,20:19,21:$V8,22:$V9,23:$Va,24:23,25:$Vb,27:$Vc,29:$Vd,30:$Ve,31:$Vf,33:$Vg,37:$Vh,48:$Vi,58:$V3},{13:34,14:[1,35],61:$Vj},o([14,61],[2,52]),o($Vk,[2,6]),{6:30,10:37,11:6,16:$V7,17:31,20:19,21:$V8,22:$V9,23:$Va,24:23,25:$Vb,27:$Vc,29:$Vd,30:$Ve,31:$Vf,33:$Vg,37:$Vh,48:$Vi,58:$V3},o($Vk,[2,8]),o($Vk,[2,9]),{17:38,48:$Vi},{5:[1,39]},o($Vk,[2,15]),{17:40,48:$Vi},{17:41,48:$Vi},{5:[1,42]},{26:43,57:$Vl},{19:[1,45]},{19:[1,46]},{19:[1,47]},{19:[1,48]},{19:[1,49]},o($Vk,[2,25]),{45:50,49:[1,51],50:[1,52],51:[1,53],52:[1,54],53:[1,55],54:[1,56],55:[1,57],56:[1,58]},{38:59,39:[1,60],43:[1,61],44:[1,62]},o([5,18,42,49,50,51,52,53,54,55,56,57],[2,41]),{5:[1,63]},{15:64,60:[1,65]},{5:[2,54]},o($Vk,[2,7]),{5:[1,67],18:[1,66]},o($Vk,[2,14]),{5:[1,68]},{5:[1,69]},o($Vk,[2,18]),{5:[1,70]},{5:[2,50]},o($Vm,$V4,{8:71}),o($Vm,$V4,{8:72}),o($Vm,$V4,{8:73}),o($Vn,$V4,{32:74,8:75}),o($Vo,$V4,{34:76,8:77}),{17:80,46:[1,78],47:[1,79],48:$Vi},o($Vp,[2,42]),o($Vp,[2,43]),o($Vp,[2,44]),o($Vp,[2,45]),o($Vp,[2,46]),o($Vp,[2,47]),o($Vp,[2,48]),o($Vp,[2,49]),{17:81,48:$Vi},{17:83,40:82,48:$Vi},{48:[2,36]},{48:[2,37]},o($Vq,[2,10]),{13:84,61:$Vj},{61:[2,53]},{19:[1,85]},o($Vk,[2,13]),o($Vk,[2,16]),o($Vk,[2,17]),o($Vk,[2,19]),{4:$V5,5:$V6,6:30,9:14,10:16,11:6,16:$V7,17:31,20:19,21:$V8,22:$V9,23:$Va,24:23,25:$Vb,27:$Vc,28:[1,86],29:$Vd,30:$Ve,31:$Vf,33:$Vg,37:$Vh,48:$Vi,58:$V3},{4:$V5,5:$V6,6:30,9:14,10:16,11:6,16:$V7,17:31,20:19,21:$V8,22:$V9,23:$Va,24:23,25:$Vb,27:$Vc,28:[1,87],29:$Vd,30:$Ve,31:$Vf,33:$Vg,37:$Vh,48:$Vi,58:$V3},{4:$V5,5:$V6,6:30,9:14,10:16,11:6,16:$V7,17:31,20:19,21:$V8,22:$V9,23:$Va,24:23,25:$Vb,27:$Vc,28:[1,88],29:$Vd,30:$Ve,31:$Vf,33:$Vg,37:$Vh,48:$Vi,58:$V3},{28:[1,89]},{4:$V5,5:$V6,6:30,9:14,10:16,11:6,16:$V7,17:31,20:19,21:$V8,22:$V9,23:$Va,24:23,25:$Vb,27:$Vc,28:[2,28],29:$Vd,30:$Ve,31:$Vf,33:$Vg,36:[1,90],37:$Vh,48:$Vi,58:$V3},{28:[1,91]},{4:$V5,5:$V6,6:30,9:14,10:16,11:6,16:$V7,17:31,20:19,21:$V8,22:$V9,23:$Va,24:23,25:$Vb,27:$Vc,28:[2,26],29:$Vd,30:$Ve,31:$Vf,33:$Vg,35:[1,92],37:$Vh,48:$Vi,58:$V3},{17:93,48:$Vi},{17:94,48:$Vi},{26:95,57:$Vl},{26:96,57:$Vl},{26:97,57:$Vl},{42:[1,98],57:[2,35]},{5:[1,99]},{5:[1,100]},o($Vk,[2,20]),o($Vk,[2,21]),o($Vk,[2,22]),o($Vk,[2,23]),{19:[1,101]},o($Vk,[2,24]),{19:[1,102]},{26:103,57:$Vl},{26:104,57:$Vl},{5:[2,40]},{5:[2,30]},{5:[2,31]},{17:105,48:$Vi},o($Vq,[2,11]),o($Vk,[2,12]),o($Vn,$V4,{8:75,32:106}),o($Vo,$V4,{8:77,34:107}),{5:[2,38]},{5:[2,39]},{57:[2,34]},{28:[2,29]},{28:[2,27]}],
defaultActions: {7:[2,51],8:[2,1],9:[2,2],10:[2,3],36:[2,54],44:[2,50],61:[2,36],62:[2,37],65:[2,53],95:[2,40],96:[2,30],97:[2,31],103:[2,38],104:[2,39],105:[2,34],106:[2,29],107:[2,27]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
            function lex() {
            var token;
            token = tstack.pop() || lexer.lex() || EOF;
            if (typeof token !== 'number') {
                if (token instanceof Array) {
                    tstack = token;
                    token = tstack.pop();
                }
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
        if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];
            for (p in table[state]) {
                if (this.terminals_[p] && p > TERROR) {
                    expected.push('\'' + this.terminals_[p] + '\'');
                }
            }
            if (lexer.showPosition) {
                errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
                errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }
            this.parseError(errStr, {
                text: lexer.match,
                token: this.terminals_[symbol] || symbol,
                line: lexer.yylineno,
                loc: yyloc,
                expected: expected
            });
        }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {"case-insensitive":true},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0: this.begin('open_directive'); return 58; 
break;
case 1: this.begin('type_directive'); return 59; 
break;
case 2: this.popState(); this.begin('arg_directive'); return 14; 
break;
case 3: this.popState(); this.popState(); return 61; 
break;
case 4:return 60;
break;
case 5:return 5;
break;
case 6:/* skip all whitespace */
break;
case 7:/* skip same-line whitespace */
break;
case 8:/* skip comments */
break;
case 9:/* skip comments */
break;
case 10:/* skip comments */
break;
case 11: this.begin('ID'); return 16; 
break;
case 12: yy_.yytext = yy_.yytext.trim(); this.begin('ALIAS'); return 48; 
break;
case 13: this.popState(); this.popState(); this.begin('LINE'); return 18; 
break;
case 14: this.popState(); this.popState(); return 5; 
break;
case 15: this.begin('LINE'); return 27; 
break;
case 16: this.begin('LINE'); return 29; 
break;
case 17: this.begin('LINE'); return 30; 
break;
case 18: this.begin('LINE'); return 31; 
break;
case 19: this.begin('LINE'); return 36; 
break;
case 20: this.begin('LINE'); return 33; 
break;
case 21: this.begin('LINE'); return 35; 
break;
case 22: this.popState(); return 19; 
break;
case 23:return 28;
break;
case 24:return 43;
break;
case 25:return 44;
break;
case 26:return 39;
break;
case 27:return 37;
break;
case 28: this.begin('ID'); return 22; 
break;
case 29: this.begin('ID'); return 23; 
break;
case 30:return 25;
break;
case 31:return 7;
break;
case 32:return 21;
break;
case 33:return 42;
break;
case 34:return 5;
break;
case 35: yy_.yytext = yy_.yytext.trim(); return 48; 
break;
case 36:return 51;
break;
case 37:return 52;
break;
case 38:return 49;
break;
case 39:return 50;
break;
case 40:return 53;
break;
case 41:return 54;
break;
case 42:return 55;
break;
case 43:return 56;
break;
case 44:return 57;
break;
case 45:return 46;
break;
case 46:return 47;
break;
case 47:return 5;
break;
case 48:return 'INVALID';
break;
}
},
rules: [/^(?:%%\{)/i,/^(?:((?:(?!\}%%)[^:.])*))/i,/^(?::)/i,/^(?:\}%%)/i,/^(?:((?:(?!\}%%).|\n)*))/i,/^(?:[\n]+)/i,/^(?:\s+)/i,/^(?:((?!\n)\s)+)/i,/^(?:#[^\n]*)/i,/^(?:%(?!\{)[^\n]*)/i,/^(?:[^\}]%%[^\n]*)/i,/^(?:participant\b)/i,/^(?:[^\->:\n,;]+?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i,/^(?:as\b)/i,/^(?:(?:))/i,/^(?:loop\b)/i,/^(?:rect\b)/i,/^(?:opt\b)/i,/^(?:alt\b)/i,/^(?:else\b)/i,/^(?:par\b)/i,/^(?:and\b)/i,/^(?:(?:[:]?(?:no)?wrap)?[^#\n;]*)/i,/^(?:end\b)/i,/^(?:left of\b)/i,/^(?:right of\b)/i,/^(?:over\b)/i,/^(?:note\b)/i,/^(?:activate\b)/i,/^(?:deactivate\b)/i,/^(?:title\b)/i,/^(?:sequenceDiagram\b)/i,/^(?:autonumber\b)/i,/^(?:,)/i,/^(?:;)/i,/^(?:[^\+\->:\n,;]+((?!(-x|--x|-\)|--\)))[\-]*[^\+\->:\n,;]+)*)/i,/^(?:->>)/i,/^(?:-->>)/i,/^(?:->)/i,/^(?:-->)/i,/^(?:-[x])/i,/^(?:--[x])/i,/^(?:-[\)])/i,/^(?:--[\)])/i,/^(?::(?:(?:no)?wrap)?[^#\n;]+)/i,/^(?:\+)/i,/^(?:-)/i,/^(?:$)/i,/^(?:.)/i],
conditions: {"open_directive":{"rules":[1,8],"inclusive":false},"type_directive":{"rules":[2,3,8],"inclusive":false},"arg_directive":{"rules":[3,4,8],"inclusive":false},"ID":{"rules":[7,8,12],"inclusive":false},"ALIAS":{"rules":[7,8,13,14],"inclusive":false},"LINE":{"rules":[7,8,22],"inclusive":false},"INITIAL":{"rules":[0,5,6,8,9,10,11,15,16,17,18,19,20,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (true) {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js").readFileSync(__webpack_require__(/*! path */ "./node_modules/path-browserify/index.js").normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if ( true && __webpack_require__.c[__webpack_require__.s] === module) {
  exports.main(process.argv.slice(1));
}
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/diagrams/sequence/sequenceDb.js":
/*!*********************************************!*\
  !*** ./src/diagrams/sequence/sequenceDb.js ***!
  \*********************************************/
/*! exports provided: parseDirective, addActor, addMessage, addSignal, getMessages, getActors, getActor, getActorKeys, getTitle, getTitleWrapped, enableSequenceNumbers, showSequenceNumbers, setWrap, autoWrap, clear, parseMessage, LINETYPE, ARROWTYPE, PLACEMENT, addNote, setTitle, apply, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseDirective", function() { return parseDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addActor", function() { return addActor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addMessage", function() { return addMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addSignal", function() { return addSignal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMessages", function() { return getMessages; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getActors", function() { return getActors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getActor", function() { return getActor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getActorKeys", function() { return getActorKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTitle", function() { return getTitle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTitleWrapped", function() { return getTitleWrapped; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableSequenceNumbers", function() { return enableSequenceNumbers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "showSequenceNumbers", function() { return showSequenceNumbers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setWrap", function() { return setWrap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "autoWrap", function() { return autoWrap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseMessage", function() { return parseMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LINETYPE", function() { return LINETYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARROWTYPE", function() { return ARROWTYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PLACEMENT", function() { return PLACEMENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addNote", function() { return addNote; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setTitle", function() { return setTitle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "apply", function() { return apply; });
/* harmony import */ var _mermaidAPI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mermaidAPI */ "./src/mermaidAPI.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");



var prevActor = undefined;
var actors = {};
var messages = [];
var notes = [];
var title = '';
var titleWrapped = false;
var sequenceNumbersEnabled = false;
var wrapEnabled = false;
var parseDirective = function parseDirective(statement, context, type) {
  _mermaidAPI__WEBPACK_IMPORTED_MODULE_0__["default"].parseDirective(this, statement, context, type);
};
var addActor = function addActor(id, name, description) {
  // Don't allow description nulling
  var old = actors[id];
  if (old && name === old.name && description == null) return; // Don't allow null descriptions, either

  if (description == null || description.text == null) {
    description = {
      text: name,
      wrap: null
    };
  }

  actors[id] = {
    name: name,
    description: description.text,
    wrap: description.wrap === undefined && autoWrap() || !!description.wrap,
    prevActor: prevActor
  };

  if (prevActor && actors[prevActor]) {
    actors[prevActor].nextActor = id;
  }

  prevActor = id;
};

var activationCount = function activationCount(part) {
  var i;
  var count = 0;

  for (i = 0; i < messages.length; i++) {
    if (messages[i].type === LINETYPE.ACTIVE_START) {
      if (messages[i].from.actor === part) {
        count++;
      }
    }

    if (messages[i].type === LINETYPE.ACTIVE_END) {
      if (messages[i].from.actor === part) {
        count--;
      }
    }
  }

  return count;
};

var addMessage = function addMessage(idFrom, idTo, message, answer) {
  messages.push({
    from: idFrom,
    to: idTo,
    message: message.text,
    wrap: message.wrap === undefined && autoWrap() || !!message.wrap,
    answer: answer
  });
};
var addSignal = function addSignal(idFrom, idTo) {
  var message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    text: undefined,
    wrap: undefined
  };
  var messageType = arguments.length > 3 ? arguments[3] : undefined;

  if (messageType === LINETYPE.ACTIVE_END) {
    var cnt = activationCount(idFrom.actor);

    if (cnt < 1) {
      // Bail out as there is an activation signal from an inactive participant
      var error = new Error('Trying to inactivate an inactive participant (' + idFrom.actor + ')');
      error.hash = {
        text: '->>-',
        token: '->>-',
        line: '1',
        loc: {
          first_line: 1,
          last_line: 1,
          first_column: 1,
          last_column: 1
        },
        expected: ["'ACTIVE_PARTICIPANT'"]
      };
      throw error;
    }
  }

  messages.push({
    from: idFrom,
    to: idTo,
    message: message.text,
    wrap: message.wrap === undefined && autoWrap() || !!message.wrap,
    type: messageType
  });
  return true;
};
var getMessages = function getMessages() {
  return messages;
};
var getActors = function getActors() {
  return actors;
};
var getActor = function getActor(id) {
  return actors[id];
};
var getActorKeys = function getActorKeys() {
  return Object.keys(actors);
};
var getTitle = function getTitle() {
  return title;
};
var getTitleWrapped = function getTitleWrapped() {
  return titleWrapped;
};
var enableSequenceNumbers = function enableSequenceNumbers() {
  sequenceNumbersEnabled = true;
};
var showSequenceNumbers = function showSequenceNumbers() {
  return sequenceNumbersEnabled;
};
var setWrap = function setWrap(wrapSetting) {
  wrapEnabled = wrapSetting;
};
var autoWrap = function autoWrap() {
  return wrapEnabled;
};
var clear = function clear() {
  actors = {};
  messages = [];
};
var parseMessage = function parseMessage(str) {
  var _str = str.trim();

  var message = {
    text: _str.replace(/^[:]?(?:no)?wrap:/, '').trim(),
    wrap: _str.match(/^[:]?wrap:/) !== null ? true : _str.match(/^[:]?nowrap:/) !== null ? false : undefined
  };
  _logger__WEBPACK_IMPORTED_MODULE_2__["log"].debug('parseMessage:', message);
  return message;
};
var LINETYPE = {
  SOLID: 0,
  DOTTED: 1,
  NOTE: 2,
  SOLID_CROSS: 3,
  DOTTED_CROSS: 4,
  SOLID_OPEN: 5,
  DOTTED_OPEN: 6,
  LOOP_START: 10,
  LOOP_END: 11,
  ALT_START: 12,
  ALT_ELSE: 13,
  ALT_END: 14,
  OPT_START: 15,
  OPT_END: 16,
  ACTIVE_START: 17,
  ACTIVE_END: 18,
  PAR_START: 19,
  PAR_AND: 20,
  PAR_END: 21,
  RECT_START: 22,
  RECT_END: 23,
  SOLID_POINT: 24,
  DOTTED_POINT: 25
};
var ARROWTYPE = {
  FILLED: 0,
  OPEN: 1
};
var PLACEMENT = {
  LEFTOF: 0,
  RIGHTOF: 1,
  OVER: 2
};
var addNote = function addNote(actor, placement, message) {
  var note = {
    actor: actor,
    placement: placement,
    message: message.text,
    wrap: message.wrap === undefined && autoWrap() || !!message.wrap
  }; // Coerce actor into a [to, from, ...] array

  var actors = [].concat(actor, actor);
  notes.push(note);
  messages.push({
    from: actors[0],
    to: actors[1],
    message: message.text,
    wrap: message.wrap === undefined && autoWrap() || !!message.wrap,
    type: LINETYPE.NOTE,
    placement: placement
  });
};
var setTitle = function setTitle(titleWrap) {
  title = titleWrap.text;
  titleWrapped = titleWrap.wrap === undefined && autoWrap() || !!titleWrap.wrap;
};
var apply = function apply(param) {
  if (param instanceof Array) {
    param.forEach(function (item) {
      apply(item);
    });
  } else {
    switch (param.type) {
      case 'addActor':
        addActor(param.actor, param.actor, param.description);
        break;

      case 'activeStart':
        addSignal(param.actor, undefined, undefined, param.signalType);
        break;

      case 'activeEnd':
        addSignal(param.actor, undefined, undefined, param.signalType);
        break;

      case 'addNote':
        addNote(param.actor, param.placement, param.text);
        break;

      case 'addMessage':
        addSignal(param.from, param.to, param.msg, param.signalType);
        break;

      case 'loopStart':
        addSignal(undefined, undefined, param.loopText, param.signalType);
        break;

      case 'loopEnd':
        addSignal(undefined, undefined, undefined, param.signalType);
        break;

      case 'rectStart':
        addSignal(undefined, undefined, param.color, param.signalType);
        break;

      case 'rectEnd':
        addSignal(undefined, undefined, undefined, param.signalType);
        break;

      case 'optStart':
        addSignal(undefined, undefined, param.optText, param.signalType);
        break;

      case 'optEnd':
        addSignal(undefined, undefined, undefined, param.signalType);
        break;

      case 'altStart':
        addSignal(undefined, undefined, param.altText, param.signalType);
        break;

      case 'else':
        addSignal(undefined, undefined, param.altText, param.signalType);
        break;

      case 'altEnd':
        addSignal(undefined, undefined, undefined, param.signalType);
        break;

      case 'setTitle':
        setTitle(param.text);
        break;

      case 'parStart':
        addSignal(undefined, undefined, param.parText, param.signalType);
        break;

      case 'and':
        addSignal(undefined, undefined, param.parText, param.signalType);
        break;

      case 'parEnd':
        addSignal(undefined, undefined, undefined, param.signalType);
        break;
    }
  }
};
/* harmony default export */ __webpack_exports__["default"] = ({
  addActor: addActor,
  addMessage: addMessage,
  addSignal: addSignal,
  autoWrap: autoWrap,
  setWrap: setWrap,
  enableSequenceNumbers: enableSequenceNumbers,
  showSequenceNumbers: showSequenceNumbers,
  getMessages: getMessages,
  getActors: getActors,
  getActor: getActor,
  getActorKeys: getActorKeys,
  getTitle: getTitle,
  parseDirective: parseDirective,
  getConfig: function getConfig() {
    return _config__WEBPACK_IMPORTED_MODULE_1__["getConfig"]().sequence;
  },
  getTitleWrapped: getTitleWrapped,
  clear: clear,
  parseMessage: parseMessage,
  LINETYPE: LINETYPE,
  ARROWTYPE: ARROWTYPE,
  PLACEMENT: PLACEMENT,
  addNote: addNote,
  setTitle: setTitle,
  apply: apply
});

/***/ }),

/***/ "./src/diagrams/sequence/sequenceRenderer.js":
/*!***************************************************!*\
  !*** ./src/diagrams/sequence/sequenceRenderer.js ***!
  \***************************************************/
/*! exports provided: bounds, drawActors, setConf, draw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounds", function() { return bounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawActors", function() { return drawActors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConf", function() { return setConf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return draw; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _svgDraw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./svgDraw */ "./src/diagrams/sequence/svgDraw.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parser/sequenceDiagram */ "./src/diagrams/sequence/parser/sequenceDiagram.jison");
/* harmony import */ var _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _common_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/common */ "./src/diagrams/common/common.js");
/* harmony import */ var _sequenceDb__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sequenceDb */ "./src/diagrams/sequence/sequenceDb.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");








_parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy = _sequenceDb__WEBPACK_IMPORTED_MODULE_5__["default"];
var conf = {};
var bounds = {
  data: {
    startx: undefined,
    stopx: undefined,
    starty: undefined,
    stopy: undefined
  },
  verticalPos: 0,
  sequenceItems: [],
  activations: [],
  models: {
    getHeight: function getHeight() {
      return Math.max.apply(null, this.actors.length === 0 ? [0] : this.actors.map(function (actor) {
        return actor.height || 0;
      })) + (this.loops.length === 0 ? 0 : this.loops.map(function (it) {
        return it.height || 0;
      }).reduce(function (acc, h) {
        return acc + h;
      })) + (this.messages.length === 0 ? 0 : this.messages.map(function (it) {
        return it.height || 0;
      }).reduce(function (acc, h) {
        return acc + h;
      })) + (this.notes.length === 0 ? 0 : this.notes.map(function (it) {
        return it.height || 0;
      }).reduce(function (acc, h) {
        return acc + h;
      }));
    },
    clear: function clear() {
      this.actors = [];
      this.loops = [];
      this.messages = [];
      this.notes = [];
    },
    addActor: function addActor(actorModel) {
      this.actors.push(actorModel);
    },
    addLoop: function addLoop(loopModel) {
      this.loops.push(loopModel);
    },
    addMessage: function addMessage(msgModel) {
      this.messages.push(msgModel);
    },
    addNote: function addNote(noteModel) {
      this.notes.push(noteModel);
    },
    lastActor: function lastActor() {
      return this.actors[this.actors.length - 1];
    },
    lastLoop: function lastLoop() {
      return this.loops[this.loops.length - 1];
    },
    lastMessage: function lastMessage() {
      return this.messages[this.messages.length - 1];
    },
    lastNote: function lastNote() {
      return this.notes[this.notes.length - 1];
    },
    actors: [],
    loops: [],
    messages: [],
    notes: []
  },
  init: function init() {
    this.sequenceItems = [];
    this.activations = [];
    this.models.clear();
    this.data = {
      startx: undefined,
      stopx: undefined,
      starty: undefined,
      stopy: undefined
    };
    this.verticalPos = 0;
    setConf(_parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.getConfig());
  },
  updateVal: function updateVal(obj, key, val, fun) {
    if (typeof obj[key] === 'undefined') {
      obj[key] = val;
    } else {
      obj[key] = fun(val, obj[key]);
    }
  },
  updateBounds: function updateBounds(startx, starty, stopx, stopy) {
    var _self = this;

    var cnt = 0;

    function updateFn(type) {
      return function updateItemBounds(item) {
        cnt++; // The loop sequenceItems is a stack so the biggest margins in the beginning of the sequenceItems

        var n = _self.sequenceItems.length - cnt + 1;

        _self.updateVal(item, 'starty', starty - n * conf.boxMargin, Math.min);

        _self.updateVal(item, 'stopy', stopy + n * conf.boxMargin, Math.max);

        _self.updateVal(bounds.data, 'startx', startx - n * conf.boxMargin, Math.min);

        _self.updateVal(bounds.data, 'stopx', stopx + n * conf.boxMargin, Math.max);

        if (!(type === 'activation')) {
          _self.updateVal(item, 'startx', startx - n * conf.boxMargin, Math.min);

          _self.updateVal(item, 'stopx', stopx + n * conf.boxMargin, Math.max);

          _self.updateVal(bounds.data, 'starty', starty - n * conf.boxMargin, Math.min);

          _self.updateVal(bounds.data, 'stopy', stopy + n * conf.boxMargin, Math.max);
        }
      };
    }

    this.sequenceItems.forEach(updateFn());
    this.activations.forEach(updateFn('activation'));
  },
  insert: function insert(startx, starty, stopx, stopy) {
    var _startx = Math.min(startx, stopx);

    var _stopx = Math.max(startx, stopx);

    var _starty = Math.min(starty, stopy);

    var _stopy = Math.max(starty, stopy);

    this.updateVal(bounds.data, 'startx', _startx, Math.min);
    this.updateVal(bounds.data, 'starty', _starty, Math.min);
    this.updateVal(bounds.data, 'stopx', _stopx, Math.max);
    this.updateVal(bounds.data, 'stopy', _stopy, Math.max);
    this.updateBounds(_startx, _starty, _stopx, _stopy);
  },
  newActivation: function newActivation(message, diagram, actors) {
    var actorRect = actors[message.from.actor];
    var stackedSize = actorActivations(message.from.actor).length || 0;
    var x = actorRect.x + actorRect.width / 2 + (stackedSize - 1) * conf.activationWidth / 2;
    this.activations.push({
      startx: x,
      starty: this.verticalPos + 2,
      stopx: x + conf.activationWidth,
      stopy: undefined,
      actor: message.from.actor,
      anchored: _svgDraw__WEBPACK_IMPORTED_MODULE_1__["default"].anchorElement(diagram)
    });
  },
  endActivation: function endActivation(message) {
    // find most recent activation for given actor
    var lastActorActivationIdx = this.activations.map(function (activation) {
      return activation.actor;
    }).lastIndexOf(message.from.actor);
    return this.activations.splice(lastActorActivationIdx, 1)[0];
  },
  createLoop: function createLoop() {
    var title = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      message: undefined,
      wrap: false,
      width: undefined
    };
    var fill = arguments.length > 1 ? arguments[1] : undefined;
    return {
      startx: undefined,
      starty: this.verticalPos,
      stopx: undefined,
      stopy: undefined,
      title: title.message,
      wrap: title.wrap,
      width: title.width,
      height: 0,
      fill: fill
    };
  },
  newLoop: function newLoop() {
    var title = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      message: undefined,
      wrap: false,
      width: undefined
    };
    var fill = arguments.length > 1 ? arguments[1] : undefined;
    this.sequenceItems.push(this.createLoop(title, fill));
  },
  endLoop: function endLoop() {
    return this.sequenceItems.pop();
  },
  addSectionToLoop: function addSectionToLoop(message) {
    var loop = this.sequenceItems.pop();
    loop.sections = loop.sections || [];
    loop.sectionTitles = loop.sectionTitles || [];
    loop.sections.push({
      y: bounds.getVerticalPos(),
      height: 0
    });
    loop.sectionTitles.push(message);
    this.sequenceItems.push(loop);
  },
  bumpVerticalPos: function bumpVerticalPos(bump) {
    this.verticalPos = this.verticalPos + bump;
    this.data.stopy = this.verticalPos;
  },
  getVerticalPos: function getVerticalPos() {
    return this.verticalPos;
  },
  getBounds: function getBounds() {
    return {
      bounds: this.data,
      models: this.models
    };
  }
};
/**
 * Draws an note in the diagram with the attached line
 * @param elem - The diagram to draw to.
 * @param noteModel:{x: number, y: number, message: string, width: number} - startx: x axis start position, verticalPos: y axis position, messsage: the message to be shown, width: Set this with a custom width to override the default configured width.
 */

var drawNote = function drawNote(elem, noteModel) {
  bounds.bumpVerticalPos(conf.boxMargin);
  noteModel.height = conf.boxMargin;
  noteModel.starty = bounds.getVerticalPos();
  var rect = _svgDraw__WEBPACK_IMPORTED_MODULE_1__["default"].getNoteRect();
  rect.x = noteModel.startx;
  rect.y = noteModel.starty;
  rect.width = noteModel.width || conf.width;
  rect.class = 'note';
  var g = elem.append('g');
  var rectElem = _svgDraw__WEBPACK_IMPORTED_MODULE_1__["default"].drawRect(g, rect);
  var textObj = _svgDraw__WEBPACK_IMPORTED_MODULE_1__["default"].getTextObj();
  textObj.x = noteModel.startx;
  textObj.y = noteModel.starty;
  textObj.width = rect.width;
  textObj.dy = '1em';
  textObj.text = noteModel.message;
  textObj.class = 'noteText';
  textObj.fontFamily = conf.noteFontFamily;
  textObj.fontSize = conf.noteFontSize;
  textObj.fontWeight = conf.noteFontWeight;
  textObj.anchor = conf.noteAlign;
  textObj.textMargin = conf.noteMargin;
  textObj.valign = conf.noteAlign;
  var textElem = Object(_svgDraw__WEBPACK_IMPORTED_MODULE_1__["drawText"])(g, textObj);
  var textHeight = Math.round(textElem.map(function (te) {
    return (te._groups || te)[0][0].getBBox().height;
  }).reduce(function (acc, curr) {
    return acc + curr;
  }));
  rectElem.attr('height', textHeight + 2 * conf.noteMargin);
  noteModel.height += textHeight + 2 * conf.noteMargin;
  bounds.bumpVerticalPos(textHeight + 2 * conf.noteMargin);
  noteModel.stopy = noteModel.starty + textHeight + 2 * conf.noteMargin;
  noteModel.stopx = noteModel.startx + rect.width;
  bounds.insert(noteModel.startx, noteModel.starty, noteModel.stopx, noteModel.stopy);
  bounds.models.addNote(noteModel);
};

var messageFont = function messageFont(cnf) {
  return {
    fontFamily: cnf.messageFontFamily,
    fontSize: cnf.messageFontSize,
    fontWeight: cnf.messageFontWeight
  };
};

var noteFont = function noteFont(cnf) {
  return {
    fontFamily: cnf.noteFontFamily,
    fontSize: cnf.noteFontSize,
    fontWeight: cnf.noteFontWeight
  };
};

var actorFont = function actorFont(cnf) {
  return {
    fontFamily: cnf.actorFontFamily,
    fontSize: cnf.actorFontSize,
    fontWeight: cnf.actorFontWeight
  };
};
/**
 * Draws a message
 * @param g - the parent of the message element
 * @param msgModel - the model containing fields describing a message
 */


var drawMessage = function drawMessage(g, msgModel) {
  bounds.bumpVerticalPos(10);
  var startx = msgModel.startx,
      stopx = msgModel.stopx,
      starty = msgModel.starty,
      message = msgModel.message,
      type = msgModel.type,
      sequenceIndex = msgModel.sequenceIndex;
  var lines = _common_common__WEBPACK_IMPORTED_MODULE_4__["default"].splitBreaks(message).length;
  var textDims = _utils__WEBPACK_IMPORTED_MODULE_7__["default"].calculateTextDimensions(message, messageFont(conf));
  var lineHeight = textDims.height / lines;
  msgModel.height += lineHeight;
  bounds.bumpVerticalPos(lineHeight);
  var textObj = _svgDraw__WEBPACK_IMPORTED_MODULE_1__["default"].getTextObj();
  textObj.x = startx;
  textObj.y = starty + 10;
  textObj.width = stopx - startx;
  textObj.class = 'messageText';
  textObj.dy = '1em';
  textObj.text = message;
  textObj.fontFamily = conf.messageFontFamily;
  textObj.fontSize = conf.messageFontSize;
  textObj.fontWeight = conf.messageFontWeight;
  textObj.anchor = conf.messageAlign;
  textObj.valign = conf.messageAlign;
  textObj.textMargin = conf.wrapPadding;
  textObj.tspan = false;
  Object(_svgDraw__WEBPACK_IMPORTED_MODULE_1__["drawText"])(g, textObj);
  var totalOffset = textDims.height - 10;
  var textWidth = textDims.width;
  var line, lineStarty;

  if (startx === stopx) {
    lineStarty = bounds.getVerticalPos() + totalOffset;

    if (conf.rightAngles) {
      line = g.append('path').attr('d', "M  ".concat(startx, ",").concat(lineStarty, " H ").concat(startx + Math.max(conf.width / 2, textWidth / 2), " V ").concat(lineStarty + 25, " H ").concat(startx));
    } else {
      totalOffset += conf.boxMargin;
      lineStarty = bounds.getVerticalPos() + totalOffset;
      line = g.append('path').attr('d', 'M ' + startx + ',' + lineStarty + ' C ' + (startx + 60) + ',' + (lineStarty - 10) + ' ' + (startx + 60) + ',' + (lineStarty + 30) + ' ' + startx + ',' + (lineStarty + 20));
    }

    totalOffset += 30;
    var dx = Math.max(textWidth / 2, conf.width / 2);
    bounds.insert(startx - dx, bounds.getVerticalPos() - 10 + totalOffset, stopx + dx, bounds.getVerticalPos() + 30 + totalOffset);
  } else {
    totalOffset += conf.boxMargin;
    lineStarty = bounds.getVerticalPos() + totalOffset;
    line = g.append('line');
    line.attr('x1', startx);
    line.attr('y1', lineStarty);
    line.attr('x2', stopx);
    line.attr('y2', lineStarty);
    bounds.insert(startx, lineStarty - 10, stopx, lineStarty);
  } // Make an SVG Container
  // Draw the line


  if (type === _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.DOTTED || type === _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.DOTTED_CROSS || type === _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.DOTTED_POINT || type === _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.DOTTED_OPEN) {
    line.style('stroke-dasharray', '3, 3');
    line.attr('class', 'messageLine1');
  } else {
    line.attr('class', 'messageLine0');
  }

  var url = '';

  if (conf.arrowMarkerAbsolute) {
    url = window.location.protocol + '//' + window.location.host + window.location.pathname + window.location.search;
    url = url.replace(/\(/g, '\\(');
    url = url.replace(/\)/g, '\\)');
  }

  line.attr('stroke-width', 2);
  line.attr('stroke', 'none'); // handled by theme/css anyway

  line.style('fill', 'none'); // remove any fill colour

  if (type === _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.SOLID || type === _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.DOTTED) {
    line.attr('marker-end', 'url(' + url + '#arrowhead)');
  }

  if (type === _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.SOLID_POINT || type === _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.DOTTED_POINT) {
    line.attr('marker-end', 'url(' + url + '#filled-head)');
  }

  if (type === _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.SOLID_CROSS || type === _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.DOTTED_CROSS) {
    line.attr('marker-end', 'url(' + url + '#crosshead)');
  } // add node number


  if (_sequenceDb__WEBPACK_IMPORTED_MODULE_5__["default"].showSequenceNumbers() || conf.showSequenceNumbers) {
    line.attr('marker-start', 'url(' + url + '#sequencenumber)');
    g.append('text').attr('x', startx).attr('y', lineStarty + 4).attr('font-family', 'sans-serif').attr('font-size', '12px').attr('text-anchor', 'middle').attr('textLength', '16px').attr('class', 'sequenceNumber').text(sequenceIndex);
  }

  bounds.bumpVerticalPos(totalOffset);
  msgModel.height += totalOffset;
  msgModel.stopy = msgModel.starty + msgModel.height;
  bounds.insert(msgModel.fromBounds, msgModel.starty, msgModel.toBounds, msgModel.stopy);
};

var drawActors = function drawActors(diagram, actors, actorKeys, verticalPos) {
  // Draw the actors
  var prevWidth = 0;
  var prevMargin = 0;

  for (var i = 0; i < actorKeys.length; i++) {
    var actor = actors[actorKeys[i]]; // Add some rendering data to the object

    actor.width = actor.width || conf.width;
    actor.height = Math.max(actor.height || conf.height, conf.height);
    actor.margin = actor.margin || conf.actorMargin;
    actor.x = prevWidth + prevMargin;
    actor.y = verticalPos; // Draw the box with the attached line

    _svgDraw__WEBPACK_IMPORTED_MODULE_1__["default"].drawActor(diagram, actor, conf);
    bounds.insert(actor.x, verticalPos, actor.x + actor.width, actor.height);
    prevWidth += actor.width;
    prevMargin += actor.margin;
    bounds.models.addActor(actor);
  } // Add a margin between the actor boxes and the first arrow


  bounds.bumpVerticalPos(conf.height);
};
var setConf = function setConf(cnf) {
  Object(_utils__WEBPACK_IMPORTED_MODULE_7__["assignWithDepth"])(conf, cnf);

  if (cnf.fontFamily) {
    conf.actorFontFamily = conf.noteFontFamily = conf.messageFontFamily = cnf.fontFamily;
  }

  if (cnf.fontSize) {
    conf.actorFontSize = conf.noteFontSize = conf.messageFontSize = cnf.fontSize;
  }

  if (cnf.fontWeight) {
    conf.actorFontWeight = conf.noteFontWeight = conf.messageFontWeight = cnf.fontWeight;
  }
};

var actorActivations = function actorActivations(actor) {
  return bounds.activations.filter(function (activation) {
    return activation.actor === actor;
  });
};

var activationBounds = function activationBounds(actor, actors) {
  // handle multiple stacked activations for same actor
  var actorObj = actors[actor];
  var activations = actorActivations(actor);
  var left = activations.reduce(function (acc, activation) {
    return Math.min(acc, activation.startx);
  }, actorObj.x + actorObj.width / 2);
  var right = activations.reduce(function (acc, activation) {
    return Math.max(acc, activation.stopx);
  }, actorObj.x + actorObj.width / 2);
  return [left, right];
};

function adjustLoopHeightForWrap(loopWidths, msg, preMargin, postMargin, addLoopFn) {
  bounds.bumpVerticalPos(preMargin);
  var heightAdjust = postMargin;

  if (msg.id && msg.message && loopWidths[msg.id]) {
    var loopWidth = loopWidths[msg.id].width;
    var textConf = messageFont(conf);
    msg.message = _utils__WEBPACK_IMPORTED_MODULE_7__["default"].wrapLabel("[".concat(msg.message, "]"), loopWidth - 2 * conf.wrapPadding, textConf);
    msg.width = loopWidth;
    msg.wrap = true; // const lines = common.splitBreaks(msg.message).length;

    var textDims = _utils__WEBPACK_IMPORTED_MODULE_7__["default"].calculateTextDimensions(msg.message, textConf);
    var totalOffset = Math.max(textDims.height, conf.labelBoxHeight);
    heightAdjust = postMargin + totalOffset;
    _logger__WEBPACK_IMPORTED_MODULE_2__["log"].debug("".concat(totalOffset, " - ").concat(msg.message));
  }

  addLoopFn(msg);
  bounds.bumpVerticalPos(heightAdjust);
}
/**
 * Draws a sequenceDiagram in the tag with id: id based on the graph definition in text.
 * @param text
 * @param id
 */


var draw = function draw(text, id) {
  conf = _config__WEBPACK_IMPORTED_MODULE_6__["getConfig"]().sequence;
  _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.clear();
  _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.setWrap(conf.wrap);
  _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].parse(text + '\n');
  bounds.init();
  _logger__WEBPACK_IMPORTED_MODULE_2__["log"].debug("C:".concat(JSON.stringify(conf, null, 2)));
  var diagram = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])("[id=\"".concat(id, "\"]")); // Fetch data from the parsing

  var actors = _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.getActors();
  var actorKeys = _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.getActorKeys();
  var messages = _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.getMessages();
  var title = _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.getTitle();
  var maxMessageWidthPerActor = getMaxMessageWidthPerActor(actors, messages);
  conf.height = calculateActorMargins(actors, maxMessageWidthPerActor);
  drawActors(diagram, actors, actorKeys, 0);
  var loopWidths = calculateLoopBounds(messages, actors, maxMessageWidthPerActor); // The arrow head definition is attached to the svg once

  _svgDraw__WEBPACK_IMPORTED_MODULE_1__["default"].insertArrowHead(diagram);
  _svgDraw__WEBPACK_IMPORTED_MODULE_1__["default"].insertArrowCrossHead(diagram);
  _svgDraw__WEBPACK_IMPORTED_MODULE_1__["default"].insertArrowFilledHead(diagram);
  _svgDraw__WEBPACK_IMPORTED_MODULE_1__["default"].insertSequenceNumber(diagram);

  function activeEnd(msg, verticalPos) {
    var activationData = bounds.endActivation(msg);

    if (activationData.starty + 18 > verticalPos) {
      activationData.starty = verticalPos - 6;
      verticalPos += 12;
    }

    _svgDraw__WEBPACK_IMPORTED_MODULE_1__["default"].drawActivation(diagram, activationData, verticalPos, conf, actorActivations(msg.from.actor).length);
    bounds.insert(activationData.startx, verticalPos - 10, activationData.stopx, verticalPos);
  } // Draw the messages/signals


  var sequenceIndex = 1;
  messages.forEach(function (msg) {
    var loopModel, noteModel, msgModel;

    switch (msg.type) {
      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.NOTE:
        noteModel = msg.noteModel;
        drawNote(diagram, noteModel);
        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.ACTIVE_START:
        bounds.newActivation(msg, diagram, actors);
        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.ACTIVE_END:
        activeEnd(msg, bounds.getVerticalPos());
        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.LOOP_START:
        adjustLoopHeightForWrap(loopWidths, msg, conf.boxMargin, conf.boxMargin + conf.boxTextMargin, function (message) {
          return bounds.newLoop(message);
        });
        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.LOOP_END:
        loopModel = bounds.endLoop();
        _svgDraw__WEBPACK_IMPORTED_MODULE_1__["default"].drawLoop(diagram, loopModel, 'loop', conf);
        bounds.bumpVerticalPos(loopModel.stopy - bounds.getVerticalPos());
        bounds.models.addLoop(loopModel);
        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.RECT_START:
        adjustLoopHeightForWrap(loopWidths, msg, conf.boxMargin, conf.boxMargin, function (message) {
          return bounds.newLoop(undefined, message.message);
        });
        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.RECT_END:
        loopModel = bounds.endLoop();
        _svgDraw__WEBPACK_IMPORTED_MODULE_1__["default"].drawBackgroundRect(diagram, loopModel);
        bounds.models.addLoop(loopModel);
        bounds.bumpVerticalPos(loopModel.stopy - bounds.getVerticalPos());
        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.OPT_START:
        adjustLoopHeightForWrap(loopWidths, msg, conf.boxMargin, conf.boxMargin + conf.boxTextMargin, function (message) {
          return bounds.newLoop(message);
        });
        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.OPT_END:
        loopModel = bounds.endLoop();
        _svgDraw__WEBPACK_IMPORTED_MODULE_1__["default"].drawLoop(diagram, loopModel, 'opt', conf);
        bounds.bumpVerticalPos(loopModel.stopy - bounds.getVerticalPos());
        bounds.models.addLoop(loopModel);
        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.ALT_START:
        adjustLoopHeightForWrap(loopWidths, msg, conf.boxMargin, conf.boxMargin + conf.boxTextMargin, function (message) {
          return bounds.newLoop(message);
        });
        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.ALT_ELSE:
        adjustLoopHeightForWrap(loopWidths, msg, conf.boxMargin + conf.boxTextMargin, conf.boxMargin, function (message) {
          return bounds.addSectionToLoop(message);
        });
        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.ALT_END:
        loopModel = bounds.endLoop();
        _svgDraw__WEBPACK_IMPORTED_MODULE_1__["default"].drawLoop(diagram, loopModel, 'alt', conf);
        bounds.bumpVerticalPos(loopModel.stopy - bounds.getVerticalPos());
        bounds.models.addLoop(loopModel);
        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.PAR_START:
        adjustLoopHeightForWrap(loopWidths, msg, conf.boxMargin, conf.boxMargin + conf.boxTextMargin, function (message) {
          return bounds.newLoop(message);
        });
        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.PAR_AND:
        adjustLoopHeightForWrap(loopWidths, msg, conf.boxMargin + conf.boxTextMargin, conf.boxMargin, function (message) {
          return bounds.addSectionToLoop(message);
        });
        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.PAR_END:
        loopModel = bounds.endLoop();
        _svgDraw__WEBPACK_IMPORTED_MODULE_1__["default"].drawLoop(diagram, loopModel, 'par', conf);
        bounds.bumpVerticalPos(loopModel.stopy - bounds.getVerticalPos());
        bounds.models.addLoop(loopModel);
        break;

      default:
        try {
          // lastMsg = msg
          msgModel = msg.msgModel;
          msgModel.starty = bounds.getVerticalPos();
          msgModel.sequenceIndex = sequenceIndex;
          drawMessage(diagram, msgModel);
          bounds.models.addMessage(msgModel);
        } catch (e) {
          _logger__WEBPACK_IMPORTED_MODULE_2__["log"].error('error while drawing message', e);
        }

    } // Increment sequence counter if msg.type is a line (and not another event like activation or note, etc)


    if ([_parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.SOLID_OPEN, _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.DOTTED_OPEN, _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.SOLID, _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.DOTTED, _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.SOLID_CROSS, _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.DOTTED_CROSS, _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.SOLID_POINT, _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.DOTTED_POINT].includes(msg.type)) {
      sequenceIndex++;
    }
  });

  if (conf.mirrorActors) {
    // Draw actors below diagram
    bounds.bumpVerticalPos(conf.boxMargin * 2);
    drawActors(diagram, actors, actorKeys, bounds.getVerticalPos());
  }

  var _bounds$getBounds = bounds.getBounds(),
      box = _bounds$getBounds.bounds; // Adjust line height of actor lines now that the height of the diagram is known


  _logger__WEBPACK_IMPORTED_MODULE_2__["log"].debug('For line height fix Querying: #' + id + ' .actor-line');
  var actorLines = Object(d3__WEBPACK_IMPORTED_MODULE_0__["selectAll"])('#' + id + ' .actor-line');
  actorLines.attr('y2', box.stopy);
  var height = box.stopy - box.starty + 2 * conf.diagramMarginY;

  if (conf.mirrorActors) {
    height = height - conf.boxMargin + conf.bottomMarginAdj;
  }

  var width = box.stopx - box.startx + 2 * conf.diagramMarginX;

  if (title) {
    diagram.append('text').text(title).attr('x', (box.stopx - box.startx) / 2 - 2 * conf.diagramMarginX).attr('y', -25);
  }

  Object(_utils__WEBPACK_IMPORTED_MODULE_7__["configureSvgSize"])(diagram, height, width, conf.useMaxWidth);
  var extraVertForTitle = title ? 40 : 0;
  diagram.attr('viewBox', box.startx - conf.diagramMarginX + ' -' + (conf.diagramMarginY + extraVertForTitle) + ' ' + width + ' ' + (height + extraVertForTitle));
  _logger__WEBPACK_IMPORTED_MODULE_2__["log"].debug("models:", bounds.models);
};
/**
 * Retrieves the max message width of each actor, supports signals (messages, loops)
 * and notes.
 *
 * It will enumerate each given message, and will determine its text width, in relation
 * to the actor it originates from, and destined to.
 *
 * @param actors - The actors map
 * @param messages - A list of message objects to iterate
 */

var getMaxMessageWidthPerActor = function getMaxMessageWidthPerActor(actors, messages) {
  var maxMessageWidthPerActor = {};
  messages.forEach(function (msg) {
    if (actors[msg.to] && actors[msg.from]) {
      var actor = actors[msg.to]; // If this is the first actor, and the message is left of it, no need to calculate the margin

      if (msg.placement === _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.PLACEMENT.LEFTOF && !actor.prevActor) {
        return;
      } // If this is the last actor, and the message is right of it, no need to calculate the margin


      if (msg.placement === _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.PLACEMENT.RIGHTOF && !actor.nextActor) {
        return;
      }

      var isNote = msg.placement !== undefined;
      var isMessage = !isNote;
      var textFont = isNote ? noteFont(conf) : messageFont(conf);
      var wrappedMessage = msg.wrap ? _utils__WEBPACK_IMPORTED_MODULE_7__["default"].wrapLabel(msg.message, conf.width - 2 * conf.wrapPadding, textFont) : msg.message;
      var messageDimensions = _utils__WEBPACK_IMPORTED_MODULE_7__["default"].calculateTextDimensions(wrappedMessage, textFont);
      var messageWidth = messageDimensions.width + 2 * conf.wrapPadding;
      /*
       * The following scenarios should be supported:
       *
       * - There's a message (non-note) between fromActor and toActor
       *   - If fromActor is on the right and toActor is on the left, we should
       *     define the toActor's margin
       *   - If fromActor is on the left and toActor is on the right, we should
       *     define the fromActor's margin
       * - There's a note, in which case fromActor == toActor
       *   - If the note is to the left of the actor, we should define the previous actor
       *     margin
       *   - If the note is on the actor, we should define both the previous and next actor
       *     margins, each being the half of the note size
       *   - If the note is on the right of the actor, we should define the current actor
       *     margin
       */

      if (isMessage && msg.from === actor.nextActor) {
        maxMessageWidthPerActor[msg.to] = Math.max(maxMessageWidthPerActor[msg.to] || 0, messageWidth);
      } else if (isMessage && msg.from === actor.prevActor) {
        maxMessageWidthPerActor[msg.from] = Math.max(maxMessageWidthPerActor[msg.from] || 0, messageWidth);
      } else if (isMessage && msg.from === msg.to) {
        maxMessageWidthPerActor[msg.from] = Math.max(maxMessageWidthPerActor[msg.from] || 0, messageWidth / 2);
        maxMessageWidthPerActor[msg.to] = Math.max(maxMessageWidthPerActor[msg.to] || 0, messageWidth / 2);
      } else if (msg.placement === _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.PLACEMENT.RIGHTOF) {
        maxMessageWidthPerActor[msg.from] = Math.max(maxMessageWidthPerActor[msg.from] || 0, messageWidth);
      } else if (msg.placement === _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.PLACEMENT.LEFTOF) {
        maxMessageWidthPerActor[actor.prevActor] = Math.max(maxMessageWidthPerActor[actor.prevActor] || 0, messageWidth);
      } else if (msg.placement === _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.PLACEMENT.OVER) {
        if (actor.prevActor) {
          maxMessageWidthPerActor[actor.prevActor] = Math.max(maxMessageWidthPerActor[actor.prevActor] || 0, messageWidth / 2);
        }

        if (actor.nextActor) {
          maxMessageWidthPerActor[msg.from] = Math.max(maxMessageWidthPerActor[msg.from] || 0, messageWidth / 2);
        }
      }
    }
  });
  _logger__WEBPACK_IMPORTED_MODULE_2__["log"].debug('maxMessageWidthPerActor:', maxMessageWidthPerActor);
  return maxMessageWidthPerActor;
};
/**
 * This will calculate the optimal margin for each given actor, for a given
 * actor->messageWidth map.
 *
 * An actor's margin is determined by the width of the actor, the width of the
 * largest message that originates from it, and the configured conf.actorMargin.
 *
 * @param actors - The actors map to calculate margins for
 * @param actorToMessageWidth - A map of actor key -> max message width it holds
 */


var calculateActorMargins = function calculateActorMargins(actors, actorToMessageWidth) {
  var maxHeight = 0;
  Object.keys(actors).forEach(function (prop) {
    var actor = actors[prop];

    if (actor.wrap) {
      actor.description = _utils__WEBPACK_IMPORTED_MODULE_7__["default"].wrapLabel(actor.description, conf.width - 2 * conf.wrapPadding, actorFont(conf));
    }

    var actDims = _utils__WEBPACK_IMPORTED_MODULE_7__["default"].calculateTextDimensions(actor.description, actorFont(conf));
    actor.width = actor.wrap ? conf.width : Math.max(conf.width, actDims.width + 2 * conf.wrapPadding);
    actor.height = actor.wrap ? Math.max(actDims.height, conf.height) : conf.height;
    maxHeight = Math.max(maxHeight, actor.height);
  });

  for (var actorKey in actorToMessageWidth) {
    var actor = actors[actorKey];

    if (!actor) {
      continue;
    }

    var nextActor = actors[actor.nextActor]; // No need to space out an actor that doesn't have a next link

    if (!nextActor) {
      continue;
    }

    var messageWidth = actorToMessageWidth[actorKey];
    var actorWidth = messageWidth + conf.actorMargin - actor.width / 2 - nextActor.width / 2;
    actor.margin = Math.max(actorWidth, conf.actorMargin);
  }

  return Math.max(maxHeight, conf.height);
};

var buildNoteModel = function buildNoteModel(msg, actors) {
  var startx = actors[msg.from].x;
  var stopx = actors[msg.to].x;
  var shouldWrap = msg.wrap && msg.message;
  var textDimensions = _utils__WEBPACK_IMPORTED_MODULE_7__["default"].calculateTextDimensions(shouldWrap ? _utils__WEBPACK_IMPORTED_MODULE_7__["default"].wrapLabel(msg.message, conf.width, noteFont(conf)) : msg.message, noteFont(conf));
  var noteModel = {
    width: shouldWrap ? conf.width : Math.max(conf.width, textDimensions.width + 2 * conf.noteMargin),
    height: 0,
    startx: actors[msg.from].x,
    stopx: 0,
    starty: 0,
    stopy: 0,
    message: msg.message
  };

  if (msg.placement === _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.PLACEMENT.RIGHTOF) {
    noteModel.width = shouldWrap ? Math.max(conf.width, textDimensions.width) : Math.max(actors[msg.from].width / 2 + actors[msg.to].width / 2, textDimensions.width + 2 * conf.noteMargin);
    noteModel.startx = startx + (actors[msg.from].width + conf.actorMargin) / 2;
  } else if (msg.placement === _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.PLACEMENT.LEFTOF) {
    noteModel.width = shouldWrap ? Math.max(conf.width, textDimensions.width + 2 * conf.noteMargin) : Math.max(actors[msg.from].width / 2 + actors[msg.to].width / 2, textDimensions.width + 2 * conf.noteMargin);
    noteModel.startx = startx - noteModel.width + (actors[msg.from].width - conf.actorMargin) / 2;
  } else if (msg.to === msg.from) {
    textDimensions = _utils__WEBPACK_IMPORTED_MODULE_7__["default"].calculateTextDimensions(shouldWrap ? _utils__WEBPACK_IMPORTED_MODULE_7__["default"].wrapLabel(msg.message, Math.max(conf.width, actors[msg.from].width), noteFont(conf)) : msg.message, noteFont(conf));
    noteModel.width = shouldWrap ? Math.max(conf.width, actors[msg.from].width) : Math.max(actors[msg.from].width, conf.width, textDimensions.width + 2 * conf.noteMargin);
    noteModel.startx = startx + (actors[msg.from].width - noteModel.width) / 2;
  } else {
    noteModel.width = Math.abs(startx + actors[msg.from].width / 2 - (stopx + actors[msg.to].width / 2)) + conf.actorMargin;
    noteModel.startx = startx < stopx ? startx + actors[msg.from].width / 2 - conf.actorMargin / 2 : stopx + actors[msg.to].width / 2 - conf.actorMargin / 2;
  }

  if (shouldWrap) {
    noteModel.message = _utils__WEBPACK_IMPORTED_MODULE_7__["default"].wrapLabel(msg.message, noteModel.width - 2 * conf.wrapPadding, noteFont(conf));
  }

  _logger__WEBPACK_IMPORTED_MODULE_2__["log"].debug("NM:[".concat(noteModel.startx, ",").concat(noteModel.stopx, ",").concat(noteModel.starty, ",").concat(noteModel.stopy, ":").concat(noteModel.width, ",").concat(noteModel.height, "=").concat(msg.message, "]"));
  return noteModel;
};

var buildMessageModel = function buildMessageModel(msg, actors) {
  var process = false;

  if ([_parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.SOLID_OPEN, _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.DOTTED_OPEN, _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.SOLID, _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.DOTTED, _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.SOLID_CROSS, _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.DOTTED_CROSS, _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.SOLID_POINT, _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.DOTTED_POINT].includes(msg.type)) {
    process = true;
  }

  if (!process) {
    return {};
  }

  var fromBounds = activationBounds(msg.from, actors);
  var toBounds = activationBounds(msg.to, actors);
  var fromIdx = fromBounds[0] <= toBounds[0] ? 1 : 0;
  var toIdx = fromBounds[0] < toBounds[0] ? 0 : 1;
  var allBounds = fromBounds.concat(toBounds);
  var boundedWidth = Math.abs(toBounds[toIdx] - fromBounds[fromIdx]);

  if (msg.wrap && msg.message) {
    msg.message = _utils__WEBPACK_IMPORTED_MODULE_7__["default"].wrapLabel(msg.message, Math.max(boundedWidth + 2 * conf.wrapPadding, conf.width), messageFont(conf));
  }

  var msgDims = _utils__WEBPACK_IMPORTED_MODULE_7__["default"].calculateTextDimensions(msg.message, messageFont(conf));
  return {
    width: Math.max(msg.wrap ? 0 : msgDims.width + 2 * conf.wrapPadding, boundedWidth + 2 * conf.wrapPadding, conf.width),
    height: 0,
    startx: fromBounds[fromIdx],
    stopx: toBounds[toIdx],
    starty: 0,
    stopy: 0,
    message: msg.message,
    type: msg.type,
    wrap: msg.wrap,
    fromBounds: Math.min.apply(null, allBounds),
    toBounds: Math.max.apply(null, allBounds)
  };
};

var calculateLoopBounds = function calculateLoopBounds(messages, actors) {
  var loops = {};
  var stack = [];
  var current, noteModel, msgModel;
  messages.forEach(function (msg) {
    msg.id = _utils__WEBPACK_IMPORTED_MODULE_7__["default"].random({
      length: 10
    });

    switch (msg.type) {
      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.LOOP_START:
      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.ALT_START:
      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.OPT_START:
      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.PAR_START:
        stack.push({
          id: msg.id,
          msg: msg.message,
          from: Number.MAX_SAFE_INTEGER,
          to: Number.MIN_SAFE_INTEGER,
          width: 0
        });
        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.ALT_ELSE:
      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.PAR_AND:
        if (msg.message) {
          current = stack.pop();
          loops[current.id] = current;
          loops[msg.id] = current;
          stack.push(current);
        }

        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.LOOP_END:
      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.ALT_END:
      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.OPT_END:
      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.PAR_END:
        current = stack.pop();
        loops[current.id] = current;
        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.ACTIVE_START:
        {
          var actorRect = actors[msg.from ? msg.from.actor : msg.to.actor];
          var stackedSize = actorActivations(msg.from ? msg.from.actor : msg.to.actor).length;
          var x = actorRect.x + actorRect.width / 2 + (stackedSize - 1) * conf.activationWidth / 2;
          var toAdd = {
            startx: x,
            stopx: x + conf.activationWidth,
            actor: msg.from.actor,
            enabled: true
          };
          bounds.activations.push(toAdd);
        }
        break;

      case _parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_3__["parser"].yy.LINETYPE.ACTIVE_END:
        {
          var lastActorActivationIdx = bounds.activations.map(function (a) {
            return a.actor;
          }).lastIndexOf(msg.from.actor);
          delete bounds.activations.splice(lastActorActivationIdx, 1)[0];
        }
        break;
    }

    var isNote = msg.placement !== undefined;

    if (isNote) {
      noteModel = buildNoteModel(msg, actors);
      msg.noteModel = noteModel;
      stack.forEach(function (stk) {
        current = stk;
        current.from = Math.min(current.from, noteModel.startx);
        current.to = Math.max(current.to, noteModel.startx + noteModel.width);
        current.width = Math.max(current.width, Math.abs(current.from - current.to)) - conf.labelBoxWidth;
      });
    } else {
      msgModel = buildMessageModel(msg, actors);
      msg.msgModel = msgModel;

      if (msgModel.startx && msgModel.stopx && stack.length > 0) {
        stack.forEach(function (stk) {
          current = stk;

          if (msgModel.startx === msgModel.stopx) {
            var from = actors[msg.from];
            var to = actors[msg.to];
            current.from = Math.min(from.x - msgModel.width / 2, from.x - from.width / 2, current.from);
            current.to = Math.max(to.x + msgModel.width / 2, to.x + from.width / 2, current.to);
            current.width = Math.max(current.width, Math.abs(current.to - current.from)) - conf.labelBoxWidth;
          } else {
            current.from = Math.min(msgModel.startx, current.from);
            current.to = Math.max(msgModel.stopx, current.to);
            current.width = Math.max(current.width, msgModel.width) - conf.labelBoxWidth;
          }
        });
      }
    }
  });
  bounds.activations = [];
  _logger__WEBPACK_IMPORTED_MODULE_2__["log"].debug('Loop type widths:', loops);
  return loops;
};

/* harmony default export */ __webpack_exports__["default"] = ({
  bounds: bounds,
  drawActors: drawActors,
  setConf: setConf,
  draw: draw
});

/***/ }),

/***/ "./src/diagrams/sequence/styles.js":
/*!*****************************************!*\
  !*** ./src/diagrams/sequence/styles.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var getStyles = function getStyles(options) {
  return ".actor {\n    stroke: ".concat(options.actorBorder, ";\n    fill: ").concat(options.actorBkg, ";\n  }\n\n  text.actor > tspan {\n    fill: ").concat(options.actorTextColor, ";\n    stroke: none;\n  }\n\n  .actor-line {\n    stroke: ").concat(options.actorLineColor, ";\n  }\n\n  .messageLine0 {\n    stroke-width: 1.5;\n    stroke-dasharray: none;\n    stroke: ").concat(options.signalColor, ";\n  }\n\n  .messageLine1 {\n    stroke-width: 1.5;\n    stroke-dasharray: 2, 2;\n    stroke: ").concat(options.signalColor, ";\n  }\n\n  #arrowhead path {\n    fill: ").concat(options.signalColor, ";\n    stroke: ").concat(options.signalColor, ";\n  }\n\n  .sequenceNumber {\n    fill: ").concat(options.sequenceNumberColor, ";\n  }\n\n  #sequencenumber {\n    fill: ").concat(options.signalColor, ";\n  }\n\n  #crosshead path {\n    fill: ").concat(options.signalColor, ";\n    stroke: ").concat(options.signalColor, ";\n  }\n\n  .messageText {\n    fill: ").concat(options.signalTextColor, ";\n    stroke: ").concat(options.signalTextColor, ";\n  }\n\n  .labelBox {\n    stroke: ").concat(options.labelBoxBorderColor, ";\n    fill: ").concat(options.labelBoxBkgColor, ";\n  }\n\n  .labelText, .labelText > tspan {\n    fill: ").concat(options.labelTextColor, ";\n    stroke: none;\n  }\n\n  .loopText, .loopText > tspan {\n    fill: ").concat(options.loopTextColor, ";\n    stroke: none;\n  }\n\n  .loopLine {\n    stroke-width: 2px;\n    stroke-dasharray: 2, 2;\n    stroke: ").concat(options.labelBoxBorderColor, ";\n    fill: ").concat(options.labelBoxBorderColor, ";\n  }\n\n  .note {\n    //stroke: #decc93;\n    stroke: ").concat(options.noteBorderColor, ";\n    fill: ").concat(options.noteBkgColor, ";\n  }\n\n  .noteText, .noteText > tspan {\n    fill: ").concat(options.noteTextColor, ";\n    stroke: none;\n  }\n\n  .activation0 {\n    fill: ").concat(options.activationBkgColor, ";\n    stroke: ").concat(options.activationBorderColor, ";\n  }\n\n  .activation1 {\n    fill: ").concat(options.activationBkgColor, ";\n    stroke: ").concat(options.activationBorderColor, ";\n  }\n\n  .activation2 {\n    fill: ").concat(options.activationBkgColor, ";\n    stroke: ").concat(options.activationBorderColor, ";\n  }\n");
};

/* harmony default export */ __webpack_exports__["default"] = (getStyles);

/***/ }),

/***/ "./src/diagrams/sequence/svgDraw.js":
/*!******************************************!*\
  !*** ./src/diagrams/sequence/svgDraw.js ***!
  \******************************************/
/*! exports provided: drawRect, drawText, drawLabel, drawActor, anchorElement, drawActivation, drawLoop, drawBackgroundRect, insertArrowHead, insertArrowFilledHead, insertSequenceNumber, insertArrowCrossHead, getTextObj, getNoteRect, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawRect", function() { return drawRect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawText", function() { return drawText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawLabel", function() { return drawLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawActor", function() { return drawActor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "anchorElement", function() { return anchorElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawActivation", function() { return drawActivation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawLoop", function() { return drawLoop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawBackgroundRect", function() { return drawBackgroundRect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertArrowHead", function() { return insertArrowHead; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertArrowFilledHead", function() { return insertArrowFilledHead; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertSequenceNumber", function() { return insertSequenceNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertArrowCrossHead", function() { return insertArrowCrossHead; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTextObj", function() { return getTextObj; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNoteRect", function() { return getNoteRect; });
/* harmony import */ var _common_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/common */ "./src/diagrams/common/common.js");

var drawRect = function drawRect(elem, rectData) {
  var rectElem = elem.append('rect');
  rectElem.attr('x', rectData.x);
  rectElem.attr('y', rectData.y);
  rectElem.attr('fill', rectData.fill);
  rectElem.attr('stroke', rectData.stroke);
  rectElem.attr('width', rectData.width);
  rectElem.attr('height', rectData.height);
  rectElem.attr('rx', rectData.rx);
  rectElem.attr('ry', rectData.ry);

  if (typeof rectData.class !== 'undefined') {
    rectElem.attr('class', rectData.class);
  }

  return rectElem;
};
var drawText = function drawText(elem, textData) {
  var prevTextHeight = 0,
      textHeight = 0;
  var lines = textData.text.split(_common_common__WEBPACK_IMPORTED_MODULE_0__["default"].lineBreakRegex);
  var textElems = [];
  var dy = 0;

  var yfunc = function yfunc() {
    return textData.y;
  };

  if (typeof textData.valign !== 'undefined' && typeof textData.textMargin !== 'undefined' && textData.textMargin > 0) {
    switch (textData.valign) {
      case 'top':
      case 'start':
        yfunc = function yfunc() {
          return Math.round(textData.y + textData.textMargin);
        };

        break;

      case 'middle':
      case 'center':
        yfunc = function yfunc() {
          return Math.round(textData.y + (prevTextHeight + textHeight + textData.textMargin) / 2);
        };

        break;

      case 'bottom':
      case 'end':
        yfunc = function yfunc() {
          return Math.round(textData.y + (prevTextHeight + textHeight + 2 * textData.textMargin) - textData.textMargin);
        };

        break;
    }
  }

  if (typeof textData.anchor !== 'undefined' && typeof textData.textMargin !== 'undefined' && typeof textData.width !== 'undefined') {
    switch (textData.anchor) {
      case 'left':
      case 'start':
        textData.x = Math.round(textData.x + textData.textMargin);
        textData.anchor = 'start';
        textData.dominantBaseline = 'text-after-edge';
        textData.alignmentBaseline = 'middle';
        break;

      case 'middle':
      case 'center':
        textData.x = Math.round(textData.x + textData.width / 2);
        textData.anchor = 'middle';
        textData.dominantBaseline = 'middle';
        textData.alignmentBaseline = 'middle';
        break;

      case 'right':
      case 'end':
        textData.x = Math.round(textData.x + textData.width - textData.textMargin);
        textData.anchor = 'end';
        textData.dominantBaseline = 'text-before-edge';
        textData.alignmentBaseline = 'middle';
        break;
    }
  }

  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];

    if (typeof textData.textMargin !== 'undefined' && textData.textMargin === 0 && typeof textData.fontSize !== 'undefined') {
      dy = i * textData.fontSize;
    }

    var textElem = elem.append('text');
    textElem.attr('x', textData.x);
    textElem.attr('y', yfunc());

    if (typeof textData.anchor !== 'undefined') {
      textElem.attr('text-anchor', textData.anchor).attr('dominant-baseline', textData.dominantBaseline).attr('alignment-baseline', textData.alignmentBaseline);
    }

    if (typeof textData.fontFamily !== 'undefined') {
      textElem.style('font-family', textData.fontFamily);
    }

    if (typeof textData.fontSize !== 'undefined') {
      textElem.style('font-size', textData.fontSize);
    }

    if (typeof textData.fontWeight !== 'undefined') {
      textElem.style('font-weight', textData.fontWeight);
    }

    if (typeof textData.fill !== 'undefined') {
      textElem.attr('fill', textData.fill);
    }

    if (typeof textData.class !== 'undefined') {
      textElem.attr('class', textData.class);
    }

    if (typeof textData.dy !== 'undefined') {
      textElem.attr('dy', textData.dy);
    } else if (dy !== 0) {
      textElem.attr('dy', dy);
    }

    if (textData.tspan) {
      var span = textElem.append('tspan');
      span.attr('x', textData.x);

      if (typeof textData.fill !== 'undefined') {
        span.attr('fill', textData.fill);
      }

      span.text(line);
    } else {
      textElem.text(line);
    }

    if (typeof textData.valign !== 'undefined' && typeof textData.textMargin !== 'undefined' && textData.textMargin > 0) {
      textHeight += (textElem._groups || textElem)[0][0].getBBox().height;
      prevTextHeight = textHeight;
    }

    textElems.push(textElem);
  }

  return textElems;
};
var drawLabel = function drawLabel(elem, txtObject) {
  function genPoints(x, y, width, height, cut) {
    return x + ',' + y + ' ' + (x + width) + ',' + y + ' ' + (x + width) + ',' + (y + height - cut) + ' ' + (x + width - cut * 1.2) + ',' + (y + height) + ' ' + x + ',' + (y + height);
  }

  var polygon = elem.append('polygon');
  polygon.attr('points', genPoints(txtObject.x, txtObject.y, txtObject.width, txtObject.height, 7));
  polygon.attr('class', 'labelBox');
  txtObject.y = txtObject.y + txtObject.height / 2;
  drawText(elem, txtObject);
  return polygon;
};
var actorCnt = -1;
/**
 * Draws an actor in the diagram with the attached line
 * @param elem - The diagram we'll draw to.
 * @param actor - The actor to draw.
 * @param conf - drawText implementation discriminator object
 */

var drawActor = function drawActor(elem, actor, conf) {
  var center = actor.x + actor.width / 2;
  var g = elem.append('g');

  if (actor.y === 0) {
    actorCnt++;
    g.append('line').attr('id', 'actor' + actorCnt).attr('x1', center).attr('y1', 5).attr('x2', center).attr('y2', 2000).attr('class', 'actor-line').attr('stroke-width', '0.5px').attr('stroke', '#999');
  }

  var rect = getNoteRect();
  rect.x = actor.x;
  rect.y = actor.y;
  rect.fill = '#eaeaea';
  rect.width = actor.width;
  rect.height = actor.height;
  rect.class = 'actor';
  rect.rx = 3;
  rect.ry = 3;
  drawRect(g, rect);

  _drawTextCandidateFunc(conf)(actor.description, g, rect.x, rect.y, rect.width, rect.height, {
    class: 'actor'
  }, conf);
};
var anchorElement = function anchorElement(elem) {
  return elem.append('g');
};
/**
 * Draws an activation in the diagram
 * @param elem - element to append activation rect.
 * @param bounds - activation box bounds.
 * @param verticalPos - precise y cooridnate of bottom activation box edge.
 * @param conf - sequence diagram config object.
 * @param actorActivations - number of activations on the actor.
 */

var drawActivation = function drawActivation(elem, bounds, verticalPos, conf, actorActivations) {
  var rect = getNoteRect();
  var g = bounds.anchored;
  rect.x = bounds.startx;
  rect.y = bounds.starty;
  rect.class = 'activation' + actorActivations % 3; // Will evaluate to 0, 1 or 2

  rect.width = bounds.stopx - bounds.startx;
  rect.height = verticalPos - bounds.starty;
  drawRect(g, rect);
};
/**
 * Draws a loop in the diagram
 * @param elem - elemenet to append the loop to.
 * @param loopModel - loopModel of the given loop.
 * @param labelText - Text within the loop.
 * @param conf - diagrom configuration
 */

var drawLoop = function drawLoop(elem, loopModel, labelText, conf) {
  var boxMargin = conf.boxMargin,
      boxTextMargin = conf.boxTextMargin,
      labelBoxHeight = conf.labelBoxHeight,
      labelBoxWidth = conf.labelBoxWidth,
      fontFamily = conf.messageFontFamily,
      fontSize = conf.messageFontSize,
      fontWeight = conf.messageFontWeight;
  var g = elem.append('g');

  var drawLoopLine = function drawLoopLine(startx, starty, stopx, stopy) {
    return g.append('line').attr('x1', startx).attr('y1', starty).attr('x2', stopx).attr('y2', stopy).attr('class', 'loopLine');
  };

  drawLoopLine(loopModel.startx, loopModel.starty, loopModel.stopx, loopModel.starty);
  drawLoopLine(loopModel.stopx, loopModel.starty, loopModel.stopx, loopModel.stopy);
  drawLoopLine(loopModel.startx, loopModel.stopy, loopModel.stopx, loopModel.stopy);
  drawLoopLine(loopModel.startx, loopModel.starty, loopModel.startx, loopModel.stopy);

  if (typeof loopModel.sections !== 'undefined') {
    loopModel.sections.forEach(function (item) {
      drawLoopLine(loopModel.startx, item.y, loopModel.stopx, item.y).style('stroke-dasharray', '3, 3');
    });
  }

  var txt = getTextObj();
  txt.text = labelText;
  txt.x = loopModel.startx;
  txt.y = loopModel.starty;
  txt.fontFamily = fontFamily;
  txt.fontSize = fontSize;
  txt.fontWeight = fontWeight;
  txt.anchor = 'middle';
  txt.valign = 'middle';
  txt.tspan = false;
  txt.width = labelBoxWidth || 50;
  txt.height = labelBoxHeight || 20;
  txt.textMargin = boxTextMargin;
  txt.class = 'labelText';
  drawLabel(g, txt);
  txt = getTextObj();
  txt.text = loopModel.title;
  txt.x = loopModel.startx + labelBoxWidth / 2 + (loopModel.stopx - loopModel.startx) / 2;
  txt.y = loopModel.starty + boxMargin + boxTextMargin;
  txt.anchor = 'middle';
  txt.valign = 'middle';
  txt.textMargin = boxTextMargin;
  txt.class = 'loopText';
  txt.fontFamily = fontFamily;
  txt.fontSize = fontSize;
  txt.fontWeight = fontWeight;
  txt.wrap = true;
  var textElem = drawText(g, txt);

  if (typeof loopModel.sectionTitles !== 'undefined') {
    loopModel.sectionTitles.forEach(function (item, idx) {
      if (item.message) {
        txt.text = item.message;
        txt.x = loopModel.startx + (loopModel.stopx - loopModel.startx) / 2;
        txt.y = loopModel.sections[idx].y + boxMargin + boxTextMargin;
        txt.class = 'loopText';
        txt.anchor = 'middle';
        txt.valign = 'middle';
        txt.tspan = false;
        txt.fontFamily = fontFamily;
        txt.fontSize = fontSize;
        txt.fontWeight = fontWeight;
        txt.wrap = loopModel.wrap;
        textElem = drawText(g, txt);
        var sectionHeight = Math.round(textElem.map(function (te) {
          return (te._groups || te)[0][0].getBBox().height;
        }).reduce(function (acc, curr) {
          return acc + curr;
        }));
        loopModel.sections[idx].height += sectionHeight - (boxMargin + boxTextMargin);
      }
    });
  }

  loopModel.height = Math.round(loopModel.stopy - loopModel.starty);
  return g;
};
/**
 * Draws a background rectangle
 * @param elem diagram (reference for bounds)
 * @param bounds shape of the rectangle
 */

var drawBackgroundRect = function drawBackgroundRect(elem, bounds) {
  var rectElem = drawRect(elem, {
    x: bounds.startx,
    y: bounds.starty,
    width: bounds.stopx - bounds.startx,
    height: bounds.stopy - bounds.starty,
    fill: bounds.fill,
    class: 'rect'
  });
  rectElem.lower();
};
/**
 * Setup arrow head and define the marker. The result is appended to the svg.
 */

var insertArrowHead = function insertArrowHead(elem) {
  elem.append('defs').append('marker').attr('id', 'arrowhead').attr('refX', 9).attr('refY', 5).attr('markerUnits', 'userSpaceOnUse').attr('markerWidth', 12).attr('markerHeight', 12).attr('orient', 'auto').append('path').attr('d', 'M 0 0 L 10 5 L 0 10 z'); // this is actual shape for arrowhead
};
/**
 * Setup arrow head and define the marker. The result is appended to the svg.
 */

var insertArrowFilledHead = function insertArrowFilledHead(elem) {
  elem.append('defs').append('marker').attr('id', 'filled-head').attr('refX', 18).attr('refY', 7).attr('markerWidth', 20).attr('markerHeight', 28).attr('orient', 'auto').append('path').attr('d', 'M 18,7 L9,13 L14,7 L9,1 Z');
};
/**
 * Setup node number. The result is appended to the svg.
 */

var insertSequenceNumber = function insertSequenceNumber(elem) {
  elem.append('defs').append('marker').attr('id', 'sequencenumber').attr('refX', 15).attr('refY', 15).attr('markerWidth', 60).attr('markerHeight', 40).attr('orient', 'auto').append('circle').attr('cx', 15).attr('cy', 15).attr('r', 6); // .style("fill", '#f00');
};
/**
 * Setup arrow head and define the marker. The result is appended to the svg.
 */

var insertArrowCrossHead = function insertArrowCrossHead(elem) {
  var defs = elem.append('defs');
  var marker = defs.append('marker').attr('id', 'crosshead').attr('markerWidth', 15).attr('markerHeight', 8).attr('orient', 'auto').attr('refX', 16).attr('refY', 4); // The arrow

  marker.append('path').attr('fill', 'black').attr('stroke', '#000000').style('stroke-dasharray', '0, 0').attr('stroke-width', '1px').attr('d', 'M 9,2 V 6 L16,4 Z'); // The cross

  marker.append('path').attr('fill', 'none').attr('stroke', '#000000').style('stroke-dasharray', '0, 0').attr('stroke-width', '1px').attr('d', 'M 0,1 L 6,7 M 6,1 L 0,7'); // this is actual shape for arrowhead
};
var getTextObj = function getTextObj() {
  return {
    x: 0,
    y: 0,
    fill: undefined,
    anchor: undefined,
    style: '#666',
    width: undefined,
    height: undefined,
    textMargin: 0,
    rx: 0,
    ry: 0,
    tspan: true,
    valign: undefined
  };
};
var getNoteRect = function getNoteRect() {
  return {
    x: 0,
    y: 0,
    fill: '#EDF2AE',
    stroke: '#666',
    width: 100,
    anchor: 'start',
    height: 100,
    rx: 0,
    ry: 0
  };
};

var _drawTextCandidateFunc = function () {
  function byText(content, g, x, y, width, height, textAttrs) {
    var text = g.append('text').attr('x', x + width / 2).attr('y', y + height / 2 + 5).style('text-anchor', 'middle').text(content);

    _setTextAttrs(text, textAttrs);
  }

  function byTspan(content, g, x, y, width, height, textAttrs, conf) {
    var actorFontSize = conf.actorFontSize,
        actorFontFamily = conf.actorFontFamily,
        actorFontWeight = conf.actorFontWeight;
    var lines = content.split(_common_common__WEBPACK_IMPORTED_MODULE_0__["default"].lineBreakRegex);

    for (var i = 0; i < lines.length; i++) {
      var dy = i * actorFontSize - actorFontSize * (lines.length - 1) / 2;
      var text = g.append('text').attr('x', x + width / 2).attr('y', y).style('text-anchor', 'middle').style('font-size', actorFontSize).style('font-weight', actorFontWeight).style('font-family', actorFontFamily);
      text.append('tspan').attr('x', x + width / 2).attr('dy', dy).text(lines[i]);
      text.attr('y', y + height / 2.0).attr('dominant-baseline', 'central').attr('alignment-baseline', 'central');

      _setTextAttrs(text, textAttrs);
    }
  }

  function byFo(content, g, x, y, width, height, textAttrs, conf) {
    var s = g.append('switch');
    var f = s.append('foreignObject').attr('x', x).attr('y', y).attr('width', width).attr('height', height);
    var text = f.append('xhtml:div').style('display', 'table').style('height', '100%').style('width', '100%');
    text.append('div').style('display', 'table-cell').style('text-align', 'center').style('vertical-align', 'middle').text(content);
    byTspan(content, s, x, y, width, height, textAttrs, conf);

    _setTextAttrs(text, textAttrs);
  }

  function _setTextAttrs(toText, fromTextAttrsDict) {
    for (var key in fromTextAttrsDict) {
      if (fromTextAttrsDict.hasOwnProperty(key)) {
        // eslint-disable-line
        toText.attr(key, fromTextAttrsDict[key]);
      }
    }
  }

  return function (conf) {
    return conf.textPlacement === 'fo' ? byFo : conf.textPlacement === 'old' ? byText : byTspan;
  };
}();

/* harmony default export */ __webpack_exports__["default"] = ({
  drawRect: drawRect,
  drawText: drawText,
  drawLabel: drawLabel,
  drawActor: drawActor,
  anchorElement: anchorElement,
  drawActivation: drawActivation,
  drawLoop: drawLoop,
  drawBackgroundRect: drawBackgroundRect,
  insertArrowHead: insertArrowHead,
  insertArrowFilledHead: insertArrowFilledHead,
  insertSequenceNumber: insertSequenceNumber,
  insertArrowCrossHead: insertArrowCrossHead,
  getTextObj: getTextObj,
  getNoteRect: getNoteRect
});

/***/ }),

/***/ "./src/diagrams/state/id-cache.js":
/*!****************************************!*\
  !*** ./src/diagrams/state/id-cache.js ***!
  \****************************************/
/*! exports provided: set, get, keys, size, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return keys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "size", function() { return size; });
var idCache = {};
var set = function set(key, val) {
  idCache[key] = val;
};
var get = function get(k) {
  return idCache[k];
};
var keys = function keys() {
  return Object.keys(idCache);
};
var size = function size() {
  return keys().length;
};
/* harmony default export */ __webpack_exports__["default"] = ({
  get: get,
  set: set,
  keys: keys,
  size: size
});

/***/ }),

/***/ "./src/diagrams/state/parser/stateDiagram.jison":
/*!******************************************************!*\
  !*** ./src/diagrams/state/parser/stateDiagram.jison ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, module) {/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,2],$V1=[1,3],$V2=[1,5],$V3=[1,7],$V4=[2,5],$V5=[1,15],$V6=[1,17],$V7=[1,19],$V8=[1,20],$V9=[1,21],$Va=[1,22],$Vb=[1,30],$Vc=[1,23],$Vd=[1,24],$Ve=[1,25],$Vf=[1,26],$Vg=[1,27],$Vh=[1,32],$Vi=[1,33],$Vj=[1,34],$Vk=[1,35],$Vl=[1,31],$Vm=[1,38],$Vn=[1,4,5,14,15,17,19,20,22,23,24,25,26,27,36,37,38,39,42,45],$Vo=[1,4,5,12,13,14,15,17,19,20,22,23,24,25,26,27,36,37,38,39,42,45],$Vp=[1,4,5,7,14,15,17,19,20,22,23,24,25,26,27,36,37,38,39,42,45],$Vq=[4,5,14,15,17,19,20,22,23,24,25,26,27,36,37,38,39,42,45];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"start":3,"SPACE":4,"NL":5,"directive":6,"SD":7,"document":8,"line":9,"statement":10,"idStatement":11,"DESCR":12,"-->":13,"HIDE_EMPTY":14,"scale":15,"WIDTH":16,"COMPOSIT_STATE":17,"STRUCT_START":18,"STRUCT_STOP":19,"STATE_DESCR":20,"AS":21,"ID":22,"FORK":23,"JOIN":24,"CHOICE":25,"CONCURRENT":26,"note":27,"notePosition":28,"NOTE_TEXT":29,"direction":30,"openDirective":31,"typeDirective":32,"closeDirective":33,":":34,"argDirective":35,"direction_tb":36,"direction_bt":37,"direction_rl":38,"direction_lr":39,"eol":40,";":41,"EDGE_STATE":42,"left_of":43,"right_of":44,"open_directive":45,"type_directive":46,"arg_directive":47,"close_directive":48,"$accept":0,"$end":1},
terminals_: {2:"error",4:"SPACE",5:"NL",7:"SD",12:"DESCR",13:"-->",14:"HIDE_EMPTY",15:"scale",16:"WIDTH",17:"COMPOSIT_STATE",18:"STRUCT_START",19:"STRUCT_STOP",20:"STATE_DESCR",21:"AS",22:"ID",23:"FORK",24:"JOIN",25:"CHOICE",26:"CONCURRENT",27:"note",29:"NOTE_TEXT",34:":",36:"direction_tb",37:"direction_bt",38:"direction_rl",39:"direction_lr",41:";",42:"EDGE_STATE",43:"left_of",44:"right_of",45:"open_directive",46:"type_directive",47:"arg_directive",48:"close_directive"},
productions_: [0,[3,2],[3,2],[3,2],[3,2],[8,0],[8,2],[9,2],[9,1],[9,1],[10,1],[10,2],[10,3],[10,4],[10,1],[10,2],[10,1],[10,4],[10,3],[10,6],[10,1],[10,1],[10,1],[10,1],[10,4],[10,4],[10,1],[10,1],[6,3],[6,5],[30,1],[30,1],[30,1],[30,1],[40,1],[40,1],[11,1],[11,1],[28,1],[28,1],[31,1],[32,1],[35,1],[33,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 4:
 /*console.warn('Root document', $$[$0]);*/ yy.setRootDoc($$[$0]);return $$[$0]; 
break;
case 5:
 this.$ = [] 
break;
case 6:

        if($$[$0]!='nl'){
            $$[$0-1].push($$[$0]);this.$ = $$[$0-1]
        }
        // console.warn('Got document',$$[$0-1], $$[$0]);
    
break;
case 7: case 8:
 this.$ = $$[$0] 
break;
case 9:
 this.$='nl';
break;
case 10:
 /*console.warn('got id and descr', $$[$0]);*/this.$={ stmt: 'state', id: $$[$0], type: 'default', description: ''};
break;
case 11:
 /*console.warn('got id and descr', $$[$0-1], $$[$0].trim());*/this.$={ stmt: 'state', id: $$[$0-1], type: 'default', description: yy.trimColon($$[$0])};
break;
case 12:

        /*console.warn('got id', $$[$0-2]);yy.addRelation($$[$0-2], $$[$0]);*/
        this.$={ stmt: 'relation', state1: { stmt: 'state', id: $$[$0-2], type: 'default', description: '' }, state2:{ stmt: 'state', id: $$[$0] ,type: 'default', description: ''}};
    
break;
case 13:

        /*yy.addRelation($$[$0-3], $$[$0-1], $$[$0].substr(1).trim());*/
        this.$={ stmt: 'relation', state1: { stmt: 'state', id: $$[$0-3], type: 'default', description: '' }, state2:{ stmt: 'state', id: $$[$0-1] ,type: 'default', description: ''}, description: $$[$0].substr(1).trim()};
    
break;
case 17:

        /* console.warn('Adding document for state without id ', $$[$0-3]);*/
        this.$={ stmt: 'state', id: $$[$0-3], type: 'default', description: '', doc: $$[$0-1] }
    
break;
case 18:

        var id=$$[$0];
        var description = $$[$0-2].trim();
        if($$[$0].match(':')){
            var parts = $$[$0].split(':');
            id=parts[0];
            description = [description, parts[1]];
        }
        this.$={stmt: 'state', id: id, type: 'default', description: description};

    
break;
case 19:

         // console.warn('Adding document for state with id zxzx', $$[$0-3], $$[$0-2], yy.getDirection()); yy.addDocument($$[$0-3]);
         this.$={ stmt: 'state', id: $$[$0-3], type: 'default', description: $$[$0-5], doc: $$[$0-1] }
    
break;
case 20:

        this.$={ stmt: 'state', id: $$[$0], type: 'fork' }
    
break;
case 21:

        this.$={ stmt: 'state', id: $$[$0], type: 'join' }
    
break;
case 22:

        this.$={ stmt: 'state', id: $$[$0], type: 'choice' }
    
break;
case 23:

        this.$={ stmt: 'state', id: yy.getDividerId(), type: 'divider' }
    
break;
case 24:

        /* console.warn('got NOTE, position: ', $$[$0-2].trim(), 'id = ', $$[$0-1].trim(), 'note: ', $$[$0]);*/
        this.$={ stmt: 'state', id: $$[$0-1].trim(), note:{position: $$[$0-2].trim(), text: $$[$0].trim()}};
    
break;
case 30:
 yy.setDirection('TB');this.$={stmt:'dir', value:'TB'};
break;
case 31:
 yy.setDirection('BT');this.$={stmt:'dir', value:'BT'};
break;
case 32:
 yy.setDirection('RL'); this.$={stmt:'dir', value:'RL'};
break;
case 33:
 yy.setDirection('LR');this.$={stmt:'dir', value:'LR'};
break;
case 36: case 37:
this.$=$$[$0];
break;
case 40:
 yy.parseDirective('%%{', 'open_directive'); 
break;
case 41:
 yy.parseDirective($$[$0], 'type_directive'); 
break;
case 42:
 $$[$0] = $$[$0].trim().replace(/'/g, '"'); yy.parseDirective($$[$0], 'arg_directive'); 
break;
case 43:
 yy.parseDirective('}%%', 'close_directive', 'state'); 
break;
}
},
table: [{3:1,4:$V0,5:$V1,6:4,7:$V2,31:6,45:$V3},{1:[3]},{3:8,4:$V0,5:$V1,6:4,7:$V2,31:6,45:$V3},{3:9,4:$V0,5:$V1,6:4,7:$V2,31:6,45:$V3},{3:10,4:$V0,5:$V1,6:4,7:$V2,31:6,45:$V3},o([1,4,5,14,15,17,20,22,23,24,25,26,27,36,37,38,39,42,45],$V4,{8:11}),{32:12,46:[1,13]},{46:[2,40]},{1:[2,1]},{1:[2,2]},{1:[2,3]},{1:[2,4],4:$V5,5:$V6,6:28,9:14,10:16,11:18,14:$V7,15:$V8,17:$V9,20:$Va,22:$Vb,23:$Vc,24:$Vd,25:$Ve,26:$Vf,27:$Vg,30:29,31:6,36:$Vh,37:$Vi,38:$Vj,39:$Vk,42:$Vl,45:$V3},{33:36,34:[1,37],48:$Vm},o([34,48],[2,41]),o($Vn,[2,6]),{6:28,10:39,11:18,14:$V7,15:$V8,17:$V9,20:$Va,22:$Vb,23:$Vc,24:$Vd,25:$Ve,26:$Vf,27:$Vg,30:29,31:6,36:$Vh,37:$Vi,38:$Vj,39:$Vk,42:$Vl,45:$V3},o($Vn,[2,8]),o($Vn,[2,9]),o($Vn,[2,10],{12:[1,40],13:[1,41]}),o($Vn,[2,14]),{16:[1,42]},o($Vn,[2,16],{18:[1,43]}),{21:[1,44]},o($Vn,[2,20]),o($Vn,[2,21]),o($Vn,[2,22]),o($Vn,[2,23]),{28:45,29:[1,46],43:[1,47],44:[1,48]},o($Vn,[2,26]),o($Vn,[2,27]),o($Vo,[2,36]),o($Vo,[2,37]),o($Vn,[2,30]),o($Vn,[2,31]),o($Vn,[2,32]),o($Vn,[2,33]),o($Vp,[2,28]),{35:49,47:[1,50]},o($Vp,[2,43]),o($Vn,[2,7]),o($Vn,[2,11]),{11:51,22:$Vb,42:$Vl},o($Vn,[2,15]),o($Vq,$V4,{8:52}),{22:[1,53]},{22:[1,54]},{21:[1,55]},{22:[2,38]},{22:[2,39]},{33:56,48:$Vm},{48:[2,42]},o($Vn,[2,12],{12:[1,57]}),{4:$V5,5:$V6,6:28,9:14,10:16,11:18,14:$V7,15:$V8,17:$V9,19:[1,58],20:$Va,22:$Vb,23:$Vc,24:$Vd,25:$Ve,26:$Vf,27:$Vg,30:29,31:6,36:$Vh,37:$Vi,38:$Vj,39:$Vk,42:$Vl,45:$V3},o($Vn,[2,18],{18:[1,59]}),{29:[1,60]},{22:[1,61]},o($Vp,[2,29]),o($Vn,[2,13]),o($Vn,[2,17]),o($Vq,$V4,{8:62}),o($Vn,[2,24]),o($Vn,[2,25]),{4:$V5,5:$V6,6:28,9:14,10:16,11:18,14:$V7,15:$V8,17:$V9,19:[1,63],20:$Va,22:$Vb,23:$Vc,24:$Vd,25:$Ve,26:$Vf,27:$Vg,30:29,31:6,36:$Vh,37:$Vi,38:$Vj,39:$Vk,42:$Vl,45:$V3},o($Vn,[2,19])],
defaultActions: {7:[2,40],8:[2,1],9:[2,2],10:[2,3],47:[2,38],48:[2,39],50:[2,42]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
            function lex() {
            var token;
            token = tstack.pop() || lexer.lex() || EOF;
            if (typeof token !== 'number') {
                if (token instanceof Array) {
                    tstack = token;
                    token = tstack.pop();
                }
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
        if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];
            for (p in table[state]) {
                if (this.terminals_[p] && p > TERROR) {
                    expected.push('\'' + this.terminals_[p] + '\'');
                }
            }
            if (lexer.showPosition) {
                errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
                errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }
            this.parseError(errStr, {
                text: lexer.match,
                token: this.terminals_[symbol] || symbol,
                line: lexer.yylineno,
                loc: yyloc,
                expected: expected
            });
        }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {"case-insensitive":true},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:return 36;
break;
case 1:return 37;
break;
case 2:return 38;
break;
case 3:return 39;
break;
case 4: this.begin('open_directive'); return 45; 
break;
case 5: this.begin('type_directive'); return 46; 
break;
case 6: this.popState(); this.begin('arg_directive'); return 34; 
break;
case 7: this.popState(); this.popState(); return 48; 
break;
case 8:return 47;
break;
case 9:/* skip comments */
break;
case 10:/* skip comments */{ /*console.log('Crap after close');*/ }
break;
case 11:return 5;
break;
case 12:/* skip all whitespace */
break;
case 13:/* skip same-line whitespace */
break;
case 14:/* skip comments */
break;
case 15:/* skip comments */
break;
case 16: this.pushState('SCALE'); /* console.log('Got scale', yy_.yytext);*/ return 15; 
break;
case 17:return 16;
break;
case 18:this.popState();
break;
case 19: /*console.log('Starting STATE zxzx'+yy.getDirection());*/this.pushState('STATE'); 
break;
case 20:this.popState();yy_.yytext=yy_.yytext.slice(0,-8).trim(); /*console.warn('Fork Fork: ',yy_.yytext);*/return 23;
break;
case 21:this.popState();yy_.yytext=yy_.yytext.slice(0,-8).trim();/*console.warn('Fork Join: ',yy_.yytext);*/return 24;
break;
case 22:this.popState();yy_.yytext=yy_.yytext.slice(0,-10).trim();/*console.warn('Fork Join: ',yy_.yytext);*/return 25;
break;
case 23:this.popState();yy_.yytext=yy_.yytext.slice(0,-8).trim();/*console.warn('Fork Fork: ',yy_.yytext);*/return 23;
break;
case 24:this.popState();yy_.yytext=yy_.yytext.slice(0,-8).trim();/*console.warn('Fork Join: ',yy_.yytext);*/return 24;
break;
case 25:this.popState();yy_.yytext=yy_.yytext.slice(0,-10).trim();/*console.warn('Fork Join: ',yy_.yytext);*/return 25;
break;
case 26: return 36;
break;
case 27: return 37;
break;
case 28: return 38;
break;
case 29: return 39;
break;
case 30: /*console.log('Starting STATE_STRING zxzx');*/this.begin("STATE_STRING");
break;
case 31:this.popState();this.pushState('STATE_ID');return "AS";
break;
case 32:this.popState();/* console.log('STATE_ID', yy_.yytext);*/return "ID";
break;
case 33:this.popState();
break;
case 34: /*console.log('Long description:', yy_.yytext);*/return "STATE_DESCR";
break;
case 35:/*console.log('COMPOSIT_STATE', yy_.yytext);*/return 17;
break;
case 36:this.popState();
break;
case 37:this.popState();this.pushState('struct'); /*console.log('begin struct', yy_.yytext);*/return 18;
break;
case 38: /*console.log('Ending struct');*/ this.popState(); return 19;
break;
case 39:/* nothing */
break;
case 40: this.begin('NOTE'); return 27; 
break;
case 41: this.popState();this.pushState('NOTE_ID');return 43;
break;
case 42: this.popState();this.pushState('NOTE_ID');return 44;
break;
case 43: this.popState();this.pushState('FLOATING_NOTE');
break;
case 44:this.popState();this.pushState('FLOATING_NOTE_ID');return "AS";
break;
case 45:/**/
break;
case 46: /*console.log('Floating note text: ', yy_.yytext);*/return "NOTE_TEXT";
break;
case 47:this.popState();/*console.log('Floating note ID', yy_.yytext);*/return "ID";
break;
case 48: this.popState();this.pushState('NOTE_TEXT');/*console.log('Got ID for note', yy_.yytext);*/return 22;
break;
case 49: this.popState();/*console.log('Got NOTE_TEXT for note',yy_.yytext);*/yy_.yytext = yy_.yytext.substr(2).trim();return 29;
break;
case 50: this.popState();/*console.log('Got NOTE_TEXT for note',yy_.yytext);*/yy_.yytext = yy_.yytext.slice(0,-8).trim();return 29;
break;
case 51: /*console.log('Got state diagram', yy_.yytext,'#');*/return 7; 
break;
case 52: /*console.log('Got state diagram', yy_.yytext,'#');*/return 7; 
break;
case 53: /*console.log('HIDE_EMPTY', yy_.yytext,'#');*/return 14; 
break;
case 54: /*console.log('EDGE_STATE=',yy_.yytext);*/ return 42;
break;
case 55: /*console.log('=>ID=',yy_.yytext);*/ return 22;
break;
case 56: yy_.yytext = yy_.yytext.trim(); /*console.log('Descr = ', yy_.yytext);*/ return 12; 
break;
case 57:return 13;
break;
case 58:return 26;
break;
case 59:return 5;
break;
case 60:return 'INVALID';
break;
}
},
rules: [/^(?:.*direction\s+TB[^\n]*)/i,/^(?:.*direction\s+BT[^\n]*)/i,/^(?:.*direction\s+RL[^\n]*)/i,/^(?:.*direction\s+LR[^\n]*)/i,/^(?:%%\{)/i,/^(?:((?:(?!\}%%)[^:.])*))/i,/^(?::)/i,/^(?:\}%%)/i,/^(?:((?:(?!\}%%).|\n)*))/i,/^(?:%%(?!\{)[^\n]*)/i,/^(?:[^\}]%%[^\n]*)/i,/^(?:[\n]+)/i,/^(?:[\s]+)/i,/^(?:((?!\n)\s)+)/i,/^(?:#[^\n]*)/i,/^(?:%[^\n]*)/i,/^(?:scale\s+)/i,/^(?:\d+)/i,/^(?:\s+width\b)/i,/^(?:state\s+)/i,/^(?:.*<<fork>>)/i,/^(?:.*<<join>>)/i,/^(?:.*<<choice>>)/i,/^(?:.*\[\[fork\]\])/i,/^(?:.*\[\[join\]\])/i,/^(?:.*\[\[choice\]\])/i,/^(?:.*direction\s+TB[^\n]*)/i,/^(?:.*direction\s+BT[^\n]*)/i,/^(?:.*direction\s+RL[^\n]*)/i,/^(?:.*direction\s+LR[^\n]*)/i,/^(?:["])/i,/^(?:\s*as\s+)/i,/^(?:[^\n\{]*)/i,/^(?:["])/i,/^(?:[^"]*)/i,/^(?:[^\n\s\{]+)/i,/^(?:\n)/i,/^(?:\{)/i,/^(?:\})/i,/^(?:[\n])/i,/^(?:note\s+)/i,/^(?:left of\b)/i,/^(?:right of\b)/i,/^(?:")/i,/^(?:\s*as\s*)/i,/^(?:["])/i,/^(?:[^"]*)/i,/^(?:[^\n]*)/i,/^(?:\s*[^:\n\s\-]+)/i,/^(?:\s*:[^:\n;]+)/i,/^(?:[\s\S]*?end note\b)/i,/^(?:stateDiagram\s+)/i,/^(?:stateDiagram-v2\s+)/i,/^(?:hide empty description\b)/i,/^(?:\[\*\])/i,/^(?:[^:\n\s\-\{]+)/i,/^(?:\s*:[^:\n;]+)/i,/^(?:-->)/i,/^(?:--)/i,/^(?:$)/i,/^(?:.)/i],
conditions: {"LINE":{"rules":[13,14],"inclusive":false},"close_directive":{"rules":[13,14],"inclusive":false},"arg_directive":{"rules":[7,8,13,14],"inclusive":false},"type_directive":{"rules":[6,7,13,14],"inclusive":false},"open_directive":{"rules":[5,13,14],"inclusive":false},"struct":{"rules":[13,14,19,26,27,28,29,38,39,40,54,55,56,57,58],"inclusive":false},"FLOATING_NOTE_ID":{"rules":[47],"inclusive":false},"FLOATING_NOTE":{"rules":[44,45,46],"inclusive":false},"NOTE_TEXT":{"rules":[49,50],"inclusive":false},"NOTE_ID":{"rules":[48],"inclusive":false},"NOTE":{"rules":[41,42,43],"inclusive":false},"SCALE":{"rules":[17,18],"inclusive":false},"ALIAS":{"rules":[],"inclusive":false},"STATE_ID":{"rules":[32],"inclusive":false},"STATE_STRING":{"rules":[33,34],"inclusive":false},"FORK_STATE":{"rules":[],"inclusive":false},"STATE":{"rules":[13,14,20,21,22,23,24,25,30,31,35,36,37],"inclusive":false},"ID":{"rules":[13,14],"inclusive":false},"INITIAL":{"rules":[0,1,2,3,4,9,10,11,12,14,15,16,19,37,40,51,52,53,54,55,56,57,59,60],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (true) {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js").readFileSync(__webpack_require__(/*! path */ "./node_modules/path-browserify/index.js").normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if ( true && __webpack_require__.c[__webpack_require__.s] === module) {
  exports.main(process.argv.slice(1));
}
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/diagrams/state/shapes.js":
/*!**************************************!*\
  !*** ./src/diagrams/state/shapes.js ***!
  \**************************************/
/*! exports provided: drawStartState, drawDivider, drawSimpleState, drawDescrState, addTitleAndBox, drawText, drawNote, drawState, drawEdge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawStartState", function() { return drawStartState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawDivider", function() { return drawDivider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawSimpleState", function() { return drawSimpleState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawDescrState", function() { return drawDescrState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addTitleAndBox", function() { return addTitleAndBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawText", function() { return drawText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawNote", function() { return drawNote; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawState", function() { return drawState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawEdge", function() { return drawEdge; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _id_cache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./id-cache.js */ "./src/diagrams/state/id-cache.js");
/* harmony import */ var _stateDb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stateDb */ "./src/diagrams/state/stateDb.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");
/* harmony import */ var _common_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/common */ "./src/diagrams/common/common.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }







 // let conf;

/**
 * Draws a start state as a black circle
 */

var drawStartState = function drawStartState(g) {
  return g.append('circle') // .style('stroke', 'black')
  // .style('fill', 'black')
  .attr('class', 'start-state').attr('r', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.sizeUnit).attr('cx', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.sizeUnit).attr('cy', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.sizeUnit);
};
/**
 * Draws a start state as a black circle
 */

var drawDivider = function drawDivider(g) {
  return g.append('line').style('stroke', 'grey').style('stroke-dasharray', '3').attr('x1', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.textHeight).attr('class', 'divider').attr('x2', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.textHeight * 2).attr('y1', 0).attr('y2', 0);
};
/**
 * Draws a an end state as a black circle
 */

var drawSimpleState = function drawSimpleState(g, stateDef) {
  var state = g.append('text').attr('x', 2 * Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('y', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.textHeight + 2 * Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('font-size', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.fontSize).attr('class', 'state-title').text(stateDef.id);
  var classBox = state.node().getBBox();
  g.insert('rect', ':first-child').attr('x', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('y', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('width', classBox.width + 2 * Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('height', classBox.height + 2 * Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('rx', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.radius);
  return state;
};
/**
 * Draws a state with descriptions
 * @param {*} g
 * @param {*} stateDef
 */

var drawDescrState = function drawDescrState(g, stateDef) {
  var addTspan = function addTspan(textEl, txt, isFirst) {
    var tSpan = textEl.append('tspan').attr('x', 2 * Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).text(txt);

    if (!isFirst) {
      tSpan.attr('dy', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.textHeight);
    }
  };

  var title = g.append('text').attr('x', 2 * Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('y', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.textHeight + 1.3 * Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('font-size', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.fontSize).attr('class', 'state-title').text(stateDef.descriptions[0]);
  var titleBox = title.node().getBBox();
  var titleHeight = titleBox.height;
  var description = g.append('text') // text label for the x axis
  .attr('x', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('y', titleHeight + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding * 0.4 + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.dividerMargin + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.textHeight).attr('class', 'state-description');
  var isFirst = true;
  var isSecond = true;
  stateDef.descriptions.forEach(function (descr) {
    if (!isFirst) {
      addTspan(description, descr, isSecond);
      isSecond = false;
    }

    isFirst = false;
  });
  var descrLine = g.append('line') // text label for the x axis
  .attr('x1', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('y1', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding + titleHeight + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.dividerMargin / 2).attr('y2', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding + titleHeight + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.dividerMargin / 2).attr('class', 'descr-divider');
  var descrBox = description.node().getBBox();
  var width = Math.max(descrBox.width, titleBox.width);
  descrLine.attr('x2', width + 3 * Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding); // const classBox = title.node().getBBox();

  g.insert('rect', ':first-child').attr('x', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('y', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('width', width + 2 * Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('height', descrBox.height + titleHeight + 2 * Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('rx', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.radius);
  return g;
};
/**
 * Adds the creates a box around the existing content and adds a
 * panel for the id on top of the content.
 */

/**
 * Function that creates an title row and a frame around a substate for a composit state diagram.
 * The function returns a new d3 svg object with updated width and height properties;
 * @param {*} g The d3 svg object for the substate to framed
 * @param {*} stateDef The info about the
 */

var addTitleAndBox = function addTitleAndBox(g, stateDef, altBkg) {
  var pad = Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding;
  var dblPad = 2 * Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding;
  var orgBox = g.node().getBBox();
  var orgWidth = orgBox.width;
  var orgX = orgBox.x;
  var title = g.append('text').attr('x', 0).attr('y', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.titleShift).attr('font-size', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.fontSize).attr('class', 'state-title').text(stateDef.id);
  var titleBox = title.node().getBBox();
  var titleWidth = titleBox.width + dblPad;
  var width = Math.max(titleWidth, orgWidth); // + dblPad;

  if (width === orgWidth) {
    width = width + dblPad;
  }

  var startX; // const lineY = 1 - getConfig().state.textHeight;
  // const descrLine = g
  //   .append('line') // text label for the x axis
  //   .attr('x1', 0)
  //   .attr('y1', lineY)
  //   .attr('y2', lineY)
  //   .attr('class', 'descr-divider');

  var graphBox = g.node().getBBox(); // descrLine.attr('x2', graphBox.width + getConfig().state.padding);

  if (stateDef.doc) {// cnsole.warn(
    //   stateDef.id,
    //   'orgX: ',
    //   orgX,
    //   'width: ',
    //   width,
    //   'titleWidth: ',
    //   titleWidth,
    //   'orgWidth: ',
    //   orgWidth,
    //   'width',
    //   width
    // );
  }

  startX = orgX - pad;

  if (titleWidth > orgWidth) {
    startX = (orgWidth - width) / 2 + pad;
  }

  if (Math.abs(orgX - graphBox.x) < pad) {
    if (titleWidth > orgWidth) {
      startX = orgX - (titleWidth - orgWidth) / 2;
    }
  }

  var lineY = 1 - Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.textHeight; // White color

  g.insert('rect', ':first-child').attr('x', startX).attr('y', lineY).attr('class', altBkg ? 'alt-composit' : 'composit').attr('width', width).attr('height', graphBox.height + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.textHeight + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.titleShift + 1).attr('rx', '0');
  title.attr('x', startX + pad);
  if (titleWidth <= orgWidth) title.attr('x', orgX + (width - dblPad) / 2 - titleWidth / 2 + pad); // Title background

  g.insert('rect', ':first-child').attr('x', startX).attr('y', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.titleShift - Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.textHeight - Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('width', width) // Just needs to be higher then the descr line, will be clipped by the white color box
  .attr('height', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.textHeight * 3).attr('rx', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.radius); // Full background

  g.insert('rect', ':first-child').attr('x', startX).attr('y', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.titleShift - Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.textHeight - Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('width', width).attr('height', graphBox.height + 3 + 2 * Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.textHeight).attr('rx', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.radius);
  return g;
};

var drawEndState = function drawEndState(g) {
  g.append('circle') // .style('stroke', 'black')
  // .style('fill', 'white')
  .attr('class', 'end-state-outer').attr('r', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.sizeUnit + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.miniPadding).attr('cx', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.sizeUnit + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.miniPadding).attr('cy', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.sizeUnit + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.miniPadding);
  return g.append('circle') // .style('stroke', 'black')
  // .style('fill', 'black')
  .attr('class', 'end-state-inner').attr('r', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.sizeUnit).attr('cx', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.sizeUnit + 2).attr('cy', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.sizeUnit + 2);
};

var drawForkJoinState = function drawForkJoinState(g, stateDef) {
  var width = Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.forkWidth;
  var height = Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.forkHeight;

  if (stateDef.parentId) {
    var tmp = width;
    width = height;
    height = tmp;
  }

  return g.append('rect').style('stroke', 'black').style('fill', 'black').attr('width', width).attr('height', height).attr('x', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('y', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding);
};

var drawText = function drawText(elem, textData) {
  // Remove and ignore br:s
  var nText = textData.text.replace(_common_common__WEBPACK_IMPORTED_MODULE_4__["default"].lineBreakRegex, ' ');
  var textElem = elem.append('text');
  textElem.attr('x', textData.x);
  textElem.attr('y', textData.y);
  textElem.style('text-anchor', textData.anchor);
  textElem.attr('fill', textData.fill);

  if (typeof textData.class !== 'undefined') {
    textElem.attr('class', textData.class);
  }

  var span = textElem.append('tspan');
  span.attr('x', textData.x + textData.textMargin * 2);
  span.attr('fill', textData.fill);
  span.text(nText);
  return textElem;
};

var _drawLongText = function _drawLongText(_text, x, y, g) {
  var textHeight = 0;
  var textElem = g.append('text');
  textElem.style('text-anchor', 'start');
  textElem.attr('class', 'noteText');

  var text = _text.replace(/\r\n/g, '<br/>');

  text = text.replace(/\n/g, '<br/>');
  var lines = text.split(_common_common__WEBPACK_IMPORTED_MODULE_4__["default"].lineBreakRegex);
  var tHeight = 1.25 * Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.noteMargin;

  var _iterator = _createForOfIteratorHelper(lines),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _line = _step.value;

      var txt = _line.trim();

      if (txt.length > 0) {
        var span = textElem.append('tspan');
        span.text(txt);

        if (tHeight === 0) {
          var textBounds = span.node().getBBox();
          tHeight += textBounds.height;
        }

        textHeight += tHeight;
        span.attr('x', x + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.noteMargin);
        span.attr('y', y + textHeight + 1.25 * Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.noteMargin);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return {
    textWidth: textElem.node().getBBox().width,
    textHeight: textHeight
  };
};
/**
 * Draws a note to the diagram
 * @param text - The text of the given note.
 * @param g - The element the note is attached to.
 */


var drawNote = function drawNote(text, g) {
  g.attr('class', 'state-note');
  var note = g.append('rect').attr('x', 0).attr('y', Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding);
  var rectElem = g.append('g');

  var _drawLongText2 = _drawLongText(text, 0, 0, rectElem),
      textWidth = _drawLongText2.textWidth,
      textHeight = _drawLongText2.textHeight;

  note.attr('height', textHeight + 2 * Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.noteMargin);
  note.attr('width', textWidth + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.noteMargin * 2);
  return note;
};
/**
 * Starting point for drawing a state. The function finds out the specifics
 * about the state and renders with approprtiate function.
 * @param {*} elem
 * @param {*} stateDef
 */

var drawState = function drawState(elem, stateDef) {
  var id = stateDef.id;
  var stateInfo = {
    id: id,
    label: stateDef.id,
    width: 0,
    height: 0
  };
  var g = elem.append('g').attr('id', id).attr('class', 'stateGroup');
  if (stateDef.type === 'start') drawStartState(g);
  if (stateDef.type === 'end') drawEndState(g);
  if (stateDef.type === 'fork' || stateDef.type === 'join') drawForkJoinState(g, stateDef);
  if (stateDef.type === 'note') drawNote(stateDef.note.text, g);
  if (stateDef.type === 'divider') drawDivider(g);
  if (stateDef.type === 'default' && stateDef.descriptions.length === 0) drawSimpleState(g, stateDef);
  if (stateDef.type === 'default' && stateDef.descriptions.length > 0) drawDescrState(g, stateDef);
  var stateBox = g.node().getBBox();
  stateInfo.width = stateBox.width + 2 * Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding;
  stateInfo.height = stateBox.height + 2 * Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding;
  _id_cache_js__WEBPACK_IMPORTED_MODULE_1__["default"].set(id, stateInfo); // stateCnt++;

  return stateInfo;
};
var edgeCount = 0;
var drawEdge = function drawEdge(elem, path, relation) {
  var getRelationType = function getRelationType(type) {
    switch (type) {
      case _stateDb__WEBPACK_IMPORTED_MODULE_2__["default"].relationType.AGGREGATION:
        return 'aggregation';

      case _stateDb__WEBPACK_IMPORTED_MODULE_2__["default"].relationType.EXTENSION:
        return 'extension';

      case _stateDb__WEBPACK_IMPORTED_MODULE_2__["default"].relationType.COMPOSITION:
        return 'composition';

      case _stateDb__WEBPACK_IMPORTED_MODULE_2__["default"].relationType.DEPENDENCY:
        return 'dependency';
    }
  };

  path.points = path.points.filter(function (p) {
    return !Number.isNaN(p.y);
  }); // The data for our line

  var lineData = path.points; // This is the accessor function we talked about above

  var lineFunction = Object(d3__WEBPACK_IMPORTED_MODULE_0__["line"])().x(function (d) {
    return d.x;
  }).y(function (d) {
    return d.y;
  }).curve(d3__WEBPACK_IMPORTED_MODULE_0__["curveBasis"]);
  var svgPath = elem.append('path').attr('d', lineFunction(lineData)).attr('id', 'edge' + edgeCount).attr('class', 'transition');
  var url = '';

  if (Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.arrowMarkerAbsolute) {
    url = window.location.protocol + '//' + window.location.host + window.location.pathname + window.location.search;
    url = url.replace(/\(/g, '\\(');
    url = url.replace(/\)/g, '\\)');
  }

  svgPath.attr('marker-end', 'url(' + url + '#' + getRelationType(_stateDb__WEBPACK_IMPORTED_MODULE_2__["default"].relationType.DEPENDENCY) + 'End' + ')');

  if (typeof relation.title !== 'undefined') {
    var label = elem.append('g').attr('class', 'stateLabel');

    var _utils$calcLabelPosit = _utils__WEBPACK_IMPORTED_MODULE_3__["default"].calcLabelPosition(path.points),
        x = _utils$calcLabelPosit.x,
        y = _utils$calcLabelPosit.y;

    var rows = _common_common__WEBPACK_IMPORTED_MODULE_4__["default"].getRows(relation.title);
    var titleHeight = 0;
    var titleRows = [];
    var maxWidth = 0;
    var minX = 0;

    for (var i = 0; i <= rows.length; i++) {
      var title = label.append('text').attr('text-anchor', 'middle').text(rows[i]).attr('x', x).attr('y', y + titleHeight);
      var boundstmp = title.node().getBBox();
      maxWidth = Math.max(maxWidth, boundstmp.width);
      minX = Math.min(minX, boundstmp.x);
      _logger__WEBPACK_IMPORTED_MODULE_6__["log"].info(boundstmp.x, x, y + titleHeight);

      if (titleHeight === 0) {
        var titleBox = title.node().getBBox();
        titleHeight = titleBox.height;
        _logger__WEBPACK_IMPORTED_MODULE_6__["log"].info('Title height', titleHeight, y);
      }

      titleRows.push(title);
    }

    var boxHeight = titleHeight * rows.length;

    if (rows.length > 1) {
      var heightAdj = (rows.length - 1) * titleHeight * 0.5;
      titleRows.forEach(function (title, i) {
        return title.attr('y', y + i * titleHeight - heightAdj);
      });
      boxHeight = titleHeight * rows.length;
    }

    var bounds = label.node().getBBox();
    label.insert('rect', ':first-child').attr('class', 'box').attr('x', x - maxWidth / 2 - Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding / 2).attr('y', y - boxHeight / 2 - Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding / 2 - 3.5).attr('width', maxWidth + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding).attr('height', boxHeight + Object(_config__WEBPACK_IMPORTED_MODULE_5__["getConfig"])().state.padding);
    _logger__WEBPACK_IMPORTED_MODULE_6__["log"].info(bounds); //label.attr('transform', '0 -' + (bounds.y / 2));
    // Debug points
    // path.points.forEach(point => {
    //   g.append('circle')
    //     .style('stroke', 'red')
    //     .style('fill', 'red')
    //     .attr('r', 1)
    //     .attr('cx', point.x)
    //     .attr('cy', point.y);
    // });
    // g.append('circle')
    //   .style('stroke', 'blue')
    //   .style('fill', 'blue')
    //   .attr('r', 1)
    //   .attr('cx', x)
    //   .attr('cy', y);
  }

  edgeCount++;
};

/***/ }),

/***/ "./src/diagrams/state/stateDb.js":
/*!***************************************!*\
  !*** ./src/diagrams/state/stateDb.js ***!
  \***************************************/
/*! exports provided: parseDirective, addState, clear, getState, getStates, logDocuments, getRelations, addRelation, cleanupLabel, lineType, relationType, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseDirective", function() { return parseDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addState", function() { return addState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getState", function() { return getState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStates", function() { return getStates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logDocuments", function() { return logDocuments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRelations", function() { return getRelations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addRelation", function() { return addRelation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cleanupLabel", function() { return cleanupLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineType", function() { return lineType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "relationType", function() { return relationType; });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");
/* harmony import */ var _mermaidAPI__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mermaidAPI */ "./src/mermaidAPI.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../config */ "./src/config.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }






var clone = function clone(o) {
  return JSON.parse(JSON.stringify(o));
};

var rootDoc = [];
var parseDirective = function parseDirective(statement, context, type) {
  _mermaidAPI__WEBPACK_IMPORTED_MODULE_2__["default"].parseDirective(this, statement, context, type);
};

var setRootDoc = function setRootDoc(o) {
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('Setting root doc', o); // rootDoc = { id: 'root', doc: o };

  rootDoc = o;
};

var getRootDoc = function getRootDoc() {
  return rootDoc;
};

var docTranslator = function docTranslator(parent, node, first) {
  if (node.stmt === 'relation') {
    docTranslator(parent, node.state1, true);
    docTranslator(parent, node.state2, false);
  } else {
    if (node.stmt === 'state') {
      if (node.id === '[*]') {
        node.id = first ? parent.id + '_start' : parent.id + '_end';
        node.start = first;
      }
    }

    if (node.doc) {
      var doc = []; // Check for concurrency

      var i = 0;
      var currentDoc = [];

      for (i = 0; i < node.doc.length; i++) {
        if (node.doc[i].type === 'divider') {
          // debugger;
          var newNode = clone(node.doc[i]);
          newNode.doc = clone(currentDoc);
          doc.push(newNode);
          currentDoc = [];
        } else {
          currentDoc.push(node.doc[i]);
        }
      } // If any divider was encountered


      if (doc.length > 0 && currentDoc.length > 0) {
        var _newNode = {
          stmt: 'state',
          id: Object(_utils__WEBPACK_IMPORTED_MODULE_1__["generateId"])(),
          type: 'divider',
          doc: clone(currentDoc)
        };
        doc.push(clone(_newNode));
        node.doc = doc;
      }

      node.doc.forEach(function (docNode) {
        return docTranslator(node, docNode, true);
      });
    }
  }
};

var getRootDocV2 = function getRootDocV2() {
  docTranslator({
    id: 'root'
  }, {
    id: 'root',
    doc: rootDoc
  }, true);
  return {
    id: 'root',
    doc: rootDoc
  }; // Here
};

var extract = function extract(_doc) {
  // const res = { states: [], relations: [] };
  var doc;

  if (_doc.doc) {
    doc = _doc.doc;
  } else {
    doc = _doc;
  } // let doc = root.doc;
  // if (!doc) {
  //   doc = root;
  // }


  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info(doc);
  clear();
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('Extract', doc);
  doc.forEach(function (item) {
    if (item.stmt === 'state') {
      addState(item.id, item.type, item.doc, item.description, item.note);
    }

    if (item.stmt === 'relation') {
      addRelation(item.state1.id, item.state2.id, item.description);
    }
  });
};

var newDoc = function newDoc() {
  return {
    relations: [],
    states: {},
    documents: {}
  };
};

var documents = {
  root: newDoc()
};
var currentDocument = documents.root;
var startCnt = 0;
var endCnt = 0; // eslint-disable-line
// let stateCnt = 0;

/**
 * Function called by parser when a node definition has been found.
 * @param id
 * @param text
 * @param type
 * @param style
 */

var addState = function addState(id, type, doc, descr, note) {
  if (typeof currentDocument.states[id] === 'undefined') {
    currentDocument.states[id] = {
      id: id,
      descriptions: [],
      type: type,
      doc: doc,
      note: note
    };
  } else {
    if (!currentDocument.states[id].doc) {
      currentDocument.states[id].doc = doc;
    }

    if (!currentDocument.states[id].type) {
      currentDocument.states[id].type = type;
    }
  }

  if (descr) {
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('Adding state ', id, descr);
    if (typeof descr === 'string') addDescription(id, descr.trim());

    if (_typeof(descr) === 'object') {
      descr.forEach(function (des) {
        return addDescription(id, des.trim());
      });
    }
  }

  if (note) currentDocument.states[id].note = note;
};
var clear = function clear() {
  documents = {
    root: newDoc()
  };
  currentDocument = documents.root;
  currentDocument = documents.root;
  startCnt = 0;
  endCnt = 0; // eslint-disable-line

  classes = [];
};
var getState = function getState(id) {
  return currentDocument.states[id];
};
var getStates = function getStates() {
  return currentDocument.states;
};
var logDocuments = function logDocuments() {
  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].info('Documents = ', documents);
};
var getRelations = function getRelations() {
  return currentDocument.relations;
};
var addRelation = function addRelation(_id1, _id2, title) {
  var id1 = _id1;
  var id2 = _id2;
  var type1 = 'default';
  var type2 = 'default';

  if (_id1 === '[*]') {
    startCnt++;
    id1 = 'start' + startCnt;
    type1 = 'start';
  }

  if (_id2 === '[*]') {
    endCnt++;
    id2 = 'end' + startCnt;
    type2 = 'end';
  }

  addState(id1, type1);
  addState(id2, type2);
  currentDocument.relations.push({
    id1: id1,
    id2: id2,
    title: title
  });
};

var addDescription = function addDescription(id, _descr) {
  var theState = currentDocument.states[id];
  var descr = _descr;

  if (descr[0] === ':') {
    descr = descr.substr(1).trim();
  }

  theState.descriptions.push(descr);
};

var cleanupLabel = function cleanupLabel(label) {
  if (label.substring(0, 1) === ':') {
    return label.substr(2).trim();
  } else {
    return label.trim();
  }
};
var lineType = {
  LINE: 0,
  DOTTED_LINE: 1
};
var dividerCnt = 0;

var getDividerId = function getDividerId() {
  dividerCnt++;
  return 'divider-id-' + dividerCnt;
};

var classes = [];

var getClasses = function getClasses() {
  return classes;
};

var direction = 'TB';

var getDirection = function getDirection() {
  return direction;
};

var setDirection = function setDirection(dir) {
  direction = dir;
};

var relationType = {
  AGGREGATION: 0,
  EXTENSION: 1,
  COMPOSITION: 2,
  DEPENDENCY: 3
};

var trimColon = function trimColon(str) {
  return str && str[0] === ':' ? str.substr(1).trim() : str.trim();
};

/* harmony default export */ __webpack_exports__["default"] = ({
  parseDirective: parseDirective,
  getConfig: function getConfig() {
    return _config__WEBPACK_IMPORTED_MODULE_3__["getConfig"]().state;
  },
  addState: addState,
  clear: clear,
  getState: getState,
  getStates: getStates,
  getRelations: getRelations,
  getClasses: getClasses,
  getDirection: getDirection,
  addRelation: addRelation,
  getDividerId: getDividerId,
  setDirection: setDirection,
  // addDescription,
  cleanupLabel: cleanupLabel,
  lineType: lineType,
  relationType: relationType,
  logDocuments: logDocuments,
  getRootDoc: getRootDoc,
  setRootDoc: setRootDoc,
  getRootDocV2: getRootDocV2,
  extract: extract,
  trimColon: trimColon
});

/***/ }),

/***/ "./src/diagrams/state/stateRenderer-v2.js":
/*!************************************************!*\
  !*** ./src/diagrams/state/stateRenderer-v2.js ***!
  \************************************************/
/*! exports provided: setConf, getClasses, draw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConf", function() { return setConf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getClasses", function() { return getClasses; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return draw; });
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphlib */ "graphlib");
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(graphlib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _stateDb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stateDb */ "./src/diagrams/state/stateDb.js");
/* harmony import */ var _parser_stateDiagram__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parser/stateDiagram */ "./src/diagrams/state/parser/stateDiagram.jison");
/* harmony import */ var _parser_stateDiagram__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_parser_stateDiagram__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/* harmony import */ var _dagre_wrapper_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../dagre-wrapper/index.js */ "./src/dagre-wrapper/index.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");




 // import { evaluate } from '../common/common';




var conf = {};
var setConf = function setConf(cnf) {
  var keys = Object.keys(cnf);

  for (var i = 0; i < keys.length; i++) {
    conf[keys[i]] = cnf[keys[i]];
  }
};
var nodeDb = {};
/**
 * Returns the all the styles from classDef statements in the graph definition.
 * @returns {object} classDef styles
 */

var getClasses = function getClasses(text) {
  _logger__WEBPACK_IMPORTED_MODULE_6__["log"].trace('Extracting classes');
  _stateDb__WEBPACK_IMPORTED_MODULE_2__["default"].clear();
  var parser = _parser_stateDiagram__WEBPACK_IMPORTED_MODULE_3___default.a.parser;
  parser.yy = _stateDb__WEBPACK_IMPORTED_MODULE_2__["default"]; // Parse the graph definition

  parser.parse(text);
  return _stateDb__WEBPACK_IMPORTED_MODULE_2__["default"].getClasses();
};

var setupNode = function setupNode(g, parent, node, altFlag) {
  // Add the node
  if (node.id !== 'root') {
    var shape = 'rect';

    if (node.start === true) {
      shape = 'start';
    }

    if (node.start === false) {
      shape = 'end';
    }

    if (node.type !== 'default') {
      shape = node.type;
    }

    if (!nodeDb[node.id]) {
      nodeDb[node.id] = {
        id: node.id,
        shape: shape,
        description: node.id,
        classes: 'statediagram-state'
      };
    } // Build of the array of description strings accordinging


    if (node.description) {
      if (Array.isArray(nodeDb[node.id].description)) {
        // There already is an array of strings,add to it
        nodeDb[node.id].shape = 'rectWithTitle';
        nodeDb[node.id].description.push(node.description);
      } else {
        if (nodeDb[node.id].description.length > 0) {
          // if there is a description already transformit to an array
          nodeDb[node.id].shape = 'rectWithTitle';

          if (nodeDb[node.id].description === node.id) {
            // If the previous description was the is, remove it
            nodeDb[node.id].description = [node.description];
          } else {
            nodeDb[node.id].description = [nodeDb[node.id].description, node.description];
          }
        } else {
          nodeDb[node.id].shape = 'rect';
          nodeDb[node.id].description = node.description;
        }
      }
    } // Save data for description and group so that for instance a statement without description overwrites
    // one with description
    // group


    if (!nodeDb[node.id].type && node.doc) {
      _logger__WEBPACK_IMPORTED_MODULE_6__["log"].info('Setting cluster for ', node.id, getDir(node));
      nodeDb[node.id].type = 'group';
      nodeDb[node.id].dir = getDir(node);
      nodeDb[node.id].shape = node.type === 'divider' ? 'divider' : 'roundedWithTitle';
      nodeDb[node.id].classes = nodeDb[node.id].classes + ' ' + (altFlag ? 'statediagram-cluster statediagram-cluster-alt' : 'statediagram-cluster');
    }

    var nodeData = {
      labelStyle: '',
      shape: nodeDb[node.id].shape,
      labelText: nodeDb[node.id].description,
      // typeof nodeDb[node.id].description === 'object'
      //   ? nodeDb[node.id].description[0]
      //   : nodeDb[node.id].description,
      classes: nodeDb[node.id].classes,
      //classStr,
      style: '',
      //styles.style,
      id: node.id,
      dir: nodeDb[node.id].dir,
      domId: 'state-' + node.id + '-' + cnt,
      type: nodeDb[node.id].type,
      padding: 15 //getConfig().flowchart.padding

    };

    if (node.note) {
      // Todo: set random id
      var noteData = {
        labelStyle: '',
        shape: 'note',
        labelText: node.note.text,
        classes: 'statediagram-note',
        //classStr,
        style: '',
        //styles.style,
        id: node.id + '----note-' + cnt,
        domId: 'state-' + node.id + '----note-' + cnt,
        type: nodeDb[node.id].type,
        padding: 15 //getConfig().flowchart.padding

      };
      var groupData = {
        labelStyle: '',
        shape: 'noteGroup',
        labelText: node.note.text,
        classes: nodeDb[node.id].classes,
        //classStr,
        style: '',
        //styles.style,
        id: node.id + '----parent',
        domId: 'state-' + node.id + '----parent-' + cnt,
        type: 'group',
        padding: 0 //getConfig().flowchart.padding

      };
      cnt++;
      g.setNode(node.id + '----parent', groupData);
      g.setNode(noteData.id, noteData);
      g.setNode(node.id, nodeData);
      g.setParent(node.id, node.id + '----parent');
      g.setParent(noteData.id, node.id + '----parent');
      var from = node.id;
      var to = noteData.id;

      if (node.note.position === 'left of') {
        from = noteData.id;
        to = node.id;
      }

      g.setEdge(from, to, {
        arrowhead: 'none',
        arrowType: '',
        style: 'fill:none',
        labelStyle: '',
        classes: 'transition note-edge',
        arrowheadStyle: 'fill: #333',
        labelpos: 'c',
        labelType: 'text',
        thickness: 'normal'
      });
    } else {
      g.setNode(node.id, nodeData);
    }
  }

  if (parent) {
    if (parent.id !== 'root') {
      _logger__WEBPACK_IMPORTED_MODULE_6__["log"].trace('Setting node ', node.id, ' to be child of its parent ', parent.id);
      g.setParent(node.id, parent.id);
    }
  }

  if (node.doc) {
    _logger__WEBPACK_IMPORTED_MODULE_6__["log"].trace('Adding nodes children ');
    setupDoc(g, node, node.doc, !altFlag);
  }
};

var cnt = 0;

var setupDoc = function setupDoc(g, parent, doc, altFlag) {
  // cnt = 0;
  _logger__WEBPACK_IMPORTED_MODULE_6__["log"].trace('items', doc);
  doc.forEach(function (item) {
    if (item.stmt === 'state' || item.stmt === 'default') {
      setupNode(g, parent, item, altFlag);
    } else if (item.stmt === 'relation') {
      setupNode(g, parent, item.state1, altFlag);
      setupNode(g, parent, item.state2, altFlag);
      var edgeData = {
        id: 'edge' + cnt,
        arrowhead: 'normal',
        arrowTypeEnd: 'arrow_barb',
        style: 'fill:none',
        labelStyle: '',
        label: item.description,
        arrowheadStyle: 'fill: #333',
        labelpos: 'c',
        labelType: 'text',
        thickness: 'normal',
        classes: 'transition'
      };
      var startId = item.state1.id;
      var endId = item.state2.id;
      g.setEdge(startId, endId, edgeData, cnt);
      cnt++;
    }
  });
};

var getDir = function getDir(nodes, defaultDir) {
  var dir = defaultDir || 'TB';

  if (nodes.doc) {
    for (var i = 0; i < nodes.doc.length; i++) {
      var node = nodes.doc[i];

      if (node.stmt === 'dir') {
        dir = node.value;
      }
    }
  }

  return dir;
};
/**
 * Draws a flowchart in the tag with id: id based on the graph definition in text.
 * @param text
 * @param id
 */


var draw = function draw(text, id) {
  _logger__WEBPACK_IMPORTED_MODULE_6__["log"].info('Drawing state diagram (v2)', id);
  _stateDb__WEBPACK_IMPORTED_MODULE_2__["default"].clear();
  nodeDb = {};
  var parser = _parser_stateDiagram__WEBPACK_IMPORTED_MODULE_3___default.a.parser;
  parser.yy = _stateDb__WEBPACK_IMPORTED_MODULE_2__["default"]; // Parse the graph definition

  parser.parse(text); // Fetch the default direction, use TD if none was found

  var dir = _stateDb__WEBPACK_IMPORTED_MODULE_2__["default"].getDirection();

  if (typeof dir === 'undefined') {
    dir = 'LR';
  }

  var conf = Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().state;
  var nodeSpacing = conf.nodeSpacing || 50;
  var rankSpacing = conf.rankSpacing || 50;
  _logger__WEBPACK_IMPORTED_MODULE_6__["log"].info(_stateDb__WEBPACK_IMPORTED_MODULE_2__["default"].getRootDocV2());
  _stateDb__WEBPACK_IMPORTED_MODULE_2__["default"].extract(_stateDb__WEBPACK_IMPORTED_MODULE_2__["default"].getRootDocV2());
  _logger__WEBPACK_IMPORTED_MODULE_6__["log"].info(_stateDb__WEBPACK_IMPORTED_MODULE_2__["default"].getRootDocV2()); // Create the input mermaid.graph

  var g = new graphlib__WEBPACK_IMPORTED_MODULE_0___default.a.Graph({
    multigraph: true,
    compound: true
  }).setGraph({
    rankdir: getDir(_stateDb__WEBPACK_IMPORTED_MODULE_2__["default"].getRootDocV2()),
    nodesep: nodeSpacing,
    ranksep: rankSpacing,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function () {
    return {};
  });
  setupNode(g, undefined, _stateDb__WEBPACK_IMPORTED_MODULE_2__["default"].getRootDocV2(), true); // Set up an SVG group so that we can translate the final graph.

  var svg = Object(d3__WEBPACK_IMPORTED_MODULE_1__["select"])("[id=\"".concat(id, "\"]")); // Run the renderer. This is what draws the final graph.

  var element = Object(d3__WEBPACK_IMPORTED_MODULE_1__["select"])('#' + id + ' g');
  Object(_dagre_wrapper_index_js__WEBPACK_IMPORTED_MODULE_5__["render"])(element, g, ['barb'], 'statediagram', id);
  var padding = 8;
  var bounds = svg.node().getBBox();
  var width = bounds.width + padding * 2;
  var height = bounds.height + padding * 2; // Zoom in a bit

  svg.attr('class', 'statediagram');
  var svgBounds = svg.node().getBBox();
  Object(_utils__WEBPACK_IMPORTED_MODULE_7__["configureSvgSize"])(svg, height, width * 1.75, conf.useMaxWidth); // Ensure the viewBox includes the whole svgBounds area with extra space for padding

  var vBox = "".concat(svgBounds.x - padding, " ").concat(svgBounds.y - padding, " ").concat(width, " ").concat(height);
  _logger__WEBPACK_IMPORTED_MODULE_6__["log"].debug("viewBox ".concat(vBox));
  svg.attr('viewBox', vBox); // Add label rects for non html labels
  // if (!evaluate(conf.htmlLabels) || true) {

  var labels = document.querySelectorAll('[id="' + id + '"] .edgeLabel .label');

  for (var k = 0; k < labels.length; k++) {
    var label = labels[k]; // Get dimensions of label

    var dim = label.getBBox();
    var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rect.setAttribute('rx', 0);
    rect.setAttribute('ry', 0);
    rect.setAttribute('width', dim.width);
    rect.setAttribute('height', dim.height);
    label.insertBefore(rect, label.firstChild); // }
  }
};
/* harmony default export */ __webpack_exports__["default"] = ({
  setConf: setConf,
  getClasses: getClasses,
  draw: draw
});

/***/ }),

/***/ "./src/diagrams/state/stateRenderer.js":
/*!*********************************************!*\
  !*** ./src/diagrams/state/stateRenderer.js ***!
  \*********************************************/
/*! exports provided: setConf, draw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConf", function() { return setConf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return draw; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var dagre__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dagre */ "dagre");
/* harmony import */ var dagre__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dagre__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! graphlib */ "graphlib");
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(graphlib__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../logger */ "./src/logger.js");
/* harmony import */ var _stateDb__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stateDb */ "./src/diagrams/state/stateDb.js");
/* harmony import */ var _common_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/common */ "./src/diagrams/common/common.js");
/* harmony import */ var _parser_stateDiagram__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parser/stateDiagram */ "./src/diagrams/state/parser/stateDiagram.jison");
/* harmony import */ var _parser_stateDiagram__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_parser_stateDiagram__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shapes */ "./src/diagrams/state/shapes.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");






 // import idCache from './id-cache';




_parser_stateDiagram__WEBPACK_IMPORTED_MODULE_6__["parser"].yy = _stateDb__WEBPACK_IMPORTED_MODULE_4__["default"]; // TODO Move conf object to main conf in mermaidAPI

var conf;
var transformationLog = {};
var setConf = function setConf() {}; // Todo optimize

/**
 * Setup arrow head and define the marker. The result is appended to the svg.
 */

var insertMarkers = function insertMarkers(elem) {
  elem.append('defs').append('marker').attr('id', 'dependencyEnd').attr('refX', 19).attr('refY', 7).attr('markerWidth', 20).attr('markerHeight', 28).attr('orient', 'auto').append('path').attr('d', 'M 19,7 L9,13 L14,7 L9,1 Z');
};
/**
 * Draws a flowchart in the tag with id: id based on the graph definition in text.
 * @param text
 * @param id
 */


var draw = function draw(text, id) {
  conf = Object(_config__WEBPACK_IMPORTED_MODULE_8__["getConfig"])().state;
  _parser_stateDiagram__WEBPACK_IMPORTED_MODULE_6__["parser"].yy.clear();
  _parser_stateDiagram__WEBPACK_IMPORTED_MODULE_6__["parser"].parse(text);
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('Rendering diagram ' + text); // Fetch the default direction, use TD if none was found

  var diagram = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])("[id='".concat(id, "']"));
  insertMarkers(diagram); // Layout graph, Create a new directed graph

  var graph = new graphlib__WEBPACK_IMPORTED_MODULE_2___default.a.Graph({
    multigraph: true,
    compound: true,
    // acyclicer: 'greedy',
    rankdir: 'RL' // ranksep: '20'

  }); // Default to assigning a new object as a label for each new edge.

  graph.setDefaultEdgeLabel(function () {
    return {};
  });
  var rootDoc = _stateDb__WEBPACK_IMPORTED_MODULE_4__["default"].getRootDoc();
  renderDoc(rootDoc, diagram, undefined, false);
  var padding = conf.padding;
  var bounds = diagram.node().getBBox();
  var width = bounds.width + padding * 2;
  var height = bounds.height + padding * 2; // zoom in a bit

  var svgWidth = width * 1.75;
  Object(_utils__WEBPACK_IMPORTED_MODULE_9__["configureSvgSize"])(diagram, height, svgWidth, conf.useMaxWidth);
  diagram.attr('viewBox', "".concat(bounds.x - conf.padding, "  ").concat(bounds.y - conf.padding, " ") + width + ' ' + height);
};

var getLabelWidth = function getLabelWidth(text) {
  return text ? text.length * conf.fontSizeFactor : 1;
};

var renderDoc = function renderDoc(doc, diagram, parentId, altBkg) {
  // // Layout graph, Create a new directed graph
  var graph = new graphlib__WEBPACK_IMPORTED_MODULE_2___default.a.Graph({
    compound: true,
    multigraph: true
  });
  var i;
  var edgeFreeDoc = true;

  for (i = 0; i < doc.length; i++) {
    if (doc[i].stmt === 'relation') {
      edgeFreeDoc = false;
      break;
    }
  } // Set an object for the graph label


  if (parentId) graph.setGraph({
    rankdir: 'LR',
    multigraph: true,
    compound: true,
    // acyclicer: 'greedy',
    ranker: 'tight-tree',
    ranksep: edgeFreeDoc ? 1 : conf.edgeLengthFactor,
    nodeSep: edgeFreeDoc ? 1 : 50,
    isMultiGraph: true // ranksep: 5,
    // nodesep: 1

  });else {
    graph.setGraph({
      rankdir: 'TB',
      multigraph: true,
      compound: true,
      // isCompound: true,
      // acyclicer: 'greedy',
      // ranker: 'longest-path'
      ranksep: edgeFreeDoc ? 1 : conf.edgeLengthFactor,
      nodeSep: edgeFreeDoc ? 1 : 50,
      ranker: 'tight-tree',
      // ranker: 'network-simplex'
      isMultiGraph: true
    });
  } // Default to assigning a new object as a label for each new edge.

  graph.setDefaultEdgeLabel(function () {
    return {};
  });
  _stateDb__WEBPACK_IMPORTED_MODULE_4__["default"].extract(doc);
  var states = _stateDb__WEBPACK_IMPORTED_MODULE_4__["default"].getStates();
  var relations = _stateDb__WEBPACK_IMPORTED_MODULE_4__["default"].getRelations();
  var keys = Object.keys(states);
  var first = true;

  for (var _i = 0; _i < keys.length; _i++) {
    var stateDef = states[keys[_i]];

    if (parentId) {
      stateDef.parentId = parentId;
    }

    var node = void 0;

    if (stateDef.doc) {
      var sub = diagram.append('g').attr('id', stateDef.id).attr('class', 'stateGroup');
      node = renderDoc(stateDef.doc, sub, stateDef.id, !altBkg);

      if (first) {
        // first = false;
        sub = Object(_shapes__WEBPACK_IMPORTED_MODULE_7__["addTitleAndBox"])(sub, stateDef, altBkg);
        var boxBounds = sub.node().getBBox();
        node.width = boxBounds.width;
        node.height = boxBounds.height + conf.padding / 2;
        transformationLog[stateDef.id] = {
          y: conf.compositTitleSize
        };
      } else {
        // sub = addIdAndBox(sub, stateDef);
        var _boxBounds = sub.node().getBBox();

        node.width = _boxBounds.width;
        node.height = _boxBounds.height; // transformationLog[stateDef.id] = { y: conf.compositTitleSize };
      }
    } else {
      node = Object(_shapes__WEBPACK_IMPORTED_MODULE_7__["drawState"])(diagram, stateDef, graph);
    }

    if (stateDef.note) {
      // Draw note note
      var noteDef = {
        descriptions: [],
        id: stateDef.id + '-note',
        note: stateDef.note,
        type: 'note'
      };
      var note = Object(_shapes__WEBPACK_IMPORTED_MODULE_7__["drawState"])(diagram, noteDef, graph); // graph.setNode(node.id, node);

      if (stateDef.note.position === 'left of') {
        graph.setNode(node.id + '-note', note);
        graph.setNode(node.id, node);
      } else {
        graph.setNode(node.id, node);
        graph.setNode(node.id + '-note', note);
      } // graph.setNode(node.id);


      graph.setParent(node.id, node.id + '-group');
      graph.setParent(node.id + '-note', node.id + '-group');
    } else {
      // Add nodes to the graph. The first argument is the node id. The second is
      // metadata about the node. In this case we're going to add labels to each of
      // our nodes.
      graph.setNode(node.id, node);
    }
  }

  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('Count=', graph.nodeCount(), graph);
  var cnt = 0;
  relations.forEach(function (relation) {
    cnt++;
    _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('Setting edge', relation);
    graph.setEdge(relation.id1, relation.id2, {
      relation: relation,
      width: getLabelWidth(relation.title),
      height: conf.labelHeight * _common_common__WEBPACK_IMPORTED_MODULE_5__["default"].getRows(relation.title).length,
      labelpos: 'c'
    }, 'id' + cnt);
  });
  dagre__WEBPACK_IMPORTED_MODULE_1___default.a.layout(graph);
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('Graph after layout', graph.nodes());
  var svgElem = diagram.node();
  graph.nodes().forEach(function (v) {
    if (typeof v !== 'undefined' && typeof graph.node(v) !== 'undefined') {
      _logger__WEBPACK_IMPORTED_MODULE_3__["log"].warn('Node ' + v + ': ' + JSON.stringify(graph.node(v)));
      Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('#' + svgElem.id + ' #' + v).attr('transform', 'translate(' + (graph.node(v).x - graph.node(v).width / 2) + ',' + (graph.node(v).y + (transformationLog[v] ? transformationLog[v].y : 0) - graph.node(v).height / 2) + ' )');
      Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('#' + svgElem.id + ' #' + v).attr('data-x-shift', graph.node(v).x - graph.node(v).width / 2);
      var dividers = document.querySelectorAll('#' + svgElem.id + ' #' + v + ' .divider');
      dividers.forEach(function (divider) {
        var parent = divider.parentElement;
        var pWidth = 0;
        var pShift = 0;

        if (parent) {
          if (parent.parentElement) pWidth = parent.parentElement.getBBox().width;
          pShift = parseInt(parent.getAttribute('data-x-shift'), 10);

          if (Number.isNaN(pShift)) {
            pShift = 0;
          }
        }

        divider.setAttribute('x1', 0 - pShift + 8);
        divider.setAttribute('x2', pWidth - pShift - 8);
      });
    } else {
      _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('No Node ' + v + ': ' + JSON.stringify(graph.node(v)));
    }
  });
  var stateBox = svgElem.getBBox();
  graph.edges().forEach(function (e) {
    if (typeof e !== 'undefined' && typeof graph.edge(e) !== 'undefined') {
      _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(graph.edge(e)));
      Object(_shapes__WEBPACK_IMPORTED_MODULE_7__["drawEdge"])(diagram, graph.edge(e), graph.edge(e).relation);
    }
  });
  stateBox = svgElem.getBBox();
  var stateInfo = {
    id: parentId ? parentId : 'root',
    label: parentId ? parentId : 'root',
    width: 0,
    height: 0
  };
  stateInfo.width = stateBox.width + 2 * conf.padding;
  stateInfo.height = stateBox.height + 2 * conf.padding;
  _logger__WEBPACK_IMPORTED_MODULE_3__["log"].debug('Doc rendered', stateInfo, graph);
  return stateInfo;
};

/* harmony default export */ __webpack_exports__["default"] = ({
  setConf: setConf,
  draw: draw
});

/***/ }),

/***/ "./src/diagrams/state/styles.js":
/*!**************************************!*\
  !*** ./src/diagrams/state/styles.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var getStyles = function getStyles(options) {
  return "\ndefs #statediagram-barbEnd {\n    fill: ".concat(options.transitionColor, ";\n    stroke: ").concat(options.transitionColor, ";\n  }\ng.stateGroup text {\n  fill: ").concat(options.nodeBorder, ";\n  stroke: none;\n  font-size: 10px;\n}\ng.stateGroup text {\n  fill: ").concat(options.textColor, ";\n  stroke: none;\n  font-size: 10px;\n\n}\ng.stateGroup .state-title {\n  font-weight: bolder;\n  fill: ").concat(options.stateLabelColor, ";\n}\n\ng.stateGroup rect {\n  fill: ").concat(options.mainBkg, ";\n  stroke: ").concat(options.nodeBorder, ";\n}\n\ng.stateGroup line {\n  stroke: ").concat(options.lineColor, ";\n  stroke-width: 1;\n}\n\n.transition {\n  stroke: ").concat(options.transitionColor, ";\n  stroke-width: 1;\n  fill: none;\n}\n\n.stateGroup .composit {\n  fill: ").concat(options.background, ";\n  border-bottom: 1px\n}\n\n.stateGroup .alt-composit {\n  fill: #e0e0e0;\n  border-bottom: 1px\n}\n\n.state-note {\n  stroke: ").concat(options.noteBorderColor, ";\n  fill: ").concat(options.noteBkgColor, ";\n\n  text {\n    fill: ").concat(options.noteTextColor, ";\n    stroke: none;\n    font-size: 10px;\n  }\n}\n\n.stateLabel .box {\n  stroke: none;\n  stroke-width: 0;\n  fill: ").concat(options.mainBkg, ";\n  opacity: 0.5;\n}\n\n.edgeLabel .label rect {\n  fill: ").concat(options.labelBackgroundColor, ";\n  opacity: 0.5;\n}\n.edgeLabel .label text {\n  fill: ").concat(options.transitionLabelColor || options.tertiaryTextColor, ";\n}\n.label div .edgeLabel {\n  color: ").concat(options.transitionLabelColor || options.tertiaryTextColor, ";\n}\n\n.stateLabel text {\n  fill: ").concat(options.stateLabelColor, ";\n  font-size: 10px;\n  font-weight: bold;\n}\n\n.node circle.state-start {\n  fill: ").concat(options.specialStateColor, ";\n  stroke: ").concat(options.specialStateColor, ";\n}\n\n.node .fork-join {\n  fill: ").concat(options.specialStateColor, ";\n  stroke: ").concat(options.specialStateColor, ";\n}\n\n.node circle.state-end {\n  fill: ").concat(options.innerEndBackground, ";\n  stroke: ").concat(options.background, ";\n  stroke-width: 1.5\n}\n.end-state-inner {\n  fill: ").concat(options.compositeBackground || options.background, ";\n  // stroke: ").concat(options.background, ";\n  stroke-width: 1.5\n}\n\n.node rect {\n  fill: ").concat(options.stateBkg || options.mainBkg, ";\n  stroke: ").concat(options.stateBorder || options.nodeBorder, ";\n  stroke-width: 1px;\n}\n.node polygon {\n  fill: ").concat(options.mainBkg, ";\n  stroke: ").concat(options.stateBorder || options.nodeBorder, ";;\n  stroke-width: 1px;\n}\n#statediagram-barbEnd {\n  fill: ").concat(options.lineColor, ";\n}\n\n.statediagram-cluster rect {\n  fill: ").concat(options.compositeTitleBackground, ";\n  stroke: ").concat(options.stateBorder || options.nodeBorder, ";\n  stroke-width: 1px;\n}\n\n.cluster-label, .nodeLabel {\n  color: ").concat(options.stateLabelColor, ";\n}\n\n.statediagram-cluster rect.outer {\n  rx: 5px;\n  ry: 5px;\n}\n.statediagram-state .divider {\n  stroke: ").concat(options.stateBorder || options.nodeBorder, ";\n}\n\n.statediagram-state .title-state {\n  rx: 5px;\n  ry: 5px;\n}\n.statediagram-cluster.statediagram-cluster .inner {\n  fill: ").concat(options.compositeBackground || options.background, ";\n}\n.statediagram-cluster.statediagram-cluster-alt .inner {\n  fill: ").concat(options.altBackground ? options.altBackground : '#efefef', ";\n}\n\n.statediagram-cluster .inner {\n  rx:0;\n  ry:0;\n}\n\n.statediagram-state rect.basic {\n  rx: 5px;\n  ry: 5px;\n}\n.statediagram-state rect.divider {\n  stroke-dasharray: 10,10;\n  fill: ").concat(options.altBackground ? options.altBackground : '#efefef', ";\n}\n\n.note-edge {\n  stroke-dasharray: 5;\n}\n\n.statediagram-note rect {\n  fill: ").concat(options.noteBkgColor, ";\n  stroke: ").concat(options.noteBorderColor, ";\n  stroke-width: 1px;\n  rx: 0;\n  ry: 0;\n}\n.statediagram-note rect {\n  fill: ").concat(options.noteBkgColor, ";\n  stroke: ").concat(options.noteBorderColor, ";\n  stroke-width: 1px;\n  rx: 0;\n  ry: 0;\n}\n\n.statediagram-note text {\n  fill: ").concat(options.noteTextColor, ";\n}\n\n.statediagram-note .nodeLabel {\n  color: ").concat(options.noteTextColor, ";\n}\n.statediagram .edgeLabel {\n  color: red; // ").concat(options.noteTextColor, ";\n}\n\n#dependencyStart, #dependencyEnd {\n  fill: ").concat(options.lineColor, ";\n  stroke: ").concat(options.lineColor, ";\n  stroke-width: 1;\n}\n");
};

/* harmony default export */ __webpack_exports__["default"] = (getStyles);

/***/ }),

/***/ "./src/diagrams/user-journey/journeyDb.js":
/*!************************************************!*\
  !*** ./src/diagrams/user-journey/journeyDb.js ***!
  \************************************************/
/*! exports provided: parseDirective, clear, setTitle, getTitle, addSection, getSections, getTasks, addTask, addTaskOrg, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseDirective", function() { return parseDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setTitle", function() { return setTitle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTitle", function() { return getTitle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addSection", function() { return addSection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSections", function() { return getSections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTasks", function() { return getTasks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addTask", function() { return addTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addTaskOrg", function() { return addTaskOrg; });
/* harmony import */ var _mermaidAPI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mermaidAPI */ "./src/mermaidAPI.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../config */ "./src/config.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



var title = '';
var currentSection = '';
var sections = [];
var tasks = [];
var rawTasks = [];
var parseDirective = function parseDirective(statement, context, type) {
  _mermaidAPI__WEBPACK_IMPORTED_MODULE_0__["default"].parseDirective(this, statement, context, type);
};
var clear = function clear() {
  sections.length = 0;
  tasks.length = 0;
  currentSection = '';
  title = '';
  rawTasks.length = 0;
};
var setTitle = function setTitle(txt) {
  title = txt;
};
var getTitle = function getTitle() {
  return title;
};
var addSection = function addSection(txt) {
  currentSection = txt;
  sections.push(txt);
};
var getSections = function getSections() {
  return sections;
};
var getTasks = function getTasks() {
  var allItemsProcessed = compileTasks();
  var maxDepth = 100;
  var iterationCount = 0;

  while (!allItemsProcessed && iterationCount < maxDepth) {
    allItemsProcessed = compileTasks();
    iterationCount++;
  }

  tasks.push.apply(tasks, rawTasks);
  return tasks;
};

var updateActors = function updateActors() {
  var tempActors = [];
  tasks.forEach(function (task) {
    if (task.people) {
      tempActors.push.apply(tempActors, _toConsumableArray(task.people));
    }
  });
  var unique = new Set(tempActors);
  return _toConsumableArray(unique).sort();
};

var addTask = function addTask(descr, taskData) {
  var pieces = taskData.substr(1).split(':');
  var score = 0;
  var peeps = [];

  if (pieces.length === 1) {
    score = Number(pieces[0]);
    peeps = [];
  } else {
    score = Number(pieces[0]);
    peeps = pieces[1].split(',');
  }

  var peopleList = peeps.map(function (s) {
    return s.trim();
  });
  var rawTask = {
    section: currentSection,
    type: currentSection,
    people: peopleList,
    task: descr,
    score: score
  };
  rawTasks.push(rawTask);
};
var addTaskOrg = function addTaskOrg(descr) {
  var newTask = {
    section: currentSection,
    type: currentSection,
    description: descr,
    task: descr,
    classes: []
  };
  tasks.push(newTask);
};

var compileTasks = function compileTasks() {
  var compileTask = function compileTask(pos) {
    return rawTasks[pos].processed;
  };

  var allProcessed = true;

  for (var i = 0; i < rawTasks.length; i++) {
    compileTask(i);
    allProcessed = allProcessed && rawTasks[i].processed;
  }

  return allProcessed;
};

var getActors = function getActors() {
  return updateActors();
};

/* harmony default export */ __webpack_exports__["default"] = ({
  parseDirective: parseDirective,
  getConfig: function getConfig() {
    return _config__WEBPACK_IMPORTED_MODULE_1__["getConfig"]().journey;
  },
  clear: clear,
  setTitle: setTitle,
  getTitle: getTitle,
  addSection: addSection,
  getSections: getSections,
  getTasks: getTasks,
  addTask: addTask,
  addTaskOrg: addTaskOrg,
  getActors: getActors
});

/***/ }),

/***/ "./src/diagrams/user-journey/journeyRenderer.js":
/*!******************************************************!*\
  !*** ./src/diagrams/user-journey/journeyRenderer.js ***!
  \******************************************************/
/*! exports provided: setConf, draw, bounds, drawTasks, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConf", function() { return setConf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return draw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounds", function() { return bounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawTasks", function() { return drawTasks; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _parser_journey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parser/journey */ "./src/diagrams/user-journey/parser/journey.jison");
/* harmony import */ var _parser_journey__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_parser_journey__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _journeyDb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./journeyDb */ "./src/diagrams/user-journey/journeyDb.js");
/* harmony import */ var _svgDraw__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./svgDraw */ "./src/diagrams/user-journey/svgDraw.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../config */ "./src/config.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils */ "./src/utils.js");






_parser_journey__WEBPACK_IMPORTED_MODULE_1__["parser"].yy = _journeyDb__WEBPACK_IMPORTED_MODULE_2__["default"];
var setConf = function setConf(cnf) {
  var keys = Object.keys(cnf);
  keys.forEach(function (key) {
    conf[key] = cnf[key];
  });
};
var actors = {};

function drawActorLegend(diagram) {
  var conf = Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().journey; // Draw the actors

  var yPos = 60;
  Object.keys(actors).forEach(function (person) {
    var colour = actors[person].color;
    var circleData = {
      cx: 20,
      cy: yPos,
      r: 7,
      fill: colour,
      stroke: '#000',
      pos: actors[person].position
    };
    _svgDraw__WEBPACK_IMPORTED_MODULE_3__["default"].drawCircle(diagram, circleData);
    var labelData = {
      x: 40,
      y: yPos + 7,
      fill: '#666',
      text: person,
      textMargin: conf.boxTextMargin | 5
    };
    _svgDraw__WEBPACK_IMPORTED_MODULE_3__["default"].drawText(diagram, labelData);
    yPos += 20;
  });
}

var conf = Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().journey;
var LEFT_MARGIN = Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().journey.leftMargin;
var draw = function draw(text, id) {
  var conf = Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().journey;
  _parser_journey__WEBPACK_IMPORTED_MODULE_1__["parser"].yy.clear();
  _parser_journey__WEBPACK_IMPORTED_MODULE_1__["parser"].parse(text + '\n');
  bounds.init();
  var diagram = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('#' + id);
  diagram.attr('xmlns:xlink', 'http://www.w3.org/1999/xlink');
  _svgDraw__WEBPACK_IMPORTED_MODULE_3__["default"].initGraphics(diagram);
  var tasks = _parser_journey__WEBPACK_IMPORTED_MODULE_1__["parser"].yy.getTasks();
  var title = _parser_journey__WEBPACK_IMPORTED_MODULE_1__["parser"].yy.getTitle();
  var actorNames = _parser_journey__WEBPACK_IMPORTED_MODULE_1__["parser"].yy.getActors();

  for (var member in actors) {
    delete actors[member];
  }

  var actorPos = 0;
  actorNames.forEach(function (actorName) {
    actors[actorName] = {
      color: conf.actorColours[actorPos % conf.actorColours.length],
      position: actorPos
    };
    actorPos++;
  });
  drawActorLegend(diagram);
  bounds.insert(0, 0, LEFT_MARGIN, Object.keys(actors).length * 50);
  drawTasks(diagram, tasks, 0);
  var box = bounds.getBounds();

  if (title) {
    diagram.append('text').text(title).attr('x', LEFT_MARGIN).attr('font-size', '4ex').attr('font-weight', 'bold').attr('y', 25);
  }

  var height = box.stopy - box.starty + 2 * conf.diagramMarginY;
  var width = LEFT_MARGIN + box.stopx + 2 * conf.diagramMarginX;
  Object(_utils__WEBPACK_IMPORTED_MODULE_5__["configureSvgSize"])(diagram, height, width, conf.useMaxWidth); // Draw activity line

  diagram.append('line').attr('x1', LEFT_MARGIN).attr('y1', conf.height * 4) // One section head + one task + margins
  .attr('x2', width - LEFT_MARGIN - 4) // Subtract stroke width so arrow point is retained
  .attr('y2', conf.height * 4).attr('stroke-width', 4).attr('stroke', 'black').attr('marker-end', 'url(#arrowhead)');
  var extraVertForTitle = title ? 70 : 0;
  diagram.attr('viewBox', "".concat(box.startx, " -25 ").concat(width, " ").concat(height + extraVertForTitle));
  diagram.attr('preserveAspectRatio', 'xMinYMin meet');
  diagram.attr('height', height + extraVertForTitle + 25);
};
var bounds = {
  data: {
    startx: undefined,
    stopx: undefined,
    starty: undefined,
    stopy: undefined
  },
  verticalPos: 0,
  sequenceItems: [],
  init: function init() {
    this.sequenceItems = [];
    this.data = {
      startx: undefined,
      stopx: undefined,
      starty: undefined,
      stopy: undefined
    };
    this.verticalPos = 0;
  },
  updateVal: function updateVal(obj, key, val, fun) {
    if (typeof obj[key] === 'undefined') {
      obj[key] = val;
    } else {
      obj[key] = fun(val, obj[key]);
    }
  },
  updateBounds: function updateBounds(startx, starty, stopx, stopy) {
    var conf = Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().journey;

    var _self = this;

    var cnt = 0;

    function updateFn(type) {
      return function updateItemBounds(item) {
        cnt++; // The loop sequenceItems is a stack so the biggest margins in the beginning of the sequenceItems

        var n = _self.sequenceItems.length - cnt + 1;

        _self.updateVal(item, 'starty', starty - n * conf.boxMargin, Math.min);

        _self.updateVal(item, 'stopy', stopy + n * conf.boxMargin, Math.max);

        _self.updateVal(bounds.data, 'startx', startx - n * conf.boxMargin, Math.min);

        _self.updateVal(bounds.data, 'stopx', stopx + n * conf.boxMargin, Math.max);

        if (!(type === 'activation')) {
          _self.updateVal(item, 'startx', startx - n * conf.boxMargin, Math.min);

          _self.updateVal(item, 'stopx', stopx + n * conf.boxMargin, Math.max);

          _self.updateVal(bounds.data, 'starty', starty - n * conf.boxMargin, Math.min);

          _self.updateVal(bounds.data, 'stopy', stopy + n * conf.boxMargin, Math.max);
        }
      };
    }

    this.sequenceItems.forEach(updateFn());
  },
  insert: function insert(startx, starty, stopx, stopy) {
    var _startx = Math.min(startx, stopx);

    var _stopx = Math.max(startx, stopx);

    var _starty = Math.min(starty, stopy);

    var _stopy = Math.max(starty, stopy);

    this.updateVal(bounds.data, 'startx', _startx, Math.min);
    this.updateVal(bounds.data, 'starty', _starty, Math.min);
    this.updateVal(bounds.data, 'stopx', _stopx, Math.max);
    this.updateVal(bounds.data, 'stopy', _stopy, Math.max);
    this.updateBounds(_startx, _starty, _stopx, _stopy);
  },
  bumpVerticalPos: function bumpVerticalPos(bump) {
    this.verticalPos = this.verticalPos + bump;
    this.data.stopy = this.verticalPos;
  },
  getVerticalPos: function getVerticalPos() {
    return this.verticalPos;
  },
  getBounds: function getBounds() {
    return this.data;
  }
};
var fills = conf.sectionFills;
var textColours = conf.sectionColours;
var drawTasks = function drawTasks(diagram, tasks, verticalPos) {
  var conf = Object(_config__WEBPACK_IMPORTED_MODULE_4__["getConfig"])().journey;
  var lastSection = '';
  var sectionVHeight = conf.height * 2 + conf.diagramMarginY;
  var taskPos = verticalPos + sectionVHeight;
  var sectionNumber = 0;
  var fill = '#CCC';
  var colour = 'black';
  var num = 0; // Draw the tasks

  for (var i = 0; i < tasks.length; i++) {
    var task = tasks[i];

    if (lastSection !== task.section) {
      fill = fills[sectionNumber % fills.length];
      num = sectionNumber % fills.length;
      colour = textColours[sectionNumber % textColours.length];
      var section = {
        x: i * conf.taskMargin + i * conf.width + LEFT_MARGIN,
        y: 50,
        text: task.section,
        fill: fill,
        num: num,
        colour: colour
      };
      _svgDraw__WEBPACK_IMPORTED_MODULE_3__["default"].drawSection(diagram, section, conf);
      lastSection = task.section;
      sectionNumber++;
    } // Collect the actors involved in the task


    var taskActors = task.people.reduce(function (acc, actorName) {
      if (actors[actorName]) {
        acc[actorName] = actors[actorName];
      }

      return acc;
    }, {}); // Add some rendering data to the object

    task.x = i * conf.taskMargin + i * conf.width + LEFT_MARGIN;
    task.y = taskPos;
    task.width = conf.diagramMarginX;
    task.height = conf.diagramMarginY;
    task.colour = colour;
    task.fill = fill;
    task.num = num;
    task.actors = taskActors; // Draw the box with the attached line

    _svgDraw__WEBPACK_IMPORTED_MODULE_3__["default"].drawTask(diagram, task, conf);
    bounds.insert(task.x, task.y, task.x + task.width + conf.taskMargin, 300 + 5 * 30); // stopy is the length of the descenders.
  }
};
/* harmony default export */ __webpack_exports__["default"] = ({
  setConf: setConf,
  draw: draw
});

/***/ }),

/***/ "./src/diagrams/user-journey/parser/journey.jison":
/*!********************************************************!*\
  !*** ./src/diagrams/user-journey/parser/journey.jison ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, module) {/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,2],$V1=[1,5],$V2=[6,9,11,17,18,19,21],$V3=[1,15],$V4=[1,16],$V5=[1,17],$V6=[1,21],$V7=[4,6,9,11,17,18,19,21];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"start":3,"journey":4,"document":5,"EOF":6,"directive":7,"line":8,"SPACE":9,"statement":10,"NEWLINE":11,"openDirective":12,"typeDirective":13,"closeDirective":14,":":15,"argDirective":16,"title":17,"section":18,"taskName":19,"taskData":20,"open_directive":21,"type_directive":22,"arg_directive":23,"close_directive":24,"$accept":0,"$end":1},
terminals_: {2:"error",4:"journey",6:"EOF",9:"SPACE",11:"NEWLINE",15:":",17:"title",18:"section",19:"taskName",20:"taskData",21:"open_directive",22:"type_directive",23:"arg_directive",24:"close_directive"},
productions_: [0,[3,3],[3,2],[5,0],[5,2],[8,2],[8,1],[8,1],[8,1],[7,4],[7,6],[10,1],[10,1],[10,2],[10,1],[12,1],[13,1],[16,1],[14,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
 return $$[$0-1]; 
break;
case 3:
 this.$ = [] 
break;
case 4:
$$[$0-1].push($$[$0]);this.$ = $$[$0-1]
break;
case 5: case 6:
 this.$ = $$[$0] 
break;
case 7: case 8:
 this.$=[];
break;
case 11:
yy.setTitle($$[$0].substr(6));this.$=$$[$0].substr(6);
break;
case 12:
yy.addSection($$[$0].substr(8));this.$=$$[$0].substr(8);
break;
case 13:
yy.addTask($$[$0-1], $$[$0]);this.$='task';
break;
case 15:
 yy.parseDirective('%%{', 'open_directive'); 
break;
case 16:
 yy.parseDirective($$[$0], 'type_directive'); 
break;
case 17:
 $$[$0] = $$[$0].trim().replace(/'/g, '"'); yy.parseDirective($$[$0], 'arg_directive'); 
break;
case 18:
 yy.parseDirective('}%%', 'close_directive', 'journey'); 
break;
}
},
table: [{3:1,4:$V0,7:3,12:4,21:$V1},{1:[3]},o($V2,[2,3],{5:6}),{3:7,4:$V0,7:3,12:4,21:$V1},{13:8,22:[1,9]},{22:[2,15]},{6:[1,10],7:18,8:11,9:[1,12],10:13,11:[1,14],12:4,17:$V3,18:$V4,19:$V5,21:$V1},{1:[2,2]},{14:19,15:[1,20],24:$V6},o([15,24],[2,16]),o($V2,[2,8],{1:[2,1]}),o($V2,[2,4]),{7:18,10:22,12:4,17:$V3,18:$V4,19:$V5,21:$V1},o($V2,[2,6]),o($V2,[2,7]),o($V2,[2,11]),o($V2,[2,12]),{20:[1,23]},o($V2,[2,14]),{11:[1,24]},{16:25,23:[1,26]},{11:[2,18]},o($V2,[2,5]),o($V2,[2,13]),o($V7,[2,9]),{14:27,24:$V6},{24:[2,17]},{11:[1,28]},o($V7,[2,10])],
defaultActions: {5:[2,15],7:[2,2],21:[2,18],26:[2,17]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
            function lex() {
            var token;
            token = tstack.pop() || lexer.lex() || EOF;
            if (typeof token !== 'number') {
                if (token instanceof Array) {
                    tstack = token;
                    token = tstack.pop();
                }
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
        if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];
            for (p in table[state]) {
                if (this.terminals_[p] && p > TERROR) {
                    expected.push('\'' + this.terminals_[p] + '\'');
                }
            }
            if (lexer.showPosition) {
                errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
            } else {
                errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
            }
            this.parseError(errStr, {
                text: lexer.match,
                token: this.terminals_[symbol] || symbol,
                line: lexer.yylineno,
                loc: yyloc,
                expected: expected
            });
        }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {"case-insensitive":true},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0: this.begin('open_directive'); return 21; 
break;
case 1: this.begin('type_directive'); return 22; 
break;
case 2: this.popState(); this.begin('arg_directive'); return 15; 
break;
case 3: this.popState(); this.popState(); return 24; 
break;
case 4:return 23;
break;
case 5:/* skip comments */
break;
case 6:/* skip comments */
break;
case 7:return 11;
break;
case 8:/* skip whitespace */
break;
case 9:/* skip comments */
break;
case 10:return 4;
break;
case 11:return 17;
break;
case 12:return 18;
break;
case 13:return 19;
break;
case 14:return 20;
break;
case 15:return 15;
break;
case 16:return 6;
break;
case 17:return 'INVALID';
break;
}
},
rules: [/^(?:%%\{)/i,/^(?:((?:(?!\}%%)[^:.])*))/i,/^(?::)/i,/^(?:\}%%)/i,/^(?:((?:(?!\}%%).|\n)*))/i,/^(?:%(?!\{)[^\n]*)/i,/^(?:[^\}]%%[^\n]*)/i,/^(?:[\n]+)/i,/^(?:\s+)/i,/^(?:#[^\n]*)/i,/^(?:journey\b)/i,/^(?:title\s[^#\n;]+)/i,/^(?:section\s[^#:\n;]+)/i,/^(?:[^#:\n;]+)/i,/^(?::[^#\n;]+)/i,/^(?::)/i,/^(?:$)/i,/^(?:.)/i],
conditions: {"open_directive":{"rules":[1],"inclusive":false},"type_directive":{"rules":[2,3],"inclusive":false},"arg_directive":{"rules":[3,4],"inclusive":false},"INITIAL":{"rules":[0,5,6,7,8,9,10,11,12,13,14,15,16,17],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (true) {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js").readFileSync(__webpack_require__(/*! path */ "./node_modules/path-browserify/index.js").normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if ( true && __webpack_require__.c[__webpack_require__.s] === module) {
  exports.main(process.argv.slice(1));
}
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/diagrams/user-journey/styles.js":
/*!*********************************************!*\
  !*** ./src/diagrams/user-journey/styles.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var getStyles = function getStyles(options) {
  return ".label {\n    font-family: 'trebuchet ms', verdana, arial, sans-serif;\n    font-family: var(--mermaid-font-family);\n    color: ".concat(options.textColor, ";\n  }\n  .mouth {\n    stroke: #666;\n  }\n\n  line {\n    stroke: ").concat(options.textColor, "\n  }\n\n  .legend {\n    fill: ").concat(options.textColor, ";\n  }\n\n  .label text {\n    fill: #333;\n  }\n  .label {\n    color: ").concat(options.textColor, "\n  }\n\n  .face {\n    ").concat(options.faceColor ? "fill: ".concat(options.faceColor) : 'fill: #FFF8DC', ";\n    stroke: #999;\n  }\n\n  .node rect,\n  .node circle,\n  .node ellipse,\n  .node polygon,\n  .node path {\n    fill: ").concat(options.mainBkg, ";\n    stroke: ").concat(options.nodeBorder, ";\n    stroke-width: 1px;\n  }\n\n  .node .label {\n    text-align: center;\n  }\n  .node.clickable {\n    cursor: pointer;\n  }\n\n  .arrowheadPath {\n    fill: ").concat(options.arrowheadColor, ";\n  }\n\n  .edgePath .path {\n    stroke: ").concat(options.lineColor, ";\n    stroke-width: 1.5px;\n  }\n\n  .flowchart-link {\n    stroke: ").concat(options.lineColor, ";\n    fill: none;\n  }\n\n  .edgeLabel {\n    background-color: ").concat(options.edgeLabelBackground, ";\n    rect {\n      opacity: 0.5;\n    }\n    text-align: center;\n  }\n\n  .cluster rect {\n  }\n\n  .cluster text {\n    fill: ").concat(options.titleColor, ";\n  }\n\n  div.mermaidTooltip {\n    position: absolute;\n    text-align: center;\n    max-width: 200px;\n    padding: 2px;\n    font-family: 'trebuchet ms', verdana, arial, sans-serif;\n    font-family: var(--mermaid-font-family);\n    font-size: 12px;\n    background: ").concat(options.tertiaryColor, ";\n    border: 1px solid ").concat(options.border2, ";\n    border-radius: 2px;\n    pointer-events: none;\n    z-index: 100;\n  }\n\n  .task-type-0, .section-type-0  {\n    ").concat(options.fillType0 ? "fill: ".concat(options.fillType0) : '', ";\n  }\n  .task-type-1, .section-type-1  {\n    ").concat(options.fillType0 ? "fill: ".concat(options.fillType1) : '', ";\n  }\n  .task-type-2, .section-type-2  {\n    ").concat(options.fillType0 ? "fill: ".concat(options.fillType2) : '', ";\n  }\n  .task-type-3, .section-type-3  {\n    ").concat(options.fillType0 ? "fill: ".concat(options.fillType3) : '', ";\n  }\n  .task-type-4, .section-type-4  {\n    ").concat(options.fillType0 ? "fill: ".concat(options.fillType4) : '', ";\n  }\n  .task-type-5, .section-type-5  {\n    ").concat(options.fillType0 ? "fill: ".concat(options.fillType5) : '', ";\n  }\n  .task-type-6, .section-type-6  {\n    ").concat(options.fillType0 ? "fill: ".concat(options.fillType6) : '', ";\n  }\n  .task-type-7, .section-type-7  {\n    ").concat(options.fillType0 ? "fill: ".concat(options.fillType7) : '', ";\n  }\n\n  .actor-0 {\n    ").concat(options.actor0 ? "fill: ".concat(options.actor0) : '', ";\n  }\n  .actor-1 {\n    ").concat(options.actor1 ? "fill: ".concat(options.actor1) : '', ";\n  }\n  .actor-2 {\n    ").concat(options.actor2 ? "fill: ".concat(options.actor2) : '', ";\n  }\n  .actor-3 {\n    ").concat(options.actor3 ? "fill: ".concat(options.actor3) : '', ";\n  }\n  .actor-4 {\n    ").concat(options.actor4 ? "fill: ".concat(options.actor4) : '', ";\n  }\n  .actor-5 {\n    ").concat(options.actor5 ? "fill: ".concat(options.actor5) : '', ";\n  }\n\n  }\n");
};

/* harmony default export */ __webpack_exports__["default"] = (getStyles);

/***/ }),

/***/ "./src/diagrams/user-journey/svgDraw.js":
/*!**********************************************!*\
  !*** ./src/diagrams/user-journey/svgDraw.js ***!
  \**********************************************/
/*! exports provided: drawRect, drawFace, drawCircle, drawText, drawLabel, drawSection, drawTask, drawBackgroundRect, getTextObj, getNoteRect, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawRect", function() { return drawRect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawFace", function() { return drawFace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawCircle", function() { return drawCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawText", function() { return drawText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawLabel", function() { return drawLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawSection", function() { return drawSection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawTask", function() { return drawTask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawBackgroundRect", function() { return drawBackgroundRect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTextObj", function() { return getTextObj; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNoteRect", function() { return getNoteRect; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);

var drawRect = function drawRect(elem, rectData) {
  var rectElem = elem.append('rect');
  rectElem.attr('x', rectData.x);
  rectElem.attr('y', rectData.y);
  rectElem.attr('fill', rectData.fill);
  rectElem.attr('stroke', rectData.stroke);
  rectElem.attr('width', rectData.width);
  rectElem.attr('height', rectData.height);
  rectElem.attr('rx', rectData.rx);
  rectElem.attr('ry', rectData.ry);

  if (typeof rectData.class !== 'undefined') {
    rectElem.attr('class', rectData.class);
  }

  return rectElem;
};
var drawFace = function drawFace(element, faceData) {
  var radius = 15;
  var circleElement = element.append('circle').attr('cx', faceData.cx).attr('cy', faceData.cy).attr('class', 'face').attr('r', radius).attr('stroke-width', 2).attr('overflow', 'visible');
  var face = element.append('g'); //left eye

  face.append('circle').attr('cx', faceData.cx - radius / 3).attr('cy', faceData.cy - radius / 3).attr('r', 1.5).attr('stroke-width', 2).attr('fill', '#666').attr('stroke', '#666'); //right eye

  face.append('circle').attr('cx', faceData.cx + radius / 3).attr('cy', faceData.cy - radius / 3).attr('r', 1.5).attr('stroke-width', 2).attr('fill', '#666').attr('stroke', '#666');

  function smile(face) {
    var arc = Object(d3__WEBPACK_IMPORTED_MODULE_0__["arc"])().startAngle(Math.PI / 2).endAngle(3 * (Math.PI / 2)).innerRadius(radius / 2).outerRadius(radius / 2.2); //mouth

    face.append('path').attr('class', 'mouth').attr('d', arc).attr('transform', 'translate(' + faceData.cx + ',' + (faceData.cy + 2) + ')');
  }

  function sad(face) {
    var arc = Object(d3__WEBPACK_IMPORTED_MODULE_0__["arc"])().startAngle(3 * Math.PI / 2).endAngle(5 * (Math.PI / 2)).innerRadius(radius / 2).outerRadius(radius / 2.2); //mouth

    face.append('path').attr('class', 'mouth').attr('d', arc).attr('transform', 'translate(' + faceData.cx + ',' + (faceData.cy + 7) + ')');
  }

  function ambivalent(face) {
    face.append('line').attr('class', 'mouth').attr('stroke', 2).attr('x1', faceData.cx - 5).attr('y1', faceData.cy + 7).attr('x2', faceData.cx + 5).attr('y2', faceData.cy + 7).attr('class', 'mouth').attr('stroke-width', '1px').attr('stroke', '#666');
  }

  if (faceData.score > 3) {
    smile(face);
  } else if (faceData.score < 3) {
    sad(face);
  } else {
    ambivalent(face);
  }

  return circleElement;
};
var drawCircle = function drawCircle(element, circleData) {
  var circleElement = element.append('circle');
  circleElement.attr('cx', circleData.cx);
  circleElement.attr('cy', circleData.cy);
  circleElement.attr('class', 'actor-' + circleData.pos);
  circleElement.attr('fill', circleData.fill);
  circleElement.attr('stroke', circleData.stroke);
  circleElement.attr('r', circleData.r);

  if (typeof circleElement.class !== 'undefined') {
    circleElement.attr('class', circleElement.class);
  }

  if (typeof circleData.title !== 'undefined') {
    circleElement.append('title').text(circleData.title);
  }

  return circleElement;
};
var drawText = function drawText(elem, textData) {
  // Remove and ignore br:s
  var nText = textData.text.replace(/<br\s*\/?>/gi, ' ');
  var textElem = elem.append('text');
  textElem.attr('x', textData.x);
  textElem.attr('y', textData.y);
  textElem.attr('class', 'legend');
  textElem.style('text-anchor', textData.anchor);

  if (typeof textData.class !== 'undefined') {
    textElem.attr('class', textData.class);
  }

  var span = textElem.append('tspan');
  span.attr('x', textData.x + textData.textMargin * 2);
  span.text(nText);
  return textElem;
};
var drawLabel = function drawLabel(elem, txtObject) {
  function genPoints(x, y, width, height, cut) {
    return x + ',' + y + ' ' + (x + width) + ',' + y + ' ' + (x + width) + ',' + (y + height - cut) + ' ' + (x + width - cut * 1.2) + ',' + (y + height) + ' ' + x + ',' + (y + height);
  }

  var polygon = elem.append('polygon');
  polygon.attr('points', genPoints(txtObject.x, txtObject.y, 50, 20, 7));
  polygon.attr('class', 'labelBox');
  txtObject.y = txtObject.y + txtObject.labelMargin;
  txtObject.x = txtObject.x + 0.5 * txtObject.labelMargin;
  drawText(elem, txtObject);
};
var drawSection = function drawSection(elem, section, conf) {
  var g = elem.append('g');
  var rect = getNoteRect();
  rect.x = section.x;
  rect.y = section.y;
  rect.fill = section.fill;
  rect.width = conf.width;
  rect.height = conf.height;
  rect.class = 'journey-section section-type-' + section.num;
  rect.rx = 3;
  rect.ry = 3;
  drawRect(g, rect);

  _drawTextCandidateFunc(conf)(section.text, g, rect.x, rect.y, rect.width, rect.height, {
    class: 'journey-section section-type-' + section.num
  }, conf, section.colour);
};
var taskCount = -1;
/**
 * Draws an actor in the diagram with the attaced line
 * @param elem The HTML element
 * @param task The task to render
 * @param conf The global configuration
 */

var drawTask = function drawTask(elem, task, conf) {
  var center = task.x + conf.width / 2;
  var g = elem.append('g');
  taskCount++;
  var maxHeight = 300 + 5 * 30;
  g.append('line').attr('id', 'task' + taskCount).attr('x1', center).attr('y1', task.y).attr('x2', center).attr('y2', maxHeight).attr('class', 'task-line').attr('stroke-width', '1px').attr('stroke-dasharray', '4 2').attr('stroke', '#666');
  drawFace(g, {
    cx: center,
    cy: 300 + (5 - task.score) * 30,
    score: task.score
  });
  var rect = getNoteRect();
  rect.x = task.x;
  rect.y = task.y;
  rect.fill = task.fill;
  rect.width = conf.width;
  rect.height = conf.height;
  rect.class = 'task task-type-' + task.num;
  rect.rx = 3;
  rect.ry = 3;
  drawRect(g, rect);
  var xPos = task.x + 14;
  task.people.forEach(function (person) {
    var colour = task.actors[person].color;
    var circle = {
      cx: xPos,
      cy: task.y,
      r: 7,
      fill: colour,
      stroke: '#000',
      title: person,
      pos: task.actors[person].position
    };
    drawCircle(g, circle);
    xPos += 10;
  });

  _drawTextCandidateFunc(conf)(task.task, g, rect.x, rect.y, rect.width, rect.height, {
    class: 'task'
  }, conf, task.colour);
};
/**
 * Draws a background rectangle
 * @param elem The html element
 * @param bounds The bounds of the drawing
 */

var drawBackgroundRect = function drawBackgroundRect(elem, bounds) {
  var rectElem = drawRect(elem, {
    x: bounds.startx,
    y: bounds.starty,
    width: bounds.stopx - bounds.startx,
    height: bounds.stopy - bounds.starty,
    fill: bounds.fill,
    class: 'rect'
  });
  rectElem.lower();
};
var getTextObj = function getTextObj() {
  return {
    x: 0,
    y: 0,
    fill: undefined,
    'text-anchor': 'start',
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0
  };
};
var getNoteRect = function getNoteRect() {
  return {
    x: 0,
    y: 0,
    width: 100,
    anchor: 'start',
    height: 100,
    rx: 0,
    ry: 0
  };
};

var _drawTextCandidateFunc = function () {
  function byText(content, g, x, y, width, height, textAttrs, colour) {
    var text = g.append('text').attr('x', x + width / 2).attr('y', y + height / 2 + 5).style('font-color', colour).style('text-anchor', 'middle').text(content);

    _setTextAttrs(text, textAttrs);
  }

  function byTspan(content, g, x, y, width, height, textAttrs, conf, colour) {
    var taskFontSize = conf.taskFontSize,
        taskFontFamily = conf.taskFontFamily;
    var lines = content.split(/<br\s*\/?>/gi);

    for (var i = 0; i < lines.length; i++) {
      var dy = i * taskFontSize - taskFontSize * (lines.length - 1) / 2;
      var text = g.append('text').attr('x', x + width / 2).attr('y', y).attr('fill', colour).style('text-anchor', 'middle').style('font-size', taskFontSize).style('font-family', taskFontFamily);
      text.append('tspan').attr('x', x + width / 2).attr('dy', dy).text(lines[i]);
      text.attr('y', y + height / 2.0).attr('dominant-baseline', 'central').attr('alignment-baseline', 'central');

      _setTextAttrs(text, textAttrs);
    }
  }

  function byFo(content, g, x, y, width, height, textAttrs, conf) {
    var body = g.append('switch');
    var f = body.append('foreignObject').attr('x', x).attr('y', y).attr('width', width).attr('height', height).attr('position', 'fixed');
    var text = f.append('xhtml:div').style('display', 'table').style('height', '100%').style('width', '100%');
    text.append('div').attr('class', 'label').style('display', 'table-cell').style('text-align', 'center').style('vertical-align', 'middle') // .style('color', colour)
    .text(content);
    byTspan(content, body, x, y, width, height, textAttrs, conf);

    _setTextAttrs(text, textAttrs);
  }

  function _setTextAttrs(toText, fromTextAttrsDict) {
    for (var key in fromTextAttrsDict) {
      if (key in fromTextAttrsDict) {
        // eslint-disable-line
        // noinspection JSUnfilteredForInLoop
        toText.attr(key, fromTextAttrsDict[key]);
      }
    }
  }

  return function (conf) {
    return conf.textPlacement === 'fo' ? byFo : conf.textPlacement === 'old' ? byText : byTspan;
  };
}();

var initGraphics = function initGraphics(graphics) {
  graphics.append('defs').append('marker').attr('id', 'arrowhead').attr('refX', 5).attr('refY', 2).attr('markerWidth', 6).attr('markerHeight', 4).attr('orient', 'auto').append('path').attr('d', 'M 0,0 V 4 L6,2 Z'); // this is actual shape for arrowhead
};

/* harmony default export */ __webpack_exports__["default"] = ({
  drawRect: drawRect,
  drawCircle: drawCircle,
  drawSection: drawSection,
  drawText: drawText,
  drawLabel: drawLabel,
  drawTask: drawTask,
  drawBackgroundRect: drawBackgroundRect,
  getTextObj: getTextObj,
  getNoteRect: getNoteRect,
  initGraphics: initGraphics
});

/***/ }),

/***/ "./src/errorRenderer.js":
/*!******************************!*\
  !*** ./src/errorRenderer.js ***!
  \******************************/
/*! exports provided: setConf, draw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setConf", function() { return setConf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "draw", function() { return draw; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logger */ "./src/logger.js");
/**
 * Created by knut on 14-12-11.
 */


var conf = {};
var setConf = function setConf(cnf) {
  var keys = Object.keys(cnf);
  keys.forEach(function (key) {
    conf[key] = cnf[key];
  });
};
/**
 * Draws a an info picture in the tag with id: id based on the graph definition in text.
 * @param text
 * @param id
 */

var draw = function draw(id, ver) {
  try {
    _logger__WEBPACK_IMPORTED_MODULE_1__["log"].debug('Renering svg for syntax error\n');
    var svg = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('#' + id);
    var g = svg.append('g');
    g.append('path').attr('class', 'error-icon').attr('d', 'm411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z');
    g.append('path').attr('class', 'error-icon').attr('d', 'm459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z');
    g.append('path').attr('class', 'error-icon').attr('d', 'm340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z');
    g.append('path').attr('class', 'error-icon').attr('d', 'm400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z');
    g.append('path').attr('class', 'error-icon').attr('d', 'm496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z');
    g.append('path').attr('class', 'error-icon').attr('d', 'm436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z');
    g.append('text') // text label for the x axis
    .attr('class', 'error-text').attr('x', 1240).attr('y', 250).attr('font-size', '150px').style('text-anchor', 'middle').text('Syntax error in graph');
    g.append('text') // text label for the x axis
    .attr('class', 'error-text').attr('x', 1050).attr('y', 400).attr('font-size', '100px').style('text-anchor', 'middle').text('mermaid version ' + ver);
    svg.attr('height', 100);
    svg.attr('width', 400);
    svg.attr('viewBox', '768 0 512 512');
  } catch (e) {
    _logger__WEBPACK_IMPORTED_MODULE_1__["log"].error('Error while rendering info diagram');
    _logger__WEBPACK_IMPORTED_MODULE_1__["log"].error(e.message);
  }
};
/* harmony default export */ __webpack_exports__["default"] = ({
  setConf: setConf,
  draw: draw
});

/***/ }),

/***/ "./src/logger.js":
/*!***********************!*\
  !*** ./src/logger.js ***!
  \***********************/
/*! exports provided: LEVELS, log, setLogLevel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LEVELS", function() { return LEVELS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setLogLevel", function() { return setLogLevel; });
/* harmony import */ var moment_mini__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! moment-mini */ "moment-mini");
/* harmony import */ var moment_mini__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(moment_mini__WEBPACK_IMPORTED_MODULE_0__);

var LEVELS = {
  debug: 1,
  info: 2,
  warn: 3,
  error: 4,
  fatal: 5
};
var log = {
  debug: function debug() {},
  info: function info() {},
  warn: function warn() {},
  error: function error() {},
  fatal: function fatal() {}
};
var setLogLevel = function setLogLevel() {
  var level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'fatal';

  if (isNaN(level)) {
    level = level.toLowerCase();

    if (LEVELS[level] !== undefined) {
      level = LEVELS[level];
    }
  }

  log.trace = function () {};

  log.debug = function () {};

  log.info = function () {};

  log.warn = function () {};

  log.error = function () {};

  log.fatal = function () {};

  if (level <= LEVELS.fatal) {
    log.fatal = console.error ? console.error.bind(console, format('FATAL'), 'color: orange') : console.log.bind(console, '\x1b[35m', format('FATAL'));
  }

  if (level <= LEVELS.error) {
    log.error = console.error ? console.error.bind(console, format('ERROR'), 'color: orange') : console.log.bind(console, '\x1b[31m', format('ERROR'));
  }

  if (level <= LEVELS.warn) {
    log.warn = console.warn ? console.warn.bind(console, format('WARN'), 'color: orange') : console.log.bind(console, "\x1B[33m", format('WARN'));
  }

  if (level <= LEVELS.info) {
    log.info = console.info // ? console.info.bind(console, '\x1b[34m', format('INFO'), 'color: blue')
    ? console.info.bind(console, format('INFO'), 'color: lightblue') : console.log.bind(console, '\x1b[34m', format('INFO'));
  }

  if (level <= LEVELS.debug) {
    log.debug = console.debug ? console.debug.bind(console, format('DEBUG'), 'color: lightgreen') : console.log.bind(console, '\x1b[32m', format('DEBUG'));
  }
};

var format = function format(level) {
  var time = moment_mini__WEBPACK_IMPORTED_MODULE_0___default()().format('ss.SSS');
  return "%c".concat(time, " : ").concat(level, " : ");
};

/***/ }),

/***/ "./src/mermaid.js":
/*!************************!*\
  !*** ./src/mermaid.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ "./src/logger.js");
/* harmony import */ var _mermaidAPI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mermaidAPI */ "./src/mermaidAPI.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/utils.js");
/**
 * Web page integration module for the mermaid framework. It uses the mermaidAPI for mermaid functionality and to render
 * the diagrams to svg code.
 */



/**
 * ## init
 * Function that goes through the document to find the chart definitions in there and render them.
 *
 * The function tags the processed attributes with the attribute data-processed and ignores found elements with the
 * attribute already set. This way the init function can be triggered several times.
 *
 * Optionally, `init` can accept in the second argument one of the following:
 * - a DOM Node
 * - an array of DOM nodes (as would come from a jQuery selector)
 * - a W3C selector, a la `.mermaid`
 *
 * ```mermaid
 * graph LR;
 *  a(Find elements)-->b{Processed}
 *  b-->|Yes|c(Leave element)
 *  b-->|No |d(Transform)
 * ```
 * Renders the mermaid diagrams
 * @param nodes a css selector or an array of nodes
 */

var init = function init() {
  var _this = this;

  var conf = _mermaidAPI__WEBPACK_IMPORTED_MODULE_1__["default"].getConfig(); // console.log('Starting rendering diagrams (init) - mermaid.init', conf);

  var nodes;

  if (arguments.length >= 2) {
    /*! sequence config was passed as #1 */
    if (typeof arguments[0] !== 'undefined') {
      mermaid.sequenceConfig = arguments[0];
    }

    nodes = arguments[1];
  } else {
    nodes = arguments[0];
  } // if last argument is a function this is the callback function


  var callback;

  if (typeof arguments[arguments.length - 1] === 'function') {
    callback = arguments[arguments.length - 1];
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Callback function found');
  } else {
    if (typeof conf.mermaid !== 'undefined') {
      if (typeof conf.mermaid.callback === 'function') {
        callback = conf.mermaid.callback;
        _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Callback function found');
      } else {
        _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('No Callback function found');
      }
    }
  }

  nodes = nodes === undefined ? document.querySelectorAll('.mermaid') : typeof nodes === 'string' ? document.querySelectorAll(nodes) : nodes instanceof window.Node ? [nodes] : nodes; // Last case  - sequence config was passed pick next

  _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Start On Load before: ' + mermaid.startOnLoad);

  if (typeof mermaid.startOnLoad !== 'undefined') {
    _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Start On Load inner: ' + mermaid.startOnLoad);
    _mermaidAPI__WEBPACK_IMPORTED_MODULE_1__["default"].updateSiteConfig({
      startOnLoad: mermaid.startOnLoad
    });
  }

  if (typeof mermaid.ganttConfig !== 'undefined') {
    _mermaidAPI__WEBPACK_IMPORTED_MODULE_1__["default"].updateSiteConfig({
      gantt: mermaid.ganttConfig
    });
  }

  var idGeneratior = new _utils__WEBPACK_IMPORTED_MODULE_2__["default"].initIdGeneratior(conf.deterministicIds, conf.deterministicIDSeed);
  var txt;

  var _loop = function _loop(i) {
    var element = nodes[i];
    /*! Check if previously processed */

    if (!element.getAttribute('data-processed')) {
      element.setAttribute('data-processed', true);
    } else {
      return "continue";
    }

    var id = "mermaid-".concat(idGeneratior.next()); // Fetch the graph definition including tags

    txt = element.innerHTML; // transforms the html to pure text

    txt = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].entityDecode(txt).trim().replace(/<br\s*\/?>/gi, '<br/>');
    var init = _utils__WEBPACK_IMPORTED_MODULE_2__["default"].detectInit(txt);

    if (init) {
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('Detected early reinit: ', init);
    }

    try {
      _mermaidAPI__WEBPACK_IMPORTED_MODULE_1__["default"].render(id, txt, function (svgCode, bindFunctions) {
        element.innerHTML = svgCode;

        if (typeof callback !== 'undefined') {
          callback(id);
        }

        if (bindFunctions) bindFunctions(element);
      }, element);
    } catch (e) {
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn('Syntax Error rendering');
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].warn(e);

      if (_this.parseError) {
        _this.parseError(e);
      }
    }
  };

  for (var i = 0; i < nodes.length; i++) {
    var _ret = _loop(i);

    if (_ret === "continue") continue;
  }
};

var initialize = function initialize(config) {
  // mermaidAPI.reset();
  if (typeof config.mermaid !== 'undefined') {
    if (typeof config.mermaid.startOnLoad !== 'undefined') {
      mermaid.startOnLoad = config.mermaid.startOnLoad;
    }

    if (typeof config.mermaid.htmlLabels !== 'undefined') {
      mermaid.htmlLabels = config.mermaid.htmlLabels === 'false' || config.mermaid.htmlLabels === false ? false : true;
    }
  }

  _mermaidAPI__WEBPACK_IMPORTED_MODULE_1__["default"].initialize(config); // mermaidAPI.reset();
};
/**
 * ##contentLoaded
 * Callback function that is called when page is loaded. This functions fetches configuration for mermaid rendering and
 * calls init for rendering the mermaid diagrams on the page.
 */


var contentLoaded = function contentLoaded() {
  var config;

  if (mermaid.startOnLoad) {
    // No config found, do check API config
    config = _mermaidAPI__WEBPACK_IMPORTED_MODULE_1__["default"].getConfig();

    if (config.startOnLoad) {
      mermaid.init();
    }
  } else {
    if (typeof mermaid.startOnLoad === 'undefined') {
      _logger__WEBPACK_IMPORTED_MODULE_0__["log"].debug('In start, no config');
      config = _mermaidAPI__WEBPACK_IMPORTED_MODULE_1__["default"].getConfig();

      if (config.startOnLoad) {
        mermaid.init();
      }
    }
  }
};

if (typeof document !== 'undefined') {
  /*!
   * Wait for document loaded before starting the execution
   */
  window.addEventListener('load', function () {
    contentLoaded();
  }, false);
}

var mermaid = {
  startOnLoad: true,
  htmlLabels: true,
  mermaidAPI: _mermaidAPI__WEBPACK_IMPORTED_MODULE_1__["default"],
  parse: _mermaidAPI__WEBPACK_IMPORTED_MODULE_1__["default"].parse,
  render: _mermaidAPI__WEBPACK_IMPORTED_MODULE_1__["default"].render,
  init: init,
  initialize: initialize,
  contentLoaded: contentLoaded
};
/* harmony default export */ __webpack_exports__["default"] = (mermaid);

/***/ }),

/***/ "./src/mermaidAPI.js":
/*!***************************!*\
  !*** ./src/mermaidAPI.js ***!
  \***************************/
/*! exports provided: encodeEntities, decodeEntities, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeEntities", function() { return encodeEntities; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeEntities", function() { return decodeEntities; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! stylis */ "stylis");
/* harmony import */ var stylis__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(stylis__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../package.json */ "./package.json");
var _package_json__WEBPACK_IMPORTED_MODULE_2___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ "./package.json", 1);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./config */ "./src/config.js");
/* harmony import */ var _diagrams_class_classDb__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./diagrams/class/classDb */ "./src/diagrams/class/classDb.js");
/* harmony import */ var _diagrams_class_classRenderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./diagrams/class/classRenderer */ "./src/diagrams/class/classRenderer.js");
/* harmony import */ var _diagrams_class_classRenderer_v2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./diagrams/class/classRenderer-v2 */ "./src/diagrams/class/classRenderer-v2.js");
/* harmony import */ var _diagrams_class_parser_classDiagram__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./diagrams/class/parser/classDiagram */ "./src/diagrams/class/parser/classDiagram.jison");
/* harmony import */ var _diagrams_class_parser_classDiagram__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_diagrams_class_parser_classDiagram__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _diagrams_er_erDb__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./diagrams/er/erDb */ "./src/diagrams/er/erDb.js");
/* harmony import */ var _diagrams_er_erRenderer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./diagrams/er/erRenderer */ "./src/diagrams/er/erRenderer.js");
/* harmony import */ var _diagrams_er_parser_erDiagram__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./diagrams/er/parser/erDiagram */ "./src/diagrams/er/parser/erDiagram.jison");
/* harmony import */ var _diagrams_er_parser_erDiagram__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_diagrams_er_parser_erDiagram__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _diagrams_flowchart_flowDb__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./diagrams/flowchart/flowDb */ "./src/diagrams/flowchart/flowDb.js");
/* harmony import */ var _diagrams_flowchart_flowRenderer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./diagrams/flowchart/flowRenderer */ "./src/diagrams/flowchart/flowRenderer.js");
/* harmony import */ var _diagrams_flowchart_flowRenderer_v2__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./diagrams/flowchart/flowRenderer-v2 */ "./src/diagrams/flowchart/flowRenderer-v2.js");
/* harmony import */ var _diagrams_flowchart_parser_flow__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./diagrams/flowchart/parser/flow */ "./src/diagrams/flowchart/parser/flow.jison");
/* harmony import */ var _diagrams_flowchart_parser_flow__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_diagrams_flowchart_parser_flow__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _diagrams_gantt_ganttDb__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./diagrams/gantt/ganttDb */ "./src/diagrams/gantt/ganttDb.js");
/* harmony import */ var _diagrams_gantt_ganttRenderer__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./diagrams/gantt/ganttRenderer */ "./src/diagrams/gantt/ganttRenderer.js");
/* harmony import */ var _diagrams_gantt_parser_gantt__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./diagrams/gantt/parser/gantt */ "./src/diagrams/gantt/parser/gantt.jison");
/* harmony import */ var _diagrams_gantt_parser_gantt__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_diagrams_gantt_parser_gantt__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var _diagrams_git_gitGraphAst__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./diagrams/git/gitGraphAst */ "./src/diagrams/git/gitGraphAst.js");
/* harmony import */ var _diagrams_git_gitGraphRenderer__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./diagrams/git/gitGraphRenderer */ "./src/diagrams/git/gitGraphRenderer.js");
/* harmony import */ var _diagrams_git_parser_gitGraph__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./diagrams/git/parser/gitGraph */ "./src/diagrams/git/parser/gitGraph.jison");
/* harmony import */ var _diagrams_git_parser_gitGraph__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(_diagrams_git_parser_gitGraph__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var _diagrams_info_infoDb__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./diagrams/info/infoDb */ "./src/diagrams/info/infoDb.js");
/* harmony import */ var _diagrams_info_infoRenderer__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./diagrams/info/infoRenderer */ "./src/diagrams/info/infoRenderer.js");
/* harmony import */ var _diagrams_info_parser_info__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./diagrams/info/parser/info */ "./src/diagrams/info/parser/info.jison");
/* harmony import */ var _diagrams_info_parser_info__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(_diagrams_info_parser_info__WEBPACK_IMPORTED_MODULE_23__);
/* harmony import */ var _diagrams_pie_parser_pie__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./diagrams/pie/parser/pie */ "./src/diagrams/pie/parser/pie.jison");
/* harmony import */ var _diagrams_pie_parser_pie__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(_diagrams_pie_parser_pie__WEBPACK_IMPORTED_MODULE_24__);
/* harmony import */ var _diagrams_pie_pieDb__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./diagrams/pie/pieDb */ "./src/diagrams/pie/pieDb.js");
/* harmony import */ var _diagrams_pie_pieRenderer__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./diagrams/pie/pieRenderer */ "./src/diagrams/pie/pieRenderer.js");
/* harmony import */ var _diagrams_requirement_parser_requirementDiagram__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./diagrams/requirement/parser/requirementDiagram */ "./src/diagrams/requirement/parser/requirementDiagram.jison");
/* harmony import */ var _diagrams_requirement_parser_requirementDiagram__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(_diagrams_requirement_parser_requirementDiagram__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var _diagrams_requirement_requirementDb__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./diagrams/requirement/requirementDb */ "./src/diagrams/requirement/requirementDb.js");
/* harmony import */ var _diagrams_requirement_requirementRenderer__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./diagrams/requirement/requirementRenderer */ "./src/diagrams/requirement/requirementRenderer.js");
/* harmony import */ var _diagrams_sequence_parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./diagrams/sequence/parser/sequenceDiagram */ "./src/diagrams/sequence/parser/sequenceDiagram.jison");
/* harmony import */ var _diagrams_sequence_parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/__webpack_require__.n(_diagrams_sequence_parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_30__);
/* harmony import */ var _diagrams_sequence_sequenceDb__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./diagrams/sequence/sequenceDb */ "./src/diagrams/sequence/sequenceDb.js");
/* harmony import */ var _diagrams_sequence_sequenceRenderer__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./diagrams/sequence/sequenceRenderer */ "./src/diagrams/sequence/sequenceRenderer.js");
/* harmony import */ var _diagrams_state_parser_stateDiagram__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./diagrams/state/parser/stateDiagram */ "./src/diagrams/state/parser/stateDiagram.jison");
/* harmony import */ var _diagrams_state_parser_stateDiagram__WEBPACK_IMPORTED_MODULE_33___default = /*#__PURE__*/__webpack_require__.n(_diagrams_state_parser_stateDiagram__WEBPACK_IMPORTED_MODULE_33__);
/* harmony import */ var _diagrams_state_stateDb__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./diagrams/state/stateDb */ "./src/diagrams/state/stateDb.js");
/* harmony import */ var _diagrams_state_stateRenderer__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./diagrams/state/stateRenderer */ "./src/diagrams/state/stateRenderer.js");
/* harmony import */ var _diagrams_state_stateRenderer_v2__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./diagrams/state/stateRenderer-v2 */ "./src/diagrams/state/stateRenderer-v2.js");
/* harmony import */ var _diagrams_user_journey_journeyDb__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./diagrams/user-journey/journeyDb */ "./src/diagrams/user-journey/journeyDb.js");
/* harmony import */ var _diagrams_user_journey_journeyRenderer__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./diagrams/user-journey/journeyRenderer */ "./src/diagrams/user-journey/journeyRenderer.js");
/* harmony import */ var _diagrams_user_journey_parser_journey__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./diagrams/user-journey/parser/journey */ "./src/diagrams/user-journey/parser/journey.jison");
/* harmony import */ var _diagrams_user_journey_parser_journey__WEBPACK_IMPORTED_MODULE_39___default = /*#__PURE__*/__webpack_require__.n(_diagrams_user_journey_parser_journey__WEBPACK_IMPORTED_MODULE_39__);
/* harmony import */ var _errorRenderer__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./errorRenderer */ "./src/errorRenderer.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./logger */ "./src/logger.js");
/* harmony import */ var _styles__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./styles */ "./src/styles.js");
/* harmony import */ var _themes__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./themes */ "./src/themes/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./utils */ "./src/utils.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 *Edit this Page[![N|Solid](img/GitHub-Mark-32px.png)](https://github.com/mermaid-js/mermaid/blob/develop/src/mermaidAPI.js)
 *
 *This is the API to be used when optionally handling the integration with the web page, instead of using the default integration provided by mermaid.js.
 *
 *
 * The core of this api is the [**render**](Setup.md?id=render) function which, given a graph
 * definition as text, renders the graph/diagram and returns an svg element for the graph.
 *
 * It is is then up to the user of the API to make use of the svg, either insert it somewhere in the page or do something completely different.
 *
 * In addition to the render function, a number of behavioral configuration options are available.
 *
 * @name mermaidAPI
 */








































 // import * as configApi from './config';
// // , {
// //   setConfig,
// //   configApi.getConfig,
// //   configApi.updateSiteConfig,
// //   configApi.setSiteConfig,
// //   configApi.getSiteConfig,
// //   configApi.defaultConfig
// // }






function parse(text) {
  var cnf = _config__WEBPACK_IMPORTED_MODULE_3__["getConfig"]();
  var graphInit = _utils__WEBPACK_IMPORTED_MODULE_44__["default"].detectInit(text, cnf);

  if (graphInit) {
    reinitialize(graphInit);
    _logger__WEBPACK_IMPORTED_MODULE_41__["log"].debug('reinit ', graphInit);
  }

  var graphType = _utils__WEBPACK_IMPORTED_MODULE_44__["default"].detectType(text, cnf);
  var parser;
  _logger__WEBPACK_IMPORTED_MODULE_41__["log"].debug('Type ' + graphType);

  switch (graphType) {
    case 'git':
      parser = _diagrams_git_parser_gitGraph__WEBPACK_IMPORTED_MODULE_20___default.a;
      parser.parser.yy = _diagrams_git_gitGraphAst__WEBPACK_IMPORTED_MODULE_18__["default"];
      break;

    case 'flowchart':
      _diagrams_flowchart_flowDb__WEBPACK_IMPORTED_MODULE_11__["default"].clear();
      parser = _diagrams_flowchart_parser_flow__WEBPACK_IMPORTED_MODULE_14___default.a;
      parser.parser.yy = _diagrams_flowchart_flowDb__WEBPACK_IMPORTED_MODULE_11__["default"];
      break;

    case 'flowchart-v2':
      _diagrams_flowchart_flowDb__WEBPACK_IMPORTED_MODULE_11__["default"].clear();
      parser = _diagrams_flowchart_parser_flow__WEBPACK_IMPORTED_MODULE_14___default.a;
      parser.parser.yy = _diagrams_flowchart_flowDb__WEBPACK_IMPORTED_MODULE_11__["default"];
      break;

    case 'sequence':
      parser = _diagrams_sequence_parser_sequenceDiagram__WEBPACK_IMPORTED_MODULE_30___default.a;
      parser.parser.yy = _diagrams_sequence_sequenceDb__WEBPACK_IMPORTED_MODULE_31__["default"];
      break;

    case 'gantt':
      parser = _diagrams_gantt_parser_gantt__WEBPACK_IMPORTED_MODULE_17___default.a;
      parser.parser.yy = _diagrams_gantt_ganttDb__WEBPACK_IMPORTED_MODULE_15__["default"];
      break;

    case 'class':
      parser = _diagrams_class_parser_classDiagram__WEBPACK_IMPORTED_MODULE_7___default.a;
      parser.parser.yy = _diagrams_class_classDb__WEBPACK_IMPORTED_MODULE_4__["default"];
      break;

    case 'classDiagram':
      parser = _diagrams_class_parser_classDiagram__WEBPACK_IMPORTED_MODULE_7___default.a;
      parser.parser.yy = _diagrams_class_classDb__WEBPACK_IMPORTED_MODULE_4__["default"];
      break;

    case 'state':
      parser = _diagrams_state_parser_stateDiagram__WEBPACK_IMPORTED_MODULE_33___default.a;
      parser.parser.yy = _diagrams_state_stateDb__WEBPACK_IMPORTED_MODULE_34__["default"];
      break;

    case 'stateDiagram':
      parser = _diagrams_state_parser_stateDiagram__WEBPACK_IMPORTED_MODULE_33___default.a;
      parser.parser.yy = _diagrams_state_stateDb__WEBPACK_IMPORTED_MODULE_34__["default"];
      break;

    case 'info':
      _logger__WEBPACK_IMPORTED_MODULE_41__["log"].debug('info info info');
      parser = _diagrams_info_parser_info__WEBPACK_IMPORTED_MODULE_23___default.a;
      parser.parser.yy = _diagrams_info_infoDb__WEBPACK_IMPORTED_MODULE_21__["default"];
      break;

    case 'pie':
      _logger__WEBPACK_IMPORTED_MODULE_41__["log"].debug('pie');
      parser = _diagrams_pie_parser_pie__WEBPACK_IMPORTED_MODULE_24___default.a;
      parser.parser.yy = _diagrams_pie_pieDb__WEBPACK_IMPORTED_MODULE_25__["default"];
      break;

    case 'er':
      _logger__WEBPACK_IMPORTED_MODULE_41__["log"].debug('er');
      parser = _diagrams_er_parser_erDiagram__WEBPACK_IMPORTED_MODULE_10___default.a;
      parser.parser.yy = _diagrams_er_erDb__WEBPACK_IMPORTED_MODULE_8__["default"];
      break;

    case 'journey':
      _logger__WEBPACK_IMPORTED_MODULE_41__["log"].debug('Journey');
      parser = _diagrams_user_journey_parser_journey__WEBPACK_IMPORTED_MODULE_39___default.a;
      parser.parser.yy = _diagrams_user_journey_journeyDb__WEBPACK_IMPORTED_MODULE_37__["default"];
      break;

    case 'requirement':
    case 'requirementDiagram':
      _logger__WEBPACK_IMPORTED_MODULE_41__["log"].debug('RequirementDiagram');
      parser = _diagrams_requirement_parser_requirementDiagram__WEBPACK_IMPORTED_MODULE_27___default.a;
      parser.parser.yy = _diagrams_requirement_requirementDb__WEBPACK_IMPORTED_MODULE_28__["default"];
      break;
  }

  parser.parser.yy.graphType = graphType;

  parser.parser.yy.parseError = function (str, hash) {
    var error = {
      str: str,
      hash: hash
    };
    throw error;
  };

  parser.parse(text);
  return parser;
}

var encodeEntities = function encodeEntities(text) {
  var txt = text;
  txt = txt.replace(/style.*:\S*#.*;/g, function (s) {
    var innerTxt = s.substring(0, s.length - 1);
    return innerTxt;
  });
  txt = txt.replace(/classDef.*:\S*#.*;/g, function (s) {
    var innerTxt = s.substring(0, s.length - 1);
    return innerTxt;
  });
  txt = txt.replace(/#\w+;/g, function (s) {
    var innerTxt = s.substring(1, s.length - 1);
    var isInt = /^\+?\d+$/.test(innerTxt);

    if (isInt) {
      return 'ﬂ°°' + innerTxt + '¶ß';
    } else {
      return 'ﬂ°' + innerTxt + '¶ß';
    }
  });
  return txt;
};
var decodeEntities = function decodeEntities(text) {
  var txt = text;
  txt = txt.replace(/ﬂ°°/g, function () {
    return '&#';
  });
  txt = txt.replace(/ﬂ°/g, function () {
    return '&';
  });
  txt = txt.replace(/¶ß/g, function () {
    return ';';
  });
  return txt;
};
/**
 * Function that renders an svg with a graph from a chart definition. Usage example below.
 *
 * ```js
 * mermaidAPI.initialize({
 *      startOnLoad:true
 *  });
 *  $(function(){
 *      const graphDefinition = 'graph TB\na-->b';
 *      const cb = function(svgGraph){
 *          console.log(svgGraph);
 *      };
 *      mermaidAPI.render('id1',graphDefinition,cb);
 *  });
 *```
 * @param id the id of the element to be rendered
 * @param _txt the graph definition
 * @param cb callback which is called after rendering is finished with the svg code as inparam.
 * @param container selector to element in which a div with the graph temporarily will be inserted. In one is
 * provided a hidden div will be inserted in the body of the page instead. The element will be removed when rendering is
 * completed.
 */

var render = function render(id, _txt, cb, container) {
  _config__WEBPACK_IMPORTED_MODULE_3__["reset"]();
  var txt = _txt;
  var graphInit = _utils__WEBPACK_IMPORTED_MODULE_44__["default"].detectInit(txt);

  if (graphInit) {
    _config__WEBPACK_IMPORTED_MODULE_3__["addDirective"](graphInit);
  } // else {
  //   configApi.reset();
  //   const siteConfig = configApi.getSiteConfig();
  //   configApi.addDirective(siteConfig);
  // }
  // console.warn('Render fetching config');


  var cnf = _config__WEBPACK_IMPORTED_MODULE_3__["getConfig"](); // Check the maximum allowed text size

  if (_txt.length > cnf.maxTextSize) {
    txt = 'graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa';
  }

  if (typeof container !== 'undefined') {
    container.innerHTML = '';
    Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])(container).append('div').attr('id', 'd' + id).attr('style', 'font-family: ' + cnf.fontFamily).append('svg').attr('id', id).attr('width', '100%').attr('xmlns', 'http://www.w3.org/2000/svg').append('g');
  } else {
    var existingSvg = document.getElementById(id);

    if (existingSvg) {
      existingSvg.remove();
    }

    var _element = document.querySelector('#' + 'd' + id);

    if (_element) {
      _element.remove();
    }

    Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('body').append('div').attr('id', 'd' + id).append('svg').attr('id', id).attr('width', '100%').attr('xmlns', 'http://www.w3.org/2000/svg').append('g');
  }

  window.txt = txt;
  txt = encodeEntities(txt);
  var element = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('#d' + id).node();
  var graphType = _utils__WEBPACK_IMPORTED_MODULE_44__["default"].detectType(txt, cnf); // insert inline style into svg

  var svg = element.firstChild;
  var firstChild = svg.firstChild;
  var userStyles = ''; // user provided theme CSS

  if (cnf.themeCSS !== undefined) {
    userStyles += "\n".concat(cnf.themeCSS);
  } // user provided theme CSS


  if (cnf.fontFamily !== undefined) {
    userStyles += "\n:root { --mermaid-font-family: ".concat(cnf.fontFamily, "}");
  } // user provided theme CSS


  if (cnf.altFontFamily !== undefined) {
    userStyles += "\n:root { --mermaid-alt-font-family: ".concat(cnf.altFontFamily, "}");
  } // classDef


  if (graphType === 'flowchart' || graphType === 'flowchart-v2' || graphType === 'graph') {
    var classes = _diagrams_flowchart_flowRenderer__WEBPACK_IMPORTED_MODULE_12__["default"].getClasses(txt);
    var htmlLabels = cnf.htmlLabels || cnf.flowchart.htmlLabels;

    for (var className in classes) {
      if (htmlLabels) {
        userStyles += "\n.".concat(className, " > * { ").concat(classes[className].styles.join(' !important; '), " !important; }");
        userStyles += "\n.".concat(className, " span { ").concat(classes[className].styles.join(' !important; '), " !important; }");
      } else {
        userStyles += "\n.".concat(className, " path { ").concat(classes[className].styles.join(' !important; '), " !important; }");
        userStyles += "\n.".concat(className, " rect { ").concat(classes[className].styles.join(' !important; '), " !important; }");
        userStyles += "\n.".concat(className, " polygon { ").concat(classes[className].styles.join(' !important; '), " !important; }");
        userStyles += "\n.".concat(className, " ellipse { ").concat(classes[className].styles.join(' !important; '), " !important; }");
        userStyles += "\n.".concat(className, " circle { ").concat(classes[className].styles.join(' !important; '), " !important; }");

        if (classes[className].textStyles) {
          userStyles += "\n.".concat(className, " tspan { ").concat(classes[className].textStyles.join(' !important; '), " !important; }");
        }
      }
    }
  } // log.warn(cnf.themeVariables);


  var stylis = function stylis(selector, styles) {
    return Object(stylis__WEBPACK_IMPORTED_MODULE_1__["serialize"])(Object(stylis__WEBPACK_IMPORTED_MODULE_1__["compile"])("".concat(selector, "{").concat(styles, "}")), stylis__WEBPACK_IMPORTED_MODULE_1__["stringify"]);
  };

  var rules = stylis("#".concat(id), Object(_styles__WEBPACK_IMPORTED_MODULE_42__["default"])(graphType, userStyles, cnf.themeVariables));
  var style1 = document.createElement('style');
  style1.innerHTML = "#".concat(id, " ") + rules;
  svg.insertBefore(style1, firstChild); // Verify that the generated svgs are ok before removing this
  // const style2 = document.createElement('style');
  // const cs = window.getComputedStyle(svg);
  // style2.innerHTML = `#d${id} * {
  //   color: ${cs.color};
  //   // font: ${cs.font};
  //   // font-family: Arial;
  //   // font-size: 24px;
  // }`;
  // svg.insertBefore(style2, firstChild);

  try {
    switch (graphType) {
      case 'git':
        cnf.flowchart.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        _diagrams_git_gitGraphRenderer__WEBPACK_IMPORTED_MODULE_19__["default"].setConf(cnf.git);
        _diagrams_git_gitGraphRenderer__WEBPACK_IMPORTED_MODULE_19__["default"].draw(txt, id, false);
        break;

      case 'flowchart':
        cnf.flowchart.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        _diagrams_flowchart_flowRenderer__WEBPACK_IMPORTED_MODULE_12__["default"].setConf(cnf.flowchart);
        _diagrams_flowchart_flowRenderer__WEBPACK_IMPORTED_MODULE_12__["default"].draw(txt, id, false);
        break;

      case 'flowchart-v2':
        cnf.flowchart.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        _diagrams_flowchart_flowRenderer_v2__WEBPACK_IMPORTED_MODULE_13__["default"].setConf(cnf.flowchart);
        _diagrams_flowchart_flowRenderer_v2__WEBPACK_IMPORTED_MODULE_13__["default"].draw(txt, id, false);
        break;

      case 'sequence':
        cnf.sequence.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;

        if (cnf.sequenceDiagram) {
          // backwards compatibility
          _diagrams_sequence_sequenceRenderer__WEBPACK_IMPORTED_MODULE_32__["default"].setConf(Object.assign(cnf.sequence, cnf.sequenceDiagram));
          console.error('`mermaid config.sequenceDiagram` has been renamed to `config.sequence`. Please update your mermaid config.');
        } else {
          _diagrams_sequence_sequenceRenderer__WEBPACK_IMPORTED_MODULE_32__["default"].setConf(cnf.sequence);
        }

        _diagrams_sequence_sequenceRenderer__WEBPACK_IMPORTED_MODULE_32__["default"].draw(txt, id);
        break;

      case 'gantt':
        cnf.gantt.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        _diagrams_gantt_ganttRenderer__WEBPACK_IMPORTED_MODULE_16__["default"].setConf(cnf.gantt);
        _diagrams_gantt_ganttRenderer__WEBPACK_IMPORTED_MODULE_16__["default"].draw(txt, id);
        break;

      case 'class':
        cnf.class.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        _diagrams_class_classRenderer__WEBPACK_IMPORTED_MODULE_5__["default"].setConf(cnf.class);
        _diagrams_class_classRenderer__WEBPACK_IMPORTED_MODULE_5__["default"].draw(txt, id);
        break;

      case 'classDiagram':
        cnf.class.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        _diagrams_class_classRenderer_v2__WEBPACK_IMPORTED_MODULE_6__["default"].setConf(cnf.class);
        _diagrams_class_classRenderer_v2__WEBPACK_IMPORTED_MODULE_6__["default"].draw(txt, id);
        break;

      case 'state':
        cnf.class.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        _diagrams_state_stateRenderer__WEBPACK_IMPORTED_MODULE_35__["default"].setConf(cnf.state);
        _diagrams_state_stateRenderer__WEBPACK_IMPORTED_MODULE_35__["default"].draw(txt, id);
        break;

      case 'stateDiagram':
        cnf.class.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        _diagrams_state_stateRenderer_v2__WEBPACK_IMPORTED_MODULE_36__["default"].setConf(cnf.state);
        _diagrams_state_stateRenderer_v2__WEBPACK_IMPORTED_MODULE_36__["default"].draw(txt, id);
        break;

      case 'info':
        cnf.class.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        _diagrams_info_infoRenderer__WEBPACK_IMPORTED_MODULE_22__["default"].setConf(cnf.class);
        _diagrams_info_infoRenderer__WEBPACK_IMPORTED_MODULE_22__["default"].draw(txt, id, _package_json__WEBPACK_IMPORTED_MODULE_2__.version);
        break;

      case 'pie':
        //cnf.class.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        //pieRenderer.setConf(cnf.pie);
        _diagrams_pie_pieRenderer__WEBPACK_IMPORTED_MODULE_26__["default"].draw(txt, id, _package_json__WEBPACK_IMPORTED_MODULE_2__.version);
        break;

      case 'er':
        _diagrams_er_erRenderer__WEBPACK_IMPORTED_MODULE_9__["default"].setConf(cnf.er);
        _diagrams_er_erRenderer__WEBPACK_IMPORTED_MODULE_9__["default"].draw(txt, id, _package_json__WEBPACK_IMPORTED_MODULE_2__.version);
        break;

      case 'journey':
        _diagrams_user_journey_journeyRenderer__WEBPACK_IMPORTED_MODULE_38__["default"].setConf(cnf.journey);
        _diagrams_user_journey_journeyRenderer__WEBPACK_IMPORTED_MODULE_38__["default"].draw(txt, id, _package_json__WEBPACK_IMPORTED_MODULE_2__.version);
        break;

      case 'requirement':
        _diagrams_requirement_requirementRenderer__WEBPACK_IMPORTED_MODULE_29__["default"].setConf(cnf.requirement);
        _diagrams_requirement_requirementRenderer__WEBPACK_IMPORTED_MODULE_29__["default"].draw(txt, id, _package_json__WEBPACK_IMPORTED_MODULE_2__.version);
        break;
    }
  } catch (e) {
    // errorRenderer.setConf(cnf.class);
    _errorRenderer__WEBPACK_IMPORTED_MODULE_40__["default"].draw(id, _package_json__WEBPACK_IMPORTED_MODULE_2__.version);
    throw e;
  }

  Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])("[id=\"".concat(id, "\"]")).selectAll('foreignobject > *').attr('xmlns', 'http://www.w3.org/1999/xhtml'); // if (cnf.arrowMarkerAbsolute) {
  //   url =
  //     window.location.protocol +
  //     '//' +
  //     window.location.host +
  //     window.location.pathname +
  //     window.location.search;
  //   url = url.replace(/\(/g, '\\(');
  //   url = url.replace(/\)/g, '\\)');
  // }
  // Fix for when the base tag is used

  var svgCode = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('#d' + id).node().innerHTML;
  _logger__WEBPACK_IMPORTED_MODULE_41__["log"].debug('cnf.arrowMarkerAbsolute', cnf.arrowMarkerAbsolute);

  if (!cnf.arrowMarkerAbsolute || cnf.arrowMarkerAbsolute === 'false') {
    svgCode = svgCode.replace(/marker-end="url\(.*?#/g, 'marker-end="url(#', 'g');
  }

  svgCode = decodeEntities(svgCode); // Fix for when the br tag is used

  svgCode = svgCode.replace(/<br>/g, '<br/>');

  if (typeof cb !== 'undefined') {
    switch (graphType) {
      case 'flowchart':
      case 'flowchart-v2':
        cb(svgCode, _diagrams_flowchart_flowDb__WEBPACK_IMPORTED_MODULE_11__["default"].bindFunctions);
        break;

      case 'gantt':
        cb(svgCode, _diagrams_gantt_ganttDb__WEBPACK_IMPORTED_MODULE_15__["default"].bindFunctions);
        break;

      case 'class':
      case 'classDiagram':
        cb(svgCode, _diagrams_class_classDb__WEBPACK_IMPORTED_MODULE_4__["default"].bindFunctions);
        break;

      default:
        cb(svgCode);
    }
  } else {
    _logger__WEBPACK_IMPORTED_MODULE_41__["log"].debug('CB = undefined!');
  }

  var node = Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('#d' + id).node();

  if (node !== null && typeof node.remove === 'function') {
    Object(d3__WEBPACK_IMPORTED_MODULE_0__["select"])('#d' + id).node().remove();
  }

  return svgCode;
};

var currentDirective = {};

var parseDirective = function parseDirective(p, statement, context, type) {
  try {
    if (statement !== undefined) {
      statement = statement.trim();

      switch (context) {
        case 'open_directive':
          currentDirective = {};
          break;

        case 'type_directive':
          currentDirective.type = statement.toLowerCase();
          break;

        case 'arg_directive':
          currentDirective.args = JSON.parse(statement);
          break;

        case 'close_directive':
          handleDirective(p, currentDirective, type);
          currentDirective = null;
          break;
      }
    }
  } catch (error) {
    _logger__WEBPACK_IMPORTED_MODULE_41__["log"].error("Error while rendering sequenceDiagram directive: ".concat(statement, " jison context: ").concat(context));
    _logger__WEBPACK_IMPORTED_MODULE_41__["log"].error(error.message);
  }
};

var handleDirective = function handleDirective(p, directive, type) {
  _logger__WEBPACK_IMPORTED_MODULE_41__["log"].debug("Directive type=".concat(directive.type, " with args:"), directive.args);

  switch (directive.type) {
    case 'init':
    case 'initialize':
      {
        ['config'].forEach(function (prop) {
          if (typeof directive.args[prop] !== 'undefined') {
            if (type === 'flowchart-v2') {
              type = 'flowchart';
            }

            directive.args[type] = directive.args[prop];
            delete directive.args[prop];
          }
        });
        _logger__WEBPACK_IMPORTED_MODULE_41__["log"].debug('sanitize in handleDirective', directive.args);
        Object(_utils__WEBPACK_IMPORTED_MODULE_44__["directiveSanitizer"])(directive.args);
        _logger__WEBPACK_IMPORTED_MODULE_41__["log"].debug('sanitize in handleDirective (done)', directive.args);
        reinitialize(directive.args);
        _config__WEBPACK_IMPORTED_MODULE_3__["addDirective"](directive.args);
        break;
      }

    case 'wrap':
    case 'nowrap':
      if (p && p['setWrap']) {
        p.setWrap(directive.type === 'wrap');
      }

      break;

    default:
      _logger__WEBPACK_IMPORTED_MODULE_41__["log"].warn("Unhandled directive: source: '%%{".concat(directive.type, ": ").concat(JSON.stringify(directive.args ? directive.args : {}), "}%%"), directive);
      break;
  }
};

function updateRendererConfigs(conf) {
  // Todo remove, all diagrams should get config on demoand from the config object, no need for this
  _diagrams_git_gitGraphRenderer__WEBPACK_IMPORTED_MODULE_19__["default"].setConf(conf.git);
  _diagrams_flowchart_flowRenderer__WEBPACK_IMPORTED_MODULE_12__["default"].setConf(conf.flowchart);
  _diagrams_flowchart_flowRenderer_v2__WEBPACK_IMPORTED_MODULE_13__["default"].setConf(conf.flowchart);

  if (typeof conf['sequenceDiagram'] !== 'undefined') {
    _diagrams_sequence_sequenceRenderer__WEBPACK_IMPORTED_MODULE_32__["default"].setConf(Object(_utils__WEBPACK_IMPORTED_MODULE_44__["assignWithDepth"])(conf.sequence, conf['sequenceDiagram']));
  }

  _diagrams_sequence_sequenceRenderer__WEBPACK_IMPORTED_MODULE_32__["default"].setConf(conf.sequence);
  _diagrams_gantt_ganttRenderer__WEBPACK_IMPORTED_MODULE_16__["default"].setConf(conf.gantt);
  _diagrams_class_classRenderer__WEBPACK_IMPORTED_MODULE_5__["default"].setConf(conf.class);
  _diagrams_state_stateRenderer__WEBPACK_IMPORTED_MODULE_35__["default"].setConf(conf.state);
  _diagrams_state_stateRenderer_v2__WEBPACK_IMPORTED_MODULE_36__["default"].setConf(conf.state);
  _diagrams_info_infoRenderer__WEBPACK_IMPORTED_MODULE_22__["default"].setConf(conf.class); // pieRenderer.setConf(conf.class);

  _diagrams_er_erRenderer__WEBPACK_IMPORTED_MODULE_9__["default"].setConf(conf.er);
  _diagrams_user_journey_journeyRenderer__WEBPACK_IMPORTED_MODULE_38__["default"].setConf(conf.journey);
  _diagrams_requirement_requirementRenderer__WEBPACK_IMPORTED_MODULE_29__["default"].setConf(conf.requirement);
  _errorRenderer__WEBPACK_IMPORTED_MODULE_40__["default"].setConf(conf.class);
}

function reinitialize() {// `mermaidAPI.reinitialize: v${pkg.version}`,
  //   JSON.stringify(options),
  //   options.themeVariables.primaryColor;
  // // if (options.theme && theme[options.theme]) {
  // //   options.themeVariables = theme[options.theme].getThemeVariables(options.themeVariables);
  // // }
  // // Set default options
  // const config =
  //   typeof options === 'object' ? configApi.setConfig(options) : configApi.getSiteConfig();
  // updateRendererConfigs(config);
  // setLogLevel(config.logLevel);
  // log.debug('mermaidAPI.reinitialize: ', config);
}

function initialize(options) {
  // console.warn(`mermaidAPI.initialize: v${pkg.version} `, options);
  // Handle legacy location of font-family configuration
  if (options && options.fontFamily) {
    if (!options.themeVariables) {
      options.themeVariables = {
        fontFamily: options.fontFamily
      };
    } else {
      if (!options.themeVariables.fontFamily) {
        options.themeVariables = {
          fontFamily: options.fontFamily
        };
      }
    }
  } // Set default options


  _config__WEBPACK_IMPORTED_MODULE_3__["saveConfigFromInitilize"](options);

  if (options && options.theme && _themes__WEBPACK_IMPORTED_MODULE_43__["default"][options.theme]) {
    // Todo merge with user options
    options.themeVariables = _themes__WEBPACK_IMPORTED_MODULE_43__["default"][options.theme].getThemeVariables(options.themeVariables);
  } else {
    if (options) options.themeVariables = _themes__WEBPACK_IMPORTED_MODULE_43__["default"].default.getThemeVariables(options.themeVariables);
  }

  var config = _typeof(options) === 'object' ? _config__WEBPACK_IMPORTED_MODULE_3__["setSiteConfig"](options) : _config__WEBPACK_IMPORTED_MODULE_3__["getSiteConfig"]();
  updateRendererConfigs(config);
  Object(_logger__WEBPACK_IMPORTED_MODULE_41__["setLogLevel"])(config.logLevel); // log.debug('mermaidAPI.initialize: ', config);
}

var mermaidAPI = Object.freeze({
  render: render,
  parse: parse,
  parseDirective: parseDirective,
  initialize: initialize,
  reinitialize: reinitialize,
  getConfig: _config__WEBPACK_IMPORTED_MODULE_3__["getConfig"],
  setConfig: _config__WEBPACK_IMPORTED_MODULE_3__["setConfig"],
  getSiteConfig: _config__WEBPACK_IMPORTED_MODULE_3__["getSiteConfig"],
  updateSiteConfig: _config__WEBPACK_IMPORTED_MODULE_3__["updateSiteConfig"],
  reset: function reset() {
    // console.warn('reset');
    _config__WEBPACK_IMPORTED_MODULE_3__["reset"](); // const siteConfig = configApi.getSiteConfig();
    // updateRendererConfigs(siteConfig);
  },
  globalReset: function globalReset() {
    _config__WEBPACK_IMPORTED_MODULE_3__["reset"](_config__WEBPACK_IMPORTED_MODULE_3__["defaultConfig"]);
    updateRendererConfigs(_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"]());
  },
  defaultConfig: _config__WEBPACK_IMPORTED_MODULE_3__["defaultConfig"]
});
Object(_logger__WEBPACK_IMPORTED_MODULE_41__["setLogLevel"])(_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"]().logLevel);
_config__WEBPACK_IMPORTED_MODULE_3__["reset"](_config__WEBPACK_IMPORTED_MODULE_3__["getConfig"]());
/* harmony default export */ __webpack_exports__["default"] = (mermaidAPI);
/**
 * ## mermaidAPI configuration defaults
 *
 * ```html
 * <script>
 *   var config = {
 *     theme:'default',
 *     logLevel:'fatal',
 *     securityLevel:'strict',
 *     startOnLoad:true,
 *     arrowMarkerAbsolute:false,
 *
 *     er:{
 *       diagramPadding:20,
 *       layoutDirection:'TB',
 *       minEntityWidth:100,
 *       minEntityHeight:75,
 *       entityPadding:15,
 *       stroke:'gray',
 *       fill:'honeydew',
 *       fontSize:12,
 *       useMaxWidth:true,
 *     },
 *     flowchart:{
 *       diagramPadding:8,
 *       htmlLabels:true,
 *       curve:'basis',
 *     },
 *     sequence:{
 *       diagramMarginX:50,
 *       diagramMarginY:10,
 *       actorMargin:50,
 *       width:150,
 *       height:65,
 *       boxMargin:10,
 *       boxTextMargin:5,
 *       noteMargin:10,
 *       messageMargin:35,
 *       messageAlign:'center',
 *       mirrorActors:true,
 *       bottomMarginAdj:1,
 *       useMaxWidth:true,
 *       rightAngles:false,
 *       showSequenceNumbers:false,
 *     },
 *     gantt:{
 *       titleTopMargin:25,
 *       barHeight:20,
 *       barGap:4,
 *       topPadding:50,
 *       leftPadding:75,
 *       gridLineStartPadding:35,
 *       fontSize:11,
 *       fontFamily:'"Open-Sans", "sans-serif"',
 *       numberSectionStyles:4,
 *       axisFormat:'%Y-%m-%d',
 *       topAxis:false,
 *     }
 *   };
 *   mermaid.initialize(config);
 * </script>
 * ```
 */

/***/ }),

/***/ "./src/styles.js":
/*!***********************!*\
  !*** ./src/styles.js ***!
  \***********************/
/*! exports provided: calcThemeVariables, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calcThemeVariables", function() { return calcThemeVariables; });
/* harmony import */ var _diagrams_class_styles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diagrams/class/styles */ "./src/diagrams/class/styles.js");
/* harmony import */ var _diagrams_er_styles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diagrams/er/styles */ "./src/diagrams/er/styles.js");
/* harmony import */ var _diagrams_flowchart_styles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./diagrams/flowchart/styles */ "./src/diagrams/flowchart/styles.js");
/* harmony import */ var _diagrams_gantt_styles__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./diagrams/gantt/styles */ "./src/diagrams/gantt/styles.js");
/* harmony import */ var _diagrams_git_styles__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./diagrams/git/styles */ "./src/diagrams/git/styles.js");
/* harmony import */ var _diagrams_info_styles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./diagrams/info/styles */ "./src/diagrams/info/styles.js");
/* harmony import */ var _diagrams_pie_styles__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./diagrams/pie/styles */ "./src/diagrams/pie/styles.js");
/* harmony import */ var _diagrams_requirement_styles__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./diagrams/requirement/styles */ "./src/diagrams/requirement/styles.js");
/* harmony import */ var _diagrams_sequence_styles__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./diagrams/sequence/styles */ "./src/diagrams/sequence/styles.js");
/* harmony import */ var _diagrams_state_styles__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./diagrams/state/styles */ "./src/diagrams/state/styles.js");
/* harmony import */ var _diagrams_user_journey_styles__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./diagrams/user-journey/styles */ "./src/diagrams/user-journey/styles.js");











var themes = {
  flowchart: _diagrams_flowchart_styles__WEBPACK_IMPORTED_MODULE_2__["default"],
  'flowchart-v2': _diagrams_flowchart_styles__WEBPACK_IMPORTED_MODULE_2__["default"],
  sequence: _diagrams_sequence_styles__WEBPACK_IMPORTED_MODULE_8__["default"],
  gantt: _diagrams_gantt_styles__WEBPACK_IMPORTED_MODULE_3__["default"],
  classDiagram: _diagrams_class_styles__WEBPACK_IMPORTED_MODULE_0__["default"],
  'classDiagram-v2': _diagrams_class_styles__WEBPACK_IMPORTED_MODULE_0__["default"],
  class: _diagrams_class_styles__WEBPACK_IMPORTED_MODULE_0__["default"],
  stateDiagram: _diagrams_state_styles__WEBPACK_IMPORTED_MODULE_9__["default"],
  state: _diagrams_state_styles__WEBPACK_IMPORTED_MODULE_9__["default"],
  git: _diagrams_git_styles__WEBPACK_IMPORTED_MODULE_4__["default"],
  info: _diagrams_info_styles__WEBPACK_IMPORTED_MODULE_5__["default"],
  pie: _diagrams_pie_styles__WEBPACK_IMPORTED_MODULE_6__["default"],
  er: _diagrams_er_styles__WEBPACK_IMPORTED_MODULE_1__["default"],
  journey: _diagrams_user_journey_styles__WEBPACK_IMPORTED_MODULE_10__["default"],
  requirement: _diagrams_requirement_styles__WEBPACK_IMPORTED_MODULE_7__["default"]
};
var calcThemeVariables = function calcThemeVariables(theme, userOverRides) {
  return theme.calcColors(userOverRides);
};

var getStyles = function getStyles(type, userStyles, options) {
  //console.warn('options in styles: ', options);
  return " {\n    font-family: ".concat(options.fontFamily, ";\n    font-size: ").concat(options.fontSize, ";\n    fill: ").concat(options.textColor, "\n  }\n\n  /* Classes common for multiple diagrams */\n\n  .error-icon {\n    fill: ").concat(options.errorBkgColor, ";\n  }\n  .error-text {\n    fill: ").concat(options.errorTextColor, ";\n    stroke: ").concat(options.errorTextColor, ";\n  }\n\n  .edge-thickness-normal {\n    stroke-width: 2px;\n  }\n  .edge-thickness-thick {\n    stroke-width: 3.5px\n  }\n  .edge-pattern-solid {\n    stroke-dasharray: 0;\n  }\n\n  .edge-pattern-dashed{\n    stroke-dasharray: 3;\n  }\n  .edge-pattern-dotted {\n    stroke-dasharray: 2;\n  }\n\n  .marker {\n    fill: ").concat(options.lineColor, ";\n    stroke: ").concat(options.lineColor, ";\n  }\n  .marker.cross {\n    stroke: ").concat(options.lineColor, ";\n  }\n\n  svg {\n    font-family: ").concat(options.fontFamily, ";\n    font-size: ").concat(options.fontSize, ";\n  }\n\n  ").concat(themes[type](options), "\n\n  ").concat(userStyles, "\n");
};

/* harmony default export */ __webpack_exports__["default"] = (getStyles);

/***/ }),

/***/ "./src/themes/index.js":
/*!*****************************!*\
  !*** ./src/themes/index.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _theme_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./theme-base */ "./src/themes/theme-base.js");
/* harmony import */ var _theme_dark__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./theme-dark */ "./src/themes/theme-dark.js");
/* harmony import */ var _theme_default__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./theme-default */ "./src/themes/theme-default.js");
/* harmony import */ var _theme_forest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./theme-forest */ "./src/themes/theme-forest.js");
/* harmony import */ var _theme_neutral__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./theme-neutral */ "./src/themes/theme-neutral.js");





/* harmony default export */ __webpack_exports__["default"] = ({
  base: {
    getThemeVariables: _theme_base__WEBPACK_IMPORTED_MODULE_0__["getThemeVariables"]
  },
  dark: {
    getThemeVariables: _theme_dark__WEBPACK_IMPORTED_MODULE_1__["getThemeVariables"]
  },
  default: {
    getThemeVariables: _theme_default__WEBPACK_IMPORTED_MODULE_2__["getThemeVariables"]
  },
  forest: {
    getThemeVariables: _theme_forest__WEBPACK_IMPORTED_MODULE_3__["getThemeVariables"]
  },
  neutral: {
    getThemeVariables: _theme_neutral__WEBPACK_IMPORTED_MODULE_4__["getThemeVariables"]
  }
});

/***/ }),

/***/ "./src/themes/theme-base.js":
/*!**********************************!*\
  !*** ./src/themes/theme-base.js ***!
  \**********************************/
/*! exports provided: getThemeVariables */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getThemeVariables", function() { return getThemeVariables; });
/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! khroma */ "khroma");
/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(khroma__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _theme_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./theme-helpers */ "./src/themes/theme-helpers.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var Theme = /*#__PURE__*/function () {
  function Theme() {
    _classCallCheck(this, Theme);

    /** # Base variables */

    /** * background - used to know what the background color is of the diagram. This is used for deducing colors for istance line color. Defaulr value is #f4f4f4. */
    this.background = '#f4f4f4';
    this.darkMode = false; // this.background = '#0c0c0c';
    // this.darkMode = true;

    this.primaryColor = '#fff4dd'; // this.background = '#0c0c0c';
    // this.primaryColor = '#1f1f00';

    this.noteBkgColor = '#fff5ad';
    this.noteTextColor = '#333'; // dark
    // this.primaryColor = '#034694';
    // this.primaryColor = '#f2ee7e';
    // this.primaryColor = '#9f33be';
    // this.primaryColor = '#f0fff0';
    // this.primaryColor = '#fa255e';
    // this.primaryColor = '#ECECFF';
    // this.secondaryColor = '#c39ea0';
    // this.tertiaryColor = '#f8e5e5';
    // this.secondaryColor = '#dfdfde';
    // this.tertiaryColor = '#CCCCFF';

    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = '16px'; // this.updateColors();
  }

  _createClass(Theme, [{
    key: "updateColors",
    value: function updateColors() {
      // The || is to make sure that if the variable has been defiend by a user override that value is to be used

      /* Main */
      this.primaryTextColor = this.primaryTextColor || (this.darkMode ? '#ddd' : '#333'); // invert(this.primaryColor);

      this.secondaryColor = this.secondaryColor || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: -120
      });
      this.tertiaryColor = this.tertiaryColor || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: 180,
        l: 5
      });
      this.primaryBorderColor = this.primaryBorderColor || Object(_theme_helpers__WEBPACK_IMPORTED_MODULE_1__["mkBorder"])(this.primaryColor, this.darkMode);
      this.secondaryBorderColor = this.secondaryBorderColor || Object(_theme_helpers__WEBPACK_IMPORTED_MODULE_1__["mkBorder"])(this.secondaryColor, this.darkMode);
      this.tertiaryBorderColor = this.tertiaryBorderColor || Object(_theme_helpers__WEBPACK_IMPORTED_MODULE_1__["mkBorder"])(this.tertiaryColor, this.darkMode);
      this.noteBorderColor = this.noteBorderColor || Object(_theme_helpers__WEBPACK_IMPORTED_MODULE_1__["mkBorder"])(this.noteBkgColor, this.darkMode);
      this.noteBkgColor = this.noteBkgColor || '#fff5ad';
      this.noteTextColor = this.noteTextColor || '#333';
      this.secondaryTextColor = this.secondaryTextColor || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.secondaryColor);
      this.tertiaryTextColor = this.tertiaryTextColor || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.tertiaryColor);
      this.lineColor = this.lineColor || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.background);
      this.textColor = this.textColor || this.primaryTextColor;
      /* Flowchart variables */

      this.nodeBkg = this.nodeBkg || this.primaryColor;
      this.mainBkg = this.mainBkg || this.primaryColor;
      this.nodeBorder = this.nodeBorder || this.primaryBorderColor;
      this.clusterBkg = this.clusterBkg || this.tertiaryColor;
      this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor;
      this.defaultLinkColor = this.defaultLinkColor || this.lineColor;
      this.titleColor = this.titleColor || this.tertiaryTextColor;
      this.edgeLabelBackground = this.edgeLabelBackground || (this.darkMode ? Object(khroma__WEBPACK_IMPORTED_MODULE_0__["darken"])(this.secondaryColor, 30) : this.secondaryColor);
      this.nodeTextColor = this.nodeTextColor || this.primaryTextColor;
      /* Sequence Diagram variables */
      // this.actorBorder = lighten(this.border1, 0.5);

      this.actorBorder = this.actorBorder || this.primaryBorderColor;
      this.actorBkg = this.actorBkg || this.mainBkg;
      this.actorTextColor = this.actorTextColor || this.primaryTextColor;
      this.actorLineColor = this.actorLineColor || 'grey';
      this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg;
      this.signalColor = this.signalColor || this.textColor;
      this.signalTextColor = this.signalTextColor || this.textColor;
      this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder;
      this.labelTextColor = this.labelTextColor || this.actorTextColor;
      this.loopTextColor = this.loopTextColor || this.actorTextColor;
      this.activationBorderColor = this.activationBorderColor || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["darken"])(this.secondaryColor, 10);
      this.activationBkgColor = this.activationBkgColor || this.secondaryColor;
      this.sequenceNumberColor = this.sequenceNumberColor || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.lineColor);
      /* Gantt chart variables */

      this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor;
      this.altSectionBkgColor = this.altSectionBkgColor || 'white';
      this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor;
      this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor;
      this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor;
      this.taskBkgColor = this.taskBkgColor || this.primaryColor;
      this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor;
      this.activeTaskBkgColor = this.activeTaskBkgColor || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["lighten"])(this.primaryColor, 23);
      this.gridColor = this.gridColor || 'lightgrey';
      this.doneTaskBkgColor = this.doneTaskBkgColor || 'lightgrey';
      this.doneTaskBorderColor = this.doneTaskBorderColor || 'grey';
      this.critBorderColor = this.critBorderColor || '#ff8888';
      this.critBkgColor = this.critBkgColor || 'red';
      this.todayLineColor = this.todayLineColor || 'red';
      this.taskTextColor = this.taskTextColor || this.textColor;
      this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor;
      this.taskTextLightColor = this.taskTextLightColor || this.textColor;
      this.taskTextColor = this.taskTextColor || this.primaryTextColor;
      this.taskTextDarkColor = this.taskTextDarkColor || this.textColor;
      this.taskTextClickableColor = this.taskTextClickableColor || '#003163';
      /* state colors */

      this.transitionColor = this.transitionColor || this.lineColor;
      this.transitionLabelColor = this.transitionLabelColor || this.textColor;
      /* The color of the text tables of the tstates*/

      this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
      this.stateBkg = this.stateBkg || this.mainBkg;
      this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
      this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
      this.altBackground = this.altBackground || this.tertiaryColor;
      this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
      this.compositeBorder = this.compositeBorder || this.nodeBorder;
      this.innerEndBackground = this.nodeBorder;
      this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
      this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
      this.transitionColor = this.transitionColor || this.lineColor;
      this.specialStateColor = this.lineColor;
      /* class */

      this.classText = this.classText || this.textColor;
      /* user-journey */

      this.fillType0 = this.fillType0 || this.primaryColor;
      this.fillType1 = this.fillType1 || this.secondaryColor;
      this.fillType2 = this.fillType2 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: 64
      });
      this.fillType3 = this.fillType3 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        h: 64
      });
      this.fillType4 = this.fillType4 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: -64
      });
      this.fillType5 = this.fillType5 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        h: -64
      });
      this.fillType6 = this.fillType6 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: 128
      });
      this.fillType7 = this.fillType7 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        h: 128
      });
      /* pie */

      this.pie1 = this.pie1 || this.primaryColor;
      this.pie2 = this.pie2 || this.secondaryColor;
      this.pie3 = this.pie3 || this.tertiaryColor;
      this.pie4 = this.pie4 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        l: -10
      });
      this.pie5 = this.pie5 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        l: -10
      });
      this.pie6 = this.pie6 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.tertiaryColor, {
        l: -10
      });
      this.pie7 = this.pie7 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: +60,
        l: -10
      });
      this.pie8 = this.pie8 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: -60,
        l: -10
      });
      this.pie9 = this.pie9 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: 120,
        l: 0
      });
      this.pie10 = this.pie10 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: +60,
        l: -20
      });
      this.pie11 = this.pie11 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: -60,
        l: -20
      });
      this.pie12 = this.pie12 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: 120,
        l: -10
      });
      this.pieTitleTextSize = this.pieTitleTextSize || '25px';
      this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
      this.pieSectionTextSize = this.pieSectionTextSize || '17px';
      this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
      this.pieLegendTextSize = this.pieLegendTextSize || '17px';
      this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
      this.pieStrokeColor = this.pieStrokeColor || 'black';
      this.pieStrokeWidth = this.pieStrokeWidth || '2px';
      this.pieOpacity = this.pieOpacity || '0.7';
      /* requirement-diagram */

      this.requirementBackground = this.requirementBackground || this.primaryColor;
      this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
      this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
      this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
      this.relationColor = this.relationColor || this.lineColor;
      this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? Object(khroma__WEBPACK_IMPORTED_MODULE_0__["darken"])(this.secondaryColor, 30) : this.secondaryColor);
      this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    }
  }, {
    key: "calculate",
    value: function calculate(overrides) {
      var _this = this;

      if (_typeof(overrides) !== 'object') {
        // Calculate colors form base colors
        this.updateColors();
        return;
      }

      var keys = Object.keys(overrides); // Copy values from overrides, this is mainly for base colors

      keys.forEach(function (k) {
        _this[k] = overrides[k];
      }); // Calculate colors form base colors

      this.updateColors(); // Copy values from overrides again in case of an override of derived value

      keys.forEach(function (k) {
        _this[k] = overrides[k];
      });
    }
  }]);

  return Theme;
}();

var getThemeVariables = function getThemeVariables(userOverrides) {
  var theme = new Theme();
  theme.calculate(userOverrides);
  return theme;
};

/***/ }),

/***/ "./src/themes/theme-dark.js":
/*!**********************************!*\
  !*** ./src/themes/theme-dark.js ***!
  \**********************************/
/*! exports provided: getThemeVariables */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getThemeVariables", function() { return getThemeVariables; });
/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! khroma */ "khroma");
/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(khroma__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _theme_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./theme-helpers */ "./src/themes/theme-helpers.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var Theme = /*#__PURE__*/function () {
  function Theme() {
    _classCallCheck(this, Theme);

    this.background = '#333';
    this.primaryColor = '#1f2020';
    this.secondaryColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["lighten"])(this.primaryColor, 16);
    this.tertiaryColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
      h: -160
    });
    this.primaryBorderColor = Object(_theme_helpers__WEBPACK_IMPORTED_MODULE_1__["mkBorder"])(this.primaryColor, this.darkMode);
    this.secondaryBorderColor = Object(_theme_helpers__WEBPACK_IMPORTED_MODULE_1__["mkBorder"])(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = Object(_theme_helpers__WEBPACK_IMPORTED_MODULE_1__["mkBorder"])(this.tertiaryColor, this.darkMode);
    this.primaryTextColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.primaryColor);
    this.secondaryTextColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.secondaryColor);
    this.tertiaryTextColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.tertiaryColor);
    this.lineColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.background);
    this.textColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.background);
    this.mainBkg = '#1f2020';
    this.secondBkg = 'calculated';
    this.mainContrastColor = 'lightgrey';
    this.darkTextColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["lighten"])(Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])('#323D47'), 10);
    this.lineColor = 'calculated';
    this.border1 = '#81B1DB';
    this.border2 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["rgba"])(255, 255, 255, 0.25);
    this.arrowheadColor = 'calculated';
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = '16px';
    this.labelBackground = '#181818';
    this.textColor = '#ccc';
    /* Flowchart variables */

    this.nodeBkg = 'calculated';
    this.nodeBorder = 'calculated';
    this.clusterBkg = 'calculated';
    this.clusterBorder = 'calculated';
    this.defaultLinkColor = 'calculated';
    this.titleColor = '#F9FFFE';
    this.edgeLabelBackground = 'calculated';
    /* Sequence Diagram variables */

    this.actorBorder = 'calculated';
    this.actorBkg = 'calculated';
    this.actorTextColor = 'calculated';
    this.actorLineColor = 'calculated';
    this.signalColor = 'calculated';
    this.signalTextColor = 'calculated';
    this.labelBoxBkgColor = 'calculated';
    this.labelBoxBorderColor = 'calculated';
    this.labelTextColor = 'calculated';
    this.loopTextColor = 'calculated';
    this.noteBorderColor = 'calculated';
    this.noteBkgColor = '#fff5ad';
    this.noteTextColor = 'calculated';
    this.activationBorderColor = 'calculated';
    this.activationBkgColor = 'calculated';
    this.sequenceNumberColor = 'black';
    /* Gantt chart variables */

    this.sectionBkgColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["darken"])('#EAE8D9', 30);
    this.altSectionBkgColor = 'calculated';
    this.sectionBkgColor2 = '#EAE8D9';
    this.taskBorderColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["rgba"])(255, 255, 255, 70);
    this.taskBkgColor = 'calculated';
    this.taskTextColor = 'calculated';
    this.taskTextLightColor = 'calculated';
    this.taskTextOutsideColor = 'calculated';
    this.taskTextClickableColor = '#003163';
    this.activeTaskBorderColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["rgba"])(255, 255, 255, 50);
    this.activeTaskBkgColor = '#81B1DB';
    this.gridColor = 'calculated';
    this.doneTaskBkgColor = 'calculated';
    this.doneTaskBorderColor = 'grey';
    this.critBorderColor = '#E83737';
    this.critBkgColor = '#E83737';
    this.taskTextDarkColor = 'calculated';
    this.todayLineColor = '#DB5757';
    /* state colors */

    this.labelColor = 'calculated';
    this.errorBkgColor = '#a44141';
    this.errorTextColor = '#ddd';
  }

  _createClass(Theme, [{
    key: "updateColors",
    value: function updateColors() {
      this.secondBkg = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["lighten"])(this.mainBkg, 16);
      this.lineColor = this.mainContrastColor;
      this.arrowheadColor = this.mainContrastColor;
      /* Flowchart variables */

      this.nodeBkg = this.mainBkg;
      this.nodeBorder = this.border1;
      this.clusterBkg = this.secondBkg;
      this.clusterBorder = this.border2;
      this.defaultLinkColor = this.lineColor;
      this.edgeLabelBackground = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["lighten"])(this.labelBackground, 25);
      /* Sequence Diagram variables */

      this.actorBorder = this.border1;
      this.actorBkg = this.mainBkg;
      this.actorTextColor = this.mainContrastColor;
      this.actorLineColor = this.mainContrastColor;
      this.signalColor = this.mainContrastColor;
      this.signalTextColor = this.mainContrastColor;
      this.labelBoxBkgColor = this.actorBkg;
      this.labelBoxBorderColor = this.actorBorder;
      this.labelTextColor = this.mainContrastColor;
      this.loopTextColor = this.mainContrastColor;
      this.noteBorderColor = this.secondaryBorderColor;
      this.noteBkgColor = this.secondBkg;
      this.noteTextColor = this.secondaryTextColor;
      this.activationBorderColor = this.border1;
      this.activationBkgColor = this.secondBkg;
      /* Gantt chart variables */

      this.altSectionBkgColor = this.background;
      this.taskBkgColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["lighten"])(this.mainBkg, 23);
      this.taskTextColor = this.darkTextColor;
      this.taskTextLightColor = this.mainContrastColor;
      this.taskTextOutsideColor = this.taskTextLightColor;
      this.gridColor = this.mainContrastColor;
      this.doneTaskBkgColor = this.mainContrastColor;
      this.taskTextDarkColor = this.darkTextColor;
      /* state colors */

      this.transitionColor = this.transitionColor || this.lineColor;
      this.transitionLabelColor = this.transitionLabelColor || this.textColor;
      this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
      this.stateBkg = this.stateBkg || this.mainBkg;
      this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
      this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
      this.altBackground = this.altBackground || '#555';
      this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
      this.compositeBorder = this.compositeBorder || this.nodeBorder;
      this.innerEndBackground = this.primaryBorderColor;
      this.specialStateColor = '#f4f4f4'; // this.lineColor;

      this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
      this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
      this.fillType0 = this.primaryColor;
      this.fillType1 = this.secondaryColor;
      this.fillType2 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: 64
      });
      this.fillType3 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        h: 64
      });
      this.fillType4 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: -64
      });
      this.fillType5 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        h: -64
      });
      this.fillType6 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: 128
      });
      this.fillType7 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        h: 128
      });
      /* pie */

      this.pie1 = this.pie1 || '#0b0000';
      this.pie2 = this.pie2 || '#4d1037';
      this.pie3 = this.pie3 || '#3f5258';
      this.pie4 = this.pie4 || '#4f2f1b';
      this.pie5 = this.pie5 || '#6e0a0a';
      this.pie6 = this.pie6 || '#3b0048';
      this.pie7 = this.pie7 || '#995a01';
      this.pie8 = this.pie8 || '#154706';
      this.pie9 = this.pie9 || '#161722';
      this.pie10 = this.pie10 || '#00296f';
      this.pie11 = this.pie11 || '#01629c';
      this.pie12 = this.pie12 || '#010029';
      this.pieTitleTextSize = this.pieTitleTextSize || '25px';
      this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
      this.pieSectionTextSize = this.pieSectionTextSize || '17px';
      this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
      this.pieLegendTextSize = this.pieLegendTextSize || '17px';
      this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
      this.pieStrokeColor = this.pieStrokeColor || 'black';
      this.pieStrokeWidth = this.pieStrokeWidth || '2px';
      this.pieOpacity = this.pieOpacity || '0.7';
      /* class */

      this.classText = this.primaryTextColor;
      /* requirement-diagram */

      this.requirementBackground = this.requirementBackground || this.primaryColor;
      this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
      this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
      this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
      this.relationColor = this.relationColor || this.lineColor;
      this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? Object(khroma__WEBPACK_IMPORTED_MODULE_0__["darken"])(this.secondaryColor, 30) : this.secondaryColor);
      this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    }
  }, {
    key: "calculate",
    value: function calculate(overrides) {
      var _this = this;

      if (_typeof(overrides) !== 'object') {
        // Calculate colors form base colors
        this.updateColors();
        return;
      }

      var keys = Object.keys(overrides); // Copy values from overrides, this is mainly for base colors

      keys.forEach(function (k) {
        _this[k] = overrides[k];
      }); // Calculate colors form base colors

      this.updateColors(); // Copy values from overrides again in case of an override of derived value

      keys.forEach(function (k) {
        _this[k] = overrides[k];
      });
    }
  }]);

  return Theme;
}();

var getThemeVariables = function getThemeVariables(userOverrides) {
  var theme = new Theme();
  theme.calculate(userOverrides);
  return theme;
};

/***/ }),

/***/ "./src/themes/theme-default.js":
/*!*************************************!*\
  !*** ./src/themes/theme-default.js ***!
  \*************************************/
/*! exports provided: getThemeVariables */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getThemeVariables", function() { return getThemeVariables; });
/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! khroma */ "khroma");
/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(khroma__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _theme_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./theme-helpers */ "./src/themes/theme-helpers.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var Theme = /*#__PURE__*/function () {
  function Theme() {
    _classCallCheck(this, Theme);

    /* Base variables */
    this.background = '#f4f4f4';
    this.primaryColor = '#ECECFF';
    this.secondaryColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
      h: 120
    });
    this.secondaryColor = '#ffffde';
    this.tertiaryColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
      h: -160
    });
    this.primaryBorderColor = Object(_theme_helpers__WEBPACK_IMPORTED_MODULE_1__["mkBorder"])(this.primaryColor, this.darkMode);
    this.secondaryBorderColor = Object(_theme_helpers__WEBPACK_IMPORTED_MODULE_1__["mkBorder"])(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = Object(_theme_helpers__WEBPACK_IMPORTED_MODULE_1__["mkBorder"])(this.tertiaryColor, this.darkMode); // this.noteBorderColor = mkBorder(this.noteBkgColor, this.darkMode);

    this.primaryTextColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.primaryColor);
    this.secondaryTextColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.secondaryColor);
    this.tertiaryTextColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.tertiaryColor);
    this.lineColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.background);
    this.textColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.background);
    this.background = 'white';
    this.mainBkg = '#ECECFF';
    this.secondBkg = '#ffffde';
    this.lineColor = '#333333';
    this.border1 = '#9370DB';
    this.border2 = '#aaaa33';
    this.arrowheadColor = '#333333';
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = '16px';
    this.labelBackground = '#e8e8e8';
    this.textColor = '#333';
    /* Flowchart variables */

    this.nodeBkg = 'calculated';
    this.nodeBorder = 'calculated';
    this.clusterBkg = 'calculated';
    this.clusterBorder = 'calculated';
    this.defaultLinkColor = 'calculated';
    this.titleColor = 'calculated';
    this.edgeLabelBackground = 'calculated';
    /* Sequence Diagram variables */

    this.actorBorder = 'calculated';
    this.actorBkg = 'calculated';
    this.actorTextColor = 'black';
    this.actorLineColor = 'grey';
    this.signalColor = 'calculated';
    this.signalTextColor = 'calculated';
    this.labelBoxBkgColor = 'calculated';
    this.labelBoxBorderColor = 'calculated';
    this.labelTextColor = 'calculated';
    this.loopTextColor = 'calculated';
    this.noteBorderColor = 'calculated';
    this.noteBkgColor = '#fff5ad';
    this.noteTextColor = 'calculated';
    this.activationBorderColor = '#666';
    this.activationBkgColor = '#f4f4f4';
    this.sequenceNumberColor = 'white';
    /* Gantt chart variables */

    this.sectionBkgColor = 'calculated';
    this.altSectionBkgColor = 'calculated';
    this.sectionBkgColor2 = 'calculated';
    this.taskBorderColor = 'calculated';
    this.taskBkgColor = 'calculated';
    this.taskTextLightColor = 'calculated';
    this.taskTextColor = this.taskTextLightColor;
    this.taskTextDarkColor = 'calculated';
    this.taskTextOutsideColor = this.taskTextDarkColor;
    this.taskTextClickableColor = 'calculated';
    this.activeTaskBorderColor = 'calculated';
    this.activeTaskBkgColor = 'calculated';
    this.gridColor = 'calculated';
    this.doneTaskBkgColor = 'calculated';
    this.doneTaskBorderColor = 'calculated';
    this.critBorderColor = 'calculated';
    this.critBkgColor = 'calculated';
    this.todayLineColor = 'calculated';
    this.sectionBkgColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["rgba"])(102, 102, 255, 0.49);
    this.altSectionBkgColor = 'white';
    this.sectionBkgColor2 = '#fff400';
    this.taskBorderColor = '#534fbc';
    this.taskBkgColor = '#8a90dd';
    this.taskTextLightColor = 'white';
    this.taskTextColor = 'calculated';
    this.taskTextDarkColor = 'black';
    this.taskTextOutsideColor = 'calculated';
    this.taskTextClickableColor = '#003163';
    this.activeTaskBorderColor = '#534fbc';
    this.activeTaskBkgColor = '#bfc7ff';
    this.gridColor = 'lightgrey';
    this.doneTaskBkgColor = 'lightgrey';
    this.doneTaskBorderColor = 'grey';
    this.critBorderColor = '#ff8888';
    this.critBkgColor = 'red';
    this.todayLineColor = 'red';
    /* state colors */

    this.labelColor = 'black';
    this.errorBkgColor = '#552222';
    this.errorTextColor = '#552222';
    this.updateColors();
  }

  _createClass(Theme, [{
    key: "updateColors",
    value: function updateColors() {
      /* Flowchart variables */
      this.nodeBkg = this.mainBkg;
      this.nodeBorder = this.border1; // border 1

      this.clusterBkg = this.secondBkg;
      this.clusterBorder = this.border2;
      this.defaultLinkColor = this.lineColor;
      this.titleColor = this.textColor;
      this.edgeLabelBackground = this.labelBackground;
      /* Sequence Diagram variables */
      // this.actorBorder = lighten(this.border1, 0.5);

      this.actorBorder = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["lighten"])(this.border1, 23);
      this.actorBkg = this.mainBkg;
      this.labelBoxBkgColor = this.actorBkg;
      this.signalColor = this.textColor;
      this.signalTextColor = this.textColor;
      this.labelBoxBorderColor = this.actorBorder;
      this.labelTextColor = this.actorTextColor;
      this.loopTextColor = this.actorTextColor;
      this.noteBorderColor = this.border2;
      this.noteTextColor = this.actorTextColor;
      /* Gantt chart variables */

      this.taskTextColor = this.taskTextLightColor;
      this.taskTextOutsideColor = this.taskTextDarkColor;
      /* state colors */

      this.transitionColor = this.transitionColor || this.lineColor;
      this.transitionLabelColor = this.transitionLabelColor || this.textColor;
      this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
      this.stateBkg = this.stateBkg || this.mainBkg;
      this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
      this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
      this.altBackground = this.altBackground || '#f0f0f0';
      this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
      this.compositeBorder = this.compositeBorder || this.nodeBorder;
      this.innerEndBackground = this.nodeBorder;
      this.specialStateColor = this.lineColor;
      this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
      this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
      this.transitionColor = this.transitionColor || this.lineColor;
      /* class */

      this.classText = this.primaryTextColor;
      /* journey */

      this.fillType0 = this.primaryColor;
      this.fillType1 = this.secondaryColor;
      this.fillType2 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: 64
      });
      this.fillType3 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        h: 64
      });
      this.fillType4 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: -64
      });
      this.fillType5 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        h: -64
      });
      this.fillType6 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: 128
      });
      this.fillType7 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        h: 128
      });
      /* pie */

      this.pie1 = this.pie1 || this.primaryColor;
      this.pie2 = this.pie2 || this.secondaryColor;
      this.pie3 = this.pie3 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.tertiaryColor, {
        l: -40
      });
      this.pie4 = this.pie4 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        l: -10
      });
      this.pie5 = this.pie5 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        l: -30
      });
      this.pie6 = this.pie6 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.tertiaryColor, {
        l: -20
      });
      this.pie7 = this.pie7 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: +60,
        l: -20
      });
      this.pie8 = this.pie8 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: -60,
        l: -40
      });
      this.pie9 = this.pie9 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: 120,
        l: -40
      });
      this.pie10 = this.pie10 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: +60,
        l: -40
      });
      this.pie11 = this.pie11 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: -90,
        l: -40
      });
      this.pie12 = this.pie12 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: 120,
        l: -30
      });
      this.pieTitleTextSize = this.pieTitleTextSize || '25px';
      this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
      this.pieSectionTextSize = this.pieSectionTextSize || '17px';
      this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
      this.pieLegendTextSize = this.pieLegendTextSize || '17px';
      this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
      this.pieStrokeColor = this.pieStrokeColor || 'black';
      this.pieStrokeWidth = this.pieStrokeWidth || '2px';
      this.pieOpacity = this.pieOpacity || '0.7';
      /* requirement-diagram */

      this.requirementBackground = this.requirementBackground || this.primaryColor;
      this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
      this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
      this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
      this.relationColor = this.relationColor || this.lineColor;
      this.relationLabelBackground = this.relationLabelBackground || this.labelBackground;
      this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    }
  }, {
    key: "calculate",
    value: function calculate(overrides) {
      var _this = this;

      if (_typeof(overrides) !== 'object') {
        // Calculate colors form base colors
        this.updateColors();
        return;
      }

      var keys = Object.keys(overrides); // Copy values from overrides, this is mainly for base colors

      keys.forEach(function (k) {
        _this[k] = overrides[k];
      }); // Calculate colors form base colors

      this.updateColors(); // Copy values from overrides again in case of an override of derived value

      keys.forEach(function (k) {
        _this[k] = overrides[k];
      });
    }
  }]);

  return Theme;
}();

var getThemeVariables = function getThemeVariables(userOverrides) {
  var theme = new Theme();
  theme.calculate(userOverrides);
  return theme;
};

/***/ }),

/***/ "./src/themes/theme-forest.js":
/*!************************************!*\
  !*** ./src/themes/theme-forest.js ***!
  \************************************/
/*! exports provided: getThemeVariables */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getThemeVariables", function() { return getThemeVariables; });
/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! khroma */ "khroma");
/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(khroma__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _theme_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./theme-helpers */ "./src/themes/theme-helpers.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var Theme = /*#__PURE__*/function () {
  function Theme() {
    _classCallCheck(this, Theme);

    /* Base vales */
    this.background = '#f4f4f4';
    this.primaryColor = '#cde498';
    this.secondaryColor = '#cdffb2';
    this.background = 'white';
    this.mainBkg = '#cde498';
    this.secondBkg = '#cdffb2';
    this.lineColor = 'green';
    this.border1 = '#13540c';
    this.border2 = '#6eaa49';
    this.arrowheadColor = 'green';
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = '16px';
    this.tertiaryColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["lighten"])('#cde498', 10);
    this.primaryBorderColor = Object(_theme_helpers__WEBPACK_IMPORTED_MODULE_1__["mkBorder"])(this.primaryColor, this.darkMode);
    this.secondaryBorderColor = Object(_theme_helpers__WEBPACK_IMPORTED_MODULE_1__["mkBorder"])(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = Object(_theme_helpers__WEBPACK_IMPORTED_MODULE_1__["mkBorder"])(this.tertiaryColor, this.darkMode);
    this.primaryTextColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.primaryColor);
    this.secondaryTextColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.secondaryColor);
    this.tertiaryTextColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.primaryColor);
    this.lineColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.background);
    this.textColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.background);
    /* Flowchart variables */

    this.nodeBkg = 'calculated';
    this.nodeBorder = 'calculated';
    this.clusterBkg = 'calculated';
    this.clusterBorder = 'calculated';
    this.defaultLinkColor = 'calculated';
    this.titleColor = '#333';
    this.edgeLabelBackground = '#e8e8e8';
    /* Sequence Diagram variables */

    this.actorBorder = 'calculated';
    this.actorBkg = 'calculated';
    this.actorTextColor = 'black';
    this.actorLineColor = 'grey';
    this.signalColor = '#333';
    this.signalTextColor = '#333';
    this.labelBoxBkgColor = 'calculated';
    this.labelBoxBorderColor = '#326932';
    this.labelTextColor = 'calculated';
    this.loopTextColor = 'calculated';
    this.noteBorderColor = 'calculated';
    this.noteBkgColor = '#fff5ad';
    this.noteTextColor = 'calculated';
    this.activationBorderColor = '#666';
    this.activationBkgColor = '#f4f4f4';
    this.sequenceNumberColor = 'white';
    /* Gantt chart variables */

    this.sectionBkgColor = '#6eaa49';
    this.altSectionBkgColor = 'white';
    this.sectionBkgColor2 = '#6eaa49';
    this.taskBorderColor = 'calculated';
    this.taskBkgColor = '#487e3a';
    this.taskTextLightColor = 'white';
    this.taskTextColor = 'calculated';
    this.taskTextDarkColor = 'black';
    this.taskTextOutsideColor = 'calculated';
    this.taskTextClickableColor = '#003163';
    this.activeTaskBorderColor = 'calculated';
    this.activeTaskBkgColor = 'calculated';
    this.gridColor = 'lightgrey';
    this.doneTaskBkgColor = 'lightgrey';
    this.doneTaskBorderColor = 'grey';
    this.critBorderColor = '#ff8888';
    this.critBkgColor = 'red';
    this.todayLineColor = 'red';
    /* state colors */

    this.labelColor = 'black';
    this.errorBkgColor = '#552222';
    this.errorTextColor = '#552222';
  }

  _createClass(Theme, [{
    key: "updateColors",
    value: function updateColors() {
      /* Flowchart variables */
      this.nodeBkg = this.mainBkg;
      this.nodeBorder = this.border1;
      this.clusterBkg = this.secondBkg;
      this.clusterBorder = this.border2;
      this.defaultLinkColor = this.lineColor;
      /* Sequence Diagram variables */

      this.actorBorder = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["darken"])(this.mainBkg, 20);
      this.actorBkg = this.mainBkg;
      this.labelBoxBkgColor = this.actorBkg;
      this.labelTextColor = this.actorTextColor;
      this.loopTextColor = this.actorTextColor;
      this.noteBorderColor = this.border2;
      this.noteTextColor = this.actorTextColor;
      /* Gantt chart variables */

      this.taskBorderColor = this.border1;
      this.taskTextColor = this.taskTextLightColor;
      this.taskTextOutsideColor = this.taskTextDarkColor;
      this.activeTaskBorderColor = this.taskBorderColor;
      this.activeTaskBkgColor = this.mainBkg;
      /* state colors */

      this.transitionColor = this.transitionColor || this.lineColor;
      this.transitionLabelColor = this.transitionLabelColor || this.textColor;
      this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
      this.stateBkg = this.stateBkg || this.mainBkg;
      this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
      this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
      this.altBackground = this.altBackground || '#f0f0f0';
      this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
      this.compositeBorder = this.compositeBorder || this.nodeBorder;
      this.innerEndBackground = this.primaryBorderColor;
      this.specialStateColor = this.lineColor;
      this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
      this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
      this.transitionColor = this.transitionColor || this.lineColor;
      /* class */

      this.classText = this.primaryTextColor;
      /* journey */

      this.fillType0 = this.primaryColor;
      this.fillType1 = this.secondaryColor;
      this.fillType2 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: 64
      });
      this.fillType3 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        h: 64
      });
      this.fillType4 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: -64
      });
      this.fillType5 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        h: -64
      });
      this.fillType6 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: 128
      });
      this.fillType7 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        h: 128
      });
      /* pie */

      this.pie1 = this.pie1 || this.primaryColor;
      this.pie2 = this.pie2 || this.secondaryColor;
      this.pie3 = this.pie3 || this.tertiaryColor;
      this.pie4 = this.pie4 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        l: -30
      });
      this.pie5 = this.pie5 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        l: -30
      });
      this.pie6 = this.pie6 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.tertiaryColor, {
        h: +40,
        l: -40
      });
      this.pie7 = this.pie7 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: +60,
        l: -10
      });
      this.pie8 = this.pie8 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: -60,
        l: -10
      });
      this.pie9 = this.pie9 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: 120,
        l: 0
      });
      this.pie10 = this.pie10 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: +60,
        l: -50
      });
      this.pie11 = this.pie11 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: -60,
        l: -50
      });
      this.pie12 = this.pie12 || Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: 120,
        l: -50
      });
      this.pieTitleTextSize = this.pieTitleTextSize || '25px';
      this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
      this.pieSectionTextSize = this.pieSectionTextSize || '17px';
      this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
      this.pieLegendTextSize = this.pieLegendTextSize || '17px';
      this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
      this.pieStrokeColor = this.pieStrokeColor || 'black';
      this.pieStrokeWidth = this.pieStrokeWidth || '2px';
      this.pieOpacity = this.pieOpacity || '0.7';
      /* requirement-diagram */

      this.requirementBackground = this.requirementBackground || this.primaryColor;
      this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
      this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
      this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
      this.relationColor = this.relationColor || this.lineColor;
      this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground;
      this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    }
  }, {
    key: "calculate",
    value: function calculate(overrides) {
      var _this = this;

      if (_typeof(overrides) !== 'object') {
        // Calculate colors form base colors
        this.updateColors();
        return;
      }

      var keys = Object.keys(overrides); // Copy values from overrides, this is mainly for base colors

      keys.forEach(function (k) {
        _this[k] = overrides[k];
      }); // Calculate colors form base colors

      this.updateColors(); // Copy values from overrides again in case of an override of derived value

      keys.forEach(function (k) {
        _this[k] = overrides[k];
      });
    }
  }]);

  return Theme;
}();

var getThemeVariables = function getThemeVariables(userOverrides) {
  var theme = new Theme();
  theme.calculate(userOverrides);
  return theme;
};

/***/ }),

/***/ "./src/themes/theme-helpers.js":
/*!*************************************!*\
  !*** ./src/themes/theme-helpers.js ***!
  \*************************************/
/*! exports provided: mkBorder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mkBorder", function() { return mkBorder; });
/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! khroma */ "khroma");
/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(khroma__WEBPACK_IMPORTED_MODULE_0__);

var mkBorder = function mkBorder(col, darkMode) {
  return darkMode ? Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(col, {
    s: -40,
    l: 10
  }) : Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(col, {
    s: -40,
    l: -10
  });
};

/***/ }),

/***/ "./src/themes/theme-neutral.js":
/*!*************************************!*\
  !*** ./src/themes/theme-neutral.js ***!
  \*************************************/
/*! exports provided: getThemeVariables */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getThemeVariables", function() { return getThemeVariables; });
/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! khroma */ "khroma");
/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(khroma__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _theme_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./theme-helpers */ "./src/themes/theme-helpers.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


 // const Color = require ( 'khroma/dist/color' ).default
// Color.format.hex.stringify(Color.parse('hsl(210, 66.6666666667%, 95%)')); // => "#EAF2FB"

var Theme = /*#__PURE__*/function () {
  function Theme() {
    _classCallCheck(this, Theme);

    this.primaryColor = '#eee';
    this.contrast = '#707070';
    this.secondaryColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["lighten"])(this.contrast, 55);
    this.background = '#ffffff'; // this.secondaryColor = adjust(this.primaryColor, { h: 120 });

    this.tertiaryColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
      h: -160
    });
    this.primaryBorderColor = Object(_theme_helpers__WEBPACK_IMPORTED_MODULE_1__["mkBorder"])(this.primaryColor, this.darkMode);
    this.secondaryBorderColor = Object(_theme_helpers__WEBPACK_IMPORTED_MODULE_1__["mkBorder"])(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = Object(_theme_helpers__WEBPACK_IMPORTED_MODULE_1__["mkBorder"])(this.tertiaryColor, this.darkMode); // this.noteBorderColor = mkBorder(this.noteBkgColor, this.darkMode);

    this.primaryTextColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.primaryColor);
    this.secondaryTextColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.secondaryColor);
    this.tertiaryTextColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.tertiaryColor);
    this.lineColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.background);
    this.textColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["invert"])(this.background); // this.altBackground = lighten(this.contrast, 55);

    this.mainBkg = '#eee';
    this.secondBkg = 'calculated';
    this.lineColor = '#666';
    this.border1 = '#999';
    this.border2 = 'calculated';
    this.note = '#ffa';
    this.text = '#333';
    this.critical = '#d42';
    this.done = '#bbb';
    this.arrowheadColor = '#333333';
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = '16px';
    /* Flowchart variables */

    this.nodeBkg = 'calculated';
    this.nodeBorder = 'calculated';
    this.clusterBkg = 'calculated';
    this.clusterBorder = 'calculated';
    this.defaultLinkColor = 'calculated';
    this.titleColor = 'calculated';
    this.edgeLabelBackground = 'white';
    /* Sequence Diagram variables */

    this.actorBorder = 'calculated';
    this.actorBkg = 'calculated';
    this.actorTextColor = 'calculated';
    this.actorLineColor = 'calculated';
    this.signalColor = 'calculated';
    this.signalTextColor = 'calculated';
    this.labelBoxBkgColor = 'calculated';
    this.labelBoxBorderColor = 'calculated';
    this.labelTextColor = 'calculated';
    this.loopTextColor = 'calculated';
    this.noteBorderColor = 'calculated';
    this.noteBkgColor = 'calculated';
    this.noteTextColor = 'calculated';
    this.activationBorderColor = '#666';
    this.activationBkgColor = '#f4f4f4';
    this.sequenceNumberColor = 'white';
    /* Gantt chart variables */

    this.sectionBkgColor = 'calculated';
    this.altSectionBkgColor = 'white';
    this.sectionBkgColor2 = 'calculated';
    this.taskBorderColor = 'calculated';
    this.taskBkgColor = 'calculated';
    this.taskTextLightColor = 'white';
    this.taskTextColor = 'calculated';
    this.taskTextDarkColor = 'calculated';
    this.taskTextOutsideColor = 'calculated';
    this.taskTextClickableColor = '#003163';
    this.activeTaskBorderColor = 'calculated';
    this.activeTaskBkgColor = 'calculated';
    this.gridColor = 'calculated';
    this.doneTaskBkgColor = 'calculated';
    this.doneTaskBorderColor = 'calculated';
    this.critBkgColor = 'calculated';
    this.critBorderColor = 'calculated';
    this.todayLineColor = 'calculated';
    /* state colors */

    this.labelColor = 'black';
    this.errorBkgColor = '#552222';
    this.errorTextColor = '#552222';
  }

  _createClass(Theme, [{
    key: "updateColors",
    value: function updateColors() {
      this.secondBkg = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["lighten"])(this.contrast, 55);
      this.border2 = this.contrast;
      /* Flowchart variables */

      this.nodeBkg = this.mainBkg;
      this.nodeBorder = this.border1;
      this.clusterBkg = this.secondBkg;
      this.clusterBorder = this.border2;
      this.defaultLinkColor = this.lineColor;
      this.titleColor = this.text;
      /* Sequence Diagram variables */

      this.actorBorder = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["lighten"])(this.border1, 23);
      this.actorBkg = this.mainBkg;
      this.actorTextColor = this.text;
      this.actorLineColor = this.lineColor;
      this.signalColor = this.text;
      this.signalTextColor = this.text;
      this.labelBoxBkgColor = this.actorBkg;
      this.labelBoxBorderColor = this.actorBorder;
      this.labelTextColor = this.text;
      this.loopTextColor = this.text;
      this.noteBorderColor = '#999';
      this.noteBkgColor = '#666';
      this.noteTextColor = '#fff';
      /* Gantt chart variables */

      this.sectionBkgColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["lighten"])(this.contrast, 30);
      this.sectionBkgColor2 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["lighten"])(this.contrast, 30);
      this.taskBorderColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["darken"])(this.contrast, 10);
      this.taskBkgColor = this.contrast;
      this.taskTextColor = this.taskTextLightColor;
      this.taskTextDarkColor = this.text;
      this.taskTextOutsideColor = this.taskTextDarkColor;
      this.activeTaskBorderColor = this.taskBorderColor;
      this.activeTaskBkgColor = this.mainBkg;
      this.gridColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["lighten"])(this.border1, 30);
      this.doneTaskBkgColor = this.done;
      this.doneTaskBorderColor = this.lineColor;
      this.critBkgColor = this.critical;
      this.critBorderColor = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["darken"])(this.critBkgColor, 10);
      this.todayLineColor = this.critBkgColor;
      /* state colors */

      this.transitionColor = this.transitionColor || '#000';
      this.transitionLabelColor = this.transitionLabelColor || this.textColor;
      this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
      this.stateBkg = this.stateBkg || this.mainBkg;
      this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
      this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
      this.altBackground = this.altBackground || '#f4f4f4';
      this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
      this.stateBorder = this.stateBorder || '#000';
      this.innerEndBackground = this.primaryBorderColor;
      this.specialStateColor = '#222';
      this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
      this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
      /* class */

      this.classText = this.primaryTextColor;
      /* journey */

      this.fillType0 = this.primaryColor;
      this.fillType1 = this.secondaryColor;
      this.fillType2 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: 64
      });
      this.fillType3 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        h: 64
      });
      this.fillType4 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: -64
      });
      this.fillType5 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        h: -64
      });
      this.fillType6 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.primaryColor, {
        h: 128
      });
      this.fillType7 = Object(khroma__WEBPACK_IMPORTED_MODULE_0__["adjust"])(this.secondaryColor, {
        h: 128
      }); // /* pie */

      this.pie1 = this.pie1 || '#F4F4F4';
      this.pie2 = this.pie2 || '#555';
      this.pie3 = this.pie3 || '#BBB';
      this.pie4 = this.pie4 || '#777';
      this.pie5 = this.pie5 || '#999';
      this.pie6 = this.pie6 || '#DDD';
      this.pie7 = this.pie7 || '#FFF';
      this.pie8 = this.pie8 || '#DDD';
      this.pie9 = this.pie9 || '#BBB';
      this.pie10 = this.pie10 || '#999';
      this.pie11 = this.pie11 || '#777';
      this.pie12 = this.pie12 || '#555';
      this.pieTitleTextSize = this.pieTitleTextSize || '25px';
      this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
      this.pieSectionTextSize = this.pieSectionTextSize || '17px';
      this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
      this.pieLegendTextSize = this.pieLegendTextSize || '17px';
      this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
      this.pieStrokeColor = this.pieStrokeColor || 'black';
      this.pieStrokeWidth = this.pieStrokeWidth || '2px';
      this.pieOpacity = this.pieOpacity || '0.7'; // this.pie1 = this.pie1 || '#212529';
      // this.pie2 = this.pie2 || '#343A40';
      // this.pie3 = this.pie3 || '#495057';
      // this.pie4 = this.pie4 || '#6C757D';
      // this.pie5 = this.pie5 || adjust(this.secondaryColor, { l: -10 });
      // this.pie6 = this.pie6 || adjust(this.tertiaryColor, { l: -10 });
      // this.pie7 = this.pie7 || adjust(this.primaryColor, { h: +60, l: -10 });
      // this.pie8 = this.pie8 || adjust(this.primaryColor, { h: -60, l: -10 });
      // this.pie9 = this.pie9 || adjust(this.primaryColor, { h: 120, l: 0 });
      // this.pie10 = this.pie10 || adjust(this.primaryColor, { h: +60, l: -20 });
      // this.pie11 = this.pie11 || adjust(this.primaryColor, { h: -60, l: -20 });
      // this.pie12 = this.pie12 || adjust(this.primaryColor, { h: 120, l: -10 });

      /* requirement-diagram */

      this.requirementBackground = this.requirementBackground || this.primaryColor;
      this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
      this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
      this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
      this.relationColor = this.relationColor || this.lineColor;
      this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground;
      this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    }
  }, {
    key: "calculate",
    value: function calculate(overrides) {
      var _this = this;

      if (_typeof(overrides) !== 'object') {
        // Calculate colors form base colors
        this.updateColors();
        return;
      }

      var keys = Object.keys(overrides); // Copy values from overrides, this is mainly for base colors

      keys.forEach(function (k) {
        _this[k] = overrides[k];
      }); // Calculate colors form base colors

      this.updateColors(); // Copy values from overrides again in case of an override of derived value

      keys.forEach(function (k) {
        _this[k] = overrides[k];
      });
    }
  }]);

  return Theme;
}();

var getThemeVariables = function getThemeVariables(userOverrides) {
  var theme = new Theme();
  theme.calculate(userOverrides);
  return theme;
};

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! exports provided: detectInit, detectDirective, detectType, isSubstringInArray, interpolateToCurve, formatUrl, runFunc, getStylesFromArray, generateId, random, assignWithDepth, getTextObj, drawSimpleText, wrapLabel, calculateTextHeight, calculateTextWidth, calculateTextDimensions, calculateSvgSizeAttrs, configureSvgSize, initIdGeneratior, entityDecode, directiveSanitizer, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detectInit", function() { return detectInit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detectDirective", function() { return detectDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detectType", function() { return detectType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSubstringInArray", function() { return isSubstringInArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateToCurve", function() { return interpolateToCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatUrl", function() { return formatUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "runFunc", function() { return runFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStylesFromArray", function() { return getStylesFromArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateId", function() { return generateId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignWithDepth", function() { return assignWithDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTextObj", function() { return getTextObj; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawSimpleText", function() { return drawSimpleText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapLabel", function() { return wrapLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateTextHeight", function() { return calculateTextHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateTextWidth", function() { return calculateTextWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateTextDimensions", function() { return calculateTextDimensions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateSvgSizeAttrs", function() { return calculateSvgSizeAttrs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "configureSvgSize", function() { return configureSvgSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initIdGeneratior", function() { return initIdGeneratior; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "entityDecode", function() { return entityDecode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "directiveSanitizer", function() { return directiveSanitizer; });
/* harmony import */ var _braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @braintree/sanitize-url */ "@braintree/sanitize-url");
/* harmony import */ var _braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _diagrams_common_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./diagrams/common/common */ "./src/diagrams/common/common.js");
/* harmony import */ var _defaultConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./defaultConfig */ "./src/defaultConfig.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./logger */ "./src/logger.js");
var _this = undefined;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





 // Effectively an enum of the supported curve types, accessible by name

var d3CurveTypes = {
  curveBasis: d3__WEBPACK_IMPORTED_MODULE_1__["curveBasis"],
  curveBasisClosed: d3__WEBPACK_IMPORTED_MODULE_1__["curveBasisClosed"],
  curveBasisOpen: d3__WEBPACK_IMPORTED_MODULE_1__["curveBasisOpen"],
  curveLinear: d3__WEBPACK_IMPORTED_MODULE_1__["curveLinear"],
  curveLinearClosed: d3__WEBPACK_IMPORTED_MODULE_1__["curveLinearClosed"],
  curveMonotoneX: d3__WEBPACK_IMPORTED_MODULE_1__["curveMonotoneX"],
  curveMonotoneY: d3__WEBPACK_IMPORTED_MODULE_1__["curveMonotoneY"],
  curveNatural: d3__WEBPACK_IMPORTED_MODULE_1__["curveNatural"],
  curveStep: d3__WEBPACK_IMPORTED_MODULE_1__["curveStep"],
  curveStepAfter: d3__WEBPACK_IMPORTED_MODULE_1__["curveStepAfter"],
  curveStepBefore: d3__WEBPACK_IMPORTED_MODULE_1__["curveStepBefore"]
};
var directive = /[%]{2}[{]\s*(?:(?:(\w+)\s*:|(\w+))\s*(?:(?:(\w+))|((?:(?![}][%]{2}).|\r?\n)*))?\s*)(?:[}][%]{2})?/gi;
var directiveWithoutOpen = /\s*(?:(?:(\w+)(?=:):|(\w+))\s*(?:(?:(\w+))|((?:(?![}][%]{2}).|\r?\n)*))?\s*)(?:[}][%]{2})?/gi;
var anyComment = /\s*%%.*\n/gm;
/**
 * @function detectInit
 * Detects the init config object from the text
 * ```mermaid
 * %%{init: {"theme": "debug", "logLevel": 1 }}%%
 * graph LR
 *  a-->b
 *  b-->c
 *  c-->d
 *  d-->e
 *  e-->f
 *  f-->g
 *  g-->h
 * ```
 * or
 * ```mermaid
 * %%{initialize: {"theme": "dark", logLevel: "debug" }}%%
 * graph LR
 *  a-->b
 *  b-->c
 *  c-->d
 *  d-->e
 *  e-->f
 *  f-->g
 *  g-->h
 * ```
 *
 * @param {string} text The text defining the graph
 * @returns {object} the json object representing the init passed to mermaid.initialize()
 */

var detectInit = function detectInit(text, cnf) {
  var inits = detectDirective(text, /(?:init\b)|(?:initialize\b)/);
  var results = {};

  if (Array.isArray(inits)) {
    var args = inits.map(function (init) {
      return init.args;
    });
    directiveSanitizer(args);
    results = assignWithDepth(results, _toConsumableArray(args));
  } else {
    results = inits.args;
  }

  if (results) {
    var type = detectType(text, cnf);
    ['config'].forEach(function (prop) {
      if (typeof results[prop] !== 'undefined') {
        if (type === 'flowchart-v2') {
          type = 'flowchart';
        }

        results[type] = results[prop];
        delete results[prop];
      }
    });
  } // Todo: refactor this, these results are never used


  return results;
};
/**
 * @function detectDirective
 * Detects the directive from the text. Text can be single line or multiline. If type is null or omitted
 * the first directive encountered in text will be returned
 * ```mermaid
 * graph LR
 *  %%{somedirective}%%
 *  a-->b
 *  b-->c
 *  c-->d
 *  d-->e
 *  e-->f
 *  f-->g
 *  g-->h
 * ```
 *
 * @param {string} text The text defining the graph
 * @param {string|RegExp} type The directive to return (default: null)
 * @returns {object | Array} An object or Array representing the directive(s): { type: string, args: object|null } matched by the input type
 *          if a single directive was found, that directive object will be returned.
 */

var detectDirective = function detectDirective(text) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  try {
    var commentWithoutDirectives = new RegExp("[%]{2}(?![{]".concat(directiveWithoutOpen.source, ")(?=[}][%]{2}).*\n"), 'ig');
    text = text.trim().replace(commentWithoutDirectives, '').replace(/'/gm, '"');
    _logger__WEBPACK_IMPORTED_MODULE_4__["log"].debug("Detecting diagram directive".concat(type !== null ? ' type:' + type : '', " based on the text:").concat(text));
    var match,
        result = [];

    while ((match = directive.exec(text)) !== null) {
      // This is necessary to avoid infinite loops with zero-width matches
      if (match.index === directive.lastIndex) {
        directive.lastIndex++;
      }

      if (match && !type || type && match[1] && match[1].match(type) || type && match[2] && match[2].match(type)) {
        var _type = match[1] ? match[1] : match[2];

        var args = match[3] ? match[3].trim() : match[4] ? JSON.parse(match[4].trim()) : null;
        result.push({
          type: _type,
          args: args
        });
      }
    }

    if (result.length === 0) {
      result.push({
        type: text,
        args: null
      });
    }

    return result.length === 1 ? result[0] : result;
  } catch (error) {
    _logger__WEBPACK_IMPORTED_MODULE_4__["log"].error("ERROR: ".concat(error.message, " - Unable to parse directive\n      ").concat(type !== null ? ' type:' + type : '', " based on the text:").concat(text));
    return {
      type: null,
      args: null
    };
  }
};
/**
 * @function detectType
 * Detects the type of the graph text. Takes into consideration the possible existence of an %%init
 * directive
 * ```mermaid
 * %%{initialize: {"startOnLoad": true, logLevel: "fatal" }}%%
 * graph LR
 *  a-->b
 *  b-->c
 *  c-->d
 *  d-->e
 *  e-->f
 *  f-->g
 *  g-->h
 * ```
 *
 * @param {string} text The text defining the graph
 * @returns {string} A graph definition key
 */

var detectType = function detectType(text, cnf) {
  text = text.replace(directive, '').replace(anyComment, '\n');

  if (text.match(/^\s*sequenceDiagram/)) {
    return 'sequence';
  }

  if (text.match(/^\s*gantt/)) {
    return 'gantt';
  }

  if (text.match(/^\s*classDiagram-v2/)) {
    return 'classDiagram';
  }

  if (text.match(/^\s*classDiagram/)) {
    if (cnf && cnf.class && cnf.class.defaultRenderer === 'dagre-wrapper') return 'classDiagram';
    return 'class';
  }

  if (text.match(/^\s*stateDiagram-v2/)) {
    return 'stateDiagram';
  }

  if (text.match(/^\s*stateDiagram/)) {
    if (cnf && cnf.class && cnf.state.defaultRenderer === 'dagre-wrapper') return 'stateDiagram';
    return 'state';
  }

  if (text.match(/^\s*gitGraph/)) {
    return 'git';
  }

  if (text.match(/^\s*flowchart/)) {
    return 'flowchart-v2';
  }

  if (text.match(/^\s*info/)) {
    return 'info';
  }

  if (text.match(/^\s*pie/)) {
    return 'pie';
  }

  if (text.match(/^\s*erDiagram/)) {
    return 'er';
  }

  if (text.match(/^\s*journey/)) {
    return 'journey';
  }

  if (text.match(/^\s*requirement/) || text.match(/^\s*requirementDiagram/)) {
    return 'requirement';
  }

  if (cnf && cnf.flowchart && cnf.flowchart.defaultRenderer === 'dagre-wrapper') return 'flowchart-v2';
  return 'flowchart';
};

var memoize = function memoize(fn, resolver) {
  var cache = {};
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var n = resolver ? resolver.apply(_this, args) : args[0];

    if (n in cache) {
      return cache[n];
    } else {
      var result = fn.apply(void 0, args);
      cache[n] = result;
      return result;
    }
  };
};
/**
 * @function isSubstringInArray
 * Detects whether a substring in present in a given array
 * @param {string} str The substring to detect
 * @param {array} arr The array to search
 * @returns {number} the array index containing the substring or -1 if not present
 **/


var isSubstringInArray = function isSubstringInArray(str, arr) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i].match(str)) return i;
  }

  return -1;
};
var interpolateToCurve = function interpolateToCurve(interpolate, defaultCurve) {
  if (!interpolate) {
    return defaultCurve;
  }

  var curveName = "curve".concat(interpolate.charAt(0).toUpperCase() + interpolate.slice(1));
  return d3CurveTypes[curveName] || defaultCurve;
};
var formatUrl = function formatUrl(linkStr, config) {
  var url = linkStr.trim();

  if (url) {
    if (config.securityLevel !== 'loose') {
      return Object(_braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_0__["sanitizeUrl"])(url);
    }

    return url;
  }
};
var runFunc = function runFunc(functionName) {
  var _obj;

  var arrPaths = functionName.split('.');
  var len = arrPaths.length - 1;
  var fnName = arrPaths[len];
  var obj = window;

  for (var i = 0; i < len; i++) {
    obj = obj[arrPaths[i]];
    if (!obj) return;
  }

  for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    params[_key2 - 1] = arguments[_key2];
  }

  (_obj = obj)[fnName].apply(_obj, params);
};

var distance = function distance(p1, p2) {
  return p1 && p2 ? Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)) : 0;
};

var traverseEdge = function traverseEdge(points) {
  var prevPoint;
  var totalDistance = 0;
  points.forEach(function (point) {
    totalDistance += distance(point, prevPoint);
    prevPoint = point;
  }); // Traverse half of total distance along points

  var remainingDistance = totalDistance / 2;
  var center = undefined;
  prevPoint = undefined;
  points.forEach(function (point) {
    if (prevPoint && !center) {
      var vectorDistance = distance(point, prevPoint);

      if (vectorDistance < remainingDistance) {
        remainingDistance -= vectorDistance;
      } else {
        // The point is remainingDistance from prevPoint in the vector between prevPoint and point
        // Calculate the coordinates
        var distanceRatio = remainingDistance / vectorDistance;
        if (distanceRatio <= 0) center = prevPoint;
        if (distanceRatio >= 1) center = {
          x: point.x,
          y: point.y
        };

        if (distanceRatio > 0 && distanceRatio < 1) {
          center = {
            x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point.x,
            y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point.y
          };
        }
      }
    }

    prevPoint = point;
  });
  return center;
};

var calcLabelPosition = function calcLabelPosition(points) {
  return traverseEdge(points);
};

var calcCardinalityPosition = function calcCardinalityPosition(isRelationTypePresent, points, initialPosition) {
  var prevPoint;
  var totalDistance = 0; // eslint-disable-line

  _logger__WEBPACK_IMPORTED_MODULE_4__["log"].info('our points', points);

  if (points[0] !== initialPosition) {
    points = points.reverse();
  }

  points.forEach(function (point) {
    totalDistance += distance(point, prevPoint);
    prevPoint = point;
  }); // Traverse only 25 total distance along points to find cardinality point

  var distanceToCardinalityPoint = 25;
  var remainingDistance = distanceToCardinalityPoint;
  var center;
  prevPoint = undefined;
  points.forEach(function (point) {
    if (prevPoint && !center) {
      var vectorDistance = distance(point, prevPoint);

      if (vectorDistance < remainingDistance) {
        remainingDistance -= vectorDistance;
      } else {
        // The point is remainingDistance from prevPoint in the vector between prevPoint and point
        // Calculate the coordinates
        var distanceRatio = remainingDistance / vectorDistance;
        if (distanceRatio <= 0) center = prevPoint;
        if (distanceRatio >= 1) center = {
          x: point.x,
          y: point.y
        };

        if (distanceRatio > 0 && distanceRatio < 1) {
          center = {
            x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point.x,
            y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point.y
          };
        }
      }
    }

    prevPoint = point;
  }); // if relation is present (Arrows will be added), change cardinality point off-set distance (d)

  var d = isRelationTypePresent ? 10 : 5; //Calculate Angle for x and y axis

  var angle = Math.atan2(points[0].y - center.y, points[0].x - center.x);
  var cardinalityPosition = {
    x: 0,
    y: 0
  }; //Calculation cardinality position using angle, center point on the line/curve but pendicular and with offset-distance

  cardinalityPosition.x = Math.sin(angle) * d + (points[0].x + center.x) / 2;
  cardinalityPosition.y = -Math.cos(angle) * d + (points[0].y + center.y) / 2;
  return cardinalityPosition;
};
/**
 * position ['start_left', 'start_right', 'end_left', 'end_right']
 */


var calcTerminalLabelPosition = function calcTerminalLabelPosition(terminalMarkerSize, position, _points) {
  // Todo looking to faster cloning method
  var points = JSON.parse(JSON.stringify(_points));
  var prevPoint;
  var totalDistance = 0; // eslint-disable-line

  _logger__WEBPACK_IMPORTED_MODULE_4__["log"].info('our points', points);

  if (position !== 'start_left' && position !== 'start_right') {
    points = points.reverse();
  }

  points.forEach(function (point) {
    totalDistance += distance(point, prevPoint);
    prevPoint = point;
  }); // Traverse only 25 total distance along points to find cardinality point

  var distanceToCardinalityPoint = 25 + terminalMarkerSize;
  var remainingDistance = distanceToCardinalityPoint;
  var center;
  prevPoint = undefined;
  points.forEach(function (point) {
    if (prevPoint && !center) {
      var vectorDistance = distance(point, prevPoint);

      if (vectorDistance < remainingDistance) {
        remainingDistance -= vectorDistance;
      } else {
        // The point is remainingDistance from prevPoint in the vector between prevPoint and point
        // Calculate the coordinates
        var distanceRatio = remainingDistance / vectorDistance;
        if (distanceRatio <= 0) center = prevPoint;
        if (distanceRatio >= 1) center = {
          x: point.x,
          y: point.y
        };

        if (distanceRatio > 0 && distanceRatio < 1) {
          center = {
            x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point.x,
            y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point.y
          };
        }
      }
    }

    prevPoint = point;
  }); // if relation is present (Arrows will be added), change cardinality point off-set distance (d)

  var d = 10 + terminalMarkerSize * 0.5; //Calculate Angle for x and y axis

  var angle = Math.atan2(points[0].y - center.y, points[0].x - center.x);
  var cardinalityPosition = {
    x: 0,
    y: 0
  }; //Calculation cardinality position using angle, center point on the line/curve but pendicular and with offset-distance

  cardinalityPosition.x = Math.sin(angle) * d + (points[0].x + center.x) / 2;
  cardinalityPosition.y = -Math.cos(angle) * d + (points[0].y + center.y) / 2;

  if (position === 'start_left') {
    cardinalityPosition.x = Math.sin(angle + Math.PI) * d + (points[0].x + center.x) / 2;
    cardinalityPosition.y = -Math.cos(angle + Math.PI) * d + (points[0].y + center.y) / 2;
  }

  if (position === 'end_right') {
    cardinalityPosition.x = Math.sin(angle - Math.PI) * d + (points[0].x + center.x) / 2 - 5;
    cardinalityPosition.y = -Math.cos(angle - Math.PI) * d + (points[0].y + center.y) / 2 - 5;
  }

  if (position === 'end_left') {
    cardinalityPosition.x = Math.sin(angle) * d + (points[0].x + center.x) / 2 - 5;
    cardinalityPosition.y = -Math.cos(angle) * d + (points[0].y + center.y) / 2 - 5;
  }

  return cardinalityPosition;
};

var getStylesFromArray = function getStylesFromArray(arr) {
  var style = '';
  var labelStyle = '';

  for (var i = 0; i < arr.length; i++) {
    if (typeof arr[i] !== 'undefined') {
      // add text properties to label style definition
      if (arr[i].startsWith('color:') || arr[i].startsWith('text-align:')) {
        labelStyle = labelStyle + arr[i] + ';';
      } else {
        style = style + arr[i] + ';';
      }
    }
  }

  return {
    style: style,
    labelStyle: labelStyle
  };
};
var cnt = 0;
var generateId = function generateId() {
  cnt++;
  return 'id-' + Math.random().toString(36).substr(2, 12) + '-' + cnt;
};

function makeid(length) {
  var result = '';
  var characters = '0123456789abcdef';
  var charactersLength = characters.length;

  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }

  return result;
}

var random = function random(options) {
  return makeid(options.length);
};
/**
 * @function assignWithDepth
 * Extends the functionality of {@link ObjectConstructor.assign} with the ability to merge arbitrary-depth objects
 * For each key in src with path `k` (recursively) performs an Object.assign(dst[`k`], src[`k`]) with
 * a slight change from the typical handling of undefined for dst[`k`]: instead of raising an error,
 * dst[`k`] is auto-initialized to {} and effectively merged with src[`k`]
 * <p>
 * Additionally, dissimilar types will not clobber unless the config.clobber parameter === true. Example:
 * ```
 * let config_0 = { foo: { bar: 'bar' }, bar: 'foo' };
 * let config_1 = { foo: 'foo', bar: 'bar' };
 * let result = assignWithDepth(config_0, config_1);
 * console.log(result);
 * //-> result: { foo: { bar: 'bar' }, bar: 'bar' }
 * ```
 * <p>
 * Traditional Object.assign would have clobbered foo in config_0 with foo in config_1.
 * <p>
 * If src is a destructured array of objects and dst is not an array, assignWithDepth will apply each element of src to dst
 * in order.
 * @param dst:any - the destination of the merge
 * @param src:any - the source object(s) to merge into destination
 * @param config:{ depth: number, clobber: boolean } - depth: depth to traverse within src and dst for merging -
 * clobber: should dissimilar types clobber (default: { depth: 2, clobber: false })
 * @returns {*}
 */

var assignWithDepth = function assignWithDepth(dst, src, config) {
  var _Object$assign = Object.assign({
    depth: 2,
    clobber: false
  }, config),
      depth = _Object$assign.depth,
      clobber = _Object$assign.clobber;

  if (Array.isArray(src) && !Array.isArray(dst)) {
    src.forEach(function (s) {
      return assignWithDepth(dst, s, config);
    });
    return dst;
  } else if (Array.isArray(src) && Array.isArray(dst)) {
    src.forEach(function (s) {
      if (dst.indexOf(s) === -1) {
        dst.push(s);
      }
    });
    return dst;
  }

  if (typeof dst === 'undefined' || depth <= 0) {
    if (dst !== undefined && dst !== null && _typeof(dst) === 'object' && _typeof(src) === 'object') {
      return Object.assign(dst, src);
    } else {
      return src;
    }
  }

  if (typeof src !== 'undefined' && _typeof(dst) === 'object' && _typeof(src) === 'object') {
    Object.keys(src).forEach(function (key) {
      if (_typeof(src[key]) === 'object' && (dst[key] === undefined || _typeof(dst[key]) === 'object')) {
        if (dst[key] === undefined) {
          dst[key] = Array.isArray(src[key]) ? [] : {};
        }

        dst[key] = assignWithDepth(dst[key], src[key], {
          depth: depth - 1,
          clobber: clobber
        });
      } else if (clobber || _typeof(dst[key]) !== 'object' && _typeof(src[key]) !== 'object') {
        dst[key] = src[key];
      }
    });
  }

  return dst;
};
var getTextObj = function getTextObj() {
  return {
    x: 0,
    y: 0,
    fill: undefined,
    anchor: 'start',
    style: '#666',
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0,
    valign: undefined
  };
};
var drawSimpleText = function drawSimpleText(elem, textData) {
  // Remove and ignore br:s
  var nText = textData.text.replace(_diagrams_common_common__WEBPACK_IMPORTED_MODULE_2__["default"].lineBreakRegex, ' ');
  var textElem = elem.append('text');
  textElem.attr('x', textData.x);
  textElem.attr('y', textData.y);
  textElem.style('text-anchor', textData.anchor);
  textElem.style('font-family', textData.fontFamily);
  textElem.style('font-size', textData.fontSize);
  textElem.style('font-weight', textData.fontWeight);
  textElem.attr('fill', textData.fill);

  if (typeof textData.class !== 'undefined') {
    textElem.attr('class', textData.class);
  }

  var span = textElem.append('tspan');
  span.attr('x', textData.x + textData.textMargin * 2);
  span.attr('fill', textData.fill);
  span.text(nText);
  return textElem;
};
var wrapLabel = memoize(function (label, maxWidth, config) {
  if (!label) {
    return label;
  }

  config = Object.assign({
    fontSize: 12,
    fontWeight: 400,
    fontFamily: 'Arial',
    joinWith: '<br/>'
  }, config);

  if (_diagrams_common_common__WEBPACK_IMPORTED_MODULE_2__["default"].lineBreakRegex.test(label)) {
    return label;
  }

  var words = label.split(' ');
  var completedLines = [];
  var nextLine = '';
  words.forEach(function (word, index) {
    var wordLength = calculateTextWidth("".concat(word, " "), config);
    var nextLineLength = calculateTextWidth(nextLine, config);

    if (wordLength > maxWidth) {
      var _breakString = breakString(word, maxWidth, '-', config),
          hyphenatedStrings = _breakString.hyphenatedStrings,
          remainingWord = _breakString.remainingWord;

      completedLines.push.apply(completedLines, [nextLine].concat(_toConsumableArray(hyphenatedStrings)));
      nextLine = remainingWord;
    } else if (nextLineLength + wordLength >= maxWidth) {
      completedLines.push(nextLine);
      nextLine = word;
    } else {
      nextLine = [nextLine, word].filter(Boolean).join(' ');
    }

    var currentWord = index + 1;
    var isLastWord = currentWord === words.length;

    if (isLastWord) {
      completedLines.push(nextLine);
    }
  });
  return completedLines.filter(function (line) {
    return line !== '';
  }).join(config.joinWith);
}, function (label, maxWidth, config) {
  return "".concat(label, "-").concat(maxWidth, "-").concat(config.fontSize, "-").concat(config.fontWeight, "-").concat(config.fontFamily, "-").concat(config.joinWith);
});
var breakString = memoize(function (word, maxWidth) {
  var hyphenCharacter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '-';
  var config = arguments.length > 3 ? arguments[3] : undefined;
  config = Object.assign({
    fontSize: 12,
    fontWeight: 400,
    fontFamily: 'Arial',
    margin: 0
  }, config);
  var characters = word.split('');
  var lines = [];
  var currentLine = '';
  characters.forEach(function (character, index) {
    var nextLine = "".concat(currentLine).concat(character);
    var lineWidth = calculateTextWidth(nextLine, config);

    if (lineWidth >= maxWidth) {
      var currentCharacter = index + 1;
      var isLastLine = characters.length === currentCharacter;
      var hyphenatedNextLine = "".concat(nextLine).concat(hyphenCharacter);
      lines.push(isLastLine ? nextLine : hyphenatedNextLine);
      currentLine = '';
    } else {
      currentLine = nextLine;
    }
  });
  return {
    hyphenatedStrings: lines,
    remainingWord: currentLine
  };
}, function (word, maxWidth) {
  var hyphenCharacter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '-';
  var config = arguments.length > 3 ? arguments[3] : undefined;
  return "".concat(word, "-").concat(maxWidth, "-").concat(hyphenCharacter, "-").concat(config.fontSize, "-").concat(config.fontWeight, "-").concat(config.fontFamily);
});
/**
 * This calculates the text's height, taking into account the wrap breaks and
 * both the statically configured height, width, and the length of the text (in pixels).
 *
 * If the wrapped text text has greater height, we extend the height, so it's
 * value won't overflow.
 *
 * @return - The height for the given text
 * @param text the text to measure
 * @param config - the config for fontSize, fontFamily, and fontWeight all impacting the resulting size
 */

var calculateTextHeight = function calculateTextHeight(text, config) {
  config = Object.assign({
    fontSize: 12,
    fontWeight: 400,
    fontFamily: 'Arial',
    margin: 15
  }, config);
  return calculateTextDimensions(text, config).height;
};
/**
 * This calculates the width of the given text, font size and family.
 *
 * @return - The width for the given text
 * @param text - The text to calculate the width of
 * @param config - the config for fontSize, fontFamily, and fontWeight all impacting the resulting size
 */

var calculateTextWidth = function calculateTextWidth(text, config) {
  config = Object.assign({
    fontSize: 12,
    fontWeight: 400,
    fontFamily: 'Arial'
  }, config);
  return calculateTextDimensions(text, config).width;
};
/**
 * This calculates the dimensions of the given text, font size, font family, font weight, and margins.
 *
 * @return - The width for the given text
 * @param text - The text to calculate the width of
 * @param config - the config for fontSize, fontFamily, fontWeight, and margin all impacting the resulting size
 */

var calculateTextDimensions = memoize(function (text, config) {
  config = Object.assign({
    fontSize: 12,
    fontWeight: 400,
    fontFamily: 'Arial'
  }, config);
  var _config = config,
      fontSize = _config.fontSize,
      fontFamily = _config.fontFamily,
      fontWeight = _config.fontWeight;

  if (!text) {
    return {
      width: 0,
      height: 0
    };
  } // We can't really know if the user supplied font family will render on the user agent;
  // thus, we'll take the max width between the user supplied font family, and a default
  // of sans-serif.


  var fontFamilies = ['sans-serif', fontFamily];
  var lines = text.split(_diagrams_common_common__WEBPACK_IMPORTED_MODULE_2__["default"].lineBreakRegex);
  var dims = [];
  var body = Object(d3__WEBPACK_IMPORTED_MODULE_1__["select"])('body'); // We don't want to leak DOM elements - if a removal operation isn't available
  // for any reason, do not continue.

  if (!body.remove) {
    return {
      width: 0,
      height: 0,
      lineHeight: 0
    };
  }

  var g = body.append('svg');

  for (var _i = 0, _fontFamilies = fontFamilies; _i < _fontFamilies.length; _i++) {
    var _fontFamily = _fontFamilies[_i];
    var cheight = 0;
    var dim = {
      width: 0,
      height: 0,
      lineHeight: 0
    };

    var _iterator = _createForOfIteratorHelper(lines),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var line = _step.value;
        var textObj = getTextObj();
        textObj.text = line;
        var textElem = drawSimpleText(g, textObj).style('font-size', fontSize).style('font-weight', fontWeight).style('font-family', _fontFamily);
        var bBox = (textElem._groups || textElem)[0][0].getBBox();
        dim.width = Math.round(Math.max(dim.width, bBox.width));
        cheight = Math.round(bBox.height);
        dim.height += cheight;
        dim.lineHeight = Math.round(Math.max(dim.lineHeight, cheight));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    dims.push(dim);
  }

  g.remove();
  var index = isNaN(dims[1].height) || isNaN(dims[1].width) || isNaN(dims[1].lineHeight) || dims[0].height > dims[1].height && dims[0].width > dims[1].width && dims[0].lineHeight > dims[1].lineHeight ? 0 : 1;
  return dims[index];
}, function (text, config) {
  return "".concat(text, "-").concat(config.fontSize, "-").concat(config.fontWeight, "-").concat(config.fontFamily);
});

var d3Attrs = function d3Attrs(d3Elem, attrs) {
  var _iterator2 = _createForOfIteratorHelper(attrs),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var attr = _step2.value;
      d3Elem.attr(attr[0], attr[1]);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
};

var calculateSvgSizeAttrs = function calculateSvgSizeAttrs(height, width, useMaxWidth) {
  var attrs = new Map();
  attrs.set('height', height);

  if (useMaxWidth) {
    attrs.set('width', '100%');
    attrs.set('style', "max-width: ".concat(width, "px;"));
  } else {
    attrs.set('width', width);
  }

  return attrs;
};
var configureSvgSize = function configureSvgSize(svgElem, height, width, useMaxWidth) {
  var attrs = calculateSvgSizeAttrs(height, width, useMaxWidth);
  d3Attrs(svgElem, attrs);
};
var initIdGeneratior = /*#__PURE__*/function () {
  function iterator(deterministic, seed) {
    _classCallCheck(this, iterator);

    this.deterministic = deterministic;
    this.seed = seed;
    this.count = seed ? seed.length : 0;
  }

  _createClass(iterator, [{
    key: "next",
    value: function next() {
      if (!this.deterministic) return Date.now();
      return this.count++;
    }
  }]);

  return iterator;
}(); // Source https://github.com/shrpne/entity-decode/blob/master/browser.js

var decoder;
var entityDecode = function entityDecode(html) {
  decoder = decoder || document.createElement('div'); // Escape HTML before decoding for HTML Entities

  html = escape(html).replace(/%26/g, '&').replace(/%23/g, '#').replace(/%3B/g, ';'); // decoding

  decoder.innerHTML = html;
  return unescape(decoder.textContent);
};
var directiveSanitizer = function directiveSanitizer(args) {
  _logger__WEBPACK_IMPORTED_MODULE_4__["log"].debug('directiveSanitizer called with', args);

  if (_typeof(args) === 'object') {
    // check for array
    if (args.length) {
      args.forEach(function (arg) {
        return directiveSanitizer(arg);
      });
    } else {
      // This is an object
      Object.keys(args).forEach(function (key) {
        _logger__WEBPACK_IMPORTED_MODULE_4__["log"].debug('Checking key', key);

        if (key.indexOf('__') === 0) {
          _logger__WEBPACK_IMPORTED_MODULE_4__["log"].debug('sanitize deleting __ option', key);
          delete args[key];
        }

        if (key.indexOf('proto') >= 0) {
          _logger__WEBPACK_IMPORTED_MODULE_4__["log"].debug('sanitize deleting proto option', key);
          delete args[key];
        }

        if (key.indexOf('constr') >= 0) {
          _logger__WEBPACK_IMPORTED_MODULE_4__["log"].debug('sanitize deleting constr option', key);
          delete args[key];
        }

        if (_defaultConfig__WEBPACK_IMPORTED_MODULE_3__["configKeys"].indexOf(key) < 0) {
          _logger__WEBPACK_IMPORTED_MODULE_4__["log"].debug('sanitize deleting option', key);
          delete args[key];
        } else {
          if (_typeof(args[key]) === 'object') {
            _logger__WEBPACK_IMPORTED_MODULE_4__["log"].debug('sanitize deleting object', key);
            directiveSanitizer(args[key]);
          }
        }
      });
    }
  }
};
/* harmony default export */ __webpack_exports__["default"] = ({
  assignWithDepth: assignWithDepth,
  wrapLabel: wrapLabel,
  calculateTextHeight: calculateTextHeight,
  calculateTextWidth: calculateTextWidth,
  calculateTextDimensions: calculateTextDimensions,
  calculateSvgSizeAttrs: calculateSvgSizeAttrs,
  configureSvgSize: configureSvgSize,
  detectInit: detectInit,
  detectDirective: detectDirective,
  detectType: detectType,
  isSubstringInArray: isSubstringInArray,
  interpolateToCurve: interpolateToCurve,
  calcLabelPosition: calcLabelPosition,
  calcCardinalityPosition: calcCardinalityPosition,
  calcTerminalLabelPosition: calcTerminalLabelPosition,
  formatUrl: formatUrl,
  getStylesFromArray: getStylesFromArray,
  generateId: generateId,
  random: random,
  memoize: memoize,
  runFunc: runFunc,
  entityDecode: entityDecode,
  initIdGeneratior: initIdGeneratior,
  directiveSanitizer: directiveSanitizer
});

/***/ }),

/***/ "@braintree/sanitize-url":
/*!******************************************!*\
  !*** external "@braintree/sanitize-url" ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("@braintree/sanitize-url");

/***/ }),

/***/ "d3":
/*!*********************!*\
  !*** external "d3" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("d3");

/***/ }),

/***/ "dagre":
/*!************************!*\
  !*** external "dagre" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("dagre");

/***/ }),

/***/ "dagre-d3":
/*!***************************!*\
  !*** external "dagre-d3" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("dagre-d3");

/***/ }),

/***/ "dagre-d3/lib/label/add-html-label.js":
/*!*******************************************************!*\
  !*** external "dagre-d3/lib/label/add-html-label.js" ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("dagre-d3/lib/label/add-html-label.js");

/***/ }),

/***/ "dompurify":
/*!****************************!*\
  !*** external "dompurify" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("dompurify");

/***/ }),

/***/ "graphlib":
/*!***************************!*\
  !*** external "graphlib" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("graphlib");

/***/ }),

/***/ "khroma":
/*!*************************!*\
  !*** external "khroma" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("khroma");

/***/ }),

/***/ "moment-mini":
/*!******************************!*\
  !*** external "moment-mini" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("moment-mini");

/***/ }),

/***/ "stylis":
/*!*************************!*\
  !*** external "stylis" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("stylis");

/***/ })

/******/ })["default"];
});
//# sourceMappingURL=mermaid.core.js.map