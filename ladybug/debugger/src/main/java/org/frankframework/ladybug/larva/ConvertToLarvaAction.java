/*
   Copyright 2024 WeAreFrank!

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
package org.frankframework.ladybug.larva;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.Stack;
import java.util.TreeMap;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.frankframework.configuration.ConfigurationUtils;
import org.frankframework.core.Resource;
import org.frankframework.util.AppConstants;
import org.frankframework.util.TransformerPool;
import org.frankframework.util.XmlUtils;
import org.springframework.stereotype.Component;

import nl.nn.testtool.Checkpoint;
import nl.nn.testtool.CheckpointType;
import nl.nn.testtool.Report;
import nl.nn.testtool.extensions.CustomReportAction;
import nl.nn.testtool.extensions.CustomReportActionResult;

@Component
public class ConvertToLarvaAction implements CustomReportAction {

	private static String scenarioSuffix;
	private final AppConstants appConstants = AppConstants.getInstance();
	private Path dir;
	private final int SINCE = (int) TimeUnit.MILLISECONDS.toMinutes(Date.from(Instant.parse("2020-01-01T01:00:00.00Z")).getTime());

	@Override
	public String getButtonText() {
		return "Convert to Larva";
	}

	@Override
	public CustomReportActionResult handleReports(List<Report> reports) {
		CustomReportActionResult customReportActionResult = new CustomReportActionResult();
		this.dir = Paths.get(
				appConstants.get(appConstants.get("dtap.stage").equals("LOC") ? "ibistesttool.directory" : "log.dir"),
				"autogenerated"
		);

		//get minutes since 2020
		int minutes = (int) TimeUnit.MILLISECONDS.toMinutes(Calendar.getInstance().getTimeInMillis()) - SINCE;

		Map<String, ArrayList<Report>> groupedReports = new HashMap<>();
		for (Report report : reports) {
			String pipelineName = report.getInputCheckpoint().getName().substring(9);
			groupedReports.computeIfAbsent(pipelineName, v -> new ArrayList<>()).add(report);
		}
		List<Scenario> scenarios = groupedReports.entrySet().stream().flatMap(adapterReports -> {
			String pipelineName = adapterReports.getKey();
			ArrayList<Scenario> adapterScenarios = new ArrayList<>();
			for (int i = 0; i < adapterReports.getValue().size(); i++) {
				Report report = adapterReports.getValue().get(i);
				adapterScenarios.add(new Scenario(report, dir, pipelineName, Integer.parseInt(minutes + "" + i)));
			}
			return adapterScenarios.stream();
		}).collect(Collectors.toList());
		String successResultsString = scenarios.stream().filter(scenario -> !scenario.error)
				.map(scenario -> scenario.reportName)
				.collect(Collectors.joining(", "));
		String errorResultsString = scenarios.stream().filter(scenario -> !scenario.error)
				.map(scenario -> scenario.reportName)
				.collect(Collectors.joining(", "));
		if (!successResultsString.isEmpty()) {
			customReportActionResult.setSuccessMessage("Success:" + successResultsString);
		}
		if (!errorResultsString.isEmpty()) {
			customReportActionResult.setErrorMessage("Error:" + errorResultsString);
		}
		return customReportActionResult;
	}

	private static class Scenario {

		private static final HashSet<String> allowedPipesWithSenders = new HashSet<>(Arrays.asList(
				"org.frankframework.pipes.SenderPipe",
				"org.frankframework.pipes.ForEachChildElementPipe",
				"org.frankframework.jdbc.ResultSetIteratingPipe",
				"org.frankframework.pipes.StreamLineIteratorPipe",
				"org.frankframework.compression.ZipIteratorPipe",
				"org.frankframework.filesystem.ForEachAttachmentPipe",
				"org.frankframework.jdbc.ClobLineIteratingPipe",
				"org.frankframework.jdbc.BlobLineIteratingPipe",
				"org.frankframework.pipes.AsyncSenderWithListenerPipe"
		));

		private static final HashSet<String> allowedSenders = new HashSet<>(Arrays.asList(
				"org.frankframework.jdbc.ResultSet2FileSender",
				"org.frankframework.jdbc.DirectQuerySender",
				"org.frankframework.jdbc.FixedQuerySender",
				"org.frankframework.jdbc.XmlQuerySender",
				"org.frankframework.senders.DelaySender",
				"org.frankframework.senders.EchoSender",
				"org.frankframework.senders.IbisLocalSender",
				"org.frankframework.senders.LogSender",
				"org.frankframework.senders.ParallelSenders",
				"org.frankframework.senders.SenderSeries",
				"org.frankframework.senders.SenderWrapper",
				"org.frankframework.senders.XsltSender",
				"org.frankframework.senders.CommandSender",
				"org.frankframework.senders.FixedResultSender",
				"org.frankframework.senders.JavascriptSender",
				"org.frankframework.jdbc.MessageStoreSender",
				"org.frankframework.senders.ReloadSender",
				"org.frankframework.compression.ZipWriterSender",
				"org.frankframework.senders.LocalFileSystemSender"
		));

		private static final HashSet<String> ignoredSessionKeys = new HashSet<>(Arrays.asList(
				"cid",
				"mid",
				"id",
				"key",
				"messageId",
				"originalMessage",
				"tcid",
				"tsReceived",
				"conversationId",
				"timestamp",
				"tsSent",
				"xPathLogKeys",
				"replyTo",
				"JmsSession",
				"servletResponse",
				"servletRequest",
				"servletContext",
				"securityHandler",
				"__isManualRetry"
		));

		private static final Set<String> ignorePropNames = Set.of(
				"ignoreRegularExpressionKey",
				"removeRegularExpressionKey",
				"decodeUnzipContentBetweenKeys",
				"canonicaliseFilePathContentBetweenKeys",
				"replaceRegularExpressionKeys",
				"ignoreContentBetweenKeys",
				"ignoreKeysAndContentBetweenKeys",
				"removeKeysAndContentBetweenKeys",
				"ignoreKey",
				"removeKey",
				"replaceKey",
				"replaceEverywhereKey",
				"ignoreCurrentTimeBetweenKeys",
				"ignoreContentBeforeKey",
				"ignoreContentAfterKey"
		);

		private static final String TESTTOOL_PREFIX = "testtool-";
		private final String reportName;
		private final String suffix;
		private final HashMap<Path, String> originalFiles = new HashMap<>();
		private final HashSet<Path> newFiles = new HashSet<>();
		Map<String, String> existingStubs = new HashMap<>();
		private final TreeMap<String, String> scenarioPropertiesMap = new TreeMap<>(new MultipleComparators<>(new ScenarioPropertiesComparator(), String.CASE_INSENSITIVE_ORDER));
		private final TreeMap<String, String> commonPropertiesMap =   new TreeMap<>(new MultipleComparators<>(new CommonPropertiesComparator(), String.CASE_INSENSITIVE_ORDER));
		private Path scenarioDirPath = null;
		private Path scenarioFilePath = null;
		private Path commonFilePath = null;
		private int longestCommonPropertyName = 0;
		private int longestScenarioPropertyName = 0;

		public boolean error = false;

		public Scenario(Report report, Path baseDir, String pipelineName, int uuid) {
			if(scenarioSuffix != null) {
				suffix = scenarioSuffix;
			} else {
				suffix = Integer.toString(uuid, Character.MAX_RADIX);
			}

			reportName = report.getName();

			if (!checkReportType()) return;

			Path testDir = baseDir.resolve(pipelineName);
			if (!tryCreateDir(testDir)) return;

			if (!checkSuffixNotInUse(testDir)) return;

			scenarioDirPath = testDir.resolve(suffix);
			scenarioFilePath = testDir.resolve("scenario" + suffix + ".properties");
			commonFilePath = testDir.resolve("common.properties");
			if (!checkScenarioDirNotInUse()) return;
			if (!tryCreateCommonFile()) return;

			String scenarioDirPrefix = scenarioDirPath.getFileName().toString() + "/";

			if (!tryLoadCommonProps()) return;

			String[] pipelineNameParts = pipelineName.split("/");
//			String configurationName = null;
			String adapterName = null;
			if(pipelineNameParts.length > 1) {
//				configurationName = pipelineNameParts[0];
				adapterName = pipelineNameParts[1];
			} else {
				adapterName = pipelineNameParts[0];
			}

			putScenarioProperty("scenario.description", "Test scenario for adapter " + adapterName + ", automatically generated based on a ladybug report");
			putScenarioProperty("include", "common.properties");

			List<Checkpoint> checkpoints = report.getCheckpoints();
			int paramI = 1;
			int current_step_nr = 1;

			String adapterInputMessage = checkpoints.get(0).getMessage();
			if(adapterInputMessage == null) {
				adapterInputMessage = "";
			}
			String adapterInputFileName = getFileName(current_step_nr, "adapter", adapterName, true, adapterInputMessage);
			putScenarioProperty("step" + current_step_nr + ".adapter." + adapterName + ".write", scenarioDirPrefix + adapterInputFileName);
			createInputOutputFile(scenarioDirPath, adapterInputFileName, adapterInputMessage);

			putCommonProperty("adapter." + adapterName + ".className", "org.frankframework.senders.IbisJavaSender");
			putCommonProperty("adapter." + adapterName + ".serviceName", TESTTOOL_PREFIX + adapterName);
			putCommonProperty("adapter." + adapterName + ".convertExceptionToMessage", "true");

			boolean skipUntilEndOfSender = false;
			String skipUntilEndOfSenderName = "";
			int skipUntilEndOfSenderLevel = -1;

			Stack<SenderPipeCheckPoint> senderPipeStack = new Stack<>();

			for (Checkpoint checkpoint : checkpoints) {
				// Create params in the scenario for session keys that are not in ignoredSessionKeys
				if (checkpoint.getLevel() == 1 && checkpoint.getType() == CheckpointType.INPUTPOINT.toInt() && checkpoint.getName().startsWith("SessionKey ")) {
					// SessionKey for listener found
					String sessionKeyName = checkpoint.getName().substring("SessionKey ".length());
					if (!ignoredSessionKeys.contains(sessionKeyName)) {
						String paramPropertyName = "adapter." + adapterName + ".param" + paramI;
						putScenarioProperty(paramPropertyName + ".name ", sessionKeyName);
						putScenarioProperty(paramPropertyName + ".value", checkpoint.getMessage());
						paramI++;
					}
				} else if (skipUntilEndOfSender && checkpoint.getName().startsWith("Sender ")) {
					// If we're currently stubbing a sender, and we haven't reached the end of it yet
					String checkpointName = checkpoint.getName();
					if (checkpoint.getLevel() == skipUntilEndOfSenderLevel && checkpoint.getType() == CheckpointType.ENDPOINT.toInt() && checkpointName.equals(skipUntilEndOfSenderName)) {
						String senderResponseMessage = checkpoint.getMessage();
						String checkPointKey = getCheckPointKey(senderPipeStack.peek(), checkpoint.getName().toLowerCase());
						String senderResponseFileName = getFileName(++current_step_nr, "stub", existingStubs.get(checkPointKey).substring(TESTTOOL_PREFIX.length()), false, senderResponseMessage);
						putScenarioProperty("step" + current_step_nr + ".stub." + existingStubs.get(checkPointKey).substring(TESTTOOL_PREFIX.length()) + ".write",
								scenarioDirPrefix + senderResponseFileName);
						if (!createInputOutputFile(scenarioDirPath, senderResponseFileName, senderResponseMessage)) {
							return;
						}
						skipUntilEndOfSender = false;
						senderPipeStack.peek().senderIndex++;
					}
				} else if (checkpoint.getType() == CheckpointType.STARTPOINT.toInt() && checkpoint.getName().startsWith("Sender ")) {
					if (!allowedSenders.contains(checkpoint.getSourceClassName())) {
						// If sender should be stubbed:
						String serviceName = null;
						SenderPipeCheckPoint sp = senderPipeStack.peek();
						if(sp != null && sp.getServiceNames().size() > sp.getSenderIndex()) {
							serviceName = sp.getServiceNames().get(sp.getSenderIndex());
						} else {
							serviceName = determineStubName(checkpoints, checkpoint);
						}
						String serviceNameWithoutTesttool = serviceName.substring(TESTTOOL_PREFIX.length());
						// If sender is already being stubbed, use existing stub name
						String checkPointKey = getCheckPointKey(sp, checkpoint.getName().toLowerCase());
						existingStubs.putIfAbsent(checkPointKey, serviceName);
						String senderInputMessage = checkpoint.getMessage() == null ? "" : checkpoint.getMessage();
						String senderInputFileName = getFileName(++current_step_nr, "stub", serviceNameWithoutTesttool, true, senderInputMessage);
						putScenarioProperty( "step" + current_step_nr + ".stub." + serviceNameWithoutTesttool + ".read", scenarioDirPrefix + senderInputFileName);

						if (!createInputOutputFile(scenarioDirPath, senderInputFileName, senderInputMessage)) {
							return;
						}

						putCommonProperty("stub." + serviceNameWithoutTesttool + ".className", "org.frankframework.receivers.JavaListener");
						putCommonProperty("stub." + serviceNameWithoutTesttool + ".serviceName", serviceName);

						skipUntilEndOfSender = true;
						skipUntilEndOfSenderName = checkpoint.getName();
						skipUntilEndOfSenderLevel = checkpoint.getLevel() + 1;
					}
				} else if(checkpoint.getType() == CheckpointType.INFOPOINT.toInt() && allowedPipesWithSenders.contains(checkpoint.getSourceClassName())) {
					String stubbedPipe = null;
					try {
						Resource xslt = Resource.getResource(ConfigurationUtils.STUB4TESTTOOL_XSLT_DEFAULT);
						TransformerPool tp = TransformerPool.getInstance(xslt);
						stubbedPipe = tp.transform(checkpoint.getMessage());
						// Extract sender testtool names from the pipe configuration 
						String regex = "testtool-([^\"]+)";

						Pattern pattern = Pattern.compile(regex);
						Matcher matcher = pattern.matcher(stubbedPipe);
						List<String> serviceNames = new ArrayList<>();
						while (matcher.find()) {
							serviceNames.add("testtool-" + matcher.group(1));
						}
						senderPipeStack.push(new SenderPipeCheckPoint(serviceNames, checkpoint.getName()));
					} catch(Exception e) {
						// Ignore exception stub name will be determined by a different approach
					}
				} else if(checkpoint.getType() == CheckpointType.ENDPOINT.toInt() && !senderPipeStack.empty() &&checkpoint.getName().equals(senderPipeStack.peek().getName())) {
					senderPipeStack.pop();
				}
			}
			if (skipUntilEndOfSender) {
				handleError();
				return;
			}

			String adapterOutputMessage = checkpoints.get(checkpoints.size() - 1).getMessage();
			String adapterOutputFileName = getFileName(++current_step_nr, "adapter", adapterName, false, adapterOutputMessage);
			putScenarioProperty(
					"step" + current_step_nr + ".adapter." + adapterName + ".read",
					scenarioDirPrefix + adapterOutputFileName);
			createInputOutputFile(scenarioDirPath, adapterOutputFileName, adapterOutputMessage);

			try {
				Files.writeString(scenarioFilePath, scenarioPropertiesToString());
				newFiles.add(scenarioFilePath);
			} catch (IOException e) {
				handleError();
				return;
			}
			try {
				if (!newFiles.contains(commonFilePath)) {
					try {
						addModifiedFile(commonFilePath, Files.readString(commonFilePath));
					} catch (IOException ex) {
						handleError();
						return;
					}
				}
				Files.writeString(commonFilePath, commonPropertiesToString());
				newFiles.add(commonFilePath);
			} catch (IOException e) {
				handleError();
			}
		}

		private String getCheckPointKey(SenderPipeCheckPoint senderPipeCheckPoint, String checkpointNamelc) {
			StringBuilder sb = new StringBuilder();
			if(senderPipeCheckPoint != null) {
				sb.append(senderPipeCheckPoint.getName());
				sb.append("-");
			}
			sb.append(checkpointNamelc);
			sb.append("-");
			sb.append(senderPipeCheckPoint.getSenderIndex());
			return sb.toString();
		}

		private String determineStubName(List<Checkpoint> checkpoints, Checkpoint checkpoint) {
			int currentIndex = checkpoints.indexOf(checkpoint);
			StringBuilder sb = new StringBuilder(TESTTOOL_PREFIX);
			Checkpoint parentCheckPoint = null;
			for (int i = currentIndex - 1; i > 0; i--) {
				if(checkpoints.get(i).getLevel() < checkpoint.getLevel() && !checkpoints.get(i).getName().equals("Thread")) {
					parentCheckPoint = checkpoints.get(i); 
					break;
				}
			}

			if(parentCheckPoint != null && allowedPipesWithSenders.contains(parentCheckPoint.getSourceClassName())) {
				sb.append(parentCheckPoint.getName().substring("Pipe ".length()));
			} else if(!checkpoint.getName().equals("Sender IbisJavaSender")) {
				sb.append(checkpoint.getName().substring("Sender ".length()));
			}

			return sb.toString();
		}

		private void putCommonProperty(String name, String value) {
			// don't override if exists
			if(commonPropertiesMap.containsKey(name)) {
				return;
			}
			commonPropertiesMap.put(name, value);
			longestCommonPropertyName = Math.max(longestCommonPropertyName, name.length());
		}

		private void putScenarioProperty(String name, String value) {
			scenarioPropertiesMap.put(name, value);
			longestScenarioPropertyName = Math.max(longestScenarioPropertyName, name.length());

		}

		private boolean checkReportType() {
			if (!reportName.startsWith("Pipeline ")) {
				handleError();
				return false;
			}
			return true;
		}

		private boolean tryCreateDir(Path testDir) {
			try {
				// Tries to create dir and parents. Does not throw error if it/they already exist(s)
				Files.createDirectories(testDir);
			} catch (IOException e) {
				handleError();
				return false;
			}
			return true;
		}

		private boolean checkSuffixNotInUse(Path testDir) {
			if (Files.exists(testDir.resolve(suffix)) || Files.exists(testDir.resolve("scenario" + suffix + ".properties"))) {
				handleError();
				return false;
			}
			return true;
		}

		private boolean checkScenarioDirNotInUse() {
			if (!Files.exists(scenarioDirPath)) {
				try {
					Files.createDirectory(scenarioDirPath);
				} catch (IOException e) {
					handleError();
					return false;
				}
			} else {
				try(Stream<Path> files = Files.list(scenarioDirPath)) {
					if (files.findAny().isPresent()) {
						handleError();
						return false;
					}
				} catch (IOException e) {
					handleError();
					return false;
				}
			}
			return true;
		}

		private boolean tryCreateCommonFile() {
			try {
				Files.createFile(commonFilePath);
			} catch (FileAlreadyExistsException e) {
				return true;
			} catch (IOException e) {
				handleError();
				return false;
			}
			newFiles.add(commonFilePath);
			return true;
		}

		private String getFileName(int step, String type, String name, boolean startPoint, String message) {
			String fileExtension = determineFileExtension(message);
			return String.format("%s-%s-%s-%s.%s",
					stepPadding(step),
					type,
					name,
					startPoint ? "in" : "out",
					fileExtension
			);
		}

		private String determineFileExtension(String message) {
			if(XmlUtils.isWellFormed(message)) {
				return "xml";
			} else if(message.trim().startsWith("{")) {
				return "json";
			} else {
				return "txt";
			}
		}

		public static String stepPadding(int i) {
			return String.format("%0" + 2 + "d", i);
		}

		private boolean createInputOutputFile(Path folder, String fileName, String message) {
			Path messageFilePath = folder.resolve(fileName);
			File messageFile = messageFilePath.toFile();
			try {
				if (messageFile.createNewFile()) {
					newFiles.add(messageFilePath);
					Files.writeString(messageFile.toPath(), message);
				} else {
					handleError();
					return false;
				}
			} catch (IOException e) {
				handleError();
				return false;
			}
			return true;
		}

		private boolean tryLoadCommonProps() {
			Properties currentCommonProps = new Properties();
			try {
				InputStream stream = Files.newInputStream(commonFilePath);
				currentCommonProps.load(stream);
			} catch (IOException e) {
				handleError();
				return false;
			}

			currentCommonProps.forEach((key, value) -> {
				if (key instanceof String && value instanceof String) {
					putCommonProperty((String) key, (String) value);
					if (((String) key).matches("stub.[a-zA-Z0-9-_.]+\\.serviceName")) {
						existingStubs.put(((String) value).toLowerCase(), ((String) key).substring(5, ((String) key).lastIndexOf('.')));
					}
				}
			});

			return true;
		}

		private String commonPropertiesToString() {
			Function<String, String> getPropGroup = propName -> {
				int lastDotIndex;
				if (propName.equals("include")) {
					return "0";
				} else if ((lastDotIndex = propName.lastIndexOf('.')) != -1) {
					return "1" + propName.substring(0, lastDotIndex);
				}
				return "";
			};
			return propertiesToString(commonPropertiesMap, getPropGroup, longestCommonPropertyName);
		}

		private String scenarioPropertiesToString() {
			Function<String, String> getPropGroup = propName -> {
				if (propName.equals("scenario.description") || propName.equals("include")) {
					return "0";
				} else if (propName.startsWith("step")) {
					return "1";
				} else if (propName.matches("\\.param\\.(name|value)$")) {
					return "2";
				} else if (ignorePropNames.contains(propName)) {
					return "3";
				}
				return "";
			};
			return propertiesToString(scenarioPropertiesMap, getPropGroup, longestScenarioPropertyName);
		}

		private String propertiesToString(TreeMap<String, String> props, Function<String, String> getPropGroup, Integer maxPropNameLength) {
			List<String> propStrings = new ArrayList<>();
			String lastPropGroup = "";
			for (Map.Entry<String, String> entry : props.entrySet()) {
				String propName = entry.getKey();
				String value = entry.getValue();
				String propGroup = getPropGroup.apply(propName);
				boolean isNewPropGroup = !propGroup.equals(lastPropGroup) && !propStrings.isEmpty();
				lastPropGroup = propGroup;
				propStrings.add((isNewPropGroup ? "\r\n" : "")
						+ propName
						+ " ".repeat(Math.max(0, maxPropNameLength - propName.length()))
						+ " = "
						+ value);
			}
			return String.join("\r\n", propStrings);
		}

		private void addModifiedFile(Path modifiedFilePath, String original) {
			if (!newFiles.contains(modifiedFilePath)) {
				originalFiles.putIfAbsent(modifiedFilePath, original);
			}
		}

		private void handleError() {
			error = true;
			cleanupModifiedFiles();
		}

		private String cleanupModifiedFiles() {
			List<String> errors = new ArrayList<>();
			originalFiles.forEach((path, original) -> {
				try {
					Files.writeString(path, original);
				} catch (IOException e) {
					errors.add("Changes to file [" + path.toAbsolutePath().normalize() + "] could not be reverted.");
				}
			});
			newFiles.forEach(path -> {
				try {
					Files.delete(path);
				} catch (NoSuchFileException ignored) {
				} catch (IOException e) {
					errors.add("Newly created file [" + path.toAbsolutePath().normalize() + "] could not be deleted.");
				}
			});
			if (errors.isEmpty()) return "&nbsp;&nbsp;&nbsp;&nbsp;Changes were reverted successfully";
			return "&nbsp;&nbsp;Some changes could not be reverted:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" + String.join("<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", errors);
		}

		private class SenderPipeCheckPoint {
			private List<String> serviceNames = new ArrayList<>();
			private int senderIndex = 0;
			private String name;

			public SenderPipeCheckPoint(List<String> serviceNames, String name) {
				this.serviceNames = serviceNames;
				this.name = name;
			}

			public List<String> getServiceNames() {
				return serviceNames;
			}

			public int getSenderIndex() {
				return senderIndex;
			}

			public String getName() {
				return name;
			}
		}
	}

	// Used by junit tests only
	protected void setScenarioSuffix(String suffix) {
		scenarioSuffix = suffix;
	}

}
