/*
   Copyright 2018-2020 Nationale-Nederlanden, 2020-2024 WeAreFrank!

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
package org.frankframework.ladybug.larva;

import nl.nn.testtool.Checkpoint;
import nl.nn.testtool.CheckpointType;
import nl.nn.testtool.Report;
import nl.nn.testtool.extensions.CustomReportAction;
import nl.nn.testtool.extensions.CustomReportActionResult;

import org.frankframework.util.AppConstants;
import org.frankframework.util.XmlUtils;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Instant;
import java.util.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class ConvertToLarvaAction implements CustomReportAction {

	private final AppConstants ac = AppConstants.getInstance();
	private Path dir;
	private final int SINCE = (int) TimeUnit.MILLISECONDS.toMinutes(Date.from(Instant.parse("2020-01-01T01:00:00.00Z")).getTime());

	@Override
	public String getButtonText() {
		return "Convert to Larva";
	}

	@Override
	public CustomReportActionResult handleReports(List<Report> reports) {
		CustomReportActionResult customReportActionResult = new CustomReportActionResult();
		this.dir = Paths.get(
				ac.get(ac.get("dtap.stage").equals("LOC") ? "ibistesttool.directory" : "log.dir"),
				"autogenerated"
		);

		//get minutes since 2020
		int minutes = (int) TimeUnit.MILLISECONDS.toMinutes(Calendar.getInstance().getTimeInMillis()) - SINCE;

		Map<String, ArrayList<Report>> groupedReports = new HashMap<>();
        for (Report report : reports) {
            String adapterName = report.getInputCheckpoint().getName().substring(9);
            groupedReports.computeIfAbsent(adapterName, v -> new ArrayList<>()).add(report);
        }
		List<Scenario> scenarios = groupedReports.entrySet().stream().flatMap(adapterReports -> {
			String adapterName = adapterReports.getKey();
			ArrayList<Scenario> adapterScenarios = new ArrayList<>();
			for (int i = 0; i < adapterReports.getValue().size(); i++) {
				Report report = adapterReports.getValue().get(i);
				adapterScenarios.add(new Scenario(report, dir, adapterName, Integer.parseInt(minutes + "" + i)));
			}
			return adapterScenarios.stream();
		}).collect(Collectors.toList());
		String successResultsString = scenarios.stream().filter(scenario -> !scenario.error)
				.map(scenario -> scenario.reportName)
				.collect(Collectors.joining(", "));
		String errorResultsString = scenarios.stream().filter(scenario -> !scenario.error)
				.map(scenario -> scenario.reportName)
				.collect(Collectors.joining(", "));
		if (!successResultsString.isEmpty()) {
			customReportActionResult.setSuccessMessage("Success:" + successResultsString);
		}
		if (!errorResultsString.isEmpty()) {
			customReportActionResult.setErrorMessage("Error:" + errorResultsString);
		}
		return customReportActionResult;
	}

	private static class Scenario {

		private static final HashSet<String> allowedSenders = new HashSet<>(Arrays.asList(
				"org.frankframework.senders.DelaySender",
				"org.frankframework.senders.EchoSender",
				"org.frankframework.senders.IbisLocalSender",
				"org.frankframework.senders.LogSender",
				"org.frankframework.senders.ParallelSenders",
				"org.frankframework.senders.SenderSeries",
				"org.frankframework.senders.SenderWrapper",
				"org.frankframework.senders.XsltSender",
				"org.frankframework.senders.CommandSender",
				"org.frankframework.senders.FixedResultSender",
				"org.frankframework.senders.JavascriptSender",
				"org.frankframework.jdbc.MessageStoreSender",
				"org.frankframework.senders.ReloadSender",
				"org.frankframework.compression.ZipWriterSender"
		));

		private static final HashSet<String> ignoredSessionKeys = new HashSet<>(Arrays.asList(
				"cid",
				"mid",
				"id",
				"key",
				"messageId",
				"originalMessage",
				"tcid",
				"tsReceived",
				"conversationId",
				"timestamp",
				"tsSent",
				"xPathLogKeys",
				"replyTo",
				"JmsSession",
				"servletResponse",
				"servletRequest",
				"servletContext",
				"securityHandler",
				"__isManualRetry"
		));

		private static final Set<String> ignorePropNames = Set.of(
				"ignoreRegularExpressionKey",
				"removeRegularExpressionKey",
				"decodeUnzipContentBetweenKeys",
				"canonicaliseFilePathContentBetweenKeys",
				"replaceRegularExpressionKeys",
				"ignoreContentBetweenKeys",
				"ignoreKeysAndContentBetweenKeys",
				"removeKeysAndContentBetweenKeys",
				"ignoreKey",
				"removeKey",
				"replaceKey",
				"replaceEverywhereKey",
				"ignoreCurrentTimeBetweenKeys",
				"ignoreContentBeforeKey",
				"ignoreContentAfterKey"
		);

		private final String reportName;
		private final String suffix;
		private final HashMap<Path, String> originalFiles = new HashMap<>();
		private final HashSet<Path> newFiles = new HashSet<>();
		Map<String, String> existingStubs = new HashMap<>();
		private final TreeMap<String, String> scenarioPropertiesMap = new TreeMap<>(new MultipleComparators<>(new ScenarioPropertiesComparator(), String.CASE_INSENSITIVE_ORDER));
		private final TreeMap<String, String> commonPropertiesMap =   new TreeMap<>(new MultipleComparators<>(new CommonPropertiesComparator(), String.CASE_INSENSITIVE_ORDER));
		private Path scenarioDirPath = null;
		private Path scenarioFilePath = null;
		private Path commonFilePath = null;
		private int longestCommonPropertyName = 0;
		private int longestScenarioPropertyName = 0;

		public boolean error = false;

		public Scenario(Report report, Path baseDir, String adapterName, int uuid) {
			suffix = Integer.toString(uuid, Character.MAX_RADIX);
			reportName = report.getName();

			if (!checkReportType()) return;

			Path testDir = baseDir.resolve(adapterName);
			if (!tryCreateDir(testDir)) return;

			if (!checkSuffixNotInUse(testDir)) return;

			scenarioDirPath = testDir.resolve(suffix);
			scenarioFilePath = testDir.resolve("scenario" + suffix + ".properties");
			commonFilePath = testDir.resolve("common.properties");
			if (!checkScenarioDirNotInUse()) return;
			if (!tryCreateCommonFile()) return;

			String scenarioDirPrefix = scenarioDirPath.getFileName().toString() + "/";

			if (!tryLoadCommonProps()) return;

			putScenarioProperty("scenario.description", "Test scenario for adapter " + adapterName + ", automatically generated based on a ladybug report");
			putScenarioProperty("include", "common.properties");
			String adapterProperty = "adapter." + adapterName.replaceAll("\\s","-");

			List<Checkpoint> checkpoints = report.getCheckpoints();
			int paramI = 1;
			int current_step_nr = 1;

			String adapterInputMessage = checkpoints.get(0).getMessage();
			String adapterInputFileName = getFileName(current_step_nr, "adapter", adapterName, true, adapterInputMessage);
			putScenarioProperty("step" + current_step_nr + "." + adapterProperty + ".write", scenarioDirPrefix + adapterInputFileName);
			createInputOutputFile(scenarioDirPath, adapterInputFileName, adapterInputMessage);

			putCommonProperty(adapterProperty + ".className", "org.frankframework.senders.IbisJavaSender");
			putCommonProperty(adapterProperty + ".serviceName", "testtool-" + adapterName);
			putCommonProperty(adapterProperty + ".convertExceptionToMessage", "true");

			boolean skipUntilEndOfSender = false;
			String skipUntilEndOfSenderName = "";
			int skipUntilEndOfSenderLevel = -1;

			for (Checkpoint checkpoint : checkpoints) {
				if (skipUntilEndOfSender) {
					//If we're currently stubbing a sender, and we haven't reached the end of it yet
					String checkpointName = checkpoint.getName().substring(7);
					if (checkpoint.getLevel() == skipUntilEndOfSenderLevel && checkpoint.getType() == CheckpointType.ENDPOINT.toInt() && checkpointName.equals(skipUntilEndOfSenderName)) {
						String senderResponseMessage = checkpoint.getMessage();
						String senderResponseFileName = getFileName(++current_step_nr, "stub", checkpointName, false, senderResponseMessage);
						putScenarioProperty(
								"step" + current_step_nr + ".stub." + existingStubs.get("testtool-" + checkpointName) + ".write",
								scenarioDirPrefix + senderResponseFileName);
						if (!createInputOutputFile(scenarioDirPath, senderResponseFileName, senderResponseMessage)) {
							return;
						}
						skipUntilEndOfSender = false;
					}
				} else if (checkpoint.getType() == CheckpointType.STARTPOINT.toInt() && checkpoint.getName().startsWith("Sender ")) {
					if (!allowedSenders.contains(checkpoint.getSourceClassName())) {
						//If sender should be stubbed:
						String senderName = checkpoint.getName().substring(7, checkpoint.getName().length() - 7);
						String serviceName = "testtool-" + senderName;
						//if sender is already being stubbed, use existing stub name
						String stubName = existingStubs.computeIfAbsent(serviceName.toLowerCase(), k -> senderName.replaceAll("\\s","-"));
						String senderInputMessage = checkpoint.getMessage();
						String senderInputFileName = getFileName(++current_step_nr, "stub.", stubName, true, senderInputMessage);
						putScenarioProperty(
								"step" + current_step_nr + ".stub" + stubName + ".read",
								scenarioDirPrefix + senderInputFileName);
						if (!createInputOutputFile(scenarioDirPath, senderInputFileName, senderInputMessage)) {
							return;
						}

						putCommonProperty(stubName + ".className  ", "org.frankframework.receivers.JavaListener");
						putCommonProperty(stubName + ".serviceName", serviceName);

						skipUntilEndOfSender = true;
						skipUntilEndOfSenderName = senderName;
						skipUntilEndOfSenderLevel = checkpoint.getLevel() + 1;
					}
				} else if (checkpoint.getLevel() == 1 && checkpoint.getType() == CheckpointType.INPUTPOINT.toInt() && checkpoint.getName().startsWith("SessionKey ")) {
					//SessionKey for listener found
					String sessionKeyName = checkpoint.getName().substring(11);
					if (!ignoredSessionKeys.contains(sessionKeyName)) {
						String paramPropertyName = adapterProperty + ".param" + paramI;
						putScenarioProperty(paramPropertyName + ".name ", sessionKeyName);
						putScenarioProperty(paramPropertyName + ".value", checkpoint.getMessage());
						paramI++;
					}
				}
			}
			if (skipUntilEndOfSender) {
				handleError();
				return;
			}
			String adapterOutputMessage = checkpoints.get(checkpoints.size() - 1).getMessage();
			String adapterOutputFileName = getFileName(++current_step_nr, "adapter", adapterName, false, adapterOutputMessage);
			putScenarioProperty(
					"step" + current_step_nr + "." + adapterProperty + ".read",
					scenarioDirPrefix + adapterOutputFileName);
			createInputOutputFile(scenarioDirPath, adapterOutputFileName, adapterOutputMessage);

			try {
				Files.writeString(scenarioFilePath, scenarioPropertiesToString());
				newFiles.add(scenarioFilePath);
			} catch (IOException e) {
				handleError();
				return;
			}
			try {
				if (!newFiles.contains(commonFilePath)) {
					try {
						addModifiedFile(commonFilePath, Files.readString(commonFilePath));
					} catch (IOException ex) {
						handleError();
						return;
					}
				}
				Files.writeString(commonFilePath, commonPropertiesToString());
				newFiles.add(commonFilePath);
			} catch (IOException e) {
				handleError();
			}
		}

		private void putCommonProperty(String name, String value) {
			commonPropertiesMap.put(name, value);
			longestCommonPropertyName = Math.max(longestCommonPropertyName, name.length());
		}

		private void putScenarioProperty(String name, String value) {
			scenarioPropertiesMap.put(name, value);
			longestScenarioPropertyName = Math.max(longestScenarioPropertyName, name.length());

		}

		private boolean checkReportType() {
			if (!reportName.startsWith("Pipeline ")) {
				handleError();
				return false;
			}
			return true;
		}

		private boolean tryCreateDir(Path testDir) {
			try {
				// Tries to create dir and parents. Does not throw error if it/they already exist(s)
				Files.createDirectories(testDir);
			} catch (IOException e) {
				handleError();
				return false;
			}
			return true;
		}

		private boolean checkSuffixNotInUse(Path testDir) {
			if (Files.exists(testDir.resolve(suffix)) || Files.exists(testDir.resolve("scenario" + suffix + ".properties"))) {
				handleError();
				return false;
			}
			return true;
		}

		private boolean checkScenarioDirNotInUse() {
			if (!Files.exists(scenarioDirPath)) {
				try {
					Files.createDirectory(scenarioDirPath);
				} catch (IOException e) {
					handleError();
					return false;
				}
			} else {
				try(Stream<Path> files = Files.list(scenarioDirPath)) {
					if (files.findAny().isPresent()) {
						handleError();
						return false;
					}
				} catch (IOException e) {
					handleError();
					return false;
				}
			}
			return true;
		}

		private boolean tryCreateCommonFile() {
			try {
				Files.createFile(commonFilePath);
			} catch (FileAlreadyExistsException e) {
				return true;
			} catch (IOException e) {
				handleError();
				return false;
			}
			newFiles.add(commonFilePath);
			return true;
		}

		private String getFileName(int step, String type, String name, boolean startPoint, String message) {
			return String.format("%s-%s-%s-%s%s",
					stepPadding(step),
					type,
					name,
					startPoint ? "in" : "out",
					XmlUtils.isWellFormed(message) ? ".xml" : ".txt"
			);
		}

		public static String stepPadding(int i) {
			return String.format("%0" + 2 + "d", i);
		}

		private boolean createInputOutputFile(Path folder, String fileName, String message) {
			Path messageFilePath = folder.resolve(fileName);
			File messageFile = messageFilePath.toFile();
			try {
				if (messageFile.createNewFile()) {
					newFiles.add(messageFilePath);
					Files.writeString(messageFile.toPath(), message);
				} else {
					handleError();
					return false;
				}
			} catch (IOException e) {
				handleError();
				return false;
			}
			return true;
		}

		private boolean tryLoadCommonProps() {
			Properties currentCommonProps = new Properties();
			try {
				InputStream stream = Files.newInputStream(commonFilePath);
				currentCommonProps.load(stream);
			} catch (IOException e) {
				handleError();
				return false;
			}

			currentCommonProps.forEach((key, value) -> {
				if (key instanceof String && value instanceof String) {
					putCommonProperty((String) key, (String) value);
					if (((String) key).matches("stub.[a-zA-Z0-9-_.]+\\.serviceName")) {
						existingStubs.put(((String) value).toLowerCase(), ((String) key).substring(5, ((String) key).lastIndexOf('.')));
					}
				}
			});

			return true;
		}

		private String commonPropertiesToString() {
			Function<String, String> getPropGroup = propName -> {
				int lastDotIndex;
				if (propName.equals("include")) {
					return "0";
				} else if ((lastDotIndex = propName.lastIndexOf('.')) != -1) {
					return "1" + propName.substring(0, lastDotIndex);
				}
				return "";
			};
			return propertiesToString(commonPropertiesMap, getPropGroup, longestCommonPropertyName);
		}

		private String scenarioPropertiesToString() {
			Function<String, String> getPropGroup = propName -> {
				if (propName.equals("scenario.description") || propName.equals("include")) {
					return "0";
				} else if (propName.startsWith("step")) {
					return "1";
				} else if (propName.matches("\\.param\\.(name|value)$")) {
					return "2";
				} else if (ignorePropNames.contains(propName)) {
					return "3";
				}
				return "";
			};
			return propertiesToString(scenarioPropertiesMap, getPropGroup, longestScenarioPropertyName);
		}

		private String propertiesToString(TreeMap<String, String> props, Function<String, String> getPropGroup, Integer maxPropNameLength) {
			List<String> propStrings = new ArrayList<>();
			String lastPropGroup = "";
			for (Map.Entry<String, String> entry : props.entrySet()) {
				String propName = entry.getKey();
				String value = entry.getValue();
				String propGroup = getPropGroup.apply(propName);
				boolean isNewPropGroup = !propGroup.equals(lastPropGroup) && !propStrings.isEmpty();
				lastPropGroup = propGroup;
				propStrings.add((isNewPropGroup ? "\r\n" : "")
						+ propName
						+ " ".repeat(Math.max(0, maxPropNameLength - propName.length()))
						+ " = "
						+ value);
			}
			return String.join("\r\n", propStrings);
		}

		private void addModifiedFile(Path modifiedFilePath, String original) {
			if (!newFiles.contains(modifiedFilePath)) {
				originalFiles.putIfAbsent(modifiedFilePath, original);
			}
		}

		private void handleError() {
			error = true;
			cleanupModifiedFiles();
		}

		private String cleanupModifiedFiles() {
			List<String> errors = new ArrayList<>();
			originalFiles.forEach((path, original) -> {
				try {
					Files.writeString(path, original);
				} catch (IOException e) {
					errors.add("Changes to file [" + path.toAbsolutePath().normalize() + "] could not be reverted.");
				}
			});
			newFiles.forEach(path -> {
				try {
					Files.delete(path);
				} catch (NoSuchFileException ignored) {
				} catch (IOException e) {
					errors.add("Newly created file [" + path.toAbsolutePath().normalize() + "] could not be deleted.");
				}
			});
			if (errors.isEmpty()) return "&nbsp;&nbsp;&nbsp;&nbsp;Changes were reverted successfully";
			return "&nbsp;&nbsp;Some changes could not be reverted:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" + String.join("<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", errors);
		}
	}

}
