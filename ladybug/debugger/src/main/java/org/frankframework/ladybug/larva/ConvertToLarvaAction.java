/*
   Copyright 2024 WeAreFrank!

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
package org.frankframework.ladybug.larva;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Instant;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.TimeUnit;
import java.util.function.UnaryOperator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import org.frankframework.configuration.ConfigurationUtils;
import org.frankframework.core.Resource;
import org.frankframework.util.AppConstants;
import org.frankframework.util.TransformerPool;
import org.frankframework.util.XmlUtils;
import org.springframework.stereotype.Component;

import nl.nn.testtool.Checkpoint;
import nl.nn.testtool.CheckpointType;
import nl.nn.testtool.Report;
import nl.nn.testtool.extensions.CustomReportAction;
import nl.nn.testtool.extensions.CustomReportActionResult;

@Component
public class ConvertToLarvaAction implements CustomReportAction {

	public static String scenarioSuffix;
	private final AppConstants appConstants = AppConstants.getInstance();
	private static final int MINUTES_2020 = (int) TimeUnit.MILLISECONDS.toMinutes(Instant.parse("2020-01-01T01:00:00.00Z").getEpochSecond());

	@Override
	public String getButtonText() {
		return "Convert to Larva";
	}

	@Override
	public CustomReportActionResult handleReports(List<Report> reports) {
		CustomReportActionResult customReportActionResult = new CustomReportActionResult();
		Path dir = Paths.get(
				appConstants.get(appConstants.get("dtap.stage").equals("LOC") ? "ibistesttool.directory" : "log.dir"),
				"autogenerated"
		);

		//get minutes since 2020
		int minutesSince2020 = (int) TimeUnit.MILLISECONDS.toMinutes(Instant.now().toEpochMilli()) - MINUTES_2020;

		List<Scenario> scenarios = reports.stream()
				.collect(Collectors.groupingBy(report -> report.getInputCheckpoint().getName().substring(9))).entrySet()
				.stream().<Scenario>flatMap(adapterReports -> {
					String pipelineName = adapterReports.getKey();
					List<Report> reportList = adapterReports.getValue();
					return IntStream.range(0, reportList.size())
							.mapToObj(i -> new Scenario(reportList.get(i), dir, pipelineName, Integer.parseInt(minutesSince2020 + "" + i)));
				}).collect(Collectors.toList());

		String successResultsString = scenarios.stream().filter(scenario -> !scenario.error)
				.map(scenario -> scenario.reportName)
				.collect(Collectors.joining(", "));
		String errorResultsString = scenarios.stream().filter(scenario -> scenario.error)
				.map(scenario -> scenario.reportName + ": " + scenario.errorMessage)
				.collect(Collectors.joining(", "));
		if (!successResultsString.isEmpty()) {
			customReportActionResult.setSuccessMessage("Success:" + successResultsString);
		}
		if (!errorResultsString.isEmpty()) {
			customReportActionResult.setErrorMessage("Error:" + errorResultsString);
		}
		return customReportActionResult;
	}

	private static class Scenario {

		private static final HashSet<String> allowedPipesWithSenders = new HashSet<>(Arrays.asList(
				"org.frankframework.pipes.SenderPipe",
				"org.frankframework.pipes.ForEachChildElementPipe",
				"org.frankframework.jdbc.ResultSetIteratingPipe",
				"org.frankframework.pipes.StreamLineIteratorPipe",
				"org.frankframework.compression.ZipIteratorPipe",
				"org.frankframework.filesystem.ForEachAttachmentPipe",
				"org.frankframework.jdbc.ClobLineIteratingPipe",
				"org.frankframework.jdbc.BlobLineIteratingPipe",
				"org.frankframework.pipes.AsyncSenderWithListenerPipe"
		));

		private static final HashSet<String> allowedSenders = new HashSet<>(Arrays.asList(
				"org.frankframework.jdbc.ResultSet2FileSender",
				"org.frankframework.jdbc.DirectQuerySender",
				"org.frankframework.jdbc.FixedQuerySender",
				"org.frankframework.jdbc.XmlQuerySender",
				"org.frankframework.senders.DelaySender",
				"org.frankframework.senders.EchoSender",
				"org.frankframework.senders.IbisLocalSender",
				"org.frankframework.senders.LogSender",
				"org.frankframework.senders.ParallelSenders",
				"org.frankframework.senders.SenderSeries",
				"org.frankframework.senders.SenderWrapper",
				"org.frankframework.senders.XsltSender",
				"org.frankframework.senders.CommandSender",
				"org.frankframework.senders.FixedResultSender",
				"org.frankframework.senders.JavascriptSender",
				"org.frankframework.jdbc.MessageStoreSender",
				"org.frankframework.senders.ReloadSender",
				"org.frankframework.compression.ZipWriterSender",
				"org.frankframework.senders.LocalFileSystemSender"
		));

		private static final HashSet<String> ignoredSessionKeys = new HashSet<>(Arrays.asList(
				"cid",
				"mid",
				"id",
				"key",
				"messageId",
				"originalMessage",
				"tcid",
				"tsReceived",
				"conversationId",
				"timestamp",
				"tsSent",
				"xPathLogKeys",
				"replyTo",
				"JmsSession",
				"servletResponse",
				"servletRequest",
				"servletContext",
				"securityHandler",
				"__isManualRetry"
		));

		private static final Set<String> ignorePropNames = Set.of(
				"ignoreRegularExpressionKey",
				"removeRegularExpressionKey",
				"decodeUnzipContentBetweenKeys",
				"canonicaliseFilePathContentBetweenKeys",
				"replaceRegularExpressionKeys",
				"ignoreContentBetweenKeys",
				"ignoreKeysAndContentBetweenKeys",
				"removeKeysAndContentBetweenKeys",
				"ignoreKey",
				"removeKey",
				"replaceKey",
				"replaceEverywhereKey",
				"ignoreCurrentTimeBetweenKeys",
				"ignoreContentBeforeKey",
				"ignoreContentAfterKey"
		);

		private static final String TESTTOOL_PREFIX = "testtool-";
		// step number - type- name - in/out . fileExtension
		// E.g. 01-adapter-ItemIterator-in.xml
		private static final String filenameFormat = "%s-%s-%s-%s.%s";
		private final String reportName;
		private final String suffix;
		private final HashMap<Path, String> originalFiles = new HashMap<>();
		private final HashSet<Path> newFiles = new HashSet<>();
		Map<String, String> existingStubs = new HashMap<>();
		private final TreeMap<String, String> scenarioPropertiesMap = new TreeMap<>(new MultipleComparators<>(new ScenarioPropertiesComparator(), String.CASE_INSENSITIVE_ORDER));
		private final TreeMap<String, String> commonPropertiesMap =   new TreeMap<>(new MultipleComparators<>(new CommonPropertiesComparator(), String.CASE_INSENSITIVE_ORDER));
		private int longestCommonPropertyName = 0;
		private int longestScenarioPropertyName = 0;
		private int stepCounter = 1;

		private boolean error = false;

		private String errorMessage;

		public Scenario(Report report, Path baseDir, String pipelineName, int uuid) {
			if(scenarioSuffix != null) {
				suffix = scenarioSuffix;
			} else {
				suffix = Integer.toString(uuid, Character.MAX_RADIX);
			}

			reportName = report.getName();

			if (!reportName.startsWith("Pipeline ")) {
				handleError();
				return;
			}

			Path testDir = baseDir.resolve(pipelineName);
			if (!tryCreateDir(testDir)) return;

			if (Files.exists(testDir.resolve(suffix)) || Files.exists(testDir.resolve("scenario" + suffix + ".properties"))) {
				handleError();
				return;
			}

			Path scenarioDirPath = testDir.resolve(suffix);
			Path scenarioFilePath = testDir.resolve("scenario" + suffix + ".properties");
			Path commonFilePath = testDir.resolve("common.properties");
			if (!checkScenarioDirNotInUse(scenarioDirPath)) return;
			if (!tryCreateCommonFile(commonFilePath)) return;

			String scenarioDirPrefix = scenarioDirPath.getFileName().toString() + "/";

			if (!tryLoadCommonProps(commonFilePath)) return;

			String adapterName = getAdapterName(pipelineName);

			scenarioPropertiesMap.put("scenario.description", "Test scenario for adapter " + adapterName + ", automatically generated based on a ladybug report");
			scenarioPropertiesMap.put("include", "common.properties");

			List<Checkpoint> checkpoints = report.getCheckpoints();

			String adapterInputMessage = checkpoints.get(0).getMessage();
			if(adapterInputMessage == null) {
				adapterInputMessage = "";
			}
			String adapterInputFileName = getFileName(stepCounter, "adapter", adapterName, true, adapterInputMessage);
			scenarioPropertiesMap.put("step" + stepCounter + ".adapter." + adapterName + ".write", scenarioDirPrefix + adapterInputFileName);
			createInputOutputFile(scenarioDirPath, adapterInputFileName, adapterInputMessage);

			commonPropertiesMap.putIfAbsent("adapter." + adapterName + ".className", "org.frankframework.senders.IbisJavaSender");
			commonPropertiesMap.putIfAbsent("adapter." + adapterName + ".serviceName", TESTTOOL_PREFIX + adapterName);
			commonPropertiesMap.putIfAbsent("adapter." + adapterName + ".convertExceptionToMessage", "true");

			processCheckPoints(checkpoints, adapterName, scenarioDirPath, scenarioDirPrefix);

			String adapterOutputMessage = checkpoints.get(checkpoints.size() - 1).getMessage();
			String adapterOutputFileName = getFileName(++stepCounter, "adapter", adapterName, false, adapterOutputMessage);
			scenarioPropertiesMap.put(
					"step" + stepCounter + ".adapter." + adapterName + ".read",
					scenarioDirPrefix + adapterOutputFileName);
			createInputOutputFile(scenarioDirPath, adapterOutputFileName, adapterOutputMessage);

			longestCommonPropertyName = commonPropertiesMap.keySet().stream().max(Comparator.comparing(String::length)).get().length();
			longestScenarioPropertyName = scenarioPropertiesMap.keySet().stream().max(Comparator.comparing(String::length)).get().length();

			try {
				Files.writeString(scenarioFilePath, scenarioPropertiesToString());
				newFiles.add(scenarioFilePath);

				if (!newFiles.contains(commonFilePath)) {
					try {
						addModifiedFile(commonFilePath, Files.readString(commonFilePath));
					} catch (IOException ex) {
						handleError();
						return;
					}
				}
				Files.writeString(commonFilePath, commonPropertiesToString());
				newFiles.add(commonFilePath);
			} catch (IOException e) {
				handleError();
				return;
			}
		}

		private void processCheckPoints(List<Checkpoint> checkpoints, String adapterName, Path scenarioDirPath, String scenarioDirPrefix) {
			int paramI = 1;
			boolean skipUntilEndOfSender = false;
			String skipUntilEndOfSenderName = "";
			int skipUntilEndOfSenderLevel = -1;
			String queueName = null;

			Deque<SenderPipeCheckPoint> senderPipeStack = new ArrayDeque<>();

			for (Checkpoint checkpoint : checkpoints) {
				// Create params in the scenario for session keys that are not in ignoredSessionKeys
				if (checkpoint.getLevel() == 1 && checkpoint.getType() == CheckpointType.INPUTPOINT.toInt() && checkpoint.getName().startsWith("SessionKey ")) {
					// SessionKey for listener found
					String sessionKeyName = checkpoint.getName().substring("SessionKey ".length());
					if (!ignoredSessionKeys.contains(sessionKeyName)) {
						String paramPropertyName = "adapter." + adapterName + ".param" + paramI;
						scenarioPropertiesMap.put(paramPropertyName + ".name ", sessionKeyName);
						String messageInOneLine = "";
						if(checkpoint.getMessage() != null) {
							messageInOneLine = checkpoint.getMessage().replaceAll("\\n|\\r\\n", "");
						}
						scenarioPropertiesMap.put(paramPropertyName + ".value", messageInOneLine);
						paramI++;
					}
				} else if (skipUntilEndOfSender && checkpoint.getName().startsWith("Sender ")) {
					// If we're currently stubbing a sender, and we haven't reached the end of it yet
					String checkpointName = checkpoint.getName();
					if (checkpoint.getLevel() == skipUntilEndOfSenderLevel && checkpoint.getType() == CheckpointType.ENDPOINT.toInt() && checkpointName.equals(skipUntilEndOfSenderName)) {
						String senderResponseMessage = checkpoint.getMessage();
						String senderResponseFileName = getFileName(++stepCounter, "stub", queueName, false, senderResponseMessage);
						scenarioPropertiesMap.put("step" + stepCounter + ".stub." + queueName + ".write",
								scenarioDirPrefix + senderResponseFileName);
						if (!createInputOutputFile(scenarioDirPath, senderResponseFileName, senderResponseMessage)) {
							return;
						}
						skipUntilEndOfSender = false;
						senderPipeStack.peek().senderIndex++;
					}
				} else if (checkpoint.getType() == CheckpointType.STARTPOINT.toInt() && checkpoint.getName().startsWith("Sender ")) {
					if (!allowedSenders.contains(checkpoint.getSourceClassName())) {
						// If sender should be stubbed:
						String serviceName = null;
						SenderPipeCheckPoint sp = senderPipeStack.peek();
						if(sp != null && sp.getServiceNames().size() > sp.getSenderIndex()) {
							serviceName = sp.getServiceNames().get(sp.getSenderIndex());
						} else {
							serviceName = determineStubName(checkpoints, checkpoint);
						}
						queueName = serviceName.substring(TESTTOOL_PREFIX.length());
						// If sender is already being stubbed, use existing stub name
						if(existingStubs.containsKey(serviceName)) {
							queueName = existingStubs.get(serviceName);
						} else {
							existingStubs.put(serviceName, queueName);
						}
						String senderInputMessage = checkpoint.getMessage() == null ? "" : checkpoint.getMessage();
						String senderInputFileName = getFileName(++stepCounter, "stub", queueName, true, senderInputMessage);
						scenarioPropertiesMap.put("step" + stepCounter + ".stub." + queueName + ".read", scenarioDirPrefix + senderInputFileName);

						if (!createInputOutputFile(scenarioDirPath, senderInputFileName, senderInputMessage)) {
							return;
						}

						commonPropertiesMap.putIfAbsent("stub." + queueName + ".className", "org.frankframework.receivers.JavaListener");
						commonPropertiesMap.putIfAbsent("stub." + queueName + ".serviceName", serviceName);

						skipUntilEndOfSender = true;
						skipUntilEndOfSenderName = checkpoint.getName();
						skipUntilEndOfSenderLevel = checkpoint.getLevel() + 1;
					}
				} else if(checkpoint.getType() == CheckpointType.INFOPOINT.toInt() && allowedPipesWithSenders.contains(checkpoint.getSourceClassName())) {
					String stubbedPipe = null;
					try {
						Resource xslt = Resource.getResource(ConfigurationUtils.STUB4TESTTOOL_XSLT_DEFAULT);
						TransformerPool tp = TransformerPool.getInstance(xslt);
						stubbedPipe = tp.transform(checkpoint.getMessage());
						// Extract sender testtool names from the pipe configuration 
						String regex = TESTTOOL_PREFIX + "([^\"]+)";

						Pattern pattern = Pattern.compile(regex);
						Matcher matcher = pattern.matcher(stubbedPipe);
						List<String> serviceNames = new ArrayList<>();
						while (matcher.find()) {
							serviceNames.add(TESTTOOL_PREFIX + matcher.group(1));
						}
						senderPipeStack.push(new SenderPipeCheckPoint(serviceNames, checkpoint.getName()));
					} catch(Exception e) {
						// Ignore exception stub name will be determined by a different approach
					}
				} else if(checkpoint.getType() == CheckpointType.ENDPOINT.toInt() && !senderPipeStack.isEmpty() &&checkpoint.getName().equals(senderPipeStack.peek().getName())) {
					senderPipeStack.pop();
				}
			}
			if (skipUntilEndOfSender) {
				handleError();
				return;
			}
			
		}

		private String getAdapterName(String pipelineName) {
			String[] pipelineNameParts = pipelineName.split("/");
			return pipelineNameParts.length > 1 ?  pipelineNameParts[1] : pipelineNameParts[0];
		}

		private String determineStubName(List<Checkpoint> checkpoints, Checkpoint checkpoint) {
			int currentIndex = checkpoints.indexOf(checkpoint);
			StringBuilder sb = new StringBuilder(TESTTOOL_PREFIX);
			// reverse search to find the parent sender checkpoint
			Optional<Checkpoint> parentCheckPoint = IntStream.range(0, currentIndex)
					.mapToObj(i -> checkpoints.get(currentIndex - 1 - i))
					.filter(cp -> cp.getLevel() < checkpoint.getLevel() && !cp.getName().equals("Thread"))
					.findFirst();

			if(parentCheckPoint.isPresent() && allowedPipesWithSenders.contains(parentCheckPoint.get().getSourceClassName())) {
				sb.append(parentCheckPoint.get().getName().substring("Pipe ".length()));
			} else if(!checkpoint.getName().equals("Sender IbisJavaSender")) {
				sb.append(checkpoint.getName().substring("Sender ".length()));
			}

			return sb.toString();
		}

		private boolean tryCreateDir(Path testDir) {
			try {
				// Tries to create dir and parents. Does not throw error if it/they already exist(s)
				Files.createDirectories(testDir);
			} catch (IOException e) {
				handleError();
				return false;
			}
			return true;
		}

		private boolean checkScenarioDirNotInUse(Path scenarioDirPath) {
			if (!Files.exists(scenarioDirPath)) {
				try {
					Files.createDirectory(scenarioDirPath);
				} catch (IOException e) {
					handleError();
					return false;
				}
			} else {
				try(Stream<Path> files = Files.list(scenarioDirPath)) {
					if (files.findAny().isPresent()) {
						handleError();
						return false;
					}
				} catch (IOException e) {
					handleError();
					return false;
				}
			}
			return true;
		}

		private boolean tryCreateCommonFile(Path commonFilePath) {
			try {
				Files.createFile(commonFilePath);
			} catch (FileAlreadyExistsException e) {
				return true;
			} catch (IOException e) {
				handleError();
				return false;
			}
			newFiles.add(commonFilePath);
			return true;
		}

		private String getFileName(int step, String type, String name, boolean startPoint, String message) {
			String fileExtension = determineFileExtension(message);
			return String.format(filenameFormat,
					stepPadding(step),
					type,
					name,
					startPoint ? "in" : "out",
					fileExtension
			);
		}

		private String determineFileExtension(String message) {
			if(XmlUtils.isWellFormed(message)) {
				return "xml";
			} else if(message.trim().startsWith("{")) {
				return "json";
			} else {
				return "txt";
			}
		}

		private String stepPadding(int i) {
			return String.format("%0" + 2 + "d", i);
		}

		private boolean createInputOutputFile(Path folder, String fileName, String message) {
			Path messageFilePath = folder.resolve(fileName);
			File messageFile = messageFilePath.toFile();
			try {
				if (messageFile.createNewFile()) {
					newFiles.add(messageFilePath);
					Files.writeString(messageFile.toPath(), message);
				} else {
					handleError();
					return false;
				}
			} catch (IOException e) {
				handleError();
				return false;
			}
			return true;
		}

		private boolean tryLoadCommonProps(Path commonFilePath) {
			Properties currentCommonProps = new Properties();
			try {
				InputStream stream = Files.newInputStream(commonFilePath);
				currentCommonProps.load(stream);
			} catch (IOException e) {
				handleError();
				return false;
			}
			currentCommonProps.forEach((key, value) -> {
				if (key instanceof String stringKey && value instanceof String stringValue) {
					commonPropertiesMap.putIfAbsent(stringKey, stringValue);
					if (stringKey.startsWith("stub.") && stringKey.endsWith(".serviceName")) {
						String queueName = stringKey.substring(stringKey.indexOf(".") + 1, stringKey.lastIndexOf('.'));
						existingStubs.put(stringValue.toLowerCase(), queueName);
					}
				}
			});

			return true;
		}

		private String commonPropertiesToString() {
			UnaryOperator<String> getPropGroup = propName -> {
				int lastDotIndex;
				if (propName.equals("include")) {
					return "0";
				} else if ((lastDotIndex = propName.lastIndexOf('.')) != -1) {
					return "1" + propName.substring(0, lastDotIndex);
				}
				return "";
			};
			return propertiesToString(commonPropertiesMap, getPropGroup, longestCommonPropertyName);
		}

		private String scenarioPropertiesToString() {
			UnaryOperator<String> getPropGroup = propName -> {
				if (propName.equals("scenario.description") || propName.equals("include")) {
					return "0";
				} else if (propName.startsWith("step")) {
					return "1";
				} else if (propName.matches("\\.param\\.(name|value)$")) {
					return "2";
				} else if (ignorePropNames.contains(propName)) {
					return "3";
				}
				return "";
			};
			return propertiesToString(scenarioPropertiesMap, getPropGroup, longestScenarioPropertyName);
		}

		private String propertiesToString(TreeMap<String, String> props, UnaryOperator<String> getPropGroup, Integer maxPropNameLength) {
			List<String> propStrings = new ArrayList<>();
			String lastPropGroup = "";
			for (Map.Entry<String, String> entry : props.entrySet()) {
				String propName = entry.getKey();
				String value = entry.getValue();
				String propGroup = getPropGroup.apply(propName);
				boolean isNewPropGroup = !propGroup.equals(lastPropGroup) && !propStrings.isEmpty();
				lastPropGroup = propGroup;
				propStrings.add((isNewPropGroup ? "\r\n" : "")
						+ propName
						+ " ".repeat(Math.max(0, maxPropNameLength - propName.length()))
						+ " = "
						+ value);
			}
			return String.join("\r\n", propStrings);
		}

		private void addModifiedFile(Path modifiedFilePath, String original) {
			if (!newFiles.contains(modifiedFilePath)) {
				originalFiles.putIfAbsent(modifiedFilePath, original);
			}
		}

		private void handleError() {
			error = true;
			errorMessage = cleanupModifiedFiles();
		}

		private String cleanupModifiedFiles() {
			List<String> errors = new ArrayList<>();
			originalFiles.forEach((path, original) -> {
				try {
					Files.writeString(path, original);
				} catch (IOException e) {
					errors.add("Changes to file [" + path.toAbsolutePath().normalize() + "] could not be reverted.");
				}
			});
			newFiles.forEach(path -> {
				try {
					Files.delete(path);
				} catch (NoSuchFileException ignored) {
					// No need to delete the file if it does not exist somehow 
				} catch (IOException e) {
					errors.add("Newly created file [" + path.toAbsolutePath().normalize() + "] could not be deleted.");
				}
			});
			if (errors.isEmpty()) return "&nbsp;&nbsp;&nbsp;&nbsp;Changes were reverted successfully";
			return "&nbsp;&nbsp;Some changes could not be reverted:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" + String.join("<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;", errors);
		}

		private static class SenderPipeCheckPoint {
			private List<String> serviceNames = new ArrayList<>();
			private int senderIndex = 0;
			private String name;

			public SenderPipeCheckPoint(List<String> serviceNames, String name) {
				this.serviceNames = serviceNames;
				this.name = name;
			}

			public List<String> getServiceNames() {
				return serviceNames;
			}

			public int getSenderIndex() {
				return senderIndex;
			}

			public String getName() {
				return name;
			}
		}
	}

}
