<body>

<h1>Introduction</h1>

The Frank!Framework offers services to integrate other software applications.
The typical end user owns many software applications that need to communicate in
a standardized way. This is done by connecting the individual software
applications to an instance of the Frank!Framework.
<p>
When some existing software application A wants to reach another existing
application B, then A typically accesses the integration solution
instead. The integration solution receives the incoming message and
transforms it to a format that B can understand. The transformed
message is sent to B. This is a very simplified view, but it allows
us to introduce the basic building blocks offered by the Frank!Framework.
<p>
The most important building blocks are listeners, pipes, senders and receivers.
Listeners are the building blocks that accept incoming messages. Messages can
originate from HTTP requests, the file system, the database and more, which
explains that there are many types of listeners. Listeners are wrapped in
receivers that add additional services about logging and transaction
management. Pipes are used to transform messages. Each possible
transformation of a message has its own type of pipe. Finally, senders
write messages to the database, send them as HTTP requests, write
them to files or send them elsewhere. Each of these possibilities
has its own type of sender.
<p>
Integration solutions are typically developed by Frank developers, who
decide how the building blocks have to be combined and configured.
Frank developers provide this information through XML files and properties
files. The Frank!Framework parses these XML files into networks of
Java objects that can provide the actual integration solution. The
Frank!Framework also allows developers to work with a graphical
user interface, the Frank!Flow.
<p>
The Frank!Framework is a Java application that provides a web interface.
It runs on an application server. WeAreFrank! supports running the
Frank!Framework on Apache Tomcat, JBoss Application Server (recently renamed to WildFly)
or WebSphere Application Server. The web interface is typically
used by operators who are responsible for the proper operation
of the integration solution, or as WeAreFrank! says: the Frank.
WeAreFrank! also hosts the Frank!Framework for demonstration purposes.
You can find it at <a href="https://ibis4example.ibissource.org">https://ibis4example.ibissource.org</a>.

To understand the Frank!Framework from a user perspective, please
read the <a href="http://frank-manual.readthedocs.io">Frank!Manual</a>. Another
source of user documentation is the Frank!Doc, which you can download from the
Frank!Framework's web console at <a href="https://ibis4example.ibissource.org">https://ibis4example.ibissource.org</a>.
<p>

<h1>Building blocks</h1>

Most building blocks are defined by Java interfaces in the package
{@link nl.nn.adapterframework.core}. All pipes implement
interface {@link nl.nn.adapterframework.core.IPipe}. All
listeners implement {@link nl.nn.adapterframework.core.IListener}.
We have class {@link nl.nn.adapterframework.receivers.Receiver}.
And all senders implement {@link nl.nn.adapterframework.core.ISender}.
There are two additional building blocks to hold groups of other
building blocks, namely adapters and configurations. An adapter,
implemented by {@link nl.nn.adapterframework.core.IAdapter},
plays the role of a function. It holds one or more receivers that listen to input
messages. Each adapter holds a network of pipes to transform
incoming messages. Pipe type
{@link nl.nn.adapterframework.pipes.SenderPipe}
wraps a sender and routes its incoming messages to the sender.
This way, adapters can produce output messages.
<p>
A configuration is a group of adapters that can be deployed
independently. A complex integration solution, or Frank,
consists of multiple configuration that each have their own
life cycle. Configurations help developers and their customers to
coordinate the release process.

<h1>Life cycle</h1>

When the Frank!Framework starts, it has to load all configurations.
The application server calls {@link nl.nn.adapterframework.lifecycle.IbisApplicationServlet#init},
which in turn calls
{@link nl.nn.adapterframework.configuration.IbisContext#init}.
Starting all configurations is the responsibility of
{@link nl.nn.adapterframework.configuration.IbisContext}.

Class {@link nl.nn.adapterframework.configuration.IbisContext} ensures
that configurations are independent. Properties set in one configuration
should not be visible to other configurations. The same holds for custom
Java classes that are part of a configuration.
Class {@link nl.nn.adapterframework.configuration.IbisContext} achieves
this by creating new {@link ClassLoader} instances. Each
configuration is loaded using its own {@link ClassLoader}. Furthermore, class
{@link nl.nn.adapterframework.configuration.Configuration} implements
Spring interface {@link org.springframework.context.ApplicationContext}.
This way, each configuration has an independent network of objects that is reachable through Spring.

<p>
Properties are then read using class {@link nl.nn.adapterframework.util.AppConstants}.
To understand what {@link nl.nn.adapterframework.util.AppConstants} is
supposed to do, please read the <a href="https://frank-manual.readthedocs.io/en/latest/advancedDevelopment/properties/properties.html">
appropriate section of the Frank!Manual</a>. You can read there that many property
files are read in a specific order. That order itself is read from
a properties file named "AppConstants.properties". A default version of this
file is included within the Frank!Framework.
<p>
Configurations are parsed using the
<a href="https://commons.apache.org/proper/commons-digester/">Apache library commons-digester</a>.
This library processes input files that reference building blocks by their
qualified Java class name, for example:
<pre>{@code
<listener className="nl.nn.adapterframework.receivers.JavaListener"
    name="TestMessageStoreSender"/>
}</pre>
Frank developers are allowed to write Frank configurations in that syntax, which we
call "syntax 1". WeAreFrank! also supports a more friendly syntax that references building blocks
by human-readable names, for example:
<pre>{@code
<JavaListener name="TestMessageStoreSender"/>
}
</pre>
This is syntax syntax 2. Parsing is done by method {@link nl.nn.adapterframework.configuration.ConfigurationDigester#digest()}.
This logic uses a XML schema file <code>FrankConfig-compatibility.xsd</code> to transform syntax 2 to syntax 1.
This file is produced by a doclet that we have implemented in the <a href="https://github.com/ibissource/frank-doc">Frank!Doc</a>
project. Our Maven build attaches this file to our source code JAR to make it available at run-time.

<h1>Web based</h1>

<h1>Database</h1>

<h1>Management</h1>

<h1>Utilities</h1>

</body>