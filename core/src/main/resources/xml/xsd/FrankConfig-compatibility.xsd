<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" version="8.0-SNAPSHOT">
  <xs:element name="Configuration" type="ConfigurationType" />
  <xs:complexType name="ConfigurationType">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Include" minOccurs="0" maxOccurs="unbounded" type="IncludeType" />
        <xs:element name="Adapter" minOccurs="0" maxOccurs="unbounded" type="AdapterType" />
        <xs:element name="Scheduler" minOccurs="0" maxOccurs="1" type="SchedulerType" />
        <xs:group ref="JobElementGroup" minOccurs="0" maxOccurs="unbounded" />
        <xs:element name="SapSystems" minOccurs="0" maxOccurs="1" type="SapSystemsType" />
        <xs:element name="JmsRealms" minOccurs="0" maxOccurs="1" type="JmsRealmsType" />
        <xs:element name="JmsRealm" minOccurs="0" maxOccurs="unbounded" type="JmsRealmType" />
        <xs:element name="Monitoring" minOccurs="0" maxOccurs="1" type="MonitoringType" />
        <xs:element name="SharedResources" minOccurs="0" maxOccurs="1" type="SharedResourcesType" />
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="autoStart" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If the Configuration should automatically start all Adapters and Jobs.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Configurations should be wired through Spring, which in turn should call #setBeanName(String).
 Once the ConfigurationContext has a name it should not be changed anymore, hence
 super.setBeanName(String) only sets the name once.
 If not created by Spring, the setIdCalled flag in AbstractRefreshableConfigApplicationContext wont be set, allowing the name to be updated.

 The DisplayName will always be updated, which is purely used for logging purposes.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.configuration.Configuration" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="IncludeType">
    <xs:attribute name="ref" type="xs:string">
      <xs:annotation>
        <xs:documentation>reference to a configuration to be included in the current.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.configuration.Include" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="include" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="AdapterType">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Receiver" minOccurs="1" maxOccurs="unbounded" type="ReceiverType" />
        <xs:group ref="ErrorMessageFormatterElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:element name="Pipeline" minOccurs="1" maxOccurs="1" type="PipelineType" />
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the adapter</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="description" type="xs:string">
      <xs:annotation>
        <xs:documentation>some functional description of the &lt;code&gt;Adapter&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoStart" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>AutoStart indicates that the adapter should be started when the configuration
 is started. Default: &lt;code&gt;true&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceNullMessage" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt; a null message is replaced by an empty message Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageKeeperSize" type="frankInt">
      <xs:annotation>
        <xs:documentation>number of message displayed in ibisconsole Default: 10</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="msgLogLevel">
      <xs:annotation>
        <xs:documentation>Defines behaviour for logging messages. Configuration is done in the MSG appender in log4j4ibis.properties. Default: &lt;code&gt;INFO, unless overridden by property msg.log.level.default&lt;/code&gt;</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="MessageLogLevelAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="requestReplyLogging" type="frankBoolean" />
    <xs:attribute name="msgLogHidden" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the length of the message is shown in the msg log instead of the content of the message Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetDesignDocument" type="xs:string" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.Adapter" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="adapter" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="ReceiverType">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="ListenerElementGroup" minOccurs="1" maxOccurs="1" />
        <xs:group ref="SenderElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:group ref="ErrorSenderElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:group ref="ErrorStorageElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:group ref="MessageLogElementGroup" minOccurs="0" maxOccurs="1" />
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Sets the name of the Receiver, as known to the Adapter.
 If the listener implements the name interface and &lt;code&gt;getName()&lt;/code&gt;
 of the listener is empty, the name of this object is given to the listener.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onError">
      <xs:annotation>
        <xs:documentation>One of 'continue' or 'close'. Controls the behaviour of the Receiver when it encounters an error sending a reply or receives an exception asynchronously Default: CONTINUE</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="OnErrorAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="numThreads" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of threads that may execute a Pipeline concurrently (only for pulling listeners) Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numThreadsPolling" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of threads that are actively polling for messages concurrently. '0' means 'limited only by &lt;code&gt;numthreads&lt;/code&gt;' (only for pulling listeners) Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pollInterval" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of seconds waited after an unsuccessful poll attempt, before another poll attempt is made. Only for polling listeners, not for e.g. jms, webservice or javaListeners Default: 10</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) to start receiver. If this timeout is exceeded, the Receiver startup is
  aborted and all resources closed and the receiver will be in state {@code EXCEPTION_STARTING}
  and a new start command may be issued again.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stopTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) to stop receiver. If this timeout is exceeded, stopping will be aborted
  and the receiver will be in state {@code EXCEPTION_STOPPING}.
  The receiver will no longer be running but some resources might not have been cleaned up properly.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkForDuplicates" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, each message is checked for presence in the messageLog. If already present, it is not processed again. Only required for non XA compatible messaging. Requires messageLog! Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkForDuplicatesMethod">
      <xs:annotation>
        <xs:documentation>(Only used when &lt;code&gt;checkForDuplicates=true&lt;/code&gt;) Indicates whether the messageid or the correlationid is used for checking presence in the message log Default: MESSAGEID</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="CheckForDuplicatesMethodAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="maxDeliveries" type="frankInt">
      <xs:annotation>
        <xs:documentation>The maximum delivery count after which to stop processing the message (only for listeners that know the delivery count of received messages). If -1 the delivery count is ignored Default: 5</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRetries" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of times a processing attempt is automatically retried after an exception is caught or rollback is experienced. If &lt;code&gt;maxRetries &amp;lt; 0&lt;/code&gt; the number of attempts is infinite Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="processResultCacheSize" type="frankInt">
      <xs:annotation>
        <xs:documentation>Size of the cache to keep process results, used by maxRetries Default: 100</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="returnedSessionKeys" type="xs:string" />
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>XPath expression to extract correlationid from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for correlationIDXPath. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>Stylesheet to extract correlationID from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>XPath expression to extract label from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for labelXPath. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>Stylesheet to extract label from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the character data in this XML element is stored inside a session key and in the message it is replaced by a reference to this session key: {sessionKey: + &lt;code&gt;elementToMoveSessionKey&lt;/code&gt; + }</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Only used when &lt;code&gt;elementToMove&lt;/code&gt; or &lt;code&gt;elementToMoveChain&lt;/code&gt; is set) Name of the session key wherein the character data is stored Default: ref_ + the name of the element</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>Like &lt;code&gt;elementToMove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. adapter;pipeline;pipe)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="frankBoolean" />
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>Regular expression to mask strings in the errorStore/logStore. Every character between to the strings in this expression will be replaced by a '*'. For example, the regular expression (?&amp;lt;=&amp;lt;party&amp;gt;).*?(?=&amp;lt;/party&amp;gt;) will replace every character between keys &amp;lt;party&amp;gt; and &amp;lt;/party&amp;gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod">
      <xs:annotation>
        <xs:documentation>Only used when hideRegex is not empty Default: all</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="HideMethodAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="hiddenInputSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of keys of session variables which are available when the &lt;code&gt;PipelineSession&lt;/code&gt; is created and of which the value will not be shown in the log (replaced by asterisks)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forceRetryFlag" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, every message read will be processed as if it is being retried, by setting a session variable to retry. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numberOfExceptionsCaughtWithoutMessageBeingReceivedThreshold" type="frankInt">
      <xs:annotation>
        <xs:documentation>Number of connection attempts to put the adapter in warning status Default: 5</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="transacted" />
    <xs:attribute ref="transactionTimeout" />
    <xs:attribute ref="transactionAttribute" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.receivers.Receiver" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="receiver" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="PipelineType">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="InputValidatorElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:group ref="OutputValidatorElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:group ref="InputWrapperElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:group ref="OutputWrapperElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:element name="Exits" minOccurs="0" maxOccurs="1" type="ExitsType" />
        <xs:element name="Exit" minOccurs="0" maxOccurs="unbounded" type="ExitType" />
        <xs:element name="GlobalForwards" minOccurs="0" maxOccurs="1" type="GlobalForwardsType" />
        <xs:element name="Forward" minOccurs="0" maxOccurs="unbounded" type="ForwardType" />
        <xs:element name="Locker" minOccurs="0" maxOccurs="1" type="LockerType" />
        <xs:group ref="CacheElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:group ref="PipeElementGroup" minOccurs="1" maxOccurs="unbounded" />
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="firstPipe" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the first pipe to execute when a message is to be processed Default: first pipe of the pipeline</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxThreads" type="frankInt">
      <xs:annotation>
        <xs:documentation>Maximum number of threads that may execute this Pipeline simultaneously, use 0 to disable limit Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeOriginalMessageWithoutNamespaces" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; the original message without namespaces (and prefixes) is stored under the session key originalMessageWithoutNamespaces Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageSizeWarn" type="xs:string">
      <xs:annotation>
        <xs:documentation>If messageSizeWarn&gt;=0 and the size of the input or result pipe message exceeds the value specified a warning message is logged. You can specify the value with the suffixes &lt;code&gt;KB&lt;/code&gt;, &lt;code&gt;MB&lt;/code&gt; or &lt;code&gt;GB&lt;/code&gt; Default: application default (30MB)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transformNullMessage" type="xs:string">
      <xs:annotation>
        <xs:documentation>when specified and &lt;code&gt;null&lt;/code&gt; is received as a message the message is changed to the specified value</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="adapterToRunBeforeOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when specified and an empty message is received the specified adapter is run before passing the message (response from specified adapter) to the pipeline</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="transacted" />
    <xs:attribute ref="transactionTimeout" />
    <xs:attribute ref="transactionAttribute" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.PipeLine" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="pipeline" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="ExitsType">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Exit" minOccurs="1" maxOccurs="unbounded" type="ExitType" />
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.PipeLineExits" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="exits" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="ExitType">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the Exit that can be referenced by a PipeForward's &lt;code&gt;path&lt;/code&gt; attribute. When a Pipeline doesn't have an Exits
 element configured it will be initialized with one Exit having name READY (and state SUCCESS)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="path" type="xs:string" />
    <xs:attribute name="state" use="required">
      <xs:annotation>
        <xs:documentation>The state of the Pipeline that is returned to the Receiver for this Exit. When a Pipeline doesn't have an Exits
 element configured it will be initialized with one Exit having state SUCCESS (and name READY)</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="ExitStateAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="code" type="frankInt">
      <xs:annotation>
        <xs:documentation>HTTP statusCode e.g. &lt;code&gt;500&lt;/code&gt; Default: 200</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="responseRoot" type="xs:string">
      <xs:annotation>
        <xs:documentation>Configures the responseRoot in the OpenAPI schema for this exit. If not set, the responseRoot value of the validator will be used. If that contains multiple (comma separated) values, the first will be used for the exits with state &lt;code&gt;SUCCESS&lt;/code&gt;, the last for the other exits.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="empty" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If using RestListener and set to &lt;code&gt;true&lt;/code&gt;, this removes the output and shows a blank page, the output is still logged in the ladybug testtool Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipWrapping" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the output will not be wrapped by the OutputWrapper. Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipValidation" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the output will not be validated or transformed by the validator. Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.PipeLineExit" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="exit" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="GlobalForwardsType">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Forward" minOccurs="0" maxOccurs="unbounded" type="ForwardType" />
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.PipeForwards" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="globalForwards" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="ForwardType">
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>the &lt;code&gt;name&lt;/code&gt; is a symbolic reference to a &lt;code&gt;path&lt;/code&gt;.&lt;br/&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="path" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>The name of the next Pipe or Exit. When the Pipeline doesn't have an Exits element configured it will be
 initialized with one Exit having name READY and state SUCCESS</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.PipeForward" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="forward" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="LockerType">
    <xs:attribute name="objectId" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Identifier for this lock</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type">
      <xs:annotation>
        <xs:documentation>Type for this lock: P(ermanent) or T(emporary). A temporary lock is released after the job has completed Default: T</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="LockTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="dateFormatSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>Format for date which is added after &lt;code&gt;objectid&lt;/code&gt; (e.g. yyyyMMdd to be sure the job is executed only once a day)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retention" type="frankInt">
      <xs:annotation>
        <xs:documentation>The time (for type=P in days and for type=T in hours) to keep the record in the database before making it eligible for deletion by a cleanup process Default: 30 days (type=P), 4 hours (type=T)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numRetries" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of times an attempt should be made to acquire a lock, after this many times an exception is thrown when no lock could be acquired, when -1 the number of retries is unlimited Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="firstDelay" type="frankInt">
      <xs:annotation>
        <xs:documentation>The time in ms to wait before the first attempt to acquire a lock is made Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryDelay" type="frankInt">
      <xs:annotation>
        <xs:documentation>The time in ms to wait before another attempt to acquire a lock is made Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWaitTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>If &gt; 0: The time in s to wait before the INSERT statement to obtain the lock is canceled. N.B. On Oracle hitting this lockWaitTimeout may cause the error: (SQLRecoverableException) SQLState [08003], errorCode [17008] connection closed Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreTableNotExist" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; and the IBISLOCK table does not exist in the database, the process continues as if the lock was obtained</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute">
      <xs:annotation>
        <xs:documentation>The &lt;code&gt;transactionAttribute&lt;/code&gt; declares transactional behavior of execution. It applies both to database transactions and XA transactions.
 The pipeline uses this to start a new transaction or suspend the current one when required.
 For developers: it is equal to &lt;a href=\"https://docs.oracle.com/javaee/7/tutorial/transactions003.htm\"&gt;EJB transaction attribute&lt;/a&gt;.
 Possible values for transactionAttribute:
   &lt;table border=\"1\"&gt;
     &lt;tr&gt;&lt;th&gt;transactionAttribute&lt;/th&gt;&lt;th&gt;callers Transaction&lt;/th&gt;&lt;th&gt;Pipeline excecuted in Transaction&lt;/th&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Required&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;RequiresNew&lt;/td&gt; &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Mandatory&lt;/td&gt;   &lt;td&gt;none&lt;/td&gt;&lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;NotSupported&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Supports&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
  										      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Never&lt;/td&gt;       &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;
   &lt;/table&gt; Default: Supports</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="TransactionAttributeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="transactionTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Timeout (in seconds) of transaction started to process a message. Default: &lt;code&gt;0&lt;/code&gt; (use system default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>JNDI name of datasource to be used, can be configured via jmsRealm, too Default: jdbc.datasource.default</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used to authenticate when connecting to database</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>User name for authentication when connecting to database, when none found from &lt;code&gt;authAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password for authentication when connecting to database, when none found from &lt;code&gt;authAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>controls the use of transactions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>informs the sender that the obtained connection is from a pool (and thus connections are reused and never closed) Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>Sets the value of providerURL</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsRealm" type="xs:string">
      <xs:annotation>
        <xs:documentation>loads JNDI (and other) properties from a JmsRealm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the sender or the listener</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.util.Locker" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="locker" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="SchedulerType">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="JobElementGroup" minOccurs="0" maxOccurs="unbounded" />
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.configuration.ScheduleManager" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="scheduler" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="SapSystemsType">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="SapSystemElementGroup" minOccurs="0" maxOccurs="unbounded" />
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.configuration.extensions.SapSystems" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="sapSystems" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="JmsRealmsType">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="JmsRealm" minOccurs="0" maxOccurs="unbounded" type="JmsRealmType" />
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jms.JmsRealmFactory" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="jmsRealms" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="JmsRealmType">
    <xs:attribute name="aliasForRealm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Includes another realm into this one</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="realmName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Set the name of this realm&lt;br/&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Set the name of the QueueConnectionFactory&lt;br/&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Set the name of the TopicConnectionFactory&lt;br/&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string" />
    <xs:attribute name="urlPkgPrefixes" type="xs:string" />
    <xs:attribute name="authentication" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string" />
    <xs:attribute name="providerURL" type="xs:string" />
    <xs:attribute name="userTransactionUrl" type="xs:string" />
    <xs:attribute name="principal" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string" />
    <xs:attribute name="authAlias" type="xs:string" />
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jms.JmsRealm" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="jmsRealm" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="MonitoringType">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="DestinationElementGroup" minOccurs="0" maxOccurs="unbounded" />
        <xs:element name="Monitor" minOccurs="0" maxOccurs="unbounded" type="MonitorType" />
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.monitoring.MonitorManager" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="monitoring" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="MonitorType">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="TriggerElementGroup" minOccurs="0" maxOccurs="unbounded" />
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="destinations" type="xs:string" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of the object.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="raised" type="frankBoolean" />
    <xs:attribute name="additionalHitCount" type="frankInt" />
    <xs:attribute name="type">
      <xs:simpleType>
        <xs:union memberTypes="EventTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="alarmSeverity">
      <xs:simpleType>
        <xs:union memberTypes="SeverityAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.monitoring.Monitor" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="monitor" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="SharedResourcesType">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="SharedResourceElementGroup" minOccurs="0" maxOccurs="unbounded" />
        <xs:element name="HttpSession" minOccurs="0" maxOccurs="unbounded" type="HttpSessionType" />
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.configuration.SharedResources" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="sharedResources" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="HttpSessionType">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of the object.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Timeout in ms of obtaining a connection/result. 0 means no timeout Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConnections" type="frankInt">
      <xs:annotation>
        <xs:documentation>The maximum number of concurrent connections Default: 10</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxExecuteRetries" type="frankInt">
      <xs:annotation>
        <xs:documentation>The maximum number of times the execution is retried Default: 1 (for repeatable messages) else 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Username used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authDomain" type="xs:string">
      <xs:annotation>
        <xs:documentation>Corporate domain name. Should only be used in combination with sAMAccountName, never with an UPN.&lt;br/&gt;
 &lt;br/&gt;
 Assuming the following user:&lt;br/&gt;
 UPN: john.doe@CorpDomain.biz&lt;br/&gt;
 sAMAccountName: CORPDOMAIN\john.doe&lt;br/&gt;
 &lt;br/&gt;
 The username attribute may be set to &lt;code&gt;john.doe&lt;/code&gt;&lt;br/&gt;
 The AuthDomain attribute may be set to &lt;code&gt;CORPDOMAIN&lt;/code&gt;&lt;br/&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tokenEndpoint" type="xs:string">
      <xs:annotation>
        <xs:documentation>Endpoint to obtain OAuth accessToken. If &lt;code&gt;authAlias&lt;/code&gt; or &lt;code&gt;username&lt;/code&gt;( and &lt;code&gt;password&lt;/code&gt;) are specified,
 then a PasswordGrant is used, otherwise a ClientCredentials grant. The obtained accessToken will be added to the regular requests
 in an HTTP Header 'Authorization' with a 'Bearer' prefix.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tokenExpiry" type="frankInt">
      <xs:annotation>
        <xs:documentation>If set to a non-negative value, then determines the time (in seconds) after which the token will be refreshed. Otherwise the token
 will be refreshed when it is half way its lifetime as defined by the &lt;code&gt;expires_in&lt;/code&gt; clause of the token response,
 or when the regular server returns a 401 status with a challenge.
 If not specified, and the accessTokens lifetime is not found in the token response, the accessToken will not be refreshed preemptively. Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clientAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain client_id and client_secret for authentication to &lt;code&gt;tokenEndpoint&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clientId" type="xs:string">
      <xs:annotation>
        <xs:documentation>Client_id used in authentication to &lt;code&gt;tokenEndpoint&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clientSecret" type="xs:string">
      <xs:annotation>
        <xs:documentation>Client_secret used in authentication to &lt;code&gt;tokenEndpoint&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scope" type="xs:string">
      <xs:annotation>
        <xs:documentation>Space or comma separated list of scope items requested for accessToken, e.g. &lt;code&gt;read write&lt;/code&gt;. Only used when &lt;code&gt;tokenEndpoint&lt;/code&gt; is specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authenticatedTokenRequest" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>if set true, clientId and clientSecret will be added as Basic Authentication header to the tokenRequest, instead of as request parameters</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="frankInt">
      <xs:annotation>
        <xs:documentation>Proxy port Default: 80</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain credentials for authentication to proxy</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyRealm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy realm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefillProxyAuthCache" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Create a pre-emptive login context for the proxy connection(s).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="disableCookies" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Disables the use of cookies, making the sender completely stateless Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystore" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource URL to keystore or certificate to be used for authentication. If none specified, the JVMs default keystore will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType">
      <xs:annotation>
        <xs:documentation>Type of keystore Default: pkcs12</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="keystoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used to obtain keystore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to access keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias to obtain specific certificate or key in keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>Resource URL to truststore to be used for authenticating peer. If none specified, the JVMs default truststore will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used to obtain truststore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to access truststore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType">
      <xs:annotation>
        <xs:documentation>Type of truststore Default: jks</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Trust manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the hostname in the certificate will be checked against the actual hostname of the peer</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowSelfSignedCertificates" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, self signed certificates are accepted Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCertificateExpiredException" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, CertificateExpiredExceptions are ignored Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="followRedirects" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, a redirect request will be honoured, e.g. to switch to HTTPS Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreRedirects" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, besides http status code 200 (OK) also the code 301 (MOVED_PERMANENTLY), 302 (MOVED_TEMPORARILY) and 307 (TEMPORARY_REDIRECT) are considered successful Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleChecking" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Controls whether connections checked to be stale, i.e. appear open, but are not. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Used when StaleChecking=&lt;code&gt;true&lt;/code&gt;. Timeout after which an idle connection will be validated before being used. Default: 5000 ms</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionTimeToLive" type="frankInt">
      <xs:annotation>
        <xs:documentation>Maximum Time to Live for connections in the pool. No connection will be re-used past its timeToLive value. Default: 900 s</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionIdleTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Maximum Time for connection to stay idle in the pool. Connections that are idle longer will periodically be evicted from the pool Default: 10 s</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="protocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>Secure socket protocol (such as 'TLSv1.2') to use when a SSLContext object is generated. Default: TLSv1.2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="supportedCipherSuites" type="xs:string">
      <xs:annotation>
        <xs:documentation>Allows you to choose which CipherSuites are used when connecting to an endpoint. Works in tandem with {@code protocol} as the provided Suite may not be valid for the provided Protocol
 See the Java Security Standard Algorithm Names Specification for all available options. Note that these may differ depending on the JRE you're using.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.http.HttpSession" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="httpSession" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:group name="ListenerElementGroup">
    <xs:choice>
      <xs:element name="Listener">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ListenerElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ListenerElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="SenderElementGroup">
    <xs:choice>
      <xs:element name="Sender">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="SenderElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="SenderElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="ErrorSenderElementGroup">
    <xs:choice>
      <xs:element name="ErrorSender">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ErrorSenderElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ErrorSenderElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="ErrorStorageElementGroup">
    <xs:choice>
      <xs:element name="ErrorStorage">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="errorStorage" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ErrorStorageElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ErrorStorageElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="MessageLogElementGroup">
    <xs:choice>
      <xs:element name="MessageLog">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="messageLog" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="MessageLogElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="MessageLogElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="ErrorMessageFormatterElementGroup">
    <xs:choice>
      <xs:element name="ErrorMessageFormatter">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="errorMessageFormatter" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ErrorMessageFormatterElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ErrorMessageFormatterElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="InputValidatorElementGroup">
    <xs:choice>
      <xs:element name="InputValidator">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="InputValidatorElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="InputValidatorElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="OutputValidatorElementGroup">
    <xs:choice>
      <xs:element name="OutputValidator">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="OutputValidatorElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="OutputValidatorElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="InputWrapperElementGroup">
    <xs:choice>
      <xs:element name="InputWrapper">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="inputWrapper" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="InputWrapperElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="InputWrapperElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="OutputWrapperElementGroup">
    <xs:choice>
      <xs:element name="OutputWrapper">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="outputWrapper" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="OutputWrapperElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="OutputWrapperElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="CacheElementGroup">
    <xs:choice>
      <xs:element name="Cache">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="cache" />
          <xs:attribute name="className" type="xs:string" default="org.frankframework.cache.EhCache" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="CacheElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="CacheElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="PipeElementGroup">
    <xs:choice>
      <xs:element name="Pipe">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
          <xs:attribute name="className" type="xs:string" default="org.frankframework.pipes.SenderPipe" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="PipeElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="PipeElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="JobElementGroup">
    <xs:choice>
      <xs:element name="Job">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="job" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="JobElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="JobElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="SapSystemElementGroup">
    <xs:choice>
      <xs:element name="SapSystem">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="sapSystem" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="SapSystemElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="SapSystemElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="DestinationElementGroup">
    <xs:choice>
      <xs:element name="Destination">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="destination" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="DestinationElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="DestinationElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="TriggerElementGroup">
    <xs:choice>
      <xs:element name="Trigger">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="trigger" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="TriggerElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="TriggerElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="SharedResourceElementGroup">
    <xs:choice>
      <xs:element name="SharedResource">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="sharedResource" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="SharedResourceElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="SharedResourceElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:simpleType name="OnErrorAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:pattern value="[cC][oO][nN][tT][iI][nN][uU][eE]" />
      <xs:pattern value="[rR][eE][cC][oO][vV][eE][rR]" />
      <xs:pattern value="[cC][lL][oO][sS][eE]" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="CheckForDuplicatesMethodAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:pattern value="[mM][eE][sS][sS][aA][gG][eE][iI][dD]" />
      <xs:pattern value="[cC][oO][rR][rR][eE][lL][aA][tT][iI][oO][nN][iI][dD]" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="HideMethodAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:pattern value="[aA][lL][lL]" />
      <xs:pattern value="[fF][iI][rR][sS][tT][hH][aA][lL][fF]" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TransactionAttributeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:pattern value="[rR][eE][qQ][uU][iI][rR][eE][dD]" />
      <xs:pattern value="[sS][uU][pP][pP][oO][rR][tT][sS]" />
      <xs:pattern value="[mM][aA][nN][dD][aA][tT][oO][rR][yY]" />
      <xs:pattern value="[rR][eE][qQ][uU][iI][rR][eE][sS][nN][eE][wW]" />
      <xs:pattern value="[nN][oO][tT][sS][uU][pP][pP][oO][rR][tT][eE][dD]" />
      <xs:pattern value="[nN][eE][vV][eE][rR]" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ExitStateAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:pattern value="[sS][uU][cC][cC][eE][sS][sS]" />
      <xs:pattern value="[eE][rR][rR][oO][rR]" />
      <xs:pattern value="[rR][eE][jJ][eE][cC][tT][eE][dD]" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="LockTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:pattern value="[tT]" />
      <xs:pattern value="[pP]" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="MessageLogLevelAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:pattern value="[oO][fF][fF]" />
      <xs:pattern value="[iI][nN][fF][oO]" />
      <xs:pattern value="[bB][aA][sS][iI][cC]" />
      <xs:pattern value="[dD][eE][bB][uU][gG]" />
      <xs:pattern value="[tT][eE][rR][sS][eE]" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="EventTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:pattern value="[tT][eE][cC][hH][nN][iI][cC][aA][lL]" />
      <xs:pattern value="[fF][uU][nN][cC][tT][iI][oO][nN][aA][lL]" />
      <xs:pattern value="[hH][eE][aA][rR][tT][bB][eE][aA][tT]" />
      <xs:pattern value="[cC][lL][eE][aA][rR][iI][nN][gG]" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="SeverityAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:pattern value="[hH][aA][rR][mM][lL][eE][sS][sS]" />
      <xs:pattern value="[wW][aA][rR][nN][iI][nN][gG]" />
      <xs:pattern value="[cC][rR][iI][tT][iI][cC][aA][lL]" />
      <xs:pattern value="[fF][aA][tT][aA][lL]" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="KeystoreTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:pattern value="[pP][kK][cC][sS][11][22]" />
      <xs:pattern value="[pP][eE][mM]" />
      <xs:pattern value="[jJ][kK][sS]" />
      <xs:pattern value="[jJ][cC][eE][kK][sS]" />
    </xs:restriction>
  </xs:simpleType>
  <xs:attribute name="transacted" type="frankBoolean" />
  <xs:attribute name="transactionTimeout" type="frankInt">
    <xs:annotation>
      <xs:documentation>Timeout (in seconds) of transaction started to process a message. Default: &lt;code&gt;0&lt;/code&gt; (use system default)</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="transactionAttribute">
    <xs:annotation>
      <xs:documentation>The &lt;code&gt;transactionAttribute&lt;/code&gt; declares transactional behavior of execution. It applies both to database transactions and XA transactions.
 The pipeline uses this to start a new transaction or suspend the current one when required.
 For developers: it is equal to &lt;a href=\"https://docs.oracle.com/javaee/7/tutorial/transactions003.htm\"&gt;EJB transaction attribute&lt;/a&gt;.
 Possible values for transactionAttribute:
   &lt;table border=\"1\"&gt;
     &lt;tr&gt;&lt;th&gt;transactionAttribute&lt;/th&gt;&lt;th&gt;callers Transaction&lt;/th&gt;&lt;th&gt;Pipeline excecuted in Transaction&lt;/th&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Required&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;RequiresNew&lt;/td&gt; &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Mandatory&lt;/td&gt;   &lt;td&gt;none&lt;/td&gt;&lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;NotSupported&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Supports&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
  										      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Never&lt;/td&gt;       &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;
   &lt;/table&gt; Default: Supports</xs:documentation>
    </xs:annotation>
    <xs:simpleType>
      <xs:union memberTypes="TransactionAttributeAttributeValuesType variableRef" />
    </xs:simpleType>
  </xs:attribute>
  <xs:simpleType name="frankBoolean">
    <xs:restriction base="xs:string">
      <xs:pattern value="(true|false)|($\{[^\}]+\})" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="frankInt">
    <xs:restriction base="xs:string">
      <xs:pattern value="((\+|-)?[0-9]+)|($\{[^\}]+\})" />
    </xs:restriction>
  </xs:simpleType>
  <xs:attribute name="active">
    <xs:annotation>
      <xs:documentation>If defined and empty or false, then this element and all its children are ignored</xs:documentation>
    </xs:annotation>
    <xs:simpleType>
      <xs:restriction base="xs:string">
        <xs:pattern value="!?(($\{[^\}]+\})|([tT][rR][uU][eE])|([fF][aA][lL][sS][eE]))" />
      </xs:restriction>
    </xs:simpleType>
  </xs:attribute>
  <xs:simpleType name="variableRef">
    <xs:restriction base="xs:string">
      <xs:pattern value="$\{[^\}]+\}" />
    </xs:restriction>
  </xs:simpleType>
</xs:schema>
