<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
  <xs:element name="Configuration">
    <xs:annotation>
      <xs:documentation>nl.nn.adapterframework.configuration.Configuration - The Configuration is placeholder of all configuration objects. Besides that, it provides
 functions for starting and stopping adapters as a facade.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="Adapter" minOccurs="0" maxOccurs="unbounded" />
        <xs:element ref="Job" minOccurs="0" maxOccurs="unbounded" />
        <xs:group ref="StatisticsHandlerElementGroup" minOccurs="0" maxOccurs="unbounded" />
      </xs:sequence>
      <xs:attribute name="autoStart" type="xs:boolean" />
      <xs:attribute name="configured" type="xs:boolean" />
      <xs:attribute name="loadedConfiguration" type="xs:string" />
      <xs:attribute name="name" type="xs:string" />
      <xs:attribute name="originalConfiguration" type="xs:string" />
      <xs:attribute name="unloadInProgressOrDone" type="xs:boolean" />
      <xs:attribute name="version" type="xs:string" />
      <xs:attribute name="validating" type="xs:boolean" />
      <xs:attribute name="beanName" type="xs:string" />
      <xs:attribute name="configLocation" type="xs:string" />
      <xs:attribute name="allowBeanDefinitionOverriding" type="xs:boolean" />
      <xs:attribute name="allowCircularReferences" type="xs:boolean" />
      <xs:attribute name="displayName" type="xs:string" />
      <xs:attribute name="id" type="xs:string" />
      <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.configuration.Configuration" use="prohibited" />
    </xs:complexType>
  </xs:element>
  <xs:element name="Adapter">
    <xs:annotation>
      <xs:documentation>nl.nn.adapterframework.core.Adapter - The Adapter is the central manager in the IBIS Adapterframework, that has knowledge
 and uses {@link Receiver Receivers} and a {@link PipeLine}.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="Receiver" minOccurs="0" maxOccurs="unbounded" />
        <xs:group ref="ErrorMessageFormatterElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:element ref="Pipeline" minOccurs="0" maxOccurs="1" />
      </xs:sequence>
      <xs:attribute name="active" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>controls whether adapter is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the receiver is not included in the configuration Default: true</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="autoStart" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>controls whether adapters starts when configuration loads Default: true</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="description" type="xs:string">
        <xs:annotation>
          <xs:documentation>description of the adapter</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="errorState" type="xs:string" />
      <xs:attribute name="messageKeeperSize" type="xs:integer">
        <xs:annotation>
          <xs:documentation>number of message displayed in ibisconsole Default: 10</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="msgLogHidden" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>if set to &lt;code&gt;true&lt;/code&gt;, the length of the message is shown in the msg log instead of the content of the message Default: false</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="msgLogLevel" type="xs:string">
        <xs:annotation>
          <xs:documentation>defines behaviour for logging messages. Configuration is done in the MSG appender in log4j4ibis.properties. Possible values are: &lt;table border='1'&gt;&lt;tr&gt;&lt;th&gt;msgLogLevel&lt;/th&gt;&lt;th&gt;messages which are logged&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan='1'&gt;Off&lt;/td&gt; &lt;td&gt;No logging&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan='1'&gt;Basic&lt;/td&gt;&lt;td&gt;Logs information from adapter level messages &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan='1'&gt;Terse&lt;/td&gt;&lt;td&gt;Logs information from pipe messages.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan='1'&gt;All&lt;/td&gt; &lt;td&gt;Logs all messages.&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; Default: BASIC</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
        <xs:annotation>
          <xs:documentation>name of the adapter</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="replaceNullMessage" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>when &lt;code&gt;true&lt;/code&gt; a null message is replaced by an empty message Default: false</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="requestReplyLogging" type="xs:boolean" />
      <xs:attribute name="targetDesignDocument" type="xs:string" />
      <xs:attribute name="elementRole" type="xs:string" fixed="adapter" />
      <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.core.Adapter" use="prohibited" />
    </xs:complexType>
  </xs:element>
  <xs:element name="Receiver">
    <xs:annotation>
      <xs:documentation>nl.nn.adapterframework.receivers.Receiver - The receiver is the trigger and central communicator for the framework.
 &lt;br/&gt;
 The main responsibilities are:
 &lt;ul&gt;
    &lt;li&gt;receiving messages&lt;/li&gt;
    &lt;li&gt;for asynchronous receivers (which have a separate sender):&lt;br/&gt;
            &lt;ul&gt;&lt;li&gt;initializing ISender objects&lt;/li&gt;
                &lt;li&gt;stopping ISender objects&lt;/li&gt;
                &lt;li&gt;sending the message with the ISender object&lt;/li&gt;
            &lt;/ul&gt;
    &lt;li&gt;synchronous receivers give the result directly&lt;/li&gt;
    &lt;li&gt;take care of connection, sessions etc. to startup and shutdown&lt;/li&gt;
 &lt;/ul&gt;
 Listeners call the IAdapter.processMessage(String correlationID,String message)
 to do the actual work, which returns a &lt;code&gt;{@link PipeLineResult}&lt;/code&gt;. The receiver
 may observe the status in the &lt;code&gt;{@link PipeLineResult}&lt;/code&gt; to perfom committing
 requests.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="ListenerElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:group ref="SenderElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:group ref="ErrorSenderElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:group ref="ErrorStorageElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:group ref="MessageLogElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:group ref="InProcessStorageElementGroup" minOccurs="0" maxOccurs="1" />
      </xs:sequence>
      <xs:attribute name="name" type="xs:string">
        <xs:annotation>
          <xs:documentation>Name of the Receiver as known to the Adapter</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="active" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>If set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the receiver is not included in the configuration Default: true</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="onError" type="OnErrorAttributeValuesType">
        <xs:annotation>
          <xs:documentation>One of 'continue' or 'close'. Controls the behaviour of the Receiver when it encounters an error sending a reply or receives an exception asynchronously Default: continue</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="numThreads" type="xs:integer">
        <xs:annotation>
          <xs:documentation>The number of threads that may execute a Pipeline concurrently (only for pulling listeners) Default: 1</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="numThreadsPolling" type="xs:integer">
        <xs:annotation>
          <xs:documentation>The number of threads that are actively polling for messages concurrently. '0' means 'limited only by &lt;code&gt;numthreads&lt;/code&gt;' (only for pulling listeners) Default: 1</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="pollInterval" type="xs:integer">
        <xs:annotation>
          <xs:documentation>The number of seconds waited after an unsuccesful poll attempt before another poll attempt is made. Only for polling listeners, not for e.g. ifsa, jms, webservice or javaListeners Default: 10</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="checkForDuplicates" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, each message is checked for presence in the messageLog. If already present, it is not processed again. Only required for non XA compatible messaging. Requires messageLog! Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="checkForDuplicatesMethod" type="xs:string">
        <xs:annotation>
          <xs:documentation>(Only used when &lt;code&gt;checkForDuplicates=true&lt;/code&gt;) Either 'CORRELATIONID' or 'MESSAGEID'. Indicates whether the messageid or the correlationid is used for checking presence in the message log Default: MESSAGEID</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="maxDeliveries" type="xs:integer">
        <xs:annotation>
          <xs:documentation>The maximum delivery count after which to stop processing the message. If -1 the delivery count is ignored Default: 5</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="maxRetries" type="xs:integer">
        <xs:annotation>
          <xs:documentation>The number of times a processing attempt is retried after an exception is caught or rollback is experienced (only applicable for transacted Receivers). If maxRetries &amp;lt; 0 the number of attempts is infinite Default: 1</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="processResultCacheSize" type="xs:integer">
        <xs:annotation>
          <xs:documentation>Size of the cache to keep process results, used by maxRetries Default: 100</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="returnedSessionKeys" type="xs:string">
        <xs:annotation>
          <xs:documentation>Comma separated list of keys of session variables that should be returned to caller, for correct results as well as for erronous results. (Only for Listeners that support it, like JavaListener)</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="correlationIDXPath" type="xs:string">
        <xs:annotation>
          <xs:documentation>XPath expression to extract correlationid from message</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
        <xs:annotation>
          <xs:documentation>Namespace defintions for correlationIDXPath. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="correlationIDStyleSheet" type="xs:string">
        <xs:annotation>
          <xs:documentation>Stylesheet to extract correlationID from message</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="labelXPath" type="xs:string">
        <xs:annotation>
          <xs:documentation>XPath expression to extract label from message</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="labelNamespaceDefs" type="xs:string">
        <xs:annotation>
          <xs:documentation>Namespace defintions for labelXPath. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="labelStyleSheet" type="xs:string">
        <xs:annotation>
          <xs:documentation>Stylesheet to extract label from message</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="chompCharSize" type="xs:string">
        <xs:annotation>
          <xs:documentation>If set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment)</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="elementToMove" type="xs:string">
        <xs:annotation>
          <xs:documentation>If set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementToMoveSessionKey&lt;/code&gt; + }</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="elementToMoveChain" type="xs:string">
        <xs:annotation>
          <xs:documentation>Like &lt;code&gt;elementToMove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. adapter;pipeline;pipe)</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="elementToMoveSessionKey" type="xs:string">
        <xs:annotation>
          <xs:documentation>(Only used when &lt;code&gt;elementToMove&lt;/code&gt; is set) Name of the session key under which the character data is stored Default: ref_ + the name of the element</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="hiddenInputSessionKeys" type="xs:string">
        <xs:annotation>
          <xs:documentation>Comma separated list of keys of session variables which are available when the &lt;code&gt;PipelineSession&lt;/code&gt; is created and of which the value will not be shown in the log (replaced by asterisks)</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="hideMethod" type="xs:string">
        <xs:annotation>
          <xs:documentation>(Only used when hideRegex is not empty) either &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;firstHalf&lt;/code&gt;. When &lt;code&gt;firstHalf&lt;/code&gt; only the first half of the string is masked, otherwise (&lt;code&gt;all&lt;/code&gt;) the entire string is masked Default: all</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="hideRegex" type="xs:string">
        <xs:annotation>
          <xs:documentation>Regular expression to mask strings in the errorStore/logStore. Every character between to the strings in this expression will be replaced by a '*'. For example, the regular expression (?&amp;lt;=&amp;lt;party&amp;gt;).*?(?=&amp;lt;/party&amp;gt;) will replace every character between keys&lt;party&gt; and &lt;/party&gt;</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="removeCompactMsgNamespaces" type="xs:boolean" />
      <xs:attribute name="transactionAttribute" type="xs:string">
        <xs:annotation>
          <xs:documentation>The &lt;code&gt;transactionAttribute&lt;/code&gt; declares transactional behavior of execution. It applies both to database transactions and XA transactions.The pipeline uses this to start a new transaction or suspend the current one when required. For developers: it is equalto &lt;a href="https://docs.oracle.com/javaee/7/tutorial/transactions003.htm"&gt;EJB transaction attribute&lt;/a&gt;. Possible values for transactionAttribute:  &lt;table border="1"&gt;    &lt;tr&gt;&lt;th&gt;transactionAttribute&lt;/th&gt;&lt;th&gt;callers Transaction&lt;/th&gt;&lt;th&gt;Pipeline excecuted in Transaction&lt;/th&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Required&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;RequiresNew&lt;/td&gt; &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Mandatory&lt;/td&gt;   &lt;td&gt;none&lt;/td&gt;&lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;NotSupported&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Supports&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt; 										      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Never&lt;/td&gt;       &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;  &lt;/table&gt; Default: Supports</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="transactionAttributeNum" type="xs:integer">
        <xs:annotation>
          <xs:documentation>Like &lt;code&gt;transactionAttribute&lt;/code&gt;, but the chosen option is represented with a number. The numbers mean:&lt;table&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Supports&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;Mandatory&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;RequiresNew&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;NotSupported&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;Never&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; Default: 1</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="transactionTimeout" type="xs:integer">
        <xs:annotation>
          <xs:documentation>Timeout (in seconds) of transaction started to process a message. Default: &lt;code&gt;0&lt;/code&gt; (use system default)</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="transacted" type="xs:boolean" />
      <xs:attribute name="elementRole" type="xs:string" fixed="receiver" />
      <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.receivers.Receiver" use="prohibited" />
    </xs:complexType>
  </xs:element>
  <xs:element name="Param">
    <xs:annotation>
      <xs:documentation>nl.nn.adapterframework.parameters.Parameter - Generic parameter definition.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
      </xs:sequence>
      <xs:attribute name="name" type="xs:string">
        <xs:annotation>
          <xs:documentation>Name of the parameter</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="type" type="xs:string">
        <xs:annotation>
          <xs:documentation>&lt;ul&gt;&lt;li&gt;&lt;code&gt;string&lt;/code&gt;: renders the contents of the first node (in combination with xslt or xpath).&lt;br/&gt;Please note that if there are child nodes, only the contents are returned, use &lt;code&gt;xml&lt;/code&gt; if the xml tags are required&lt;/li&gt;&lt;li&gt;&lt;code&gt;xml&lt;/code&gt;:  renders an xml-nodeset as an xml-string (in combination with xslt or xpath). This will include the xml tags&lt;/li&gt;&lt;li&gt;&lt;code&gt;node&lt;/code&gt;: renders the CONTENTS of the first node as a nodeset that can be used as such when passed as xslt-parameter (only for XSLT 1.0). &lt;br/&gt;Please note that the nodeset may contain multiple nodes, without a common root node. &lt;br/&gt;N.B. The result is the set of children of what you might expect it to be...&lt;/li&gt;&lt;li&gt;&lt;code&gt;domdoc&lt;/code&gt;: renders xml as a DOM document; similar to &lt;code&gt;node&lt;/code&gt; with the distinction that there is always a common root node (required for XSLT 2.0)&lt;/li&gt;&lt;li&gt;&lt;code&gt;date&lt;/code&gt;: converts the result to a Date, by default using formatString &lt;code&gt;yyyy-MM-dd&lt;/code&gt;. When applied as a JDBC parameter, the method setDate() is used&lt;/li&gt;&lt;li&gt;&lt;code&gt;time&lt;/code&gt;: converts the result to a Date, by default using formatString &lt;code&gt;HH:mm:ss&lt;/code&gt;. When applied as a JDBC parameter, the method setTime() is used&lt;/li&gt;&lt;li&gt;&lt;code&gt;datetime&lt;/code&gt;: converts the result to a Date, by default using formatString &lt;code&gt;yyyy-MM-dd HH:mm:ss&lt;/code&gt;. When applied as a JDBC parameter, the method setTimestamp() is used&lt;/li&gt;&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt;: similar to datetime, except for the formatString that is &lt;code&gt;yyyy-MM-dd HH:mm:ss.SSS&lt;/code&gt; by default&lt;/li&gt;&lt;li&gt;&lt;code&gt;xmldatetime&lt;/code&gt;: converts the result from a XML dateTime to a Date. When applied as a JDBC parameter, the method setTimestamp() is used&lt;/li&gt;&lt;li&gt;&lt;code&gt;number&lt;/code&gt;: converts the result to a Number, using decimalSeparator and groupingSeparator. When applied as a JDBC parameter, the method setDouble() is used&lt;/li&gt;&lt;li&gt;&lt;code&gt;integer&lt;/code&gt;: converts the result to an Integer&lt;/li&gt;&lt;li&gt;&lt;code&gt;inputstream&lt;/code&gt;: only applicable as a JDBC parameter, the method setBinaryStream() is used&lt;/li&gt;&lt;li&gt;&lt;code&gt;list&lt;/code&gt;: converts a List&amp;lt;String&amp;gt; object to a xml-string (&amp;lt;items&amp;gt;&amp;lt;item&amp;gt;...&amp;lt;/item&amp;gt;&amp;lt;item&amp;gt;...&amp;lt;/item&amp;gt;&amp;lt;/items&amp;gt;)&lt;/li&gt;&lt;li&gt;&lt;code&gt;map&lt;/code&gt;: converts a Map&amp;lt;String, String&amp;gt; object to a xml-string (&amp;lt;items&amp;gt;&amp;lt;item name='...'&amp;gt;...&amp;lt;/item&amp;gt;&amp;lt;item name='...'&amp;gt;...&amp;lt;/item&amp;gt;&amp;lt;/items&amp;gt;)&lt;/li&gt;&lt;/ul&gt; Default: string</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="value" type="xs:string">
        <xs:annotation>
          <xs:documentation>The value of the parameter, or the base for transformation using xpathExpression or stylesheet, or formatting.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="sessionKey" type="xs:string">
        <xs:annotation>
          <xs:documentation>Key of a pipelinesession-variable. &lt;br/&gt;If specified, the value of the pipelinesession variable is used as input for the xpathExpression or stylesheet, instead of the current input message. &lt;br/&gt;If no xpathExpression or stylesheet are specified, the value itself is returned. &lt;br/&gt;If the value '*' is specified, all existing sessionkeys are added as parameter of which the name starts with the name of this parameter. &lt;br/&gt;If also the name of the parameter has the value '*' then all existing sessionkeys are added as parameter (except tsreceived)</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="sessionKeyXPath" type="xs:string">
        <xs:annotation>
          <xs:documentation>Instead of a fixed &lt;code&gt;sessionkey&lt;/code&gt; it's also possible to use a xpath expression to extract the name of the &lt;code&gt;sessionkey&lt;/code&gt;</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="styleSheetName" type="xs:string">
        <xs:annotation>
          <xs:documentation>url to a stylesheet that wil be applied to the contents of the message or the value of the session-variable.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xpathExpression" type="xs:string">
        <xs:annotation>
          <xs:documentation>the xpath expression to extract the parameter value from the (xml formatted) input or session-variable.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xsltVersion" type="xs:integer">
        <xs:annotation>
          <xs:documentation>when set to &lt;code&gt;2&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan). &lt;code&gt;0&lt;/code&gt; will auto detect Default: 0</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="xslt2" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan) Default: false</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="namespaceDefs" type="xs:string">
        <xs:annotation>
          <xs:documentation>Namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions. One entry can be without a prefix, that will define the default namespace.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="removeNamespaces" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>When set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed before the stylesheet/xpathexpression is executed Default: false</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="defaultValue" type="xs:string">
        <xs:annotation>
          <xs:documentation>If the result of sessionKey, xpathExpression and/or stylesheet returns null or an empty string, this value is returned</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="defaultValueMethods" type="xs:string">
        <xs:annotation>
          <xs:documentation>Comma separated list of methods (defaultvalue, sessionKey, pattern, value or input) to use as default value. Used in the order they appear until a non-null value is found. Default: defaultvalue</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="pattern" type="xs:string">
        <xs:annotation>
          <xs:documentation>Value of parameter is determined using substitution and formating. The expression can contain references to session-variables or other parameters using {name-of-parameter} and is formatted using java.text.MessageFormat. &lt;br/&gt;If for instance &lt;code&gt;fname&lt;/code&gt; is a parameter or session variable that resolves to eric, then the pattern 'hi {fname}, hoe gaat het?' resolves to 'hi eric, hoe gaat het?'.&lt;br/&gt;The following predefined reference can be used in the expression too:&lt;ul&gt;&lt;li&gt;{now}: the current system time&lt;/li&gt;&lt;li&gt;{uid}: an unique identifier, based on the IP address and java.rmi.server.UID&lt;/li&gt;&lt;li&gt;{uuid}: an unique identifier, based on the IP address and java.util.UUID&lt;/li&gt;&lt;li&gt;{hostname}: the name of the machine the application runs on&lt;/li&gt;&lt;li&gt;{username}: username from the credentials found using authAlias, or the username attribute&lt;/li&gt;&lt;li&gt;{password}: password from the credentials found using authAlias, or the password attribute&lt;/li&gt;&lt;li&gt;{fixeddate}: fake date, for testing only&lt;/li&gt;&lt;li&gt;{fixeduid}: fake uid, for testing only&lt;/li&gt;&lt;li&gt;{fixedhostname}: fake hostname, for testing only&lt;/li&gt;&lt;/ul&gt;A guid can be generated using {hostname}_{uid}, see also &lt;a href="http://java.sun.com/j2se/1.4.2/docs/api/java/rmi/server/uid.html"&gt;http://java.sun.com/j2se/1.4.2/docs/api/java/rmi/server/uid.html&lt;/a&gt; for more information about (g)uid's or &lt;a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/uuid.html"&gt;http://docs.oracle.com/javase/1.5.0/docs/api/java/util/uuid.html&lt;/a&gt; for more information about uuid's.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="authAlias" type="xs:string">
        <xs:annotation>
          <xs:documentation>Alias used to obtain username and password, used when a &lt;code&gt;pattern&lt;/code&gt; containing {username} or {password} is specified</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="userName" type="xs:string">
        <xs:annotation>
          <xs:documentation>Default username that is used when a &lt;code&gt;pattern&lt;/code&gt; containing {username} is specified</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="password" type="xs:string">
        <xs:annotation>
          <xs:documentation>Default password that is used when a &lt;code&gt;pattern&lt;/code&gt; containing {password} is specified Default:</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="formatString" type="xs:string">
        <xs:annotation>
          <xs:documentation>Used in combination with types &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;datetime&lt;/code&gt; Default: depends on type</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="decimalSeparator" type="xs:string">
        <xs:annotation>
          <xs:documentation>Used in combination with type &lt;code&gt;number&lt;/code&gt; Default: system default</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="groupingSeparator" type="xs:string">
        <xs:annotation>
          <xs:documentation>Used in combination with type &lt;code&gt;number&lt;/code&gt; Default: system default</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="minLength" type="xs:integer">
        <xs:annotation>
          <xs:documentation>If set (&gt;=0) and the length of the value of the parameter deceeds this minimum length, the value is padded Default: -1</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="maxLength" type="xs:integer">
        <xs:annotation>
          <xs:documentation>If set (&gt;=0) and the length of the value of the parameter exceeds this maximum length, the length is trimmed to this maximum length Default: -1</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="maxInclusive" type="xs:string">
        <xs:annotation>
          <xs:documentation>Used in combination with type &lt;code&gt;number&lt;/code&gt;; if set and the value of the parameter exceeds this maximum value, this maximum value is taken</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="minInclusive" type="xs:string">
        <xs:annotation>
          <xs:documentation>Used in combination with type &lt;code&gt;number&lt;/code&gt;; if set and the value of the parameter exceeds this minimum value, this minimum value is taken</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="hidden" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the value of the parameter will not be shown in the log (replaced by asterisks) Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="elementRole" type="xs:string" fixed="param" />
      <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.parameters.Parameter" use="prohibited" />
    </xs:complexType>
  </xs:element>
  <xs:element name="Pipeline">
    <xs:annotation>
      <xs:documentation>nl.nn.adapterframework.core.PipeLine - Processor and keeper of a line of {@link IPipe Pipes}.
 &lt;br/&gt;
 Pipelines also generate statics information per Pipe and keep forwards, that are registered
 at individual pipes during the configure fase.
 &lt;br/&gt;
 In the AppConstants there may be a property named "log.logIntermediaryResults" (true/false)
 which indicates wether the intermediary results (between calling pipes) have to be logged.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="InputValidatorElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:group ref="OutputValidatorElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:group ref="InputWrapperElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:group ref="OutputWrapperElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:element ref="Exit" minOccurs="0" maxOccurs="unbounded" />
        <xs:element ref="Forward" minOccurs="0" maxOccurs="unbounded" />
        <xs:element ref="Locker" minOccurs="0" maxOccurs="1" />
        <xs:group ref="CacheElementGroup" minOccurs="0" maxOccurs="1" />
        <xs:group ref="PipeElementGroup" minOccurs="0" maxOccurs="unbounded" />
      </xs:sequence>
      <xs:attribute name="firstPipe" type="xs:string">
        <xs:annotation>
          <xs:documentation>Name of the first pipe to execute when a message is to be processed Default: &lt;first pipe of the pipeline&gt;</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="maxThreads" type="xs:integer">
        <xs:annotation>
          <xs:documentation>Maximum number of threads that may execute this Pipeline simultaneously Default: 0 (unlimited)</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="commitOnState" type="xs:string">
        <xs:annotation>
          <xs:documentation>If the pipelineresult.getstate() equals this value, the transaction is committed, otherwise it is rolled back. Default: &lt;code&gt;success&lt;/code&gt;</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="storeOriginalMessageWithoutNamespaces" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; the original message without namespaces (and prefixes) is stored under the session key originalMessageWithoutNamespaces Default: false</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="messageSizeWarn" type="xs:string">
        <xs:annotation>
          <xs:documentation>If messageSizeWarn&gt;=0 and the size of the input or result pipe message exceeds the value specified a warning message is logged. You can specify the value with the suffixes "KB", "MB" or "GB" Default: application default (3MB)</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="forceFixedForwarding" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>Forces that each pipe in the pipeline is not automatically added to the globalforwards table Default: application default</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="transformNullMessage" type="xs:string">
        <xs:annotation>
          <xs:documentation>when specified and &lt;code&gt;null&lt;/code&gt; is received as a message the message is changed to the specified value</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="adapterToRunBeforeOnEmptyInput" type="xs:string">
        <xs:annotation>
          <xs:documentation>when specified and an empty message is received the specified adapter is run before passing the message (response from specified adapter) to the pipeline</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="transactionAttribute" type="xs:string">
        <xs:annotation>
          <xs:documentation>The &lt;code&gt;transactionAttribute&lt;/code&gt; declares transactional behavior of execution. It applies both to database transactions and XA transactions.The pipeline uses this to start a new transaction or suspend the current one when required. For developers: it is equalto &lt;a href="https://docs.oracle.com/javaee/7/tutorial/transactions003.htm"&gt;EJB transaction attribute&lt;/a&gt;. Possible values for transactionAttribute:  &lt;table border="1"&gt;    &lt;tr&gt;&lt;th&gt;transactionAttribute&lt;/th&gt;&lt;th&gt;callers Transaction&lt;/th&gt;&lt;th&gt;Pipeline excecuted in Transaction&lt;/th&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Required&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;RequiresNew&lt;/td&gt; &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Mandatory&lt;/td&gt;   &lt;td&gt;none&lt;/td&gt;&lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;NotSupported&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Supports&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt; 										      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Never&lt;/td&gt;       &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;  &lt;/table&gt; Default: Supports</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="transactionAttributeNum" type="xs:integer">
        <xs:annotation>
          <xs:documentation>Like &lt;code&gt;transactionAttribute&lt;/code&gt;, but the chosen option is represented with a number. The numbers mean:&lt;table&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Supports&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;Mandatory&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;RequiresNew&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;NotSupported&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;Never&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; Default: 1</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="transactionTimeout" type="xs:integer">
        <xs:annotation>
          <xs:documentation>Timeout (in seconds) of transaction started to process a message. Default: &lt;code&gt;0&lt;/code&gt; (use system default)</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="transacted" type="xs:boolean" />
      <xs:attribute name="elementRole" type="xs:string" fixed="pipeline" />
      <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.core.PipeLine" use="prohibited" />
    </xs:complexType>
  </xs:element>
  <xs:element name="Forward">
    <xs:annotation>
      <xs:documentation>nl.nn.adapterframework.core.PipeForward - Bean that knows a functional name of a Forward, to be referred by
 other Pipes and the PipeLine.
 &lt;br/&gt;
 The &lt;code&gt;name&lt;/code&gt; is the name which a Pipe may lookup to return
 to the PipeLine, indicating the next pipe to be executed. (this is done
 in the {@link nl.nn.adapterframework.pipes.AbstractPipe#findForward(String) findForward()}-method. The actual
 pipeName is defined in the &lt;code&gt;path&lt;/code&gt; property.&lt;br/&gt;&lt;br/&gt;
 In this manner it is possible to influence the flow through the pipeline
 without affecting the Java-code. Simply change the forwarding-XML.&lt;br/&gt;</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence />
      <xs:attribute name="name" type="xs:string" />
      <xs:attribute name="path" type="xs:string" />
      <xs:attribute name="elementRole" type="xs:string" fixed="forward" />
      <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.core.PipeForward" use="prohibited" />
    </xs:complexType>
  </xs:element>
  <xs:element name="Locker">
    <xs:annotation>
      <xs:documentation>nl.nn.adapterframework.util.Locker - Locker of scheduler jobs and pipes.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence />
      <xs:attribute name="objectId" type="xs:string">
        <xs:annotation>
          <xs:documentation>Identifier for this lock</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="transactionAttribute" type="xs:string">
        <xs:annotation>
          <xs:documentation>The &lt;code&gt;transactionAttribute&lt;/code&gt; declares transactional behavior of execution. It applies both to database transactions and XA transactions.The pipeline uses this to start a new transaction or suspend the current one when required. For developers: it is equalto &lt;a href="https://docs.oracle.com/javaee/7/tutorial/transactions003.htm"&gt;EJB transaction attribute&lt;/a&gt;. Possible values for transactionAttribute:  &lt;table border="1"&gt;    &lt;tr&gt;&lt;th&gt;transactionAttribute&lt;/th&gt;&lt;th&gt;callers Transaction&lt;/th&gt;&lt;th&gt;Pipeline excecuted in Transaction&lt;/th&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Required&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;RequiresNew&lt;/td&gt; &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Mandatory&lt;/td&gt;   &lt;td&gt;none&lt;/td&gt;&lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;NotSupported&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Supports&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt; 										      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Never&lt;/td&gt;       &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;  &lt;/table&gt; Default: Supports</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="transactionAttributeNum" type="xs:integer">
        <xs:annotation>
          <xs:documentation>Like &lt;code&gt;transactionAttribute&lt;/code&gt;, but the chosen option is represented with a number. The numbers mean:&lt;table&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Supports&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;Mandatory&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;RequiresNew&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;NotSupported&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;Never&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; Default: 1</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="type" type="xs:string">
        <xs:annotation>
          <xs:documentation>Type for this lock: P(ermanent) or T(emporary). A temporary lock is released after the job has completed Default: T</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="retention" type="xs:integer">
        <xs:annotation>
          <xs:documentation>The time (for type=P in days and for type=T in hours) to keep the record in the database before making it eligible for deletion by a cleanup process Default: 30 days (type=P), 4 hours (type=T)</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="transactionTimeout" type="xs:integer">
        <xs:annotation>
          <xs:documentation>Timeout (in seconds) of transaction started to process a message. Default: &lt;code&gt;0&lt;/code&gt; (use system default)</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="numRetries" type="xs:integer">
        <xs:annotation>
          <xs:documentation>The number of times an attempt should be made to acquire a lock, after this many times an exception is thrown when no lock could be acquired, when -1 the number of retries is unlimited Default: 0</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="firstDelay" type="xs:integer">
        <xs:annotation>
          <xs:documentation>The time in ms to wait before the first attempt to acquire a lock is made Default: 0</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="lockWaitTimeout" type="xs:integer">
        <xs:annotation>
          <xs:documentation>If &gt; 0: The time in s to wait before the INSERT statement to obtain the lock is canceled.  Default: 0</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="retryDelay" type="xs:integer">
        <xs:annotation>
          <xs:documentation>The time in ms to wait before another attempt to acquire a lock is made Default: 10000</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="dateFormatSuffix" type="xs:string">
        <xs:annotation>
          <xs:documentation>Format for date which is added after &lt;code&gt;objectid&lt;/code&gt; (e.g. yyyyMMdd to be sure the job is executed only once a day)</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="ignoreTableNotExist" type="xs:boolean" />
      <xs:attribute name="datasourceName" type="xs:string">
        <xs:annotation>
          <xs:documentation>JNDI name of datasource to be used, can be configured via jmsRealm, too Default: ${jdbc.datasource.default}</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="authAlias" type="xs:string">
        <xs:annotation>
          <xs:documentation>Authentication alias used to authenticate when connecting to database</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="username" type="xs:string">
        <xs:annotation>
          <xs:documentation>User name for authentication when connecting to database, when none found from &lt;code&gt;authAlias&lt;/code&gt;</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="password" type="xs:string">
        <xs:annotation>
          <xs:documentation>Password for authentication when connecting to database, when none found from &lt;code&gt;authAlias&lt;/code&gt;</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="connectionsArePooled" type="xs:boolean" />
      <xs:attribute name="transacted" type="xs:boolean" />
      <xs:attribute name="authentication" type="xs:string">
        <xs:annotation>
          <xs:documentation>maps to the field context.security_authentication</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="credentials" type="xs:string">
        <xs:annotation>
          <xs:documentation>username to connect to context, maps to context.security_credentials</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="initialContextFactoryName" type="xs:string">
        <xs:annotation>
          <xs:documentation>class to use as initial context factory</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="jmsRealm" type="xs:string" />
      <xs:attribute name="jndiAuthAlias" type="xs:string">
        <xs:annotation>
          <xs:documentation>authentication alias, may be used to override principal and credential-settings</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="jndiContextPrefix" type="xs:string" />
      <xs:attribute name="jndiProperties" type="xs:string" />
      <xs:attribute name="name" type="xs:string">
        <xs:annotation>
          <xs:documentation>Name of the sender or the listener</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="principal" type="xs:string">
        <xs:annotation>
          <xs:documentation>username to connect to context, maps to context.security_principal</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="providerURL" type="xs:string">
        <xs:annotation>
          <xs:documentation>Default:</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="securityProtocol" type="xs:string">
        <xs:annotation>
          <xs:documentation>maps to the field context.security_protocol</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="urlPkgPrefixes" type="xs:string">
        <xs:annotation>
          <xs:documentation>maps to the field context.url_pkg_prefixes</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="elementRole" type="xs:string" fixed="locker" />
      <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.util.Locker" use="prohibited" />
    </xs:complexType>
  </xs:element>
  <xs:element name="Exit">
    <xs:annotation>
      <xs:documentation>nl.nn.adapterframework.core.PipeLineExit - The PipeLineExit, that represents a terminator of the PipeLine, provides a placeholder
 for a path (corresponding to a pipeforward) and a state (that is returned to the receiver).</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence />
      <xs:attribute name="code" type="xs:string">
        <xs:annotation>
          <xs:documentation>http statuscode e.g. &lt;code&gt;500&lt;/code&gt; Default: 200</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="empty" type="xs:string">
        <xs:annotation>
          <xs:documentation>when using restlistener and set to &lt;code&gt;true&lt;/code&gt;, this removes the output and shows a blank page, the output is still logged in the ladybug testtool Default: false</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="path" type="xs:string">
        <xs:annotation>
          <xs:documentation>name of the pipeline exit</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="responseRoot" type="xs:string">
        <xs:annotation>
          <xs:documentation>Configures the responseRoot in the OpenAPI schema for this exit. If not set, the responseRoot value of the validator will be used. If that contains multiple (comma separated) values, the first will be used for the exits with state 'success', the last for the other exits.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="state" type="xs:string">
        <xs:annotation>
          <xs:documentation>the exit state defines possible exists to the pipeline. the state can be one of the following: &lt;code&gt;success, error&lt;/code&gt;</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="elementRole" type="xs:string" fixed="exit" />
      <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.core.PipeLineExit" use="prohibited" />
    </xs:complexType>
  </xs:element>
  <xs:element name="Flow">
    <xs:annotation>
      <xs:documentation>nl.nn.adapterframework.batch.RecordHandlingFlow - The flow contains the handlers to handle records of a specific type. 
 Each flow is registered to a manager using the recordHandlerManagerRef.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence />
      <xs:attribute name="recordKey" type="xs:string">
        <xs:annotation>
          <xs:documentation>Key under which this flow is registered in the manager</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="nextRecordHandlerManagerRef" type="xs:string">
        <xs:annotation>
          <xs:documentation>Name of the manager to be used after handling this record</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="recordHandlerRef" type="xs:string">
        <xs:annotation>
          <xs:documentation>Name of the recordHandler to be used to transform records of the type specified in the key (optional)</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="recordHandlerManagerRef" type="xs:string">
        <xs:annotation>
          <xs:documentation>Name of the manager to which this flow must be added</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="resultHandlerRef" type="xs:string">
        <xs:annotation>
          <xs:documentation>Name of the resultHandler to be used to handle the transformed result</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="openBlockBeforeLine" type="xs:string">
        <xs:annotation>
          <xs:documentation>Instructs the resultHandler to start a new block before the parsed line is processed</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="closeBlockBeforeLine" type="xs:string">
        <xs:annotation>
          <xs:documentation>Instructs the resultHandler to end the specified block before the parsed line is processed</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="openBlockAfterLine" type="xs:string">
        <xs:annotation>
          <xs:documentation>Instructs the resultHandler to start a new block after the parsed line is processed</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="closeBlockAfterLine" type="xs:string">
        <xs:annotation>
          <xs:documentation>Instructs the resultHandler to end the specified block after the parsed line is processed</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="autoCloseBlock" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, any open block of this type (and other nested open 'autoClose' block) is closed before a new one of the same type is opened. At a forced close, nested blocks are closed too (since 4.9) Default: &lt;code&gt;true&lt;/code&gt;</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="openBlockBeforeLineNumber" type="xs:integer">
        <xs:annotation>
          <xs:documentation>If &amp;gt;0 the &lt;code&gt;openBlockBeforeLine&lt;/code&gt; instruction is only performed when the current line number is a multiple of this value Default: 0</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="elementRole" type="xs:string" fixed="flow" />
      <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.RecordHandlingFlow" />
    </xs:complexType>
  </xs:element>
  <xs:element name="InputFields">
    <xs:annotation>
      <xs:documentation>nl.nn.adapterframework.batch.InputfieldsPart</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence />
      <xs:attribute name="description" type="xs:string" />
      <xs:attribute name="value" type="xs:string" />
      <xs:attribute name="elementRole" type="xs:string" fixed="inputFields" />
      <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.InputfieldsPart" />
    </xs:complexType>
  </xs:element>
  <xs:element name="OutputFields">
    <xs:annotation>
      <xs:documentation>nl.nn.adapterframework.batch.OutputfieldsPart</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence />
      <xs:attribute name="description" type="xs:string" />
      <xs:attribute name="value" type="xs:string" />
      <xs:attribute name="elementRole" type="xs:string" fixed="outputFields" />
      <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.OutputfieldsPart" />
    </xs:complexType>
  </xs:element>
  <xs:element name="Job">
    <xs:annotation>
      <xs:documentation>nl.nn.adapterframework.scheduler.JobDef - Definition / configuration of scheduler jobs.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="DirectoryCleaner" minOccurs="0" maxOccurs="unbounded" />
        <xs:element ref="Locker" minOccurs="0" maxOccurs="1" />
      </xs:sequence>
      <xs:attribute name="adapterName" type="xs:string">
        <xs:annotation>
          <xs:documentation>adapter on which job operates</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="configurationName" type="xs:string">
        <xs:annotation>
          <xs:documentation>configuration on which job operates</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="cronExpression" type="xs:string">
        <xs:annotation>
          <xs:documentation>cron expression that determines the frequency of execution (see below)</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="description" type="xs:string">
        <xs:annotation>
          <xs:documentation>optional description of the job</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="function" type="JobDefFunctionsAttributeValuesType">
        <xs:annotation>
          <xs:documentation>one of: stopadapter, startadapter, stopreceiver, startreceiver, sendmessage, executequery, cleanupfilesystem</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="interval" type="xs:integer">
        <xs:annotation>
          <xs:documentation>repeat the job at the specified number of ms. keep cronexpression empty to use interval. set to 0 to only run once at startup of the application. a value of 0 in combination with function 'sendmessage' will set dependencytimeout on the ibislocalsender to -1 to keep waiting indefinitely instead of max 60 seconds for the adapter to start.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="jmsRealm" type="xs:string">
        <xs:annotation>
          <xs:documentation>Default:</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="jobGroup" type="xs:string" />
      <xs:attribute name="message" type="xs:string">
        <xs:annotation>
          <xs:documentation>message to be send into the pipeline</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="messageKeeperSize" type="xs:integer">
        <xs:annotation>
          <xs:documentation>number of message displayed in ibisconsole Default: 10</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="name" type="xs:string">
        <xs:annotation>
          <xs:documentation>name of the job</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="numThreads" type="xs:integer">
        <xs:annotation>
          <xs:documentation>the number of threads that may execute concurrently Default: 1</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="query" type="xs:string">
        <xs:annotation>
          <xs:documentation>the sql query text to be executed</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="queryTimeout" type="xs:integer">
        <xs:annotation>
          <xs:documentation>the number of seconds the driver will wait for a statement object to execute. if the limit is exceeded, a timeoutexception is thrown. 0 means no timeout Default: 0</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="receiverName" type="xs:string">
        <xs:annotation>
          <xs:documentation>receiver on which job operates. If function is 'sendmessage' this should be the name of the javalistener you wish to call</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="transactionAttribute" type="xs:string">
        <xs:annotation>
          <xs:documentation>The &lt;code&gt;transactionAttribute&lt;/code&gt; declares transactional behavior of execution. It applies both to database transactions and XA transactions.The pipeline uses this to start a new transaction or suspend the current one when required. For developers: it is equalto &lt;a href="https://docs.oracle.com/javaee/7/tutorial/transactions003.htm"&gt;EJB transaction attribute&lt;/a&gt;. Possible values for transactionAttribute:  &lt;table border="1"&gt;    &lt;tr&gt;&lt;th&gt;transactionAttribute&lt;/th&gt;&lt;th&gt;callers Transaction&lt;/th&gt;&lt;th&gt;Pipeline excecuted in Transaction&lt;/th&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Required&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;RequiresNew&lt;/td&gt; &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Mandatory&lt;/td&gt;   &lt;td&gt;none&lt;/td&gt;&lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;NotSupported&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Supports&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt; 										      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Never&lt;/td&gt;       &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;  &lt;/table&gt; Default: Supports</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="transactionAttributeNum" type="xs:integer">
        <xs:annotation>
          <xs:documentation>Like &lt;code&gt;transactionAttribute&lt;/code&gt;, but the chosen option is represented with a number. The numbers mean:&lt;table&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Supports&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;Mandatory&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;RequiresNew&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;NotSupported&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;Never&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; Default: 1</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="transactionTimeout" type="xs:integer">
        <xs:annotation>
          <xs:documentation>Timeout (in seconds) of transaction started to process a message. Default: &lt;code&gt;0&lt;/code&gt; (use system default)</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="transacted" type="xs:boolean" />
      <xs:attribute name="elementRole" type="xs:string" fixed="job" />
      <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.scheduler.JobDef" use="prohibited" />
    </xs:complexType>
  </xs:element>
  <xs:element name="DirectoryCleaner">
    <xs:annotation>
      <xs:documentation>nl.nn.adapterframework.util.DirectoryCleaner - Cleans up a directory.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence />
      <xs:attribute name="deleteEmptySubdirectories" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, empty subdirectories will be deleted, too Default: false</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="directory" type="xs:string">
        <xs:annotation>
          <xs:documentation>directory to be cleaned up</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="notExistWarn" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, send warnings to logging and console about not existing directories Default: true</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="retention" type="xs:string">
        <xs:annotation>
          <xs:documentation>time (with suffix 'd', 'h', 'm' or 's' in milliseconds) that must have passed at least before a file will be deleted Default: 30d</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="subdirectories" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, files in subdirectories will be deleted, too Default: false</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="elementRole" type="xs:string" fixed="directoryCleaner" />
      <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.util.DirectoryCleaner" />
    </xs:complexType>
  </xs:element>
  <xs:group name="ListenerElementGroup">
    <xs:choice>
      <xs:element name="Listener">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element ref="Param" />
              <xs:group ref="SenderElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ListenerElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="SenderElementGroup">
    <xs:choice>
      <xs:element name="Sender">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:group ref="CacheElementGroup" />
              <xs:element ref="Param" />
              <xs:group ref="SenderElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="SenderElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="CacheElementGroup">
    <xs:choice>
      <xs:element name="Cache">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded" />
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="cache" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="CacheElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="CacheElementGroupBase">
    <xs:choice>
      <xs:element name="EhCacheCache">
        <xs:annotation>
          <xs:documentation>EhCacheCache - nl.nn.adapterframework.cache.EhCache used as Cache

General Cache provider.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EhCacheType">
              <xs:attribute name="elementRole" type="xs:string" fixed="cache" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.cache.EhCache" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="EhCacheType">
    <xs:attributeGroup ref="EhCacheCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="EhCacheDeclaredAttributeGroup">
    <xs:attribute name="maxElementsInMemory" type="xs:integer">
      <xs:annotation>
        <xs:documentation>The maximum number of elements in memory, before they are evicted Default: 100</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="memoryStoreEvictionPolicy" type="xs:string">
      <xs:annotation>
        <xs:documentation>Either &lt;code&gt;LRU&lt;/code&gt;=Least Recent Use,&lt;code&gt;LFU&lt;/code&gt;=Least Frequent Use or &lt;code&gt;FIFO&lt;/code&gt;=First In - First Out Default: LRU</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="eternal" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the elements in the cache are eternal, i.e. never expire Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeToLiveSeconds" type="xs:integer">
      <xs:annotation>
        <xs:documentation>The amount of time to live for an element from its creation date Default: 36000 (=10 hours)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeToIdleSeconds" type="xs:integer">
      <xs:annotation>
        <xs:documentation>The amount of time to live for an element from its last accessed or modified date Default: 36000 (=10 hours)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="overflowToDisk" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the elements that are evicted from memory are spooled to disk Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxElementsOnDisk" type="xs:integer">
      <xs:annotation>
        <xs:documentation>The maximum number of elements on disk, before they are removed Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="diskPersistent" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the the cache is reloaded after the JVM restarts Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="diskExpiryThreadIntervalSeconds" type="xs:integer">
      <xs:annotation>
        <xs:documentation>How often to run the disk store expiry thread Default: 600</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="EhCacheCumulativeAttributeGroup">
    <xs:attributeGroup ref="EhCacheDeclaredAttributeGroup" />
    <xs:attributeGroup ref="CacheAdapterBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="CacheAdapterBaseDeclaredAttributeGroup">
    <xs:attribute name="cacheEmptyKeys" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether empty keys are used for caching. when set true, cache entries with empty keys can exist. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cacheEmptyValues" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether empty values will be cached. when set true, empty cache entries can exist for any key. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyInputSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to use as input for transformation of request message to key by keyxpath or keystylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for keyxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract cache key from request message. Use in combination with {@link #setCacheEmptyKeys(boolean) cacheEmptyKeys} to inhibit caching for certain groups of request messages</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract cache key from request message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyXPathOutputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>output type of xpath expression to extract cache key from request message, must be 'xml' or 'text' Default: text</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the cache, will be set from owner</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueInputSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to use as input for transformation of response message to cached value by valuexpath or valuestylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for valuexpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract value to be cached from response message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract value to be cached key from response message. Use in combination with {@link #setCacheEmptyValues(boolean) cacheEmptyValues} to inhibit caching for certain groups of response messages</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueXPathOutputType" type="xs:string" />
  </xs:attributeGroup>
  <xs:group name="SenderElementGroupBase">
    <xs:choice>
      <xs:element name="Afm2EdiFactSender">
        <xs:annotation>
          <xs:documentation>Afm2EdiFactSender - nl.nn.adapterframework.extensions.afm.Afm2EdiFactSender used as Sender

Domparser om AFM-XML berichten om te zetten in edifactberichten (voor de backoffice).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Afm2EdiFactSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.afm.Afm2EdiFactSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="AmazonS3Sender">
        <xs:annotation>
          <xs:documentation>AmazonS3Sender - nl.nn.adapterframework.senders.AmazonS3Sender used as Sender

Sender to work with Amazon S3.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="AmazonS3SenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.AmazonS3Sender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="BisJmsSender">
        <xs:annotation>
          <xs:documentation>BisJmsSender - nl.nn.adapterframework.extensions.bis.BisJmsSender used as Sender

Bis (Business Integration Services) extension of JmsSender.
 &lt;br/&gt;
 For example request and reply, see {@link BisJmsListener}.
 &lt;br/&gt;
 If synchronous=true and one of the following conditions is true a SenderException is thrown:
 - Result/Status in the reply soap body equals 'ERROR'
 - faultcode in the reply soap fault is not empty
 &lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="BisJmsSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.bis.BisJmsSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CommandSender">
        <xs:annotation>
          <xs:documentation>CommandSender - nl.nn.adapterframework.senders.CommandSender used as Sender

Sender that executes either its input or a fixed line, with all parametervalues appended, as a command.
 &lt;table border="1"&gt;
 &lt;p&gt;&lt;b&gt;Parameters:&lt;/b&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;type&lt;/th&gt;&lt;th&gt;remarks&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;the values of all parameters present are appended as arguments to the command&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CommandSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.CommandSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DelaySender">
        <xs:annotation>
          <xs:documentation>DelaySender - nl.nn.adapterframework.senders.DelaySender used as Sender

Sender that sleeps for a specified time, which defaults to 5000 msecs.
 Useful for testing purposes.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DelaySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.DelaySender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DirectQuerySender">
        <xs:annotation>
          <xs:documentation>DirectQuerySender - nl.nn.adapterframework.jdbc.DirectQuerySender used as Sender

QuerySender that interprets the input message as a query, possibly with attributes.
 Messages are expected to contain sql-text.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DirectQuerySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.DirectQuerySender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EchoSender">
        <xs:annotation>
          <xs:documentation>EchoSender - nl.nn.adapterframework.senders.EchoSender used as Sender

Echos input to output.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EchoSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.EchoSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbJmsSender">
        <xs:annotation>
          <xs:documentation>EsbJmsSender - nl.nn.adapterframework.extensions.esb.EsbJmsSender used as Sender

ESB (Enterprise Service Bus) extension of JmsSender.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbJmsSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.esb.EsbJmsSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ExchangeFolderSender">
        <xs:annotation>
          <xs:documentation>ExchangeFolderSender - nl.nn.adapterframework.senders.ExchangeFolderSender used as Sender

Implementation of a {@link FileSystemSender} that enables to manipulate messages in a Exchange folder.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ExchangeFolderSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.ExchangeFolderSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FileSender">
        <xs:annotation>
          <xs:documentation>FileSender - nl.nn.adapterframework.senders.FileSender used as Sender

&lt;p&gt;See {@link FileHandler}&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FileSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.FileSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FileSystemSender">
        <xs:annotation>
          <xs:documentation>FileSystemSender - nl.nn.adapterframework.filesystem.FileSystemSender used as Sender

Base class for Senders that use a {@link IBasicFileSystem FileSystem}.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FileSystemSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.filesystem.FileSystemSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FileSystemSenderWithAttachmentsSender">
        <xs:annotation>
          <xs:documentation>FileSystemSenderWithAttachmentsSender - nl.nn.adapterframework.filesystem.FileSystemSenderWithAttachments used as Sender

FileSystem Sender extension to handle Attachments.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FileSystemSenderWithAttachmentsType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.filesystem.FileSystemSenderWithAttachments" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FixedQuerySender">
        <xs:annotation>
          <xs:documentation>FixedQuerySender - nl.nn.adapterframework.jdbc.FixedQuerySender used as Sender

QuerySender that assumes a fixed query, possibly with attributes.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FixedQuerySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.FixedQuerySender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FixedResultSender">
        <xs:annotation>
          <xs:documentation>FixedResultSender - nl.nn.adapterframework.senders.FixedResultSender used as Sender

FixedResultSender, same behaviour as {@link nl.nn.adapterframework.pipes.FixedResultPipe FixedResultPipe}, but now as a ISender.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FixedResultSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.FixedResultSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FtpFileSystemSender">
        <xs:annotation>
          <xs:documentation>FtpFileSystemSender - nl.nn.adapterframework.senders.FtpFileSystemSender used as Sender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FtpFileSystemSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.FtpFileSystemSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FtpSender">
        <xs:annotation>
          <xs:documentation>FtpSender - nl.nn.adapterframework.ftp.FtpSender used as Sender

FTP client voor het versturen van files via FTP.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FtpSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.ftp.FtpSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="HttpSender">
        <xs:annotation>
          <xs:documentation>HttpSender - nl.nn.adapterframework.http.HttpSender used as Sender

Sender for the HTTP protocol using GET, POST, PUT or DELETE.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="HttpSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.HttpSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IbisJavaSender">
        <xs:annotation>
          <xs:documentation>IbisJavaSender - nl.nn.adapterframework.senders.IbisJavaSender used as Sender

Posts a message to another IBIS-adapter or application in the same JVM using IbisServiceDispatcher.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IbisJavaSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.IbisJavaSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IbisLocalSender">
        <xs:annotation>
          <xs:documentation>IbisLocalSender - nl.nn.adapterframework.senders.IbisLocalSender used as Sender

Posts a message to another IBIS-adapter in the same IBIS instance.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IbisLocalSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.IbisLocalSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IbisWebServiceSender">
        <xs:annotation>
          <xs:documentation>IbisWebServiceSender - nl.nn.adapterframework.http.IbisWebServiceSender used as Sender

Posts a message to another IBIS-adapter as a WebService.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IbisWebServiceSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.IbisWebServiceSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ImapSender">
        <xs:annotation>
          <xs:documentation>ImapSender - nl.nn.adapterframework.senders.ImapSender used as Sender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ImapSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.ImapSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JavascriptSender">
        <xs:annotation>
          <xs:documentation>JavascriptSender - nl.nn.adapterframework.senders.JavascriptSender used as Sender

Sender used to run javascript code using J2V8 or Rhino</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JavascriptSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.JavascriptSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JmsSender">
        <xs:annotation>
          <xs:documentation>JmsSender - nl.nn.adapterframework.jms.JmsSender used as Sender

This class sends messages with JMS.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JmsSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jms.JmsSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JsonXsltSender">
        <xs:annotation>
          <xs:documentation>JsonXsltSender - nl.nn.adapterframework.senders.JsonXsltSender used as Sender

Perform an XSLT transformation with a specified stylesheet on a JSON input, yielding JSON, yielding JSON, XML or text.
 JSON input is transformed into XML map, array, string, integer and boolean elements, in the namespace http://www.w3.org/2013/XSL/json.
 The XSLT stylesheet or XPathExpression operates on these element.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JsonXsltSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.JsonXsltSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LdapSender">
        <xs:annotation>
          <xs:documentation>LdapSender - nl.nn.adapterframework.ldap.LdapSender used as Sender

Sender to obtain information from and write to an LDAP Directory.
 Returns the set of attributes in an XML format. Examples are shown below.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LdapSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.ldap.LdapSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LocalFileSystemSender">
        <xs:annotation>
          <xs:documentation>LocalFileSystemSender - nl.nn.adapterframework.senders.LocalFileSystemSender used as Sender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LocalFileSystemSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.LocalFileSystemSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LogSender">
        <xs:annotation>
          <xs:documentation>LogSender - nl.nn.adapterframework.senders.LogSender used as Sender

Sender that just logs its message.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LogSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.LogSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MailSender">
        <xs:annotation>
          <xs:documentation>MailSender - nl.nn.adapterframework.senders.MailSender used as Sender

{@link nl.nn.adapterframework.core.ISender sender} that sends a mail specified by an XML message.
 &lt;p&gt;
 Sample email.xml:
 &lt;code&gt;&lt;pre&gt;
    &amp;lt;email&amp;gt;
       &amp;lt;recipients&amp;gt;
          &amp;lt;recipient type="to"&amp;gt;***@hotmail.com&amp;lt;/recipient&amp;gt;
          &amp;lt;recipient type="cc"&amp;gt;***@gmail.com&amp;lt;/recipient&amp;gt;
       &amp;lt;/recipients&amp;gt;
       &amp;lt;from name="*** ***"&amp;gt;***@yahoo.com&amp;lt;/from&amp;gt;
       &amp;lt;subject&amp;gt;This is the subject&amp;lt;/subject&amp;gt;
       &amp;lt;threadTopic&amp;gt;subject&amp;lt;/threadTopic&amp;gt;
       &amp;lt;message&amp;gt;This is the message&amp;lt;/message&amp;gt;
       &amp;lt;messageType&amp;gt;text/plain&amp;lt;/messageType&amp;gt;&amp;lt;!-- Optional --&amp;gt;
       &amp;lt;messageBase64&amp;gt;false&amp;lt;/messageBase64&amp;gt;&amp;lt;!-- Optional --&amp;gt;
       &amp;lt;charset&amp;gt;UTF-8&amp;lt;/charset&amp;gt;&amp;lt;!-- Optional --&amp;gt;
       &amp;lt;attachments&amp;gt;
          &amp;lt;attachment name="filename1.txt"&amp;gt;This is the first attachment&amp;lt;/attachment&amp;gt;
          &amp;lt;attachment name="filename2.pdf" base64="true"&amp;gt;JVBERi0xLjQKCjIgMCBvYmoKPDwvVHlwZS9YT2JqZWN0L1N1YnR5cGUvSW1...vSW5mbyA5IDAgUgo+PgpzdGFydHhyZWYKMzQxNDY2CiUlRU9GCg==&amp;lt;/attachment&amp;gt;
          &amp;lt;attachment name="filename3.pdf" url="file:/c:/filename3.pdf"/&amp;gt;
          &amp;lt;attachment name="filename4.pdf" sessionKey="fileContent"/&amp;gt;
       &amp;lt;/attachments&amp;gt;&amp;lt;!-- Optional --&amp;gt;
   &amp;lt;/email&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;
 &lt;p&gt;
 Notice: the XML message must be valid XML. Therefore, especially the message element
 must be plain text or be wrapped as CDATA. Example:
 &lt;code&gt;&lt;pre&gt;
    &amp;lt;message&amp;gt;&amp;lt;![CDATA[&amp;lt;h1&amp;gt;This is a HtmlMessage&amp;lt;/h1&amp;gt;]]&amp;gt;&amp;lt;/message&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;
 &lt;p&gt;
 The &lt;code&gt;sessionKey&lt;/code&gt; attribute for attachment can contain an inputstream or a string. Other types are not supported at this moment.
 &lt;p&gt;
 The attribute order for attachments is as follows:
 &lt;ol&gt;
    &lt;li&gt;sessionKey&lt;/li&gt;
    &lt;li&gt;url&lt;/li&gt;
    &lt;li&gt;&lt;i&gt;value of the attachment element&lt;/i&gt;&lt;/li&gt;
 &lt;/ol&gt;
 &lt;p&gt;
 The &lt;code&gt;base64&lt;/code&gt; attribute is only used when the value of the PipeLineSession variable &lt;code&gt;sessionKey&lt;/code&gt; is a String object
 or when the value of the attachment element is used. If &lt;code&gt;base64=true&lt;/code&gt; then the value will be decoded before it's used.
 &lt;p&gt;
 &lt;b&gt;Configuration:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setSmtpHost(String) smtpHost}&lt;/td&gt;&lt;td&gt;name of the host by which the messages are to be send&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setAuthAlias(String) smtpAuthAlias}&lt;/td&gt;&lt;td&gt;alias used to obtain credentials for authentication to smtpHost&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setUserId(String) userId}&lt;/td&gt;&lt;td&gt;userId on the smtpHost&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setPassword(String) password}&lt;/td&gt;&lt;td&gt;password of userId on the smtpHost&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setSmtpAuthAlias(String) smtpAuthAlias}&lt;/td&gt;&lt;td&gt;alias used to obtain credentials for authentication to smtpHost&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setSmtpUserid(String) userId}&lt;/td&gt;&lt;td&gt;userId on the smtpHost&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setSmtpPassword(String) password}&lt;/td&gt;&lt;td&gt;password of userId on the smtpHost&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setDefaultFrom(String) defaultFrom}&lt;/td&gt;&lt;td&gt;value of the From: header if not specified in message itself&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setDefaultSubject(String) defaultSubject}&lt;/td&gt;&lt;td&gt;value of the Subject: header if not specified in message itself&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setDefaultAttachmentName(String) defaultAttachmentName}&lt;/td&gt;&lt;td&gt;When this name is used, it will be followed by a number which is equal to the node's position&lt;/td&gt;&lt;td&gt;attachment&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setTimeout(int) timeout}&lt;/td&gt;&lt;td&gt;timeout (in milliseconds). Used for socket connection timeout and socket I/O timeout&lt;/td&gt;&lt;td&gt;20000&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;p&gt;
 &lt;table border="1"&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;type&lt;/th&gt;&lt;th&gt;remarks&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;from&lt;/td&gt;&lt;td&gt;string&lt;/td&gt;&lt;td&gt;email address of the sender&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;subject&lt;/td&gt;&lt;td&gt;string&lt;/td&gt;&lt;td&gt;subject field of the message&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;threadTopic&lt;/td&gt;&lt;td&gt;string&lt;/td&gt;&lt;td&gt;(optional) conversation field of the message, used to correlate mails in mail viewer (header field "Thread-Topic"). Note: subject must end with value of threadTopic, but cann't be exactly the same&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;message&lt;/td&gt;&lt;td&gt;string&lt;/td&gt;&lt;td&gt;message itself. If absent, the complete input message is assumed to be the message&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;messageType&lt;/td&gt;&lt;td&gt;string&lt;/td&gt;&lt;td&gt;message MIME type (at this moment only available are text/plain and text/html - default: text/plain)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;messageBase64&lt;/td&gt;&lt;td&gt;boolean&lt;/td&gt;&lt;td&gt;indicates whether the message content is base64 encoded (default: false)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;charSet&lt;/td&gt;&lt;td&gt;string&lt;/td&gt;&lt;td&gt;the character encoding (e.g. ISO-8859-1 or UTF-8) used to send the email (default: UTF-8)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;recipients&lt;/td&gt;&lt;td&gt;xml&lt;/td&gt;&lt;td&gt;recipients of the message. must result in a structure like: &lt;code&gt;&lt;pre&gt;
       &amp;lt;recipient type="to"&amp;gt;***@hotmail.com&amp;lt;/recipient&amp;gt;
       &amp;lt;recipient type="cc"&amp;gt;***@gmail.com&amp;lt;/recipient&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;attachments&lt;/td&gt;&lt;td&gt;xml&lt;/td&gt;&lt;td&gt;attachments to the message. must result in a structure like: &lt;code&gt;&lt;pre&gt;
       &amp;lt;attachment name="filename1.txt"&amp;gt;This is the first attachment&amp;lt;/attachment&amp;gt;
       &amp;lt;attachment name="filename2.pdf" base64="true"&amp;gt;JVBERi0xLjQKCjIgMCBvYmoKPDwvVHlwZS9YT2JqZWN0L1N1YnR5cGUvSW1...vSW5mbyA5IDAgUgo+PgpzdGFydHhyZWYKMzQxNDY2CiUlRU9GCg==&amp;lt;/attachment&amp;gt;
       &amp;lt;attachment name="filename3.pdf" url="file:/c:/filename3.pdf"/&amp;gt;
       &amp;lt;attachment name="filename4.pdf" sessionKey="fileContent"/&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;p&gt;
 &lt;b&gt;Compilation and Deployment Note:&lt;/b&gt; mail.jar (v1.2) and activation.jar must appear BEFORE j2ee.jar.
 Otherwise errors like the following might occur: &lt;code&gt;NoClassDefFoundException: com/sun/mail/util/MailDateFormat&lt;/code&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MailSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.MailSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MessageStoreSender">
        <xs:annotation>
          <xs:documentation>MessageStoreSender - nl.nn.adapterframework.jdbc.MessageStoreSender used as Sender

Send messages to the ibisstore to have them processed exactly-once by another
 adapter which will read the messages using a {@link MessageStoreListener}.
 This other adapter will process the messages asynchronously and (optionally)
 under transaction control. Duplicate messages are ignored based on the
 messageId (except when onlyStoreWhenMessageIdUnique is set to false), hence
 the sender of the message can retry sending the message until a valid reply
 is received in which case it can be certain that the message is stored in the
 ibisstore.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MessageStoreSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.MessageStoreSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MongoDbSender">
        <xs:annotation>
          <xs:documentation>MongoDbSender - nl.nn.adapterframework.mongodb.MongoDbSender used as Sender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MongoDbSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.mongodb.MongoDbSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MqttSender">
        <xs:annotation>
          <xs:documentation>MqttSender - nl.nn.adapterframework.extensions.mqtt.MqttSender used as Sender

MQTT listener which will connect to a broker and subscribe to a topic.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MqttSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.mqtt.MqttSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MultipartHttpSender">
        <xs:annotation>
          <xs:documentation>MultipartHttpSender - nl.nn.adapterframework.http.MultipartHttpSender used as Sender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MultipartHttpSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.MultipartHttpSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ParallelSendersSender">
        <xs:annotation>
          <xs:documentation>ParallelSendersSender - nl.nn.adapterframework.senders.ParallelSenders used as Sender

Collection of Senders, that are executed all at the same time.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ParallelSendersType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.ParallelSenders" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ReloadSender">
        <xs:annotation>
          <xs:documentation>ReloadSender - nl.nn.adapterframework.senders.ReloadSender used as Sender

Performs a reload on database config .</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ReloadSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.ReloadSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="RestSender">
        <xs:annotation>
          <xs:documentation>RestSender - nl.nn.adapterframework.http.RestSender used as Sender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RestSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.RestSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ResultSet2FileSender">
        <xs:annotation>
          <xs:documentation>ResultSet2FileSender - nl.nn.adapterframework.jdbc.ResultSet2FileSender used as Sender

QuerySender that writes each row in a ResultSet to a file.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ResultSet2FileSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.ResultSet2FileSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Samba1Sender">
        <xs:annotation>
          <xs:documentation>Samba1Sender - nl.nn.adapterframework.senders.Samba1Sender used as Sender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Samba1SenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.Samba1Sender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Samba2Sender">
        <xs:annotation>
          <xs:documentation>Samba2Sender - nl.nn.adapterframework.senders.Samba2Sender used as Sender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Samba2SenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.Samba2Sender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SambaSender">
        <xs:annotation>
          <xs:documentation>SambaSender - nl.nn.adapterframework.senders.SambaSender used as Sender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SambaSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.SambaSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SambaSenderOldSender">
        <xs:annotation>
          <xs:documentation>SambaSenderOldSender - nl.nn.adapterframework.senders.SambaSenderOld used as Sender

Samba Sender: The standard Windows interoperability suite for Linux and Unix.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SambaSenderOldType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.SambaSenderOld" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SchedulerSender">
        <xs:annotation>
          <xs:documentation>SchedulerSender - nl.nn.adapterframework.scheduler.SchedulerSender used as Sender

Registers a trigger in the scheduler so that the message is send to a javalistener
 at a scheduled time.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SchedulerSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.scheduler.SchedulerSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SendGridSender">
        <xs:annotation>
          <xs:documentation>SendGridSender - nl.nn.adapterframework.senders.SendGridSender used as Sender

Sender that sends a mail via SendGrid v3 (cloud-based SMTP provider).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SendGridSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.SendGridSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SenderSeriesSender">
        <xs:annotation>
          <xs:documentation>SenderSeriesSender - nl.nn.adapterframework.senders.SenderSeries used as Sender

Series of Senders, that are executed one after another.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SenderSeriesType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.SenderSeries" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SenderWrapperSender">
        <xs:annotation>
          <xs:documentation>SenderWrapperSender - nl.nn.adapterframework.senders.SenderWrapper used as Sender

Wrapper for senders, that allows to get input from a session variable, and to store output in a session variable.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SenderWrapperType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.SenderWrapper" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ShadowSender">
        <xs:annotation>
          <xs:documentation>ShadowSender - nl.nn.adapterframework.senders.ShadowSender used as Sender

Collection of Senders, that are executed all at the same time. Once the results are processed, all results will be sent to the resultSender, while the original sender will return it's result to the pipeline.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ShadowSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.ShadowSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="WebServiceNtlmSender">
        <xs:annotation>
          <xs:documentation>WebServiceNtlmSender - nl.nn.adapterframework.http.WebServiceNtlmSender used as Sender

Sender that sends a message via a WebService based on NTLM authentication.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="WebServiceNtlmSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.WebServiceNtlmSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="WebServiceSender">
        <xs:annotation>
          <xs:documentation>WebServiceSender - nl.nn.adapterframework.http.WebServiceSender used as Sender

Sender that sends a message via a WebService.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="WebServiceSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.WebServiceSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XComSender">
        <xs:annotation>
          <xs:documentation>XComSender - nl.nn.adapterframework.xcom.XComSender used as Sender

XCom client voor het versturen van files via XCom.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XComSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.xcom.XComSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XfbSender">
        <xs:annotation>
          <xs:documentation>XfbSender - nl.nn.adapterframework.extensions.xfb.XfbSender used as Sender

Sender for transferring files using the XFB protocol. Assumes sender input is local filename.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XfbSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.xfb.XfbSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlJmsBrowserSender">
        <xs:annotation>
          <xs:documentation>XmlJmsBrowserSender - nl.nn.adapterframework.jms.XmlJmsBrowserSender used as Sender

Sender for browsing and removing queue messages (with input and output in a XML message).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlJmsBrowserSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jms.XmlJmsBrowserSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlQuerySender">
        <xs:annotation>
          <xs:documentation>XmlQuerySender - nl.nn.adapterframework.jdbc.XmlQuerySender used as Sender

QuerySender that transforms the input message to a query.
 &lt;br/&gt;&lt;code&gt;&lt;pre&gt;
  select
  delete
  insert
  update - tableName
         - columns [0..1] - column [1..n] - name
                                          - value [0..1]
                                          - type [0..1] one of {string;function;number;datetime;blob;clob;xmldatetime}, string by default
                                          - decimalSeparator [0..1] only applicable for type=number
                                          - groupingSeparator [0..1] only applicable for type=number
                                          - formatString [0..1] only applicable for type=datetime, yyyy-MM-dd HH:mm:ss.SSS by default 
         - where [0..1]
         - order [0..1]
 &lt;br/&gt;
  alter - sequenceName
        - startWith
 &lt;br/&gt;
  sql   - type [0..1] one of {select;ddl;other}, other by default
        - query
 &lt;br/&gt;
 &lt;/pre&gt;&lt;/code&gt;&lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlQuerySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.XmlQuerySender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlValidatorSender">
        <xs:annotation>
          <xs:documentation>XmlValidatorSender - nl.nn.adapterframework.senders.XmlValidatorSender used as Sender

&lt;code&gt;Sender&lt;/code&gt; that validates the input message against a XML-Schema.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlValidatorSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.XmlValidatorSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XsltSender">
        <xs:annotation>
          <xs:documentation>XsltSender - nl.nn.adapterframework.senders.XsltSender used as Sender

Perform an XSLT transformation with a specified stylesheet or XPath-expression.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XsltSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.XsltSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ZipWriterSender">
        <xs:annotation>
          <xs:documentation>ZipWriterSender - nl.nn.adapterframework.compression.ZipWriterSender used as Sender

Sender that writes an entry to a ZipStream, similar to ZipWriterPipe with action='write'.
 Filename and contents are taken from parameters. If one of the parameters is not present, the input message 
 is used for either filename or contents.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ZipWriterSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.compression.ZipWriterSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="Afm2EdiFactSenderType">
    <xs:attributeGroup ref="Afm2EdiFactSenderDeclaredAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="Afm2EdiFactSenderDeclaredAttributeGroup">
    <xs:attribute name="destination" type="xs:string" />
    <xs:attribute name="name" type="xs:string" />
    <xs:attribute name="postbus" type="xs:string" />
    <xs:attribute name="tpnummer" type="xs:string" />
  </xs:attributeGroup>
  <xs:complexType name="AmazonS3SenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="AmazonS3SenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="AmazonS3SenderDeclaredAttributeGroup">
    <xs:attribute name="accessKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>access key to access to the AWS resources owned by the account</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain AWS credentials</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="bucketCreationEnabled" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>enables creating bucket by upload and copy action if the bucket does not exist Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="bucketName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the bucket to access</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="bucketRegion" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the bucket region for create action</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chunkedEncodingDisabled" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>setting this flag will result in disabling chunked encoding for all requests. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clientRegion" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the region that the client will be created from Default: eu-west-1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationBucketName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the destination bucket name can be used for copy action</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expirationInDays" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the time, in days, between when an object is restored to thebucket and when it expires</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forceGlobalBucketAccessEnabled" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>set whether the client should be configured with global bucket access enabled. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>setting proxy host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:integer">
      <xs:annotation>
        <xs:documentation>setting proxy port</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secretKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>secret key to access to the AWS resources owned by the account</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storageClass" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the storage class for copy action. If storage class is enabled must be specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storageClassEnabled" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>enables storage class for copy action Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tier" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of tier for restore action</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="AmazonS3SenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="AmazonS3SenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="SenderWithParametersBaseDeclaredChildGroup">
    <xs:sequence>
      <xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="SenderBaseDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the sender</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:complexType name="FileSystemSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FileSystemSenderDeclaredAttributeGroup">
    <xs:attribute name="action" type="xs:string">
      <xs:annotation>
        <xs:documentation>Possible values: list, info, read, readDelete, move, copy, delete, mkdir, rmdir, write, append, rename. If parameter [action] is set, then the attribute action value will be overridden with the value of the parameter.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destination" type="xs:string">
      <xs:annotation>
        <xs:documentation>destination for move, copy or rename. If not set, the parameter destination is used. When that is not set either, the input is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filename" type="xs:string">
      <xs:annotation>
        <xs:documentation>filename to operate on. When not set, the parameter filename is used. When that is not set either, the input is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder that is scanned for files when action=list. When not set, the root is scanned</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createFolder" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the folder to move or copy to is created if it does not exist Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="overwrite" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, for actions move, copy or rename, the destination file is overwritten if it already exists Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rotateDays" type="xs:integer">
      <xs:annotation>
        <xs:documentation>for action=append: when set to a positive number, the file is rotated each day, and this number of files is kept. The inputFolder must point to the directory where the file resides Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rotateSize" type="xs:integer">
      <xs:annotation>
        <xs:documentation>for action=append: when set to a positive number, the file is rotated when it has reached the specified size, and the number of files specified in numberOfBackups is kept. Size is specified in plain bytes, suffixes like 'K', 'M' or 'G' are not recognized. The inputFolder must point to the directory where the file resides Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numberOfBackups" type="xs:integer">
      <xs:annotation>
        <xs:documentation>for action=write, and for action=append with rotateSize&gt;0: the number of backup files that is kept. The inputFolder must point to the directory where the file resides Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="base64" type="xs:string">
      <xs:annotation>
        <xs:documentation>Can be set to 'encode' or 'decode' for actions read, write and append. When set the stream is base64 encoded or decoded, respectively</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wildCard" type="xs:string">
      <xs:annotation>
        <xs:documentation>Filter of files to look for in inputFolder e.g. '*.inp'. Works with actions move, copy, delete and list</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="excludeWildCard" type="xs:string">
      <xs:annotation>
        <xs:documentation>Filter of files to be excluded when looking in inputFolder. Works with actions move, copy, delete and list</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNonEmptyFolder" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to true then the folder and the content of the non empty folder will be deleted.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FileSystemSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="FileSystemSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="BisJmsSenderType">
    <xs:group ref="JmsSenderDeclaredChildGroup" />
    <xs:attributeGroup ref="BisJmsSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="BisJmsSenderDeclaredAttributeGroup">
    <xs:attribute name="conversationIdSessionKey" type="xs:string" />
    <xs:attribute name="errorListSessionKey" type="xs:string" />
    <xs:attribute name="externalRefToMessageIdSessionKey" type="xs:string" />
    <xs:attribute name="messageHeaderInSoapBody" type="xs:boolean" />
    <xs:attribute name="removeResponseNamespaces" type="xs:boolean" />
    <xs:attribute name="requestNamespace" type="xs:string" />
    <xs:attribute name="responseNamespaceDefs" type="xs:string" />
    <xs:attribute name="responseXPath" type="xs:string" />
    <xs:attribute name="resultInPayload" type="xs:boolean" />
  </xs:attributeGroup>
  <xs:attributeGroup name="BisJmsSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="BisJmsSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JmsSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JmsSenderType">
    <xs:group ref="JmsSenderDeclaredChildGroup" />
    <xs:attributeGroup ref="JmsSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:group name="JmsSenderDeclaredChildGroup">
    <xs:sequence>
      <xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="JmsSenderDeclaredAttributeGroup">
    <xs:attribute name="destinationParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>Parameter that is used, if specified and not empty, to determine the destination. Overrides the destination attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the sender operates in RR mode: the a reply is expected, either on the queue specified in 'replyToName', or on a dynamically generated temporary queue Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyToName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the queue the reply is expected on. This value is sent in the JMSReplyTo-header with the message.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of the JMSType field Default: not set by application</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deliveryMode" type="DeliveryModeAttributeValuesType">
      <xs:annotation>
        <xs:documentation>Controls mode that messages are sent with: either 'PERSISTENT' or 'NON_PERSISTENT' Default: not set by application</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="priority" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Sets the priority that is used to deliver the message. Ranges from 0 to 9. Defaults to -1, meaning not set. Effectively the default priority is set by JMS to 4 Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soap" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyleURI" type="xs:string">
      <xs:annotation>
        <xs:documentation>SOAP encoding style URI</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespaceURI" type="xs:string">
      <xs:annotation>
        <xs:documentation>SOAP service namespace URI</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapAction" type="xs:string">
      <xs:annotation>
        <xs:documentation>SOAPAction string sent as message property</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of parameter containing SOAP header Default: soapHeader</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyTimeout" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Maximum time in ms to wait for a reply. 0 means no timeout. (only for synchronous=true) Default: 5000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replySoapHeaderSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to store SOAP header of reply Default: replySoapHeader</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Only used when synchronous='true' and and replytoname is set) either 'CORRELATIONID', 'CORRELATIONID_FROM_MESSAGE' or 'MESSAGEID'. Iindicates wether the server uses the correlationId from the pipeline, the correlationId from the message or the messageIid in the correlationId field of the reply. This requires the sender to have set the correlationId at the time of sending. Default: MESSAGEID</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="responseHeadersToSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>A list of JMS headers of the response to add to the pipelinesession</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:simpleType name="DeliveryModeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="NOT_SET" />
      <xs:enumeration value="PERSISTENT" />
      <xs:enumeration value="NON_PERSISTENT" />
    </xs:restriction>
  </xs:simpleType>
  <xs:attributeGroup name="JmsSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="JmsSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JMSFacadeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JMSFacadeType">
    <xs:attributeGroup ref="JMSFacadeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="JMSFacadeDeclaredAttributeGroup">
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the JMS destination (queue or topic) to use</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationType" type="DestinationTypeAttributeValuesType">
      <xs:annotation>
        <xs:documentation>Either &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;topic&lt;/code&gt; Default: &lt;code&gt;queue&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="acknowledgeMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>Acknowledge mode, can be one of ('auto' or 'auto_acknowledge'), ('dups' or 'dups_ok_acknowledge') or ('client' or 'client_acknowledge') Default: auto_acknowledge</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistent" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Normally, if (lookupDestination=true AND destinationType=TOPIC) then the topic is created, instead of looked up. By setting persistent=true in that case, the topic will be looked up. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="subscriberType" type="SubscriberTypeAttributeValuesType">
      <xs:annotation>
        <xs:documentation>SubscriberType, should &lt;b&gt;DURABLE&lt;/b&gt; or &lt;b&gt;TRANSIENT&lt;/b&gt;. Only applicable for topics  Default: DURABLE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>JNDI-name of the queueConnectionFactory, used when &lt;code&gt;destinationType&lt;code&gt;=&lt;/code&gt;QUEUE&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>JNDI-name of the topicConnectionFactory, used when &lt;code&gt;destinationType&lt;code&gt;=&lt;/code&gt;TOPIC&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHex" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part). Useful when sending messages to MQ which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: MQJMS1044: String is not a valid hexadecimal number Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHexPrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>Prefix to check before executing correlationIdToHex. If empty (and correlationIdToHex equals true) all correlationid's are transformed, this is useful in case you want the entire correlationId to be transformed (for example when the receiving party doesn't allow characters like a colon to be present in the correlationId). Default: id:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageTimeToLive" type="xs:integer">
      <xs:annotation>
        <xs:documentation>The time (in milliseconds) it takes for the message to expire. If the message is not consumed before, it will be lost. Mmake sure to set it to a positive value for request/repy type of messages. Default: 0 (unlimited)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdMaxLength" type="xs:integer">
      <xs:annotation>
        <xs:documentation>If set (&gt;=0) and the length of the correlationId exceeds this maximum length, the correlationId is trimmed from the left side of a string to this maximum length Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageSelector" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the value of this attribute is used as a selector to filter messages. Default: 0 (unlimited)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain credentials for authentication to JMS server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lookupDestination" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;false&lt;/code&gt;, the destinationName is used directly instead of performing a JNDI lookup Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ackMode" type="AcknowledgeModeAttributeValuesType" />
    <xs:attribute name="jmsTransacted" type="xs:boolean" />
  </xs:attributeGroup>
  <xs:simpleType name="DestinationTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="QUEUE" />
      <xs:enumeration value="TOPIC" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="SubscriberTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="DURABLE" />
      <xs:enumeration value="TRANSIENT" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="AcknowledgeModeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="NOT_SET" />
      <xs:enumeration value="AUTO_ACKNOWLEDGE" />
      <xs:enumeration value="CLIENT_ACKNOWLEDGE" />
      <xs:enumeration value="DUPS_OK_ACKNOWLEDGE" />
    </xs:restriction>
  </xs:simpleType>
  <xs:attributeGroup name="JMSFacadeCumulativeAttributeGroup">
    <xs:attributeGroup ref="JMSFacadeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JndiBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JndiBaseType">
    <xs:attributeGroup ref="JndiBaseDeclaredAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="JndiBaseDeclaredAttributeGroup">
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsRealm" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the sender or the listener</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:complexType name="CommandSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="CommandSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="CommandSenderDeclaredAttributeGroup">
    <xs:attribute name="command" type="xs:string">
      <xs:annotation>
        <xs:documentation>The command to be executed. Note: Executing a command in WAS requires &lt;&lt;ALL FILES&gt;&gt; execute permission to avoid that provide the absolute path of the command. Absolute path can be found with the following command 'which -a {commandName}'</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOut" type="xs:integer">
      <xs:annotation>
        <xs:documentation>The number of seconds to execute a command. If the limit is exceeded, a TimeoutException is thrown. A value of 0 means execution time is not limited Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commandWithArguments" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>In case the command that will be executed contains arguments then this flag should be set to true Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CommandSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="CommandSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="DelaySenderType">
    <xs:attributeGroup ref="DelaySenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="DelaySenderDeclaredAttributeGroup">
    <xs:attribute name="delayTime" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the time the thread will be put to sleep Default: 5000 [ms]</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="DelaySenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="DelaySenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="DirectQuerySenderType">
    <xs:group ref="JdbcSenderBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="JdbcQuerySenderBaseCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:group name="JdbcSenderBaseDeclaredChildGroup">
    <xs:sequence>
      <xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="JdbcSenderBaseDeclaredAttributeGroup">
    <xs:attribute name="timeout" type="xs:integer">
      <xs:annotation>
        <xs:documentation>The number of seconds the driver will wait for a statement object to execute. If the limit is exceeded, a TimeoutException is thrown. A value of 0 means execution time is not limited Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcSenderBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcSenderBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcFacadeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JdbcFacadeType">
    <xs:attributeGroup ref="JdbcFacadeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="JdbcFacadeDeclaredAttributeGroup">
    <xs:attribute name="datasourceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>JNDI name of datasource to be used, can be configured via jmsRealm, too Default: ${jdbc.datasource.default}</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used to authenticate when connecting to database</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>User name for authentication when connecting to database, when none found from &lt;code&gt;authAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password for authentication when connecting to database, when none found from &lt;code&gt;authAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:boolean" />
    <xs:attribute name="transacted" type="xs:boolean" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcFacadeCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcFacadeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JndiBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcQuerySenderBaseDeclaredAttributeGroup">
    <xs:attribute name="queryType" type="QueryTypeAttributeValuesType">
      <xs:annotation>
        <xs:documentation>One of: &lt;ul&gt;&lt;li&gt;&lt;code&gt;select&lt;/code&gt; for queries that return data&lt;/li&gt;&lt;li&gt;&lt;code&gt;updateBlob&lt;/code&gt; for queries that update a BLOB&lt;/li&gt;&lt;li&gt;&lt;code&gt;updateClob&lt;/code&gt; for queries that update a CLOB&lt;/li&gt;&lt;li&gt;&lt;code&gt;package&lt;/code&gt; to execute Oracle PL/SQL package&lt;/li&gt;&lt;li&gt;&lt;code&gt;other&lt;/code&gt; for queries that return no data.&lt;/li&gt;&lt;/ul&gt; Default: &lt;code&gt;other&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalar" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When &lt;code&gt;true&lt;/code&gt;, the value of the first column of the first row (or the startrow) is returned as the only result, as a simple non-xml value Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalarExtended" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;scalar&lt;/code&gt; is also &lt;code&gt;true&lt;/code&gt;, but returns no value, one of the following is returned: &lt;ul&gt;&lt;li&gt;'[absent]' no row is found&lt;/li&gt;&lt;li&gt;'[null]' a row is found, but the value is a SQL-NULL&lt;/li&gt;&lt;li&gt;'[empty]' a row is found, but the value is a empty string&lt;/li&gt;&lt;/ul&gt; Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRows" type="xs:integer">
      <xs:annotation>
        <xs:documentation>The maximum number of rows to be returned from the output of &lt;code&gt;select&lt;/code&gt; queries Default: -1 (unlimited)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startRow" type="xs:integer">
      <xs:annotation>
        <xs:documentation>The number of the first row to be returned from the output of &lt;code&gt;select&lt;/code&gt; queries. Rows before this are skipped from the output. Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="nullValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value used in result as contents of fields that contain no value (sql-null) Default: &lt;i&gt;empty string&lt;/i&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>Query that can be used to obtain result of side-effect of update-query, like generated value of sequence. Example: SELECT mysequence.currval FROM dual</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="columnsReturned" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of columns whose values are to be returned. Works only if the driver implements jdbc 3.0 getGeneratedKeys(). Note: not all drivers support multiple values and returned field names may vary between drivers</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useNamedParams" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When &lt;code&gt;true&lt;/code&gt;, every string in the message which equals &lt;code&gt;?{paramname}&lt;/code&gt; will be replaced by the value of the corresponding parameter. The parameters don't need to be in the correct order and unused parameters are skipped. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="includeFieldDefinition" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the result contains besides the returned rows also a header with information about the fetched fields Default: application default (true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trimSpaces" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Remove trailing blanks from all result values. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rowIdSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If specified, the rowid of the processed row is put in the pipelinesession under the specified key (only applicable for &lt;code&gt;querytype=other&lt;/code&gt;). &lt;b&gt;Note:&lt;/b&gt; If multiple rows are processed a SqlException is thrown.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set, the result is streamed to the HttpServletResponse object of the RestServiceDispatcher (instead of passed as bytes or as a String) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sqlDialect" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the SQL dialect in which the queries are written and should be translated from to the actual SQL dialect</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockRows" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When set &lt;code&gt;true&lt;/code&gt;, exclusive row-level locks are obtained on all the rows identified by the select statement (e.g. by appending ' FOR UPDATE NOWAIT SKIP LOCKED' to the end of the query) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWait" type="xs:integer">
      <xs:annotation>
        <xs:documentation>when set and &gt;=0, ' FOR UPDATE WAIT #' is used instead of ' FOR UPDATE NOWAIT SKIP LOCKED' Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobColumn" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Only for querytype 'updateBlob': column that contains the BLOB to be updated Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>For querytype 'updateBlob': key of session variable that contains the data (String or InputStream) to be loaded to the BLOB. When empty, the input of the pipe, which then must be a String, is used.&lt;br/&gt;For querytype 'select': key of session variable that contains the OutputStream, Writer or Filename to write the BLOB to</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is stored compressed in the database Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobBase64Direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether the streamed blobdata will need to be base64 &lt;code&gt;encode&lt;/code&gt; or &lt;code&gt;decode&lt;/code&gt; or not.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Charset that is used to read and write BLOBs. This assumes the blob contains character data. If blobCharset and blobSmartGet are not set, BLOBs are returned as bytes. Before version 7.6, blobs were base64 encoded after being read to accommodate for the fact that senders need to return a String. This is no longer the case</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Controls automatically whether blobdata is stored compressed and/or serialized in the database Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobColumn" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Only for querytype 'updateClob': column that contains the CLOB to be updated Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>For querytype 'updateClob': key of session variable that contains the CLOB (String or InputStream) to be loaded to the CLOB. When empty, the input of the pipe, which then must be a String, is used.&lt;br/&gt;For querytype 'select': key of session variable that contains the OutputStream, Writer or Filename to write the CLOB to</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When set to &lt;code&gt;false&lt;/code&gt;, the Inputstream is not closed after it has been used to update a BLOB or CLOB Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeOutputstreamOnExit" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When set to &lt;code&gt;false&lt;/code&gt;, the Outputstream is not closed after BLOB or CLOB has been written to it Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Charset used when reading a stream (that is e.g. going to be written to a BLOB or CLOB). When empty, the stream is copied directly to the BLOB, without conversion</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="avoidLocking" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true, then select queries are executed in a way that avoids taking locks, e.g. with isolation mode 'read committed' instead of 'repeatable read'. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prettyPrint" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true and scalar=false, multiline indented XML is produced Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="packageContent" type="xs:string" />
    <xs:attribute name="synchronous" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:simpleType name="QueryTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="SELECT" />
      <xs:enumeration value="UPDATEBLOB" />
      <xs:enumeration value="UPDATECLOB" />
      <xs:enumeration value="PACKAGE" />
      <xs:enumeration value="OTHER" />
    </xs:restriction>
  </xs:simpleType>
  <xs:attributeGroup name="JdbcQuerySenderBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcQuerySenderBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcSenderBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="EchoSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="EchoSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="EchoSenderDeclaredAttributeGroup">
    <xs:attribute name="synchronous" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>hack to allow to introduce a correlationid Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="EchoSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="EchoSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="EsbJmsSenderType">
    <xs:group ref="JmsSenderDeclaredChildGroup" />
    <xs:attributeGroup ref="EsbJmsSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="EsbJmsSenderDeclaredAttributeGroup">
    <xs:attribute name="messageProtocol" type="xs:string" />
    <xs:attribute name="timeOut" type="xs:integer" />
  </xs:attributeGroup>
  <xs:attributeGroup name="EsbJmsSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="EsbJmsSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JmsSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ExchangeFolderSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="ExchangeFolderSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ExchangeFolderSenderDeclaredAttributeGroup">
    <xs:attribute name="mailAddress" type="xs:string">
      <xs:annotation>
        <xs:documentation>The mail address of the mailbox connected to (also used for auto discovery)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>Url of the Exchange server. Set to e.g. https://outlook.office365.com/EWS/Exchange.asmx to speed up start up, leave empty to use autodiscovery</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="accessToken" type="xs:string">
      <xs:annotation>
        <xs:documentation>AccessToken for authentication to Exchange mail server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Username for authentication to Exchange mail server. Ignored when accessToken is also specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password for authentication to Exchange mail server. Ignored when accessToken is also specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain accessToken or username and password for authentication to Exchange mail server. If the alias refers to a combination of a username and a password, the deprecated Basic Authentication method is used. If the alias refers to a password without a username, the password is treated as the accessToken.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="baseFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder (subfolder of root or of inbox) to look for mails. If empty, the inbox folder is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filter" type="xs:string">
      <xs:annotation>
        <xs:documentation>If empty, all mails are retrieved. If set to &lt;code&gt;NDR&lt;/code&gt; only Non-Delivery Report mails ('bounces') are retrieved</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyAddressFields" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of fields to try as response address Default: replyTo,from,sender,Return-Path</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:integer">
      <xs:annotation>
        <xs:documentation>proxy port</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy authAlias</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyDomain" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy domain</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUserName" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="ExchangeFolderSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="ExchangeFolderSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FileSenderType">
    <xs:group ref="FileSenderDeclaredChildGroup" />
    <xs:attributeGroup ref="FileSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:group name="FileSenderDeclaredChildGroup">
    <xs:sequence>
      <xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="FileSenderDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="FileSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="FileSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileHandlerDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FileHandlerType">
    <xs:attributeGroup ref="FileHandlerDeclaredAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FileHandlerDeclaredAttributeGroup">
    <xs:attribute name="actions" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of actions to be performed. Possible action values: &lt;ul&gt; &lt;li&gt;write: create a new file and write input to it&lt;/li&gt; &lt;li&gt;write_append: create a new file if it does not exist, otherwise append to existing file; then write input to it&lt;/li&gt; &lt;li&gt;create: create a new file, but do not write anything to it&lt;/li&gt; &lt;li&gt;read: read from file&lt;/li&gt; &lt;li&gt;delete: delete the file&lt;/li&gt;&lt;li&gt;read_delete: read the contents, then delete (when outputType is stream the file is deleted after the stream is read)&lt;/li&gt; &lt;li&gt;encode: encode base64&lt;/li&gt; &lt;li&gt;decode: decode base64&lt;/li&gt; &lt;li&gt;list: returns the files and directories in the directory that satisfy the specified filter (see {@link nl.nn.adapterframework.util.Dir2Xml dir2xml}). If a directory is not specified, the fileName is expected to include the directory&lt;/li&gt; &lt;li&gt;info: returns information about the file&lt;/li&gt; &lt;/ul&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>the charset to be used when transforming a string to a byte array and/or the other way around Default: the value of the system property file.encoding</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createDirectory" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the directory to read from or write to is created if it does not exist Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deleteEmptyDirectory" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(only used when actions=delete) when set to &lt;code&gt;true&lt;/code&gt;, the directory from which a file is deleted is also deleted when it contains no other files Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directory" type="xs:string">
      <xs:annotation>
        <xs:documentation>base directory where files are stored in or read from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileName" type="xs:string" />
    <xs:attribute name="fileNameSessionKey" type="xs:string" />
    <xs:attribute name="fileSource" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;filesystem&lt;/code&gt; or &lt;code&gt;classpath&lt;/code&gt; (classpath will only work for actions 'read' and 'info' and for 'info' only when resources are available as a file (i.e. doesn't work for resources in jar files and war files which are deployed without being extracted by the application server)) Default: filesystem</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filename" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the file to use</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filenameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>the session key that contains the name of the file to use (only used if filename is not set)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;bytes&lt;/code&gt;, &lt;code&gt;stream&lt;/code&gt; or &lt;code&gt;base64&lt;/code&gt; Default: string</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipBOM" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, a possible bytes order mark (bom) at the start of the file is skipped (only used for the action read and encoding uft-8) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(only used when outputtype=stream) if set, the result is streamed to the httpservletresponse object Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="testCanWrite" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, a test is performed to find out if a temporary file can be created and deleted in the specified directory (only used if directory is set and combined with the action write, write_append or create) Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="testExists" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>test if the specified directory exists at configure() Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeLineSeparator" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, a line separator is written after the content is written Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>suffix of the file to be created (only used if filename and filenamesession are not set)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:complexType name="FileSystemSenderWithAttachmentsType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="FixedQuerySenderType">
    <xs:group ref="JdbcSenderBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedQuerySenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FixedQuerySenderDeclaredAttributeGroup">
    <xs:attribute name="query" type="xs:string">
      <xs:annotation>
        <xs:documentation>The SQL query text to be excecuted each time sendMessage() is called</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="batchSize" type="xs:integer">
      <xs:annotation>
        <xs:documentation>When set larger than 0 and used as a child of an IteratingPipe, then the database calls are made in batches of this size. Only for queryType=other. Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FixedQuerySenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="FixedQuerySenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcQuerySenderBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FixedResultSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedResultSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FixedResultSenderDeclaredAttributeGroup">
    <xs:attribute name="fileName" type="xs:string" />
    <xs:attribute name="filename" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the file containing the resultmessage</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceFrom" type="xs:string" />
    <xs:attribute name="replaceTo" type="xs:string" />
    <xs:attribute name="returnString" type="xs:string">
      <xs:annotation>
        <xs:documentation>returned message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string" />
    <xs:attribute name="substituteVars" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>should values between ${ and } be resolved from the pipelinesession Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FixedResultSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="FixedResultSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FtpFileSystemSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="FtpFileSystemSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FtpFileSystemSenderDeclaredAttributeGroup">
    <xs:attribute name="allowSelfSignedCertificates" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(ftps) if true, the server certificate can be self signed Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the alias to obtain credentials to authenticate on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificate" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) resource url to certificate to be used for authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) alias used to obtain certificate password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificatePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  Default: pkcs12</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="consoleKnownHostsVerifier" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(sftp)  Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileType" type="xs:string">
      <xs:annotation>
        <xs:documentation>File type, one of ascii, binary</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ftpTypeDescription" type="xs:string">
      <xs:annotation>
        <xs:documentation>One of ftp, sftp, ftps(i) or ftpsi, ftpsx(ssl), ftpsx(tls) Default: ftp</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="host" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name or ip address of remote host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Selects the algorithm to generate keymanagers. can be left empty to use the servers default algorithm Default: websphere: ibmx509</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyboardInteractive" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When true, keyboardinteractive is used to login Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="knownHostsPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) path to file with knownhosts</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageIsContent" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true, the contents of the message is send, otherwise it message contains the local filenames of the files to be send Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="passive" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true, passive ftp is used: before data is sent, a pasv command is issued, and the connection is set up by the server Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password of the user to authenticate on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Port number of remote host Default: 21</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefCSEncryption" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) optional preferred encryption from client to server for sftp protocol</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefSCEncryption" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) optional preferred encryption from server to client for sftp protocol</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) name of the alias to obtain credentials for passphrase of private key file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyFilePath" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) path to private key file for sftp authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) passphrase of private key file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="protP" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(ftps) if true, the server returns data via another socket Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the alias to obtain credentials to authenticate on proxy</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy host name</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password in case proxy requires authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Proxy port Default: 1080</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyTransportType" type="xs:integer">
      <xs:annotation>
        <xs:documentation>(sftp) transport type in case of sftp (1=standard, 2=http, 3=socks4, 4=socks5) Default: 4</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default user name in case proxy requires authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>pathname of The file or directory to list. Default: Home folder of the ftp user.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Selects the algorithm to generate trustmanagers. can be left empty to use the servers default algorithm Default: websphere: ibmx509</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) resource url to truststore to be used for authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) alias used to obtain truststore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  Default: jks</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the user to authenticate on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(ftps) when true, the hostname in the certificate will be checked against the actual hostname Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FtpFileSystemSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="FtpFileSystemSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FtpSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="FtpSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FtpSenderDeclaredAttributeGroup">
    <xs:attribute name="allowSelfSignedCertificates" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(ftps) if true, the server certificate can be self signed Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the alias to obtain credentials to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificate" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) resource url to certificate to be used for authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) alias used to obtain certificate password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificatePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  Default: pkcs12</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="consoleKnownHostsVerifier" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(sftp)  Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileType" type="xs:string">
      <xs:annotation>
        <xs:documentation>file type, one of ascii, binary</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ftpTypeDescription" type="xs:string">
      <xs:annotation>
        <xs:documentation>one of ftp, sftp, ftps(i) or ftpsi, ftpsx(ssl), ftpsx(tls) Default: ftp</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="host" type="xs:string">
      <xs:annotation>
        <xs:documentation>name or ip adres of remote host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>selects the algorithm to generate keymanagers. can be left empty to use the servers default algorithm Default: websphere: ibmx509</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyboardInteractive" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true, keyboardinteractive is used to login Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="knownHostsPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) path to file with knownhosts</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageIsContent" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>if true, the contents of the message is send, otherwise it message contains the local filenames of the files to be send Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="passive" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>if true, passive ftp is used: before data is sent, a pasv command is issued, and the connection is set up by the server Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the password to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="xs:integer">
      <xs:annotation>
        <xs:documentation>portnumber of remote host Default: 21</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefCSEncryption" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) optional preferred encryption from client to server for sftp protocol</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefSCEncryption" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) optional preferred encryption from server to client for sftp protocol</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) name of the alias to obtain credentials for passphrase of private key file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyFilePath" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) path to private key file for sftp authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) passphrase of private key file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="protP" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(ftps) if true, the server returns data via another socket Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the alias to obtain credentials to authenticate on proxy</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy host name</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>default password in case proxy requires authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:integer">
      <xs:annotation>
        <xs:documentation>proxy port Default: 1080</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyTransportType" type="xs:integer">
      <xs:annotation>
        <xs:documentation>(sftp) transport type in case of sftp (1=standard, 2=http, 3=socks4, 4=socks5) Default: 4</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>default user name in case proxy requires authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>remote directory in which files have to be uploaded</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteFilenamePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>filename pattern for uploaded files</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>selects the algorithm to generate trustmanagers. can be left empty to use the servers default algorithm Default: websphere: ibmx509</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) resource url to truststore to be used for authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) alias used to obtain truststore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  Default: jks</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the user to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(ftps) when true, the hostname in the certificate will be checked against the actual hostname Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FtpSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="FtpSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="HttpSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="HttpSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="HttpSenderDeclaredAttributeGroup">
    <xs:attribute name="encodeMessages" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>specifies whether messages will encoded, e.g. spaces will be replaced by '+' etc. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="base64" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true, the result is base64 encoded Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="firstBodyPartName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Only used when &lt;code&gt;methodType=POST&lt;/code&gt; and &lt;code&gt;postType=URLENCODED, FORM-DATA or MTOM&lt;/code&gt;) Name of the first body part</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreRedirects" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When true, besides http status code 200 (OK) also the code 301 (MOVED_PERMANENTLY), 302 (MOVED_TEMPORARILY) and 307 (TEMPORARY_REDIRECT) are considered successful Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputMessageParam" type="xs:string" />
    <xs:attribute name="mtomContentTransferEncoding" type="xs:string" />
    <xs:attribute name="mtomEnabled" type="xs:boolean" />
    <xs:attribute name="multipart" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true and &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;, request parameters are put in a multipart/form-data entity instead of in the request body Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartResponse" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true the response body is expected to be in mime multipart which is the case when a soap message with attachments is received (see also &lt;a href="https://docs.oracle.com/javaee/7/api/javax/xml/soap/soapmessage.html"&gt;https://docs.oracle.com/javaee/7/api/javax/xml/soap/soapmessage.html&lt;/a&gt;). the first part will be returned as result of this sender. other parts are returned as streams in sessionkeys with names multipart1, multipart2, etc. the http connection is held open until the last stream is read. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartXmlSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set and &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;, a multipart/form-data entity is created instead of a request body. for each part element in the session key a part in the multipart entity is created</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="paramsInUrl" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When false and &lt;code&gt;methodType=POST&lt;/code&gt;, request parameters are put in the request body instead of in the url Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="postType" type="xs:string">
      <xs:annotation>
        <xs:documentation>When &lt;code&gt;methodType=POST&lt;/code&gt;, the type of post request, must be one of [RAW (text/xml/json), BINARY (file), URLENCODED, FORMDATA, MTOM] Default: RAW</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultAsByteArrayInSessionKey" type="xs:string" />
    <xs:attribute name="storeResultAsStreamInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, a pointer to an input stream of the result is put in the specified sessionkey (as the sender interface only allows a sender to return a string a sessionkey is used instead to return the stream)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToFileNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to a file (instead of passed as a string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to the httpservletresponse object of the restservicedispatcher (instead of passed as a string) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="HttpSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="HttpSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="HttpSenderBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="HttpSenderBaseDeclaredAttributeGroup">
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>URL or base of URL to be used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>parameter that is used to obtain url; overrides url-attribute. Default: url</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="methodType" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of method to be executed, either 'GET', 'POST', 'PUT', 'DELETE', 'HEAD' or 'REPORT' Default: GET</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="contentType" type="xs:string">
      <xs:annotation>
        <xs:documentation>content-type (superset of mimetype + charset) of the request, for POST and PUT methods Default: text/html</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charSet" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset of the request. Typically only used on PUT and POST requests. Default: UTF-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:integer">
      <xs:annotation>
        <xs:documentation>timeout in ms of obtaining a connection/result. 0 means no timeout Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConnections" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the maximum number of concurrent connections Default: 10</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxExecuteRetries" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the maximum number of times it the execution is retried Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="userName" type="xs:string">
      <xs:annotation>
        <xs:documentation>username used in authentication to host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>password used in authentication to host Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authDomain" type="xs:string">
      <xs:annotation>
        <xs:documentation>domain used in authentication to host Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy host Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:integer">
      <xs:annotation>
        <xs:documentation>proxy port Default: 80</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to proxy</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy username Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy password Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyRealm" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy realm Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="disableCookies" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Disables the use of cookies, making the sender completely stateless Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificate" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource url to certificate to be used for authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain certificate password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificatePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>certificate password Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default: pkcs12</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource url to truststore to be used for authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain truststore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>truststore password Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of truststore Default: jks</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true, the hostname in the certificate will be checked against the actual hostname Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowSelfSignedCertificates" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true, self signed certificates are accepted Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCertificateExpiredException" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true, the certificateexpiredexception is ignored Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="headersParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of parameter names which should be set as http headers</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="followRedirects" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true, a redirect request will be honoured, e.g. to switch to https Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleChecking" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether connections checked to be stale, i.e. appear open, but are not. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleTimeout" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Used when StaleChecking=true. Timeout when stale connections should be closed. Default: 5000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xhtml" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true, the html response is transformed to xhtml Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>&gt;(only used when &lt;code&gt;xhtml=true&lt;/code&gt;) stylesheet to apply to the html response</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="protocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>Secure socket protocol (such as 'SSL' and 'TLS') to use when a SSLContext object is generated. If empty the protocol 'SSL' is used Default: SSL</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultStatusCodeSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the status code of the http response is put in specified in the sessionkey and the (error or okay) response message is returned</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUserName" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="HttpSenderBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="HttpSenderBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="IbisJavaSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="IbisJavaSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="IbisJavaSenderDeclaredAttributeGroup">
    <xs:attribute name="dispatchType" type="xs:string">
      <xs:annotation>
        <xs:documentation>set to 'dll' to make the dispatcher communicate with a dll set on the classpath</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartResponse" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>currently used to mimic the httpsender when it is stubbed locally. it could be useful in other situations too although currently the response string is used which isn't streamed, it would be better to pass the multipart as an input stream in the context map in which case content type and charset could also be passed Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="returnedSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of keys of session variables that should be returned to caller, for correct results as well as for erronous results. (only for listeners that support it, like javalistener)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>serviceName of the {@link nl.nn.adapterframework.receivers.JavaListener JavaListener} that should be called</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNameSessionKey" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="IbisJavaSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="IbisJavaSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="IbisLocalSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="IbisLocalSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="IbisLocalSenderDeclaredAttributeGroup">
    <xs:attribute name="checkDependency" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the sender waits upon open until the called {@link nl.nn.adapterframework.receivers.JavaListener JavaListener} is opened Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dependencyTimeOut" type="xs:integer">
      <xs:annotation>
        <xs:documentation>maximum time (in seconds) the sender waits for the listener to start. a value of -1 indicates to wait indefinitely Default: 60 s</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="isolated" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the call is made in a separate thread, possibly using separate transaction Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="javaListener" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the {@link nl.nn.adapterframework.receivers.JavaListener JavaListener} that should be called (will be ignored when javaListenerSessionKey is set)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="javaListenerSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the sessionkey which holds the name of the {@link nl.nn.adapterframework.receivers.JavaListener JavaListener} that should be called</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="returnedSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of keys of session variables that should be returned to caller, for correct results as well as for erronous results. (Only for listeners that support it, like JavaListener)&lt;br/&gt;N.B. To get this working, the attribute returnedSessionKeys must also be set on the corresponding Receiver</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the {@link nl.nn.adapterframework.http.WebServiceListener WebServiceListener} that should be called</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the call is made asynchronously. this implies &lt;code&gt;isolated=true&lt;/code&gt; Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwJavaListenerNotFoundException" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the xml-string "&amp;lt;error&amp;gt;could not find JavaListener [...]&amp;lt;/error&amp;gt;" is returned instead of throwing a senderexception Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="IbisLocalSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="IbisLocalSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="IbisWebServiceSenderType">
    <xs:attributeGroup ref="IbisWebServiceSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="IbisWebServiceSenderDeclaredAttributeGroup">
    <xs:attribute name="ibisHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>name (or ipaddress) and optinally port of the host where the ibis to be called is running Default: localhost</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ibisInstance" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the ibis instance to be called Default: name of the current instance</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the receiver that should be called Default: servicelistener</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="IbisWebServiceSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="IbisWebServiceSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ImapSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="ImapSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ImapSenderDeclaredAttributeGroup">
    <xs:attribute name="host" type="xs:string">
      <xs:annotation>
        <xs:documentation>The hostname of the IMAP server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="xs:integer">
      <xs:annotation>
        <xs:documentation>The port of the IMAP server Default: 993</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain accessToken or username and password for authentication to Exchange mail server. If the alias refers to a combination of a username and a password, the deprecated Basic Authentication method is used. If the alias refers to a password without a username, the password is treated as the accessToken.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Username for authentication to mail server.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password for authentication to mail server.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="baseFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder (subfolder of root or of inbox) to look for mails. If empty, the inbox folder is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyAddressFields" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of fields to try as response address Default: replyTo,from,sender,Return-Path</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ImapSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="ImapSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JavascriptSenderType">
    <xs:group ref="SenderSeriesCumulativeChildGroup" />
    <xs:attributeGroup ref="JavascriptSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="JavascriptSenderDeclaredAttributeGroup">
    <xs:attribute name="engineName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the javascript engine to be used Default: J2V8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsFileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the javascript file containing the functions to run</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsFunctionName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the javascript function that will be called (first) Default: main</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JavascriptSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="JavascriptSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderSeriesCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SenderSeriesType">
    <xs:group ref="SenderSeriesCumulativeChildGroup" />
    <xs:attributeGroup ref="SenderSeriesCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:group name="SenderSeriesDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="SenderElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:group name="SenderSeriesCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="SenderSeriesDeclaredChildGroup" />
      <xs:group ref="CacheElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="SenderSeriesDeclaredAttributeGroup">
    <xs:attribute name="synchronous" type="xs:boolean" />
  </xs:attributeGroup>
  <xs:attributeGroup name="SenderSeriesCumulativeAttributeGroup">
    <xs:attributeGroup ref="SenderSeriesDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderWrapperBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="SenderWrapperBaseDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="CacheElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="SenderElementGroup" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:group name="SenderWrapperBaseCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="SenderWrapperBaseDeclaredChildGroup" />
      <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="SenderWrapperBaseDeclaredAttributeGroup">
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, input is taken from this session key, instead of regular input</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, this fixed value is taken as input, instead of regular input</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the result is stored under this session key</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SenderWrapperBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="SenderWrapperBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JsonXsltSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="JsonXsltSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="JsonXsltSenderDeclaredAttributeGroup">
    <xs:attribute name="jsonResult" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When &lt;code&gt;true&lt;/code&gt;, the xml result of the transformation is converted back to json Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions Default: j=http://www.w3.org/2013/XSL/json</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JsonXsltSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="JsonXsltSenderDeclaredAttributeGroup" />
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Location of stylesheet to apply to the input message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key to retrieve stylesheet location. Overrides stylesheetName or xpathExpression attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetCacheSize" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Size of cache of stylesheets retrieved from styleSheetNameSessionKey Default: 100</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alternatively: xpath-expression to create stylesheet from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>omit the xml declaration on top of the output. When not set, the value specified in the stylesheet is followed Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>For xpathExpression only: either 'text' or 'xml'. Default: text</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indentXml" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, result is pretty-printed. When not set, the value specified in the stylesheet is followed Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNamespaces" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed before transformation Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipEmptyTags" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; empty tags in the output are removed after transformation Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xsltVersion" type="xs:integer">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;2&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan). &lt;code&gt;0&lt;/code&gt; will auto detect Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="debugInput" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; the input is written to the log file, at DEBUG level Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XsltSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="XsltSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="XsltSenderDeclaredAttributeGroup">
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Location of stylesheet to apply to the input message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key to retrieve stylesheet location. Overrides stylesheetName or xpathExpression attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetCacheSize" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Size of cache of stylesheets retrieved from styleSheetNameSessionKey Default: 100</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alternatively: xpath-expression to create stylesheet from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>omit the xml declaration on top of the output. When not set, the value specified in the stylesheet is followed Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions. For some use other cases (NOT xpathExpression), one entry can be without a prefix, that will define the default namespace.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>For xpathExpression only: either 'text' or 'xml'. Default: text</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indentXml" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, result is pretty-printed. When not set, the value specified in the stylesheet is followed Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNamespaces" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed before transformation Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipEmptyTags" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; empty tags in the output are removed after transformation Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xsltVersion" type="xs:integer">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;2&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan). &lt;code&gt;0&lt;/code&gt; will auto detect Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="debugInput" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; the input is written to the log file, at DEBUG level Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XsltSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="XsltSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LdapSenderType">
    <xs:group ref="LdapSenderDeclaredChildGroup" />
    <xs:attributeGroup ref="LdapSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:group name="LdapSenderDeclaredChildGroup">
    <xs:sequence>
      <xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="LdapSenderDeclaredAttributeGroup">
    <xs:attribute name="attributesToReturn" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of attributes to return. when no are attributes specified, all the attributes from the object read are returned. Default: &lt;i&gt;all attributes&lt;/i&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="errorSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable used to store cause of errors Default: errorreason</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ldapProviderURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>url to context to search in, e.g. 'ldap://edsnlm01.group.intranet/ou=people, o=ing' to search in te people group of ing cds. used to overwrite the providerurl specified in jmsrealm.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="manipulationSubject" type="xs:string">
      <xs:annotation>
        <xs:documentation>specifies subject to perform operation on. must be one of 'entry' or 'attribute' Default: attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxEntriesReturned" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the maximum number of entries to be returned by a search query, or 0 for unlimited Default: &lt;i&gt;0 (unlimited)&lt;/i&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="operation" type="xs:string">
      <xs:annotation>
        <xs:documentation>specifies operation to perform. Must be one of &lt;ul&gt;&lt;li&gt;&lt;code&gt;read&lt;/code&gt;: read the contents of an entry&lt;/li&gt;&lt;li&gt;&lt;code&gt;create&lt;/code&gt;: create an attribute or an entry&lt;/li&gt;&lt;li&gt;&lt;code&gt;update&lt;/code&gt;: update an attribute or an entry&lt;/li&gt;&lt;li&gt;&lt;code&gt;delete&lt;/code&gt;: delete an attribute or an entry&lt;/li&gt;&lt;li&gt;&lt;code&gt;search&lt;/code&gt;: search for an entry in the direct children of the specified root&lt;/li&gt;&lt;li&gt;&lt;code&gt;deepSearch&lt;/code&gt;: search for an entry in the complete tree below the specified root&lt;/li&gt;&lt;li&gt;&lt;code&gt;getSubContexts&lt;/code&gt;: get a list of the direct children of the specifed root&lt;/li&gt;&lt;li&gt;&lt;code&gt;getTree&lt;/code&gt;: get a copy of the complete tree below the specified root&lt;/li&gt;&lt;li&gt;&lt;code&gt;challenge&lt;/code&gt;: check username and password against LDAP specifying principal and credential using parameters&lt;/li&gt;&lt;li&gt;&lt;code&gt;changeUnicodePwd&lt;/code&gt;: typical user change-password operation (one of the two methods to modify the unicodePwd attribute in AD (http://support.microsoft.com/kb/263991))&lt;/li&gt;&lt;/ul&gt; Default: read</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyNotFound" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;operation=search/deepsearch&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt; the xml '&amp;lt;ldapresult&amp;gt;object not found&amp;lt;/ldapresult&amp;gt;' is returned instead of the partialresultexception 'unprocessed continuation reference(s)' Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="searchTimeout" type="xs:integer">
      <xs:annotation>
        <xs:documentation>specifies the time (in ms) that is spent searching for results for operation search Default: 20000 ms</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="unicodePwd" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true the attributes passed by the input xml are scanned for an attribute with id unicodepwd, when found the value of this attribute will be encoded as required by active directory (a utf-16 encoded unicode string containing the password surrounded by quotation marks) before sending it to the ldap server Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="usePooling" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>specifies whether connection pooling is used or not Default: true when principal not set as parameter, false otherwise</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LdapSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="LdapSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JndiBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LocalFileSystemSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="LocalFileSystemSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="LocalFileSystemSenderDeclaredAttributeGroup">
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional base folder, that serves as root for all other folders</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LocalFileSystemSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="LocalFileSystemSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LogSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="LogSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="LogSenderDeclaredAttributeGroup">
    <xs:attribute name="logCategory" type="xs:string">
      <xs:annotation>
        <xs:documentation>category under which messages are logged Default: name of the sender</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logLevel" type="xs:string">
      <xs:annotation>
        <xs:documentation>level on which messages are logged Default: info</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LogSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="LogSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="MailSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="MailSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="MailSenderDeclaredAttributeGroup">
    <xs:attribute name="smtpHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the host by which the messages are to be send</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="MailSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="MailSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="MailSenderBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="MailSenderBaseDeclaredAttributeGroup">
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authAlias used to obtain credentials for authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="bounceAddress" type="xs:string">
      <xs:annotation>
        <xs:documentation>NDR return address when mail cannot be delivered. This adds a Return-Path header Default: MAIL FROM attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="defaultAttachmentName" type="xs:string">
      <xs:annotation>
        <xs:documentation>when this name is used, it will be followed by a number which is equal to the node's position Default: attachment</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="defaultFrom" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of the from: header if not specified in message itself</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="defaultMessageBase64" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when messageBase64 is not specified defaultMessageBase64 will be used Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="defaultMessageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>when messageType is not specified defaultMessageType will be used Default: text/plain</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="defaultSubject" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of the subject: header if not specified in message itself</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>password of userid</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="smtpAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to smtphost</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="smtpPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>password of userid on the smtphost</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="smtpUserid" type="xs:string">
      <xs:annotation>
        <xs:documentation>userId on the smtphost</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:integer">
      <xs:annotation>
        <xs:documentation>timeout (in milliseconds). used for socket connection timeout and socket i/o timeout Default: 20000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="userId" type="xs:string">
      <xs:annotation>
        <xs:documentation>userId on the smtphost</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="MailSenderBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="MailSenderBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="MessageStoreSenderType">
    <xs:group ref="MessageStoreSenderDeclaredChildGroup" />
    <xs:attributeGroup ref="MessageStoreSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:group name="MessageStoreSenderDeclaredChildGroup">
    <xs:sequence>
      <xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="MessageStoreSenderDeclaredAttributeGroup">
    <xs:attribute name="sessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of sessionKey's to be stored together with the message. Please note: corresponding MessagestoreListener must have the same value for this attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onlyStoreWhenMessageIdUnique" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the message is stored only if the MessageId is not present in the store yet. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="MessageStoreSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="MessageStoreSenderDeclaredAttributeGroup" />
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column slotids are stored in Default: SLOTID</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column slotids are stored in Default: SLOTID</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>Possible values are E (error store), M (message store), L (message log for pipe) or A (message log for receiver). Receiver will always set type to E for errorStorage and always set type to A for messageLog. SenderPipe will set type to L for messageLog (when type isn't specified). See {@link MessagestoreSender} for type M Default: E for errorstorage on receiver, A for messageLog on receiver and L for messageLog on Pipe</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="typeField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column types are stored in Default: TYPE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hostField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column that stores the hostname of the server Default: HOST</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sequenceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the sequence used to generate the primary key, for DBMSes that use sequences, like Oracle) Default: seq_ibisstore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkTable" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, checks are performed if the table exists and is properly created Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createTable" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the table is created if it does not exist Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>The type of the column message themselves are stored in</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>The type of the column that contains the primary key of the table</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dateFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>The type of the column the timestamps are stored in</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="textFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>The type of the columns messageId and correlationId, slotId and comments are stored in. N.B. (100) is appended for id's, (1000) is appended for comments.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:boolean" />
    <xs:attribute name="blobsCompressed" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the messages are stored compressed Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkIfTableExists" type="xs:boolean" />
    <xs:attribute name="retention" type="xs:integer">
      <xs:annotation>
        <xs:documentation>The time (in days) to keep the record in the database before making it eligible for deletion by a cleanup process. when set to -1, the record will live on forever Default: 30</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaOwner4Check" type="xs:string">
      <xs:annotation>
        <xs:documentation>Schema owner to be used to check the database Default: &amp;lt;current_schema&amp;gt; (only for oracle)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeFullMessage" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the full message is stored with the log. Can be set to &lt;code&gt;false&lt;/code&gt; to reduce table size, by avoiding to store the full message Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="JdbcTableMessageBrowserCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JdbcTransactionalStorageType">
    <xs:attributeGroup ref="JdbcTransactionalStorageCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="JdbcTransactionalStorageDeclaredAttributeGroup">
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column slotids are stored in Default: SLOTID</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column slotids are stored in Default: SLOTID</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>Possible values are E (error store), M (message store), L (message log for pipe) or A (message log for receiver). Receiver will always set type to E for errorStorage and always set type to A for messageLog. SenderPipe will set type to L for messageLog (when type isn't specified). See {@link MessagestoreSender} for type M Default: E for errorstorage on receiver, A for messageLog on receiver and L for messageLog on Pipe</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="typeField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column types are stored in Default: TYPE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hostField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column that stores the hostname of the server Default: HOST</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sequenceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the sequence used to generate the primary key, for DBMSes that use sequences, like Oracle) Default: seq_ibisstore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkTable" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, checks are performed if the table exists and is properly created Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createTable" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the table is created if it does not exist Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>The type of the column message themselves are stored in</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>The type of the column that contains the primary key of the table</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dateFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>The type of the column the timestamps are stored in</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="textFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>The type of the columns messageId and correlationId, slotId and comments are stored in. N.B. (100) is appended for id's, (1000) is appended for comments.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:boolean" />
    <xs:attribute name="blobsCompressed" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the messages are stored compressed Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkIfTableExists" type="xs:boolean" />
    <xs:attribute name="onlyStoreWhenMessageIdUnique" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the message is stored only if the MessageId is not present in the store yet. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retention" type="xs:integer">
      <xs:annotation>
        <xs:documentation>The time (in days) to keep the record in the database before making it eligible for deletion by a cleanup process. when set to -1, the record will live on forever Default: 30</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaOwner4Check" type="xs:string">
      <xs:annotation>
        <xs:documentation>Schema owner to be used to check the database Default: &amp;lt;current_schema&amp;gt; (only for oracle)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeFullMessage" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the full message is stored with the log. Can be set to &lt;code&gt;false&lt;/code&gt; to reduce table size, by avoiding to store the full message Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcTransactionalStorageCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcTransactionalStorageDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcTableMessageBrowserCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JdbcTableMessageBrowserType">
    <xs:attributeGroup ref="JdbcTableMessageBrowserCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="JdbcTableMessageBrowserDeclaredAttributeGroup">
    <xs:attribute name="tableName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the table messages are stored in Default: IBISSTORE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indexName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the index, to be used in hints for query optimizer too (only for Oracle) Default: IX_IBISSTORE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcTableMessageBrowserCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcTableMessageBrowserDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcMessageBrowserCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcMessageBrowserDeclaredAttributeGroup">
    <xs:attribute name="keyField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column that contains the primary key of the table Default: MESSAGEKEY</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="idField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column messageIds are stored in Default: MESSAGEID</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column correlation-ids are stored in Default: CORRELATIONID</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column message themselves are stored in Default: MESSAGE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column the timestamp is stored in Default: MESSAGEDATE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commentField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column comments are stored in Default: COMMENTS</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expiryDateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column the timestamp for expiry is stored in Default: EXPIRYDATE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column labels are stored in Default: LABEL</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>prefix to be prefixed on all database objects (tables, indices, sequences), e.g. to access a different Oracle schema</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Only used when hideRegex is not empty) either &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;firstHalf&lt;/code&gt;. When &lt;code&gt;firstHalf&lt;/code&gt; only the first half of the string is masked, otherwise (&lt;code&gt;all&lt;/code&gt;) the entire string is masked Default: all</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>Regular expression to mask strings in the errorStore/logStore. Every character between to the strings in this expression will be replaced by a '*'. For example, the regular expression (?&amp;lt;=&amp;lt;party&amp;gt;).*?(?=&amp;lt;/party&amp;gt;) will replace every character between keys&lt;party&gt; and &lt;/party&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="order" type="SortOrderAttributeValuesType" />
  </xs:attributeGroup>
  <xs:simpleType name="SortOrderAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="NONE" />
      <xs:enumeration value="ASC" />
      <xs:enumeration value="DESC" />
    </xs:restriction>
  </xs:simpleType>
  <xs:attributeGroup name="JdbcMessageBrowserCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcMessageBrowserDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcFacadeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="MongoDbSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="MongoDbSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="MongoDbSenderDeclaredAttributeGroup">
    <xs:attribute name="datasourceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>The MongoDB datasource Default: ${mongodb.datasource.default}</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="database" type="xs:string">
      <xs:annotation>
        <xs:documentation>Database to connect to. Can be overridden by parameter 'database'</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collection" type="xs:string">
      <xs:annotation>
        <xs:documentation>Collection to act upon. Can be overridden by parameter 'collection'</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="action" type="MongoActionAttributeValuesType">
      <xs:annotation>
        <xs:documentation>Action</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filter" type="xs:string">
      <xs:annotation>
        <xs:documentation>Filter. Can contain references to parameters between '?{' and '}'. Can be overridden by parameter 'filter'</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="limit" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Limit to number of results returned. A value of 0 means 'no limit'. Can be overridden by parameter 'limit' Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="countOnly" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Only for find operation: return only the count and not the full document(s) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="DocumentFormatAttributeValuesType">
      <xs:annotation>
        <xs:documentation>OutputFormat Default: JSON</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:simpleType name="MongoActionAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="INSERTONE" />
      <xs:enumeration value="INSERTMANY" />
      <xs:enumeration value="FINDONE" />
      <xs:enumeration value="FINDMANY" />
      <xs:enumeration value="UPDATEONE" />
      <xs:enumeration value="UPDATEMANY" />
      <xs:enumeration value="DELETEONE" />
      <xs:enumeration value="DELETEMANY" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DocumentFormatAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="XML" />
      <xs:enumeration value="JSON" />
    </xs:restriction>
  </xs:simpleType>
  <xs:attributeGroup name="MongoDbSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="MongoDbSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="MqttSenderType">
    <xs:group ref="MqttSenderDeclaredChildGroup" />
    <xs:attributeGroup ref="MqttFacadeDeclaredAttributeGroup" />
  </xs:complexType>
  <xs:group name="MqttSenderDeclaredChildGroup">
    <xs:sequence>
      <xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:complexType name="MqttFacadeType">
    <xs:attributeGroup ref="MqttFacadeDeclaredAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="MqttFacadeDeclaredAttributeGroup">
    <xs:attribute name="authAlias" type="xs:string" />
    <xs:attribute name="automaticReconnect" type="xs:boolean" />
    <xs:attribute name="brokerUrl" type="xs:string" />
    <xs:attribute name="charset" type="xs:string" />
    <xs:attribute name="cleanSession" type="xs:boolean" />
    <xs:attribute name="clientId" type="xs:string" />
    <xs:attribute name="keepAliveInterval" type="xs:integer" />
    <xs:attribute name="name" type="xs:string" />
    <xs:attribute name="password" type="xs:string" />
    <xs:attribute name="persistenceDirectory" type="xs:string" />
    <xs:attribute name="qos" type="xs:integer" />
    <xs:attribute name="timeout" type="xs:integer" />
    <xs:attribute name="topic" type="xs:string" />
    <xs:attribute name="username" type="xs:string" />
  </xs:attributeGroup>
  <xs:complexType name="MultipartHttpSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="HttpSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="ParallelSendersType">
    <xs:group ref="SenderSeriesCumulativeChildGroup" />
    <xs:attributeGroup ref="ParallelSendersCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ParallelSendersDeclaredAttributeGroup">
    <xs:attribute name="maxConcurrentThreads" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Set the upper limit to the amount of concurrent threads that can be run simultaneously. Use 0 to disable. Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ParallelSendersCumulativeAttributeGroup">
    <xs:attributeGroup ref="ParallelSendersDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderSeriesCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ReloadSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="ReloadSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ReloadSenderDeclaredAttributeGroup">
    <xs:attribute name="forceReload" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>reload the configuration regardless of the version Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ReloadSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="ReloadSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="RestSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="HttpSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="ResultSet2FileSenderType">
    <xs:group ref="JdbcSenderBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="ResultSet2FileSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ResultSet2FileSenderDeclaredAttributeGroup">
    <xs:attribute name="append" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; and the file already exists, the resultset rows are written to the end of the file Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileNameSessionKey" type="xs:string" />
    <xs:attribute name="filenameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>the session key that contains the name of the file to use</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRecordsSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set (and &amp;gt;=0), this session key contains the maximum number of records which are processed. if &lt;code&gt;query&lt;/code&gt; contains a group field (3), then also following records with the same group field value as the last record are processed</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of the optional status field which is set after the row is written to the file: timestamp</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ResultSet2FileSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="ResultSet2FileSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedQuerySenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Samba1SenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="Samba1SenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="Samba1SenderDeclaredAttributeGroup">
    <xs:attribute name="share" type="xs:string">
      <xs:annotation>
        <xs:documentation>Shared folder name in the samba server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for the smb share</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="domain" type="xs:string">
      <xs:annotation>
        <xs:documentation>in case the user account is bound to a domain</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="force" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether hidden files are seen or not Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Samba1SenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="Samba1SenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Samba2SenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="Samba2SenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="Samba2SenderDeclaredAttributeGroup">
    <xs:attribute name="share" type="xs:string">
      <xs:annotation>
        <xs:documentation>the destination, aka smb://xxx/yyy share</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for the smb share</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="domain" type="xs:string">
      <xs:annotation>
        <xs:documentation>domain, in case the user account is bound to a domain</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authType" type="xs:string">
      <xs:annotation>
        <xs:documentation>Type of the authentication either 'NTLM' or 'SPNEGO'  Default: SPNEGO</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="kdc" type="xs:string">
      <xs:annotation>
        <xs:documentation>Kerberos Domain Controller, as set in java.security.krb5.kdc. If authentication type specified as SPNEGO and realm is specified then this field must be filled.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="realm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Kerberos Realm, as set in java.security.krb5.realm. If authentication type specified as SPNEGO this field must be filled. If not filled then default realm is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Samba2SenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="Samba2SenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SambaSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="Samba2SenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="SambaSenderOldType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="SambaSenderOldCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="SambaSenderOldDeclaredAttributeGroup">
    <xs:attribute name="action" type="xs:string">
      <xs:annotation>
        <xs:documentation>possible values: delete, download, list, mkdir, rename, rmdir, upload</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for the smb share</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authDomain" type="xs:string">
      <xs:annotation>
        <xs:documentation>in case the user account is bound to a domain</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="force" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>used when creating folders or overwriting existing files (when renaming or moving) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="share" type="xs:string">
      <xs:annotation>
        <xs:documentation>the destination, aka smb://xxx/yyy share</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SambaSenderOldCumulativeAttributeGroup">
    <xs:attributeGroup ref="SambaSenderOldDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SchedulerSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="SchedulerSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="SchedulerSenderDeclaredAttributeGroup">
    <xs:attribute name="cronExpressionPattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>expression that generates the cron trigger</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="javaListener" type="xs:string">
      <xs:annotation>
        <xs:documentation>java listener to be called when scheduler trigger fires</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jobGroup" type="xs:string">
      <xs:annotation>
        <xs:documentation>job group in which the new trigger is to be created (optional)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jobNamePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>pattern that leads to the name of the registered trigger(optional)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SchedulerSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="SchedulerSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SendGridSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="SendGridSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="SendGridSenderDeclaredAttributeGroup">
    <xs:attribute name="timeout" type="xs:integer">
      <xs:annotation>
        <xs:documentation>timeout in ms of obtaining a connection/result. 0 means no timeout Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConnections" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the maximum number of concurrent connections Default: 10</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxExecuteRetries" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the maximum number of times it the execution is retried Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>hostname of the proxy</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:integer">
      <xs:annotation>
        <xs:documentation>port of the proxy Default: 80</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for proxy authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>username used to obtain credentials for proxy authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>password used to obtain credentials for proxy authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyRealm" type="xs:string">
      <xs:annotation>
        <xs:documentation>realm used for proxy authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificate" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource url to certificate to be used for authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain truststore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificatePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>certificate password Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default: pkcs12</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource url to truststore to be used for authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain truststore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>truststore password Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of truststore Default: jks</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true, the hostname in the certificate will be checked against the actual hostname Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowSelfSignedCertificates" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true, self signed certificates are accepted Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCertificateExpiredException" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true, the certificateexpiredexception is ignored Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="followRedirects" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true, a redirect request will be honoured, e.g. to switch to https Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleChecking" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether connections checked to be stale, i.e. appear open, but are not. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleTimeout" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Used when StaleChecking=true. Timeout when stale connections should be closed. Default: 5000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="protocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>Secure socket protocol (such as 'SSL' and 'TLS') to use when a SSLContext object is generated. If empty the protocol 'SSL' is used Default: SSL</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default: pkcs12</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUserName" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="SendGridSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="SendGridSenderDeclaredAttributeGroup" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authAlias used to obtain credentials for authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="bounceAddress" type="xs:string">
      <xs:annotation>
        <xs:documentation>NDR return address when mail cannot be delivered. This adds a Return-Path header Default: MAIL FROM attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="defaultAttachmentName" type="xs:string">
      <xs:annotation>
        <xs:documentation>when this name is used, it will be followed by a number which is equal to the node's position Default: attachment</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="defaultFrom" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of the from: header if not specified in message itself</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="defaultMessageBase64" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when messageBase64 is not specified defaultMessageBase64 will be used Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="defaultMessageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>when messageType is not specified defaultMessageType will be used Default: text/plain</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="defaultSubject" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of the subject: header if not specified in message itself</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>password of userid</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="smtpAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to smtphost</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="smtpPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>password of userid on the smtphost</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="smtpUserid" type="xs:string">
      <xs:annotation>
        <xs:documentation>userId on the smtphost</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="userId" type="xs:string">
      <xs:annotation>
        <xs:documentation>userId on the smtphost</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SenderWrapperType">
    <xs:group ref="SenderWrapperBaseCumulativeChildGroup" />
    <xs:attributeGroup ref="SenderWrapperBaseCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="ShadowSenderType">
    <xs:group ref="SenderSeriesCumulativeChildGroup" />
    <xs:attributeGroup ref="ShadowSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ShadowSenderDeclaredAttributeGroup">
    <xs:attribute name="originalSender" type="xs:string">
      <xs:annotation>
        <xs:documentation>the default or original sender</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultSender" type="xs:string">
      <xs:annotation>
        <xs:documentation>the sender which will process all results</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ShadowSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="ShadowSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="ParallelSendersCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="WebServiceNtlmSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="WebServiceNtlmSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="WebServiceNtlmSenderDeclaredAttributeGroup">
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authDomain" type="xs:string" />
    <xs:attribute name="contentType" type="xs:string">
      <xs:annotation>
        <xs:documentation>content-type of the request Default: text/html; charset=utf-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConnections" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the maximum number of concurrent connections Default: 10</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Default: 80</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapAction" type="xs:string">
      <xs:annotation>
        <xs:documentation>the soapactionuri to be set in the requestheader</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:integer">
      <xs:annotation>
        <xs:documentation>timeout in ms of obtaining a connection/result. 0 means no timeout Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>url or base of url to be used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="userName" type="xs:string">
      <xs:annotation>
        <xs:documentation>username used in authentication to host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="WebServiceNtlmSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="WebServiceNtlmSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="WebServiceSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="WebServiceSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="WebServiceSenderDeclaredAttributeGroup">
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the messageheader</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyleURI" type="xs:string" />
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions to be added in the soap envelope tag. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespaceParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>parameter to obtain the servicenamespace</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespaceURI" type="xs:string" />
    <xs:attribute name="serviceNamespaceURIParam" type="xs:string" />
    <xs:attribute name="soap" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope and the soap envelope is removed from received messages (soap envelope will not be visible to the pipeline) Default: &lt;code&gt;true&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapAction" type="xs:string">
      <xs:annotation>
        <xs:documentation>the soapactionuri to be set in the requestheader</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapActionParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>parameter to obtain the soapactionuri</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapActionURI" type="xs:string" />
    <xs:attribute name="soapActionURIParam" type="xs:string" />
    <xs:attribute name="throwApplicationFaults" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether soap faults generated by the application generate an exception, or are treated as 'normal' messages Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="WebServiceSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="WebServiceSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="HttpSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XComSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="XComSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="XComSenderDeclaredAttributeGroup">
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the alias to obtain credentials to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="carriageflag" type="xs:string">
      <xs:annotation>
        <xs:documentation>one of yes, no, vrl, vrl2, mpack or xpack</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="codeflag" type="xs:string">
      <xs:annotation>
        <xs:documentation>characterset conversion, one of ascii or ebcdic</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compress" type="xs:string">
      <xs:annotation>
        <xs:documentation>one of yes, no, rle, compact, lzlarge, lzmedium or lzsmall</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="configFile" type="xs:string" />
    <xs:attribute name="fileOption" type="xs:string">
      <xs:annotation>
        <xs:documentation>one of create, append or replace</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logfile" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of logfile for xcomtcp to be used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the sender</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>password of user on remote system</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="xs:string">
      <xs:annotation>
        <xs:documentation>port of remote host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queue" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>set queue off or on</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>remote directory is prefixed witht the remote file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteFilePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>remote file to create. if empty, the name is equal to the local file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteSystem" type="xs:string">
      <xs:annotation>
        <xs:documentation>hostname or tcpip adres of remote host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tracelevel" type="xs:integer">
      <xs:annotation>
        <xs:documentation>set between 0 (no trace) and 10</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truncation" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>set truncation off or on</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="userid" type="xs:string">
      <xs:annotation>
        <xs:documentation>loginname of user on remote system</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="workingDirName" type="xs:string">
      <xs:annotation>
        <xs:documentation>directory in which to run the xcomtcp command</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xcomtcp" type="xs:string">
      <xs:annotation>
        <xs:documentation>path to xcomtcp command</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XComSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="XComSenderDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XfbSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="XfbSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="XfbSenderDeclaredAttributeGroup">
    <xs:attribute name="appli" type="xs:string" />
    <xs:attribute name="copy" type="xs:boolean" />
    <xs:attribute name="copyPrefix" type="xs:string" />
    <xs:attribute name="flow" type="xs:string" />
    <xs:attribute name="ft" type="xs:string" />
    <xs:attribute name="noname" type="xs:string" />
    <xs:attribute name="script" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="XfbSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="XfbSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XmlJmsBrowserSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="XmlQuerySenderType">
    <xs:group ref="JdbcSenderBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="JdbcQuerySenderBaseCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="XmlValidatorSenderType">
    <xs:group ref="XmlValidatorSenderDeclaredChildGroup" />
    <xs:attributeGroup ref="XmlValidatorSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:group name="XmlValidatorSenderDeclaredChildGroup">
    <xs:sequence>
      <xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="XmlValidatorSenderDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="XmlValidatorSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="XmlValidatorSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractXmlValidatorDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="AbstractXmlValidatorDeclaredAttributeGroup">
    <xs:attribute name="addNamespaceToSchema" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Characterset used for reading file, only used when &lt;code&gt;validateFile&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; Default: utf-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Perform addional memory intensive checks Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCaching" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the number for caching validators in appConstants is ignored and no caching is done (for this validator only) Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:boolean" />
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of namespaces which are excluded from an import or include in the schema document</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of schemaLocations which are excluded from an import or include in the schema document</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set: key of session variable to store reasons of mis-validation in Default: failureReason</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Should the XmlValidator throw a PipeRunexception on a validation error. If not, a forward with name 'failure' must be defined. Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the comparison for importedSchemaLocationsToIgnore is done on base filename without any path Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. Otherwise the input itself is validated Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="warn" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, send warnings to logging and console about syntax problems in the configured schema('s) Default: &lt;code&gt;true&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Like &lt;code&gt;reasonSessionKey&lt;/code&gt; but stores reasons in xml format and more extensive Default: xmlFailureReason</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlSchemaVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;1.0&lt;/code&gt;, Xerces's previous XML Schema factory will be used, which would make all XSD 1.1 features illegal. The default behaviour can also be set with &lt;code&gt;xsd.processor.version&lt;/code&gt; property.  Default: &lt;code&gt;1.1&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:complexType name="ZipWriterSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="ZipWriterSenderCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ZipWriterSenderDeclaredAttributeGroup">
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>characterset used for writing zip entry Default: utf-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeStreamOnExit" type="xs:boolean" />
    <xs:attribute name="zipWriterHandle" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key used to refer to zip session. must be used if zipwriterpipes are nested Default: zipwriterhandle</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ZipWriterSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="ZipWriterSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="ListenerElementGroupBase">
    <xs:choice>
      <xs:element name="ApiListener">
        <xs:annotation>
          <xs:documentation>ApiListener - nl.nn.adapterframework.http.rest.ApiListener used as Listener</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ApiListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.rest.ApiListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="BisJmsListener">
        <xs:annotation>
          <xs:documentation>BisJmsListener - nl.nn.adapterframework.extensions.bis.BisJmsListener used as Listener

Bis (Business Integration Services) extension of JmsListener.
 &lt;br/&gt;
 Example request:&lt;br/&gt;&lt;code&gt;&lt;pre&gt;
	&amp;lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;
		&amp;lt;soap:Header&amp;gt;
			&amp;lt;bis:MessageHeader xmlns:bis="http://www.ing.com/CSP/XSD/General/Message_2"&amp;gt;
				&amp;lt;bis:From&amp;gt;
					&amp;lt;bis:Id&amp;gt;PolicyConversion_01_ServiceAgents_01&amp;lt;/bis:Id&amp;gt;
				&amp;lt;/bis:From&amp;gt;
				&amp;lt;bis:HeaderFields&amp;gt;
					&amp;lt;bis:ConversationId&amp;gt;1790257_10000050_04&amp;lt;/bis:ConversationId&amp;gt;
					&amp;lt;bis:MessageId&amp;gt;1790257&amp;lt;/bis:MessageId&amp;gt;
					&amp;lt;bis:Timestamp&amp;gt;2011-03-02T10:26:31.464+01:00&amp;lt;/bis:Timestamp&amp;gt;
				&amp;lt;/bis:HeaderFields&amp;gt;
			&amp;lt;/bis:MessageHeader&amp;gt;
		&amp;lt;/soap:Header&amp;gt;
		&amp;lt;soap:Body&amp;gt;
			&lt;i&gt;&amp;lt;pcr:GetRequest xmlns:pcr="http://www.ing.com/nl/pcretail/ts/migrationauditdata_01"&amp;gt;
				&amp;lt;pcr:PolicyDetails&amp;gt;
					&amp;lt;pcr:RVS_PARTY_ID&amp;gt;1790257&amp;lt;/pcr:RVS_PARTY_ID&amp;gt;
					&amp;lt;pcr:RVS_POLICY_NUMBER&amp;gt;10000050&amp;lt;/pcr:RVS_POLICY_NUMBER&amp;gt;
					&amp;lt;pcr:RVS_BRANCH_CODE&amp;gt;04&amp;lt;/pcr:RVS_BRANCH_CODE&amp;gt;
				&amp;lt;/pcr:PolicyDetails&amp;gt;
			&amp;lt;/pcr:GetRequest&amp;gt;&lt;/i&gt;
		&amp;lt;/soap:Body&amp;gt;
	&amp;lt;/soap:Envelope&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;&lt;br/&gt;
 The element MessageHeader in the soap header is mandatory.
 &lt;br/&gt;
 Example reply:&lt;br/&gt;&lt;code&gt;&lt;pre&gt;
	&amp;lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;
		&amp;lt;soap:Header&amp;gt;
			&amp;lt;bis:MessageHeader xmlns:bis="http://www.ing.com/CSP/XSD/General/Message_2"&amp;gt;
				&amp;lt;bis:From&amp;gt;
					&amp;lt;bis:Id&amp;gt;IJA_DB4CONV&amp;lt;/bis:Id&amp;gt;
				&amp;lt;/bis:From&amp;gt;
				&amp;lt;bis:HeaderFields&amp;gt;
					&amp;lt;bis:ConversationId&amp;gt;1790257_10000050_04&amp;lt;/bis:ConversationId&amp;gt;
					&amp;lt;bis:MessageId&amp;gt;rn09ce_0a3b8d2d--33192359_12e588118c1_-612f&amp;lt;/bis:MessageId&amp;gt;
					&amp;lt;bis:ExternalRefToMessageId&amp;gt;1790257&amp;lt;/bis:ExternalRefToMessageId&amp;gt;
					&amp;lt;bis:Timestamp&amp;gt;2011-03-02T10:26:31&amp;lt;/bis:Timestamp&amp;gt;
				&amp;lt;/bis:HeaderFields&amp;gt;
			&amp;lt;/bis:MessageHeader&amp;gt;
		&amp;lt;/soap:Header&amp;gt;
		&amp;lt;soap:Body&amp;gt;
			&lt;i&gt;&amp;lt;GetResponse xmlns="http://www.ing.com/nl/pcretail/ts/migrationcasedata_01"&amp;gt;&lt;/i&gt;
				&lt;i&gt;&amp;lt;CaseData&amp;gt;...&amp;lt;/CaseData&amp;gt;&lt;/i&gt;
				&amp;lt;bis:Result xmlns:bis="http://www.ing.com/CSP/XSD/General/Message_2"&amp;gt;
					&amp;lt;bis:Status&amp;gt;OK&amp;lt;/bis:Status&amp;gt;
				&amp;lt;/bis:Result&amp;gt;
			&lt;i&gt;&amp;lt;/GetResponse&amp;gt;&lt;/i&gt;
		&amp;lt;/soap:Body&amp;gt;
	&amp;lt;/soap:Envelope&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;&lt;br/&gt;
 The elements MessageHeader in the soap header and Result in the soap body are mandatory.
 &lt;br/&gt;
 Example element Result in case of an error reply:&lt;br/&gt;&lt;code&gt;&lt;pre&gt;
	&amp;lt;bis:Result xmlns:bis="http://www.ing.com/CSP/XSD/General/Message_2"&amp;gt;
		&amp;lt;bis:Status&amp;gt;ERROR&amp;lt;/bis:Status&amp;gt;
		&amp;lt;bis:ErrorList&amp;gt;
			&amp;lt;bis:Error&amp;gt;
				&amp;lt;bis:Code&amp;gt;ERR6003&amp;lt;/bis:Code&amp;gt;
				&amp;lt;bis:Reason&amp;gt;Invalid Request Message&amp;lt;/bis:Reason&amp;gt;
				&amp;lt;bis:Service&amp;gt;
					&amp;lt;bis:Name&amp;gt;migrationauditdata_01&amp;lt;/bis:Name&amp;gt;
					&amp;lt;bis:Context&amp;gt;1&amp;lt;/bis:Context&amp;gt;
					&amp;lt;bis:Action&amp;gt;
						&amp;lt;bis:Name&amp;gt;SetPolicyDetails_Action&amp;lt;/bis:Name&amp;gt;
						&amp;lt;bis:Version&amp;gt;1&amp;lt;/bis:Version&amp;gt;
					&amp;lt;/bis:Action&amp;gt;
				&amp;lt;/bis:Service&amp;gt;
				&amp;lt;bis:DetailList&amp;gt;
					&amp;lt;bis:Detail&amp;gt;
						&amp;lt;bis:Code/&amp;gt;
						&amp;lt;bis:Text&amp;gt;Pipe [Validate tibco request] msgId [Test Tool correlation id] got invalid xml according to schema [....&amp;lt;/bis:Text&amp;gt;
					&amp;lt;/bis:Detail&amp;gt;
				&amp;lt;/bis:DetailList&amp;gt;
			&amp;lt;/bis:Error&amp;gt;
		&amp;lt;/bis:ErrorList&amp;gt;
	&amp;lt;/bis:Result&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;&lt;br/&gt;
 &lt;p&gt;&lt;b&gt;Configuration:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;className&lt;/td&gt;&lt;td&gt;nl.nn.adapterframework.extensions.bis.BisSoapJmsListener&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setSoap(boolean) soap}&lt;/td&gt;&lt;td&gt;when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a SOAP envelope&lt;/td&gt;&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setRequestXPath(String) requestXPath}&lt;/td&gt;&lt;td&gt;xpath expression to extract the message which is passed to the pipeline. When soap=true the initial message is the content of the soap body. If empty, the content of the soap body is passed (without the root body)&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setRequestNamespaceDefs(String) requestNamespaceDefs}&lt;/td&gt;&lt;td&gt;namespace defintions for requestXPath. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setMessageHeaderInSoapBody(boolean) messageHeaderInSoapBody}&lt;/td&gt;&lt;td&gt;when &lt;code&gt;true&lt;/code&gt;, the MessageHeader is put in the SOAP body instead of in the SOAP header (first one is the old BIS standard)&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setResultInPayload(boolean) resultInPayload}&lt;/td&gt;&lt;td&gt;when &lt;code&gt;true&lt;/code&gt;, the Result is put in the payload (as last child in root tag) instead of in the SOAP body as sibling of the payload (last one is the old BIS standard)&lt;/td&gt;&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setOmitResult(boolean) omitResult}&lt;/td&gt;&lt;td&gt;when &lt;code&gt;true&lt;/code&gt;, the Result is omitted and instead of Result/Status 'ERROR' a ListenerException is thrown (this functionality will be used during migration from IFSA to TIBCO)&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setRemoveRequestNamespaces(boolean) removeRequestNamespaces}&lt;/td&gt;&lt;td&gt;when set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the request are removed (this functionality will be used during migration from IFSA to TIBCO)&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setLayByNamespace(boolean) layByNamespace}&lt;/td&gt;&lt;td&gt;when &lt;code&gt;true&lt;/code&gt;, the namespace of the request is laid by and afterwards added to the reply (this functionality will be used during migration from IFSA to TIBCO)&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setErrorCodeSessionKey(String) errorCodeSessionKey}&lt;/td&gt;&lt;td&gt;key of session variable to store error code in (if an error occurs)&lt;/td&gt;&lt;td&gt;bisErrorCode&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setErrorTextSessionKey(String) errorTextSessionKey}&lt;/td&gt;&lt;td&gt;key of session variable to store error text in (if an error occurs). If not specified, the following error text is derived from the error code: 
   &lt;table border="1"&gt;
   &lt;tr&gt;&lt;th&gt;errorCode&lt;/th&gt;&lt;th&gt;errorText&lt;/th&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6002&lt;/td&gt;&lt;td&gt;Service Interface Request Time Out&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6003&lt;/td&gt;&lt;td&gt;Invalid Request Message&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6004&lt;/td&gt;&lt;td&gt;Invalid Backend system response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6005&lt;/td&gt;&lt;td&gt;Backend system failure response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6999&lt;/td&gt;&lt;td&gt;Unspecified Errors&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setErrorReasonSessionKey(String) errorReasonSessionKey}&lt;/td&gt;&lt;td&gt;key of session variable to store error reason in (if an error occurs)&lt;/td&gt;&lt;td&gt;bisErrorReason&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setServiceName(String) serviceName}&lt;/td&gt;&lt;td&gt;name of the service; used in the error reply&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setActionName(String) actionName}&lt;/td&gt;&lt;td&gt;name of the operation; used in the error reply&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="BisJmsListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.bis.BisJmsListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DirectoryListener">
        <xs:annotation>
          <xs:documentation>DirectoryListener - nl.nn.adapterframework.receivers.DirectoryListener used as Listener</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DirectoryListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.receivers.DirectoryListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbJmsListener">
        <xs:annotation>
          <xs:documentation>EsbJmsListener - nl.nn.adapterframework.extensions.esb.EsbJmsListener used as Listener

ESB (Enterprise Service Bus) extension of JmsListener.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbJmsListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.esb.EsbJmsListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ExchangeMailListener">
        <xs:annotation>
          <xs:documentation>ExchangeMailListener - nl.nn.adapterframework.receivers.ExchangeMailListener used as Listener

Microsoft Exchange Implementation of a {@link nl.nn.adapterframework.filesystem.MailListener}.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ExchangeMailListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.receivers.ExchangeMailListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FileRecordListener">
        <xs:annotation>
          <xs:documentation>FileRecordListener - nl.nn.adapterframework.receivers.FileRecordListener used as Listener

File {@link IPullingListener listener} that looks in a directory for files according to a wildcard. When a file is
 found, it is read in a String object and parsed to records. 
 After reading the file, the file is renamed and moved to a directory.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FileRecordListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.receivers.FileRecordListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FtpListener">
        <xs:annotation>
          <xs:documentation>FtpListener - nl.nn.adapterframework.ftp.FtpListener used as Listener

Listener that polls a directory via FTP for files according to a wildcard. 
 When a file is found, it is moved to an outputdirectory, so that it isn't found more then once.  
 The name of the moved file is passed to the pipeline.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FtpListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.ftp.FtpListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FxfListener">
        <xs:annotation>
          <xs:documentation>FxfListener - nl.nn.adapterframework.extensions.fxf.FxfListener used as Listener

FxF extension of EsbJmsListener.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FxfListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.fxf.FxfListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="HttpListener">
        <xs:annotation>
          <xs:documentation>HttpListener - nl.nn.adapterframework.http.HttpListener used as Listener

Implementation of a {@link IPushingListener IPushingListener} that enables a {@link nl.nn.adapterframework.receivers.Receiver}
 to receive messages from HTTP requests.
 &lt;/table&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="HttpListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.HttpListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ImapListener">
        <xs:annotation>
          <xs:documentation>ImapListener - nl.nn.adapterframework.receivers.ImapListener used as Listener</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ImapListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.receivers.ImapListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JavaListener">
        <xs:annotation>
          <xs:documentation>JavaListener - nl.nn.adapterframework.receivers.JavaListener used as Listener

The JavaListener listens to java requests.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JavaListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.receivers.JavaListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JdbcListener">
        <xs:annotation>
          <xs:documentation>JdbcListener - nl.nn.adapterframework.jdbc.JdbcListener used as Listener

JdbcListener base class.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JdbcListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.JdbcListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JdbcQueryListener">
        <xs:annotation>
          <xs:documentation>JdbcQueryListener - nl.nn.adapterframework.jdbc.JdbcQueryListener used as Listener

/**
 Database Listener that operates on a table having at least a key and a status field.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JdbcQueryListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.JdbcQueryListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JdbcTableListener">
        <xs:annotation>
          <xs:documentation>JdbcTableListener - nl.nn.adapterframework.jdbc.JdbcTableListener used as Listener

Database Listener that operates on a table having at least a key and a status field.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JdbcTableListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.JdbcTableListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JmsListener">
        <xs:annotation>
          <xs:documentation>JmsListener - nl.nn.adapterframework.jms.JmsListener used as Listener

A true multi-threaded {@link nl.nn.adapterframework.core.IPullingListener Listener}-class.
 &lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JmsListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jms.JmsListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MessageStoreListener">
        <xs:annotation>
          <xs:documentation>MessageStoreListener - nl.nn.adapterframework.jdbc.MessageStoreListener used as Listener

Read messages from the ibisstore previously stored by a
 {@link MessageStoreSender}.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MessageStoreListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.MessageStoreListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MqttListener">
        <xs:annotation>
          <xs:documentation>MqttListener - nl.nn.adapterframework.extensions.mqtt.MqttListener used as Listener

MQTT listener which will connect to a broker and subscribe to a topic.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MqttListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.mqtt.MqttListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PullingJmsListener">
        <xs:annotation>
          <xs:documentation>PullingJmsListener - nl.nn.adapterframework.jms.PullingJmsListener used as Listener

A true multi-threaded {@link nl.nn.adapterframework.core.IPullingListener Listener}-class.
 &lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PullingJmsListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jms.PullingJmsListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PushingJmsListener">
        <xs:annotation>
          <xs:documentation>PushingJmsListener - nl.nn.adapterframework.jms.PushingJmsListener used as Listener

JMSListener re-implemented as a pushing listener rather than a pulling listener.
 The JMS messages have to come in from an external source: an MDB or a Spring
 message container.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PushingJmsListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jms.PushingJmsListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PushingListenerAdapterListener">
        <xs:annotation>
          <xs:documentation>PushingListenerAdapterListener - nl.nn.adapterframework.http.PushingListenerAdapter used as Listener

Baseclass of a {@link IPushingListener IPushingListener} that enables a {@link nl.nn.adapterframework.receivers.Receiver}
 to receive messages from Servlets.
 &lt;/table&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PushingListenerAdapterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.PushingListenerAdapter" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="RestListener">
        <xs:annotation>
          <xs:documentation>RestListener - nl.nn.adapterframework.http.RestListener used as Listener

Implementation of a {@link nl.nn.adapterframework.core.IPushingListener IPushingListener} that enables a {@link nl.nn.adapterframework.receivers.Receiver}
 to receive REST messages.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RestListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.RestListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Samba2Listener">
        <xs:annotation>
          <xs:documentation>Samba2Listener - nl.nn.adapterframework.receivers.Samba2Listener used as Listener</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Samba2ListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.receivers.Samba2Listener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SambaListener">
        <xs:annotation>
          <xs:documentation>SambaListener - nl.nn.adapterframework.receivers.SambaListener used as Listener</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SambaListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.receivers.SambaListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SimpleJdbcListener">
        <xs:annotation>
          <xs:documentation>SimpleJdbcListener - nl.nn.adapterframework.jdbc.SimpleJdbcListener used as Listener

Database Listener that returns a count of messages available, but does not perform any locking or
 other management of processing messages in parallel.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SimpleJdbcListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.SimpleJdbcListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="WebServiceListener">
        <xs:annotation>
          <xs:documentation>WebServiceListener - nl.nn.adapterframework.http.WebServiceListener used as Listener

Implementation of a {@link nl.nn.adapterframework.core.IPushingListener IPushingListener} that enables a {@link nl.nn.adapterframework.receivers.Receiver}
 to receive messages as a web-service.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="WebServiceListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.WebServiceListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="ApiListenerType">
    <xs:attributeGroup ref="ApiListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ApiListenerDeclaredAttributeGroup">
    <xs:attribute name="method" type="xs:string">
      <xs:annotation>
        <xs:documentation>HTTP method eq. GET POST PUT DELETE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="uriPattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>uri pattern to register this listener on, eq. `/my-listener/{something}/here`</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="consumes" type="MediaTypesAttributeValuesType">
      <xs:annotation>
        <xs:documentation>the specified contentType on requests, if it doesn't match the request will fail Default: ANY</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produces" type="MediaTypesAttributeValuesType">
      <xs:annotation>
        <xs:documentation>the specified contentType on response Default: ANY</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="characterEncoding" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets the specified character encoding on the response contentType header Default: UTF-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="updateEtag" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>automatically generate and validate etags Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authenticationMethod" type="AuthenticationMethodsAttributeValuesType">
      <xs:annotation>
        <xs:documentation>enables security for this listener, must be one of [NONE, COOKIE, HEADER, AUTHROLE]. If you wish to use the application servers authorisation roles [AUTHROLE], you need to enable them globally for all ApiListeners with the `servlet.ApiListenerServlet.securityroles=ibistester,ibiswebservice` property Default: NONE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authenticationRoles" type="xs:string">
      <xs:annotation>
        <xs:documentation>only active when AuthenticationMethod=AUTHROLE. comma separated list of authorization roles which are granted for this service, eq. ibistester,ibisobserver</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartBodyName" type="xs:string">
      <xs:annotation>
        <xs:documentation>specify the form-part you wish to enter the pipeline Default: name of the first form-part</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageIdHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the header which contains the message-id Default: message-id</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="operationId" type="xs:string">
      <xs:annotation>
        <xs:documentation>Unique string used to identify the operation. The id MUST be unique among all operations described in the OpenApi schema</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="headerParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of parameters passed as http header. Parameters will be stored in 'headers' sessionkey.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:simpleType name="MediaTypesAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ANY" />
      <xs:enumeration value="TEXT" />
      <xs:enumeration value="XML" />
      <xs:enumeration value="JSON" />
      <xs:enumeration value="PDF" />
      <xs:enumeration value="OCTET" />
      <xs:enumeration value="MULTIPART_RELATED" />
      <xs:enumeration value="MULTIPART_FORMDATA" />
      <xs:enumeration value="MULTIPART" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="AuthenticationMethodsAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="NONE" />
      <xs:enumeration value="COOKIE" />
      <xs:enumeration value="HEADER" />
      <xs:enumeration value="AUTHROLE" />
    </xs:restriction>
  </xs:simpleType>
  <xs:attributeGroup name="ApiListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="ApiListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="PushingListenerAdapterDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="PushingListenerAdapterType">
    <xs:attributeGroup ref="PushingListenerAdapterDeclaredAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="PushingListenerAdapterDeclaredAttributeGroup">
    <xs:attribute name="applicationFaultsAsExceptions" type="xs:boolean" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the listener as known to the adapter</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="running" type="xs:boolean" />
  </xs:attributeGroup>
  <xs:complexType name="BisJmsListenerType">
    <xs:group ref="JmsListenerBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="BisJmsListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="BisJmsListenerDeclaredAttributeGroup">
    <xs:attribute name="actionName" type="xs:string" />
    <xs:attribute name="errorCodeSessionKey" type="xs:string" />
    <xs:attribute name="errorReasonSessionKey" type="xs:string" />
    <xs:attribute name="errorTextSessionKey" type="xs:string" />
    <xs:attribute name="layByNamespace" type="xs:boolean" />
    <xs:attribute name="messageHeaderInSoapBody" type="xs:boolean" />
    <xs:attribute name="omitResult" type="xs:boolean" />
    <xs:attribute name="removeRequestNamespaces" type="xs:boolean" />
    <xs:attribute name="requestNamespaceDefs" type="xs:string" />
    <xs:attribute name="requestXPath" type="xs:string" />
    <xs:attribute name="resultInPayload" type="xs:boolean" />
    <xs:attribute name="serviceName" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="BisJmsListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="BisJmsListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="PushingJmsListenerCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JmsListenerBaseType">
    <xs:group ref="JmsListenerBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="JmsListenerBaseCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:group name="JmsListenerBaseDeclaredChildGroup">
    <xs:sequence>
      <xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
      <xs:group ref="SenderElementGroup" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="JmsListenerBaseDeclaredAttributeGroup">
    <xs:attribute name="commitOnState" type="xs:string">
      <xs:annotation>
        <xs:documentation>&lt;i&gt;deprecated&lt;/i&gt; exit state to control commit or rollback of jmssession. only used if &lt;code&gt;jmstransacted&lt;/code&gt; is set true. Default: success</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forceMessageIdAsCorrelationId" type="xs:boolean" />
    <xs:attribute name="replyDeliveryMode" type="DeliveryModeAttributeValuesType">
      <xs:annotation>
        <xs:documentation>Controls mode that reply messages are sent with: either 'PERSISTENT' or 'NON_PERSISTENT' Default: not set by application</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyEncodingStyleURI" type="xs:string" />
    <xs:attribute name="replyMessageTimeToLive" type="xs:integer">
      <xs:annotation>
        <xs:documentation>time that replymessage will live Default: 0 [ms]</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyMessageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of the jmstype field of the reply message Default: not set by application</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyNamespaceURI" type="xs:string" />
    <xs:attribute name="replyPriority" type="xs:integer">
      <xs:annotation>
        <xs:documentation>sets the priority that is used to deliver the reply message. ranges from 0 to 9. defaults to -1, meaning not set. effectively the default priority is set by jms to 4</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replySoapAction" type="xs:string" />
    <xs:attribute name="soap" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="timeOut" type="xs:integer">
      <xs:annotation>
        <xs:documentation>receive timeout in milliseconds as specified by the JMS API, see https://docs.oracle.com/javaee/7/api/javax/jms/MessageConsumer.html#receive-long- Default: 1000 [ms]</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useReplyTo" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xPathLoggingKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of all xpath keys that need to be logged. (overrides &lt;code&gt;msg.log.keys&lt;/code&gt; property)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JmsListenerBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="JmsListenerBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JMSFacadeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="PushingJmsListenerType">
    <xs:group ref="JmsListenerBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="PushingJmsListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="PushingJmsListenerDeclaredAttributeGroup">
    <xs:attribute name="cacheMode" type="xs:string" />
    <xs:attribute name="listenerPort" type="xs:string" />
    <xs:attribute name="pollGuardInterval" type="xs:integer">
      <xs:annotation>
        <xs:documentation>interval in milliseconds for the poll guard to check whether a successful poll was done by the receive (https://docs.oracle.com/javaee/7/api/javax/jms/messageconsumer.html#receive-long-) since last check. when polling has stopped this will be logged and the listener will be stopped and started in an attempt to workaround problems with polling. polling might stop due to bugs in the jms driver/implementation which should be fixed by the supplier. as the poll time includes reading and processing of the message no successful poll might be registered since the last check when message processing takes a long time, hence while messages are being processed the check on last successful poll will be skipped. set to -1 to disable Default: ten times the specified timeout</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="PushingJmsListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="PushingJmsListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JmsListenerBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="DirectoryListenerType">
    <xs:attributeGroup ref="DirectoryListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="DirectoryListenerDeclaredAttributeGroup">
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional base folder, that serves as root for all other folders</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="DirectoryListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="DirectoryListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemListenerDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="FileSystemListenerDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the listener</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder that is scanned for files. If not set, the root is scanned</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inProcessFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder where files are stored &lt;i&gt;while&lt;/i&gt; being processed</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="processedFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder where files are stored &lt;i&gt;after&lt;/i&gt; being processed</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="errorFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder where files are stored &lt;i&gt;after&lt;/i&gt; being processed, in case the exit-state was not equal to &lt;code&gt;success&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="holdFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder where messages from the error folder can be put on Hold, temporarily</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder where a copy of every file that is received is stored</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createFolders" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the folders to look for files and to move files to when being processed and after being processed are created if they are specified and do not exist Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="delete" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the file processed will be deleted after being processed, and not stored Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numberOfBackups" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Number of copies held of a file with the same name. Backup files have a dot and a number suffixed to their name. If set to 0, no backups will be kept. Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="overwrite" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the destination file will be deleted if it already exists Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>Determines the contents of the message that is sent to the pipeline. Can be 'name', for the filename, 'path', for the full file path, 'contents' for the contents of the file. For any other value, the attributes of the file are searched and used Default: path</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileTimeSensitive" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the file modification time is used in addition to the filename to determine if a file has been seen before Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="minStableTime" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Minimal age of file in milliseconds, to avoid receiving a file while it is still being written Default: 1000 [ms]</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageIdPropertyKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of Property to use as messageId. If not set, the filename of the file as it was received in the inputFolder is used as the messageId Default: for MailFileSystems: Message-ID</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="disableMessageBrowsers" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, no browsers for process folders are generated Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wildCard" type="xs:string">
      <xs:annotation>
        <xs:documentation>Filter of files to look for in inputFolder e.g. '*.inp'.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="excludeWildCard" type="xs:string">
      <xs:annotation>
        <xs:documentation>Filter of files to be excluded when looking in inputFolder.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createInputDirectory" type="xs:boolean" />
    <xs:attribute name="inputDirectory" type="xs:string" />
    <xs:attribute name="outputDirectory" type="xs:string" />
    <xs:attribute name="processedDirectory" type="xs:string" />
  </xs:attributeGroup>
  <xs:complexType name="EsbJmsListenerType">
    <xs:group ref="JmsListenerBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="EsbJmsListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="EsbJmsListenerDeclaredAttributeGroup">
    <xs:attribute name="copyAEProperties" type="xs:boolean" />
    <xs:attribute name="messageProtocol" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="EsbJmsListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="EsbJmsListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="PushingJmsListenerCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ExchangeMailListenerType">
    <xs:attributeGroup ref="ExchangeMailListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ExchangeMailListenerDeclaredAttributeGroup">
    <xs:attribute name="mailAddress" type="xs:string">
      <xs:annotation>
        <xs:documentation>The mail address of the mailbox connected to (also used for auto discovery)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>Url of the Exchange server. Set to e.g. https://outlook.office365.com/EWS/Exchange.asmx to speed up start up, leave empty to use autodiscovery</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="accessToken" type="xs:string">
      <xs:annotation>
        <xs:documentation>AccessToken for authentication to Exchange mail server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Username for authentication to Exchange mail server. Ignored when accessToken is also specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password for authentication to Exchange mail server. Ignored when accessToken is also specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain accessToken or username and password for authentication to Exchange mail server. If the alias refers to a combination of a username and a password, the deprecated Basic Authentication method is used. If the alias refers to a password without a username, the password is treated as the accessToken.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="baseFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder (subfolder of root or of inbox) to look for mails. If empty, the inbox folder is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filter" type="xs:string">
      <xs:annotation>
        <xs:documentation>If empty, all mails are retrieved. If set to &lt;code&gt;NDR&lt;/code&gt; only Non-Delivery Report mails ('bounces') are retrieved</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyAddressFields" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of fields to try as response address Default: replyTo,from,sender,Return-Path</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:integer">
      <xs:annotation>
        <xs:documentation>proxy port</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy authAlias</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyDomain" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy domain</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFolder" type="xs:string" />
    <xs:attribute name="proxyUserName" type="xs:string" />
    <xs:attribute name="tempFolder" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="ExchangeMailListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="ExchangeMailListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="MailListenerCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="MailListenerDeclaredAttributeGroup">
    <xs:attribute name="simple" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the xml string passed to the pipeline only contains the subject of the mail (to save memory)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeEmailAsStreamInSessionKey" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="MailListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="MailListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemListenerDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FileRecordListenerType">
    <xs:group ref="FileRecordListenerDeclaredChildGroup" />
    <xs:attributeGroup ref="FileRecordListenerDeclaredAttributeGroup" />
  </xs:complexType>
  <xs:group name="FileRecordListenerDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="SenderElementGroup" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="FileRecordListenerDeclaredAttributeGroup">
    <xs:attribute name="directoryProcessedFiles" type="xs:string">
      <xs:annotation>
        <xs:documentation>the directory to store processed files in</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>set the directory name to look in for files.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the listener as known to the adapter.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="responseTime" type="xs:integer">
      <xs:annotation>
        <xs:documentation>set the time to delay when no records are to be processed and this class has to look for the arrival of a new file Default: 1000 [ms]</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeFileNameInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the name of the read file is stored under this session key</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wildcard" type="xs:string">
      <xs:annotation>
        <xs:documentation>the {@link nl.nn.adapterframework.util.wildcardfilter wildcard} to look for files in the specified directory, e.g. "*.inp"</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:complexType name="FtpListenerType">
    <xs:attributeGroup ref="FtpListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FtpListenerDeclaredAttributeGroup">
    <xs:attribute name="remoteDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>remote directory from which files have to be downloaded</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="responseTime" type="xs:integer">
      <xs:annotation>
        <xs:documentation>time between pollings Default: 3600000 (one hour)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FtpListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="FtpListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FtpSessionDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FtpSessionType">
    <xs:attributeGroup ref="FtpSessionDeclaredAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FtpSessionDeclaredAttributeGroup">
    <xs:attribute name="allowSelfSignedCertificates" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(ftps) if true, the server certificate can be self signed Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the alias to obtain credentials to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificate" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) resource url to certificate to be used for authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) alias used to obtain certificate password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificatePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  Default: pkcs12</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="consoleKnownHostsVerifier" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(sftp)  Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileType" type="xs:string">
      <xs:annotation>
        <xs:documentation>file type, one of ascii, binary</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ftpTypeDescription" type="xs:string">
      <xs:annotation>
        <xs:documentation>one of ftp, sftp, ftps(i) or ftpsi, ftpsx(ssl), ftpsx(tls) Default: ftp</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="host" type="xs:string">
      <xs:annotation>
        <xs:documentation>name or ip adres of remote host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>selects the algorithm to generate keymanagers. can be left empty to use the servers default algorithm Default: websphere: ibmx509</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyboardInteractive" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true, keyboardinteractive is used to login Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="knownHostsPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) path to file with knownhosts</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageIsContent" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>if true, the contents of the message is send, otherwise it message contains the local filenames of the files to be send Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the listener or sender</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="passive" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>if true, passive ftp is used: before data is sent, a pasv command is issued, and the connection is set up by the server Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the password to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="xs:integer">
      <xs:annotation>
        <xs:documentation>portnumber of remote host Default: 21</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefCSEncryption" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) optional preferred encryption from client to server for sftp protocol</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefSCEncryption" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) optional preferred encryption from server to client for sftp protocol</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) name of the alias to obtain credentials for passphrase of private key file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyFilePath" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) path to private key file for sftp authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) passphrase of private key file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="protP" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(ftps) if true, the server returns data via another socket Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the alias to obtain credentials to authenticate on proxy</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy host name</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>default password in case proxy requires authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:integer">
      <xs:annotation>
        <xs:documentation>proxy port Default: 1080</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyTransportType" type="xs:integer">
      <xs:annotation>
        <xs:documentation>(sftp) transport type in case of sftp (1=standard, 2=http, 3=socks4, 4=socks5) Default: 4</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>default user name in case proxy requires authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>selects the algorithm to generate trustmanagers. can be left empty to use the servers default algorithm Default: websphere: ibmx509</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) resource url to truststore to be used for authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) alias used to obtain truststore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  Default: jks</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the user to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(ftps) when true, the hostname in the certificate will be checked against the actual hostname Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:complexType name="FxfListenerType">
    <xs:group ref="JmsListenerBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="FxfListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FxfListenerDeclaredAttributeGroup">
    <xs:attribute name="createProcessedDirectory" type="xs:boolean" />
    <xs:attribute name="fxfFileSessionKey" type="xs:string" />
    <xs:attribute name="moveProcessedFile" type="xs:boolean" />
    <xs:attribute name="processedSiblingDirectory" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="FxfListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="FxfListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="EsbJmsListenerCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="HttpListenerType">
    <xs:attributeGroup ref="HttpListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="HttpListenerDeclaredAttributeGroup">
    <xs:attribute name="serviceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the service that is provided by the adapter of this listener</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="HttpListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="HttpListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="PushingListenerAdapterDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ImapListenerType">
    <xs:attributeGroup ref="ImapListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ImapListenerDeclaredAttributeGroup">
    <xs:attribute name="host" type="xs:string">
      <xs:annotation>
        <xs:documentation>The hostname of the IMAP server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="xs:integer">
      <xs:annotation>
        <xs:documentation>The port of the IMAP server Default: 993</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain accessToken or username and password for authentication to Exchange mail server. If the alias refers to a combination of a username and a password, the deprecated Basic Authentication method is used. If the alias refers to a password without a username, the password is treated as the accessToken.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Username for authentication to mail server.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password for authentication to mail server.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="baseFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder (subfolder of root or of inbox) to look for mails. If empty, the inbox folder is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyAddressFields" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of fields to try as response address Default: replyTo,from,sender,Return-Path</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ImapListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="ImapListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="MailListenerCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JavaListenerType">
    <xs:attributeGroup ref="JavaListenerDeclaredAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="JavaListenerDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Internal name of the listener, as known to the adapter. An IbisLocalSender refers to this name in its &lt;code&gt;javaListener&lt;/code&gt;-attribute.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>External Name of the listener. An IbisJavaSender refers to this name in its &lt;code&gt;serviceName&lt;/code&gt;-attribute.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;false&lt;/code&gt;, the request is executed asynchronously. N.B. be aware that there is no limit on the number of threads generated Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Should the JavaListener throw a ListenerException when it occurs or return an error message Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="httpWsdl" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the WSDL of the service provided by this listener will available for download  Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="isolated" type="xs:boolean" />
    <xs:attribute name="local" type="xs:string" />
  </xs:attributeGroup>
  <xs:complexType name="JdbcListenerType">
    <xs:attributeGroup ref="JdbcListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="JdbcListenerDeclaredAttributeGroup">
    <xs:attribute name="keyField" type="xs:string">
      <xs:annotation>
        <xs:documentation>Primary key field of the table, used to identify messages</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageField" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Optional) field containing the message data Default: &lt;i&gt;same as keyField&lt;/i&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>Type of the field containing the message data: either String, clob or blob Default: &lt;i&gt;String&lt;/i&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Controls whether BLOB is considered stored compressed in the database Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Charset used to read BLOB. When specified, then the BLOB will be converted into a string</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Controls automatically whether blobdata is stored compressed and/or serialized in the database. N.B. When set true, then the BLOB will be converted into a string Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="peekQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;peekUntransacted=true&lt;/code&gt;) peek query to determine if the select query should be executed. Peek queries are, unlike select queries, executed without a transaction and without a rowlock Default: selectQuery</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="peekUntransacted" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true, then PollingListener container will execute getRawMessage() only when hasRawMessageAvailable() has returned true. This avoids rolling back a lot of XA transactions, that appears to be problematic on MS SQL Server Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trace" type="xs:boolean" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcFacadeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JdbcQueryListenerType">
    <xs:attributeGroup ref="JdbcQueryListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="JdbcQueryListenerDeclaredAttributeGroup">
    <xs:attribute name="selectQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>Query that returns a row to be processed. Must contain a key field and optionally a message field</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="updateStatusToProcessedQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>SQL statement to set the status of a row to 'processed'. Must contain one parameter, that is set to the value of the key</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="updateStatusToErrorQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>SQL statement to set the status of a row to 'error'. Must contain one parameter, that is set to the value of the key Default: same as &lt;code&gt;updateStatusToProcessedQuery&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="updateStatusToInProcessQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>SQL statement to set the status of a row to 'in process'. Must contain one parameter, that is set to the value of the key. Can be left emtpy if database has SKIP LOCKED functionality and the Receiver can be (and is) set to Required or RequiresNew.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="revertInProcessStatusQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>SQL statement to set the status of a row to 'available'. Must contain one parameter, that is set to the value of the key. Only use in rollbacks, when updateStatusToInProcessQuery is specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcQueryListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcQueryListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcListenerCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JdbcTableListenerType">
    <xs:attributeGroup ref="JdbcTableListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="JdbcTableListenerDeclaredAttributeGroup">
    <xs:attribute name="tableName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the table to be used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tableAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias of the table, that can be used in selectCondition Default: t</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusField" type="xs:string">
      <xs:annotation>
        <xs:documentation>Field containing the status of the message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="orderField" type="xs:string">
      <xs:annotation>
        <xs:documentation>(optional) Field determining the order in which messages are processed</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timestampField" type="xs:string">
      <xs:annotation>
        <xs:documentation>(optional) Field used to store the date and time of the last change of the statusField</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueAvailable" type="xs:string">
      <xs:annotation>
        <xs:documentation>(optional) Value of statusField indicating row is available to be processed. If not specified, any row not having any of the other status values is considered available.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueError" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of statusField indicating the processing of the row resulted in an error</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueProcessed" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of status field indicating row is processed ok</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueInProcess" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of status field indicating is being processed. Can be left emtpy if database has SKIP LOCKED functionality and the Receiver can be (and is) set to Required or RequiresNew.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueHold" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of status field indicating message is on Hold, temporarily</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="selectCondition" type="xs:string">
      <xs:annotation>
        <xs:documentation>Additional condition for a row to belong to this TableListener</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcTableListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcTableListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcListenerCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JmsListenerType">
    <xs:group ref="JmsListenerBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="PushingJmsListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="MessageStoreListenerType">
    <xs:attributeGroup ref="MessageStoreListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="MessageStoreListenerDeclaredAttributeGroup">
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>Identifier for this service</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of sessionKey's to be read together with the message. Please note: corresponding {@link MessagestoreSender} must have the same value for this attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="moveToMessageLog" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Move to messageLog after processing, as the message is already stored in the ibisstore only some fields need to be updated. When set false, messages are deleted after being processed Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueInProcess" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of status field indicating is being processed. Set to 'I' if database has no SKIP LOCKED functionality or the Receiver cannot be set to Required or RequiresNew.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="MessageStoreListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="MessageStoreListenerDeclaredAttributeGroup" />
    <xs:attribute name="tableName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the table to be used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tableAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias of the table, that can be used in selectCondition Default: t</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusField" type="xs:string">
      <xs:annotation>
        <xs:documentation>Field containing the status of the message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="orderField" type="xs:string">
      <xs:annotation>
        <xs:documentation>(optional) Field determining the order in which messages are processed</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timestampField" type="xs:string">
      <xs:annotation>
        <xs:documentation>(optional) Field used to store the date and time of the last change of the statusField</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueAvailable" type="xs:string">
      <xs:annotation>
        <xs:documentation>(optional) Value of statusField indicating row is available to be processed. If not specified, any row not having any of the other status values is considered available.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueError" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of statusField indicating the processing of the row resulted in an error</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueProcessed" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of status field indicating row is processed ok</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueHold" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of status field indicating message is on Hold, temporarily</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="selectCondition" type="xs:string">
      <xs:annotation>
        <xs:documentation>Additional condition for a row to belong to this TableListener</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="JdbcListenerCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="MqttListenerType">
    <xs:attributeGroup ref="MqttFacadeDeclaredAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="PullingJmsListenerType">
    <xs:group ref="JmsListenerBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="JmsListenerBaseCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="RestListenerType">
    <xs:attributeGroup ref="RestListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="RestListenerDeclaredAttributeGroup">
    <xs:attribute name="authRoles" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of authorization roles which are granted for this rest service Default: IbisAdmin,IbisDataAdmin,IbisTester,IbisObserver,IbisWebService</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="consumes" type="xs:string">
      <xs:annotation>
        <xs:documentation>Mediatype (e.g. XML, JSON, TEXT) the {@link nl.nn.adapterframework.http.RestServiceDispatcher restServiceDispatcher} receives as input Default: XML</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="contentTypeSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of Session variable that determines requested content type, overrides {@link #setProduces(String) produces}</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="etagSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of session variable to store etag</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="generateEtag" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to true the ibis will automatically create an etag Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="method" type="xs:string">
      <xs:annotation>
        <xs:documentation>Method (e.g. GET or POST) to match</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produces" type="xs:string">
      <xs:annotation>
        <xs:documentation>Mediatype (e.g. XML, JSON, TEXT) the {@link nl.nn.adapterframework.http.RestServiceDispatcher restServiceDispatcher} sends as output, if set to json the ibis will automatically try to convert the xml message Default: XML</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restPath" type="xs:string" />
    <xs:attribute name="retrieveMultipart" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Indicates whether the parts of a multipart entity should be retrieved and put in session keys. This can only be done once! Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="uriPattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>Uri pattern to match, the {uri} part in https://mydomain.com/ibis4something/rest/{uri}, where mydomain.com and ibis4something refer to 'your ibis'.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateEtag" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to true the ibis will automatically validate and process etags Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="view" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Indicates whether this listener supports a view (and a link should be put in the ibis console) Default: if &lt;code&gt;method=get&lt;/code&gt; then &lt;code&gt;true&lt;/code&gt;, else &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeSecLogMessage" type="xs:boolean" />
    <xs:attribute name="writeToSecLog" type="xs:boolean" />
  </xs:attributeGroup>
  <xs:attributeGroup name="RestListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="RestListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="PushingListenerAdapterDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Samba2ListenerType">
    <xs:attributeGroup ref="Samba2ListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="Samba2ListenerDeclaredAttributeGroup">
    <xs:attribute name="share" type="xs:string">
      <xs:annotation>
        <xs:documentation>Shared folder name in the samba server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for the smb share</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="domain" type="xs:string">
      <xs:annotation>
        <xs:documentation>domain, in case the user account is bound to a domain</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authType" type="xs:string">
      <xs:annotation>
        <xs:documentation>Type of the authentication either 'NTLM' or 'SPNEGO'  Default: SPNEGO</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="kdc" type="xs:string">
      <xs:annotation>
        <xs:documentation>Kerberos Domain Controller, as set in java.security.krb5.kdc. If authentication type specified as SPNEGO and realm is specified then this field must be filled.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="realm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Kerberos Realm, as set in java.security.krb5.realm. If authentication type specified as SPNEGO this field must be filled. If not filled then default realm is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Samba2ListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="Samba2ListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemListenerDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SambaListenerType">
    <xs:attributeGroup ref="Samba2ListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="SimpleJdbcListenerType">
    <xs:attributeGroup ref="SimpleJdbcListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="SimpleJdbcListenerDeclaredAttributeGroup">
    <xs:attribute name="selectQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>count query that returns the number of available records. when there are available records the pipeline is activated</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trace" type="xs:boolean" />
  </xs:attributeGroup>
  <xs:attributeGroup name="SimpleJdbcListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="SimpleJdbcListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcFacadeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="WebServiceListenerType">
    <xs:attributeGroup ref="WebServiceListenerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="WebServiceListenerDeclaredAttributeGroup">
    <xs:attribute name="address" type="xs:string">
      <xs:annotation>
        <xs:documentation>The address to listen to, e.g the part &lt;address&gt; in https://mydomain.com/ibis4something/services/&lt;/address&gt;, where mydomain.com and ibis4something refer to 'your ibis'</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="applicationFaultsAsSoapFaults" type="xs:boolean" />
    <xs:attribute name="attachmentSessionKeys" type="xs:string" />
    <xs:attribute name="mtomEnabled" type="xs:boolean" />
    <xs:attribute name="multipartXmlSessionKey" type="xs:string" />
    <xs:attribute name="serviceNamespaceURI" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace of the service that is provided by the adapter of this listener</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soap" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; the soap envelope is removed from received messages and a soap envelope is added to returned messages (soap envelope will not be visible to the pipeline) Default: &lt;code&gt;true&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="WebServiceListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="WebServiceListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="PushingListenerAdapterDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="ErrorSenderElementGroup">
    <xs:choice>
      <xs:element name="ErrorSender">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:group ref="CacheElementGroup" />
              <xs:element ref="Param" />
              <xs:group ref="SenderElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ErrorSenderElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ErrorSenderElementGroupBase">
    <xs:choice>
      <xs:element name="Afm2EdiFactErrorSender">
        <xs:annotation>
          <xs:documentation>Afm2EdiFactErrorSender - nl.nn.adapterframework.extensions.afm.Afm2EdiFactSender used as ErrorSender

Domparser om AFM-XML berichten om te zetten in edifactberichten (voor de backoffice).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Afm2EdiFactSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.afm.Afm2EdiFactSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="AmazonS3ErrorSender">
        <xs:annotation>
          <xs:documentation>AmazonS3ErrorSender - nl.nn.adapterframework.senders.AmazonS3Sender used as ErrorSender

Sender to work with Amazon S3.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="AmazonS3SenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.AmazonS3Sender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="BisJmsErrorSender">
        <xs:annotation>
          <xs:documentation>BisJmsErrorSender - nl.nn.adapterframework.extensions.bis.BisJmsSender used as ErrorSender

Bis (Business Integration Services) extension of JmsSender.
 &lt;br/&gt;
 For example request and reply, see {@link BisJmsListener}.
 &lt;br/&gt;
 If synchronous=true and one of the following conditions is true a SenderException is thrown:
 - Result/Status in the reply soap body equals 'ERROR'
 - faultcode in the reply soap fault is not empty
 &lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="BisJmsSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.bis.BisJmsSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CommandErrorSender">
        <xs:annotation>
          <xs:documentation>CommandErrorSender - nl.nn.adapterframework.senders.CommandSender used as ErrorSender

Sender that executes either its input or a fixed line, with all parametervalues appended, as a command.
 &lt;table border="1"&gt;
 &lt;p&gt;&lt;b&gt;Parameters:&lt;/b&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;type&lt;/th&gt;&lt;th&gt;remarks&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;the values of all parameters present are appended as arguments to the command&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CommandSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.CommandSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DelayErrorSender">
        <xs:annotation>
          <xs:documentation>DelayErrorSender - nl.nn.adapterframework.senders.DelaySender used as ErrorSender

Sender that sleeps for a specified time, which defaults to 5000 msecs.
 Useful for testing purposes.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DelaySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.DelaySender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DirectQueryErrorSender">
        <xs:annotation>
          <xs:documentation>DirectQueryErrorSender - nl.nn.adapterframework.jdbc.DirectQuerySender used as ErrorSender

QuerySender that interprets the input message as a query, possibly with attributes.
 Messages are expected to contain sql-text.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DirectQuerySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.DirectQuerySender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EchoErrorSender">
        <xs:annotation>
          <xs:documentation>EchoErrorSender - nl.nn.adapterframework.senders.EchoSender used as ErrorSender

Echos input to output.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EchoSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.EchoSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbJmsErrorSender">
        <xs:annotation>
          <xs:documentation>EsbJmsErrorSender - nl.nn.adapterframework.extensions.esb.EsbJmsSender used as ErrorSender

ESB (Enterprise Service Bus) extension of JmsSender.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbJmsSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.esb.EsbJmsSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ExchangeFolderErrorSender">
        <xs:annotation>
          <xs:documentation>ExchangeFolderErrorSender - nl.nn.adapterframework.senders.ExchangeFolderSender used as ErrorSender

Implementation of a {@link FileSystemSender} that enables to manipulate messages in a Exchange folder.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ExchangeFolderSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.ExchangeFolderSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FileErrorSender">
        <xs:annotation>
          <xs:documentation>FileErrorSender - nl.nn.adapterframework.senders.FileSender used as ErrorSender

&lt;p&gt;See {@link FileHandler}&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FileSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.FileSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FileSystemErrorSender">
        <xs:annotation>
          <xs:documentation>FileSystemErrorSender - nl.nn.adapterframework.filesystem.FileSystemSender used as ErrorSender

Base class for Senders that use a {@link IBasicFileSystem FileSystem}.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FileSystemSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.filesystem.FileSystemSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FileSystemSenderWithAttachmentsErrorSender">
        <xs:annotation>
          <xs:documentation>FileSystemSenderWithAttachmentsErrorSender - nl.nn.adapterframework.filesystem.FileSystemSenderWithAttachments used as ErrorSender

FileSystem Sender extension to handle Attachments.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FileSystemSenderWithAttachmentsType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.filesystem.FileSystemSenderWithAttachments" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FixedQueryErrorSender">
        <xs:annotation>
          <xs:documentation>FixedQueryErrorSender - nl.nn.adapterframework.jdbc.FixedQuerySender used as ErrorSender

QuerySender that assumes a fixed query, possibly with attributes.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FixedQuerySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.FixedQuerySender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FixedResultErrorSender">
        <xs:annotation>
          <xs:documentation>FixedResultErrorSender - nl.nn.adapterframework.senders.FixedResultSender used as ErrorSender

FixedResultSender, same behaviour as {@link nl.nn.adapterframework.pipes.FixedResultPipe FixedResultPipe}, but now as a ISender.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FixedResultSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.FixedResultSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FtpFileSystemErrorSender">
        <xs:annotation>
          <xs:documentation>FtpFileSystemErrorSender - nl.nn.adapterframework.senders.FtpFileSystemSender used as ErrorSender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FtpFileSystemSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.FtpFileSystemSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FtpErrorSender">
        <xs:annotation>
          <xs:documentation>FtpErrorSender - nl.nn.adapterframework.ftp.FtpSender used as ErrorSender

FTP client voor het versturen van files via FTP.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FtpSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.ftp.FtpSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="HttpErrorSender">
        <xs:annotation>
          <xs:documentation>HttpErrorSender - nl.nn.adapterframework.http.HttpSender used as ErrorSender

Sender for the HTTP protocol using GET, POST, PUT or DELETE.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="HttpSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.HttpSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IbisJavaErrorSender">
        <xs:annotation>
          <xs:documentation>IbisJavaErrorSender - nl.nn.adapterframework.senders.IbisJavaSender used as ErrorSender

Posts a message to another IBIS-adapter or application in the same JVM using IbisServiceDispatcher.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IbisJavaSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.IbisJavaSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IbisLocalErrorSender">
        <xs:annotation>
          <xs:documentation>IbisLocalErrorSender - nl.nn.adapterframework.senders.IbisLocalSender used as ErrorSender

Posts a message to another IBIS-adapter in the same IBIS instance.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IbisLocalSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.IbisLocalSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IbisWebServiceErrorSender">
        <xs:annotation>
          <xs:documentation>IbisWebServiceErrorSender - nl.nn.adapterframework.http.IbisWebServiceSender used as ErrorSender

Posts a message to another IBIS-adapter as a WebService.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IbisWebServiceSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.IbisWebServiceSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ImapErrorSender">
        <xs:annotation>
          <xs:documentation>ImapErrorSender - nl.nn.adapterframework.senders.ImapSender used as ErrorSender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ImapSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.ImapSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JavascriptErrorSender">
        <xs:annotation>
          <xs:documentation>JavascriptErrorSender - nl.nn.adapterframework.senders.JavascriptSender used as ErrorSender

Sender used to run javascript code using J2V8 or Rhino</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JavascriptSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.JavascriptSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JmsErrorSender">
        <xs:annotation>
          <xs:documentation>JmsErrorSender - nl.nn.adapterframework.jms.JmsSender used as ErrorSender

This class sends messages with JMS.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JmsSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jms.JmsSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JsonXsltErrorSender">
        <xs:annotation>
          <xs:documentation>JsonXsltErrorSender - nl.nn.adapterframework.senders.JsonXsltSender used as ErrorSender

Perform an XSLT transformation with a specified stylesheet on a JSON input, yielding JSON, yielding JSON, XML or text.
 JSON input is transformed into XML map, array, string, integer and boolean elements, in the namespace http://www.w3.org/2013/XSL/json.
 The XSLT stylesheet or XPathExpression operates on these element.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JsonXsltSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.JsonXsltSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LdapErrorSender">
        <xs:annotation>
          <xs:documentation>LdapErrorSender - nl.nn.adapterframework.ldap.LdapSender used as ErrorSender

Sender to obtain information from and write to an LDAP Directory.
 Returns the set of attributes in an XML format. Examples are shown below.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LdapSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.ldap.LdapSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LocalFileSystemErrorSender">
        <xs:annotation>
          <xs:documentation>LocalFileSystemErrorSender - nl.nn.adapterframework.senders.LocalFileSystemSender used as ErrorSender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LocalFileSystemSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.LocalFileSystemSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LogErrorSender">
        <xs:annotation>
          <xs:documentation>LogErrorSender - nl.nn.adapterframework.senders.LogSender used as ErrorSender

Sender that just logs its message.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LogSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.LogSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MailErrorSender">
        <xs:annotation>
          <xs:documentation>MailErrorSender - nl.nn.adapterframework.senders.MailSender used as ErrorSender

{@link nl.nn.adapterframework.core.ISender sender} that sends a mail specified by an XML message.
 &lt;p&gt;
 Sample email.xml:
 &lt;code&gt;&lt;pre&gt;
    &amp;lt;email&amp;gt;
       &amp;lt;recipients&amp;gt;
          &amp;lt;recipient type="to"&amp;gt;***@hotmail.com&amp;lt;/recipient&amp;gt;
          &amp;lt;recipient type="cc"&amp;gt;***@gmail.com&amp;lt;/recipient&amp;gt;
       &amp;lt;/recipients&amp;gt;
       &amp;lt;from name="*** ***"&amp;gt;***@yahoo.com&amp;lt;/from&amp;gt;
       &amp;lt;subject&amp;gt;This is the subject&amp;lt;/subject&amp;gt;
       &amp;lt;threadTopic&amp;gt;subject&amp;lt;/threadTopic&amp;gt;
       &amp;lt;message&amp;gt;This is the message&amp;lt;/message&amp;gt;
       &amp;lt;messageType&amp;gt;text/plain&amp;lt;/messageType&amp;gt;&amp;lt;!-- Optional --&amp;gt;
       &amp;lt;messageBase64&amp;gt;false&amp;lt;/messageBase64&amp;gt;&amp;lt;!-- Optional --&amp;gt;
       &amp;lt;charset&amp;gt;UTF-8&amp;lt;/charset&amp;gt;&amp;lt;!-- Optional --&amp;gt;
       &amp;lt;attachments&amp;gt;
          &amp;lt;attachment name="filename1.txt"&amp;gt;This is the first attachment&amp;lt;/attachment&amp;gt;
          &amp;lt;attachment name="filename2.pdf" base64="true"&amp;gt;JVBERi0xLjQKCjIgMCBvYmoKPDwvVHlwZS9YT2JqZWN0L1N1YnR5cGUvSW1...vSW5mbyA5IDAgUgo+PgpzdGFydHhyZWYKMzQxNDY2CiUlRU9GCg==&amp;lt;/attachment&amp;gt;
          &amp;lt;attachment name="filename3.pdf" url="file:/c:/filename3.pdf"/&amp;gt;
          &amp;lt;attachment name="filename4.pdf" sessionKey="fileContent"/&amp;gt;
       &amp;lt;/attachments&amp;gt;&amp;lt;!-- Optional --&amp;gt;
   &amp;lt;/email&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;
 &lt;p&gt;
 Notice: the XML message must be valid XML. Therefore, especially the message element
 must be plain text or be wrapped as CDATA. Example:
 &lt;code&gt;&lt;pre&gt;
    &amp;lt;message&amp;gt;&amp;lt;![CDATA[&amp;lt;h1&amp;gt;This is a HtmlMessage&amp;lt;/h1&amp;gt;]]&amp;gt;&amp;lt;/message&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;
 &lt;p&gt;
 The &lt;code&gt;sessionKey&lt;/code&gt; attribute for attachment can contain an inputstream or a string. Other types are not supported at this moment.
 &lt;p&gt;
 The attribute order for attachments is as follows:
 &lt;ol&gt;
    &lt;li&gt;sessionKey&lt;/li&gt;
    &lt;li&gt;url&lt;/li&gt;
    &lt;li&gt;&lt;i&gt;value of the attachment element&lt;/i&gt;&lt;/li&gt;
 &lt;/ol&gt;
 &lt;p&gt;
 The &lt;code&gt;base64&lt;/code&gt; attribute is only used when the value of the PipeLineSession variable &lt;code&gt;sessionKey&lt;/code&gt; is a String object
 or when the value of the attachment element is used. If &lt;code&gt;base64=true&lt;/code&gt; then the value will be decoded before it's used.
 &lt;p&gt;
 &lt;b&gt;Configuration:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setSmtpHost(String) smtpHost}&lt;/td&gt;&lt;td&gt;name of the host by which the messages are to be send&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setAuthAlias(String) smtpAuthAlias}&lt;/td&gt;&lt;td&gt;alias used to obtain credentials for authentication to smtpHost&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setUserId(String) userId}&lt;/td&gt;&lt;td&gt;userId on the smtpHost&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setPassword(String) password}&lt;/td&gt;&lt;td&gt;password of userId on the smtpHost&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setSmtpAuthAlias(String) smtpAuthAlias}&lt;/td&gt;&lt;td&gt;alias used to obtain credentials for authentication to smtpHost&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setSmtpUserid(String) userId}&lt;/td&gt;&lt;td&gt;userId on the smtpHost&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setSmtpPassword(String) password}&lt;/td&gt;&lt;td&gt;password of userId on the smtpHost&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setDefaultFrom(String) defaultFrom}&lt;/td&gt;&lt;td&gt;value of the From: header if not specified in message itself&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setDefaultSubject(String) defaultSubject}&lt;/td&gt;&lt;td&gt;value of the Subject: header if not specified in message itself&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setDefaultAttachmentName(String) defaultAttachmentName}&lt;/td&gt;&lt;td&gt;When this name is used, it will be followed by a number which is equal to the node's position&lt;/td&gt;&lt;td&gt;attachment&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setTimeout(int) timeout}&lt;/td&gt;&lt;td&gt;timeout (in milliseconds). Used for socket connection timeout and socket I/O timeout&lt;/td&gt;&lt;td&gt;20000&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;p&gt;
 &lt;table border="1"&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;type&lt;/th&gt;&lt;th&gt;remarks&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;from&lt;/td&gt;&lt;td&gt;string&lt;/td&gt;&lt;td&gt;email address of the sender&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;subject&lt;/td&gt;&lt;td&gt;string&lt;/td&gt;&lt;td&gt;subject field of the message&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;threadTopic&lt;/td&gt;&lt;td&gt;string&lt;/td&gt;&lt;td&gt;(optional) conversation field of the message, used to correlate mails in mail viewer (header field "Thread-Topic"). Note: subject must end with value of threadTopic, but cann't be exactly the same&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;message&lt;/td&gt;&lt;td&gt;string&lt;/td&gt;&lt;td&gt;message itself. If absent, the complete input message is assumed to be the message&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;messageType&lt;/td&gt;&lt;td&gt;string&lt;/td&gt;&lt;td&gt;message MIME type (at this moment only available are text/plain and text/html - default: text/plain)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;messageBase64&lt;/td&gt;&lt;td&gt;boolean&lt;/td&gt;&lt;td&gt;indicates whether the message content is base64 encoded (default: false)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;charSet&lt;/td&gt;&lt;td&gt;string&lt;/td&gt;&lt;td&gt;the character encoding (e.g. ISO-8859-1 or UTF-8) used to send the email (default: UTF-8)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;recipients&lt;/td&gt;&lt;td&gt;xml&lt;/td&gt;&lt;td&gt;recipients of the message. must result in a structure like: &lt;code&gt;&lt;pre&gt;
       &amp;lt;recipient type="to"&amp;gt;***@hotmail.com&amp;lt;/recipient&amp;gt;
       &amp;lt;recipient type="cc"&amp;gt;***@gmail.com&amp;lt;/recipient&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;attachments&lt;/td&gt;&lt;td&gt;xml&lt;/td&gt;&lt;td&gt;attachments to the message. must result in a structure like: &lt;code&gt;&lt;pre&gt;
       &amp;lt;attachment name="filename1.txt"&amp;gt;This is the first attachment&amp;lt;/attachment&amp;gt;
       &amp;lt;attachment name="filename2.pdf" base64="true"&amp;gt;JVBERi0xLjQKCjIgMCBvYmoKPDwvVHlwZS9YT2JqZWN0L1N1YnR5cGUvSW1...vSW5mbyA5IDAgUgo+PgpzdGFydHhyZWYKMzQxNDY2CiUlRU9GCg==&amp;lt;/attachment&amp;gt;
       &amp;lt;attachment name="filename3.pdf" url="file:/c:/filename3.pdf"/&amp;gt;
       &amp;lt;attachment name="filename4.pdf" sessionKey="fileContent"/&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;p&gt;
 &lt;b&gt;Compilation and Deployment Note:&lt;/b&gt; mail.jar (v1.2) and activation.jar must appear BEFORE j2ee.jar.
 Otherwise errors like the following might occur: &lt;code&gt;NoClassDefFoundException: com/sun/mail/util/MailDateFormat&lt;/code&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MailSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.MailSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MessageStoreErrorSender">
        <xs:annotation>
          <xs:documentation>MessageStoreErrorSender - nl.nn.adapterframework.jdbc.MessageStoreSender used as ErrorSender

Send messages to the ibisstore to have them processed exactly-once by another
 adapter which will read the messages using a {@link MessageStoreListener}.
 This other adapter will process the messages asynchronously and (optionally)
 under transaction control. Duplicate messages are ignored based on the
 messageId (except when onlyStoreWhenMessageIdUnique is set to false), hence
 the sender of the message can retry sending the message until a valid reply
 is received in which case it can be certain that the message is stored in the
 ibisstore.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MessageStoreSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.MessageStoreSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MongoDbErrorSender">
        <xs:annotation>
          <xs:documentation>MongoDbErrorSender - nl.nn.adapterframework.mongodb.MongoDbSender used as ErrorSender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MongoDbSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.mongodb.MongoDbSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MqttErrorSender">
        <xs:annotation>
          <xs:documentation>MqttErrorSender - nl.nn.adapterframework.extensions.mqtt.MqttSender used as ErrorSender

MQTT listener which will connect to a broker and subscribe to a topic.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MqttSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.mqtt.MqttSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MultipartHttpErrorSender">
        <xs:annotation>
          <xs:documentation>MultipartHttpErrorSender - nl.nn.adapterframework.http.MultipartHttpSender used as ErrorSender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MultipartHttpSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.MultipartHttpSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ParallelSendersErrorSender">
        <xs:annotation>
          <xs:documentation>ParallelSendersErrorSender - nl.nn.adapterframework.senders.ParallelSenders used as ErrorSender

Collection of Senders, that are executed all at the same time.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ParallelSendersType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.ParallelSenders" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ReloadErrorSender">
        <xs:annotation>
          <xs:documentation>ReloadErrorSender - nl.nn.adapterframework.senders.ReloadSender used as ErrorSender

Performs a reload on database config .</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ReloadSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.ReloadSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="RestErrorSender">
        <xs:annotation>
          <xs:documentation>RestErrorSender - nl.nn.adapterframework.http.RestSender used as ErrorSender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RestSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.RestSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ResultSet2FileErrorSender">
        <xs:annotation>
          <xs:documentation>ResultSet2FileErrorSender - nl.nn.adapterframework.jdbc.ResultSet2FileSender used as ErrorSender

QuerySender that writes each row in a ResultSet to a file.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ResultSet2FileSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.ResultSet2FileSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Samba1ErrorSender">
        <xs:annotation>
          <xs:documentation>Samba1ErrorSender - nl.nn.adapterframework.senders.Samba1Sender used as ErrorSender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Samba1SenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.Samba1Sender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Samba2ErrorSender">
        <xs:annotation>
          <xs:documentation>Samba2ErrorSender - nl.nn.adapterframework.senders.Samba2Sender used as ErrorSender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Samba2SenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.Samba2Sender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SambaErrorSender">
        <xs:annotation>
          <xs:documentation>SambaErrorSender - nl.nn.adapterframework.senders.SambaSender used as ErrorSender</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SambaSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.SambaSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SambaSenderOldErrorSender">
        <xs:annotation>
          <xs:documentation>SambaSenderOldErrorSender - nl.nn.adapterframework.senders.SambaSenderOld used as ErrorSender

Samba Sender: The standard Windows interoperability suite for Linux and Unix.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SambaSenderOldType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.SambaSenderOld" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SchedulerErrorSender">
        <xs:annotation>
          <xs:documentation>SchedulerErrorSender - nl.nn.adapterframework.scheduler.SchedulerSender used as ErrorSender

Registers a trigger in the scheduler so that the message is send to a javalistener
 at a scheduled time.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SchedulerSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.scheduler.SchedulerSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SendGridErrorSender">
        <xs:annotation>
          <xs:documentation>SendGridErrorSender - nl.nn.adapterframework.senders.SendGridSender used as ErrorSender

Sender that sends a mail via SendGrid v3 (cloud-based SMTP provider).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SendGridSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.SendGridSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SenderSeriesErrorSender">
        <xs:annotation>
          <xs:documentation>SenderSeriesErrorSender - nl.nn.adapterframework.senders.SenderSeries used as ErrorSender

Series of Senders, that are executed one after another.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SenderSeriesType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.SenderSeries" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SenderWrapperErrorSender">
        <xs:annotation>
          <xs:documentation>SenderWrapperErrorSender - nl.nn.adapterframework.senders.SenderWrapper used as ErrorSender

Wrapper for senders, that allows to get input from a session variable, and to store output in a session variable.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SenderWrapperType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.SenderWrapper" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ShadowErrorSender">
        <xs:annotation>
          <xs:documentation>ShadowErrorSender - nl.nn.adapterframework.senders.ShadowSender used as ErrorSender

Collection of Senders, that are executed all at the same time. Once the results are processed, all results will be sent to the resultSender, while the original sender will return it's result to the pipeline.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ShadowSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.ShadowSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="WebServiceNtlmErrorSender">
        <xs:annotation>
          <xs:documentation>WebServiceNtlmErrorSender - nl.nn.adapterframework.http.WebServiceNtlmSender used as ErrorSender

Sender that sends a message via a WebService based on NTLM authentication.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="WebServiceNtlmSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.WebServiceNtlmSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="WebServiceErrorSender">
        <xs:annotation>
          <xs:documentation>WebServiceErrorSender - nl.nn.adapterframework.http.WebServiceSender used as ErrorSender

Sender that sends a message via a WebService.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="WebServiceSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.WebServiceSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XComErrorSender">
        <xs:annotation>
          <xs:documentation>XComErrorSender - nl.nn.adapterframework.xcom.XComSender used as ErrorSender

XCom client voor het versturen van files via XCom.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XComSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.xcom.XComSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XfbErrorSender">
        <xs:annotation>
          <xs:documentation>XfbErrorSender - nl.nn.adapterframework.extensions.xfb.XfbSender used as ErrorSender

Sender for transferring files using the XFB protocol. Assumes sender input is local filename.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XfbSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.xfb.XfbSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlJmsBrowserErrorSender">
        <xs:annotation>
          <xs:documentation>XmlJmsBrowserErrorSender - nl.nn.adapterframework.jms.XmlJmsBrowserSender used as ErrorSender

Sender for browsing and removing queue messages (with input and output in a XML message).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlJmsBrowserSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jms.XmlJmsBrowserSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlQueryErrorSender">
        <xs:annotation>
          <xs:documentation>XmlQueryErrorSender - nl.nn.adapterframework.jdbc.XmlQuerySender used as ErrorSender

QuerySender that transforms the input message to a query.
 &lt;br/&gt;&lt;code&gt;&lt;pre&gt;
  select
  delete
  insert
  update - tableName
         - columns [0..1] - column [1..n] - name
                                          - value [0..1]
                                          - type [0..1] one of {string;function;number;datetime;blob;clob;xmldatetime}, string by default
                                          - decimalSeparator [0..1] only applicable for type=number
                                          - groupingSeparator [0..1] only applicable for type=number
                                          - formatString [0..1] only applicable for type=datetime, yyyy-MM-dd HH:mm:ss.SSS by default 
         - where [0..1]
         - order [0..1]
 &lt;br/&gt;
  alter - sequenceName
        - startWith
 &lt;br/&gt;
  sql   - type [0..1] one of {select;ddl;other}, other by default
        - query
 &lt;br/&gt;
 &lt;/pre&gt;&lt;/code&gt;&lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlQuerySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.XmlQuerySender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlValidatorErrorSender">
        <xs:annotation>
          <xs:documentation>XmlValidatorErrorSender - nl.nn.adapterframework.senders.XmlValidatorSender used as ErrorSender

&lt;code&gt;Sender&lt;/code&gt; that validates the input message against a XML-Schema.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlValidatorSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.XmlValidatorSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XsltErrorSender">
        <xs:annotation>
          <xs:documentation>XsltErrorSender - nl.nn.adapterframework.senders.XsltSender used as ErrorSender

Perform an XSLT transformation with a specified stylesheet or XPath-expression.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XsltSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.senders.XsltSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ZipWriterErrorSender">
        <xs:annotation>
          <xs:documentation>ZipWriterErrorSender - nl.nn.adapterframework.compression.ZipWriterSender used as ErrorSender

Sender that writes an entry to a ZipStream, similar to ZipWriterPipe with action='write'.
 Filename and contents are taken from parameters. If one of the parameters is not present, the input message 
 is used for either filename or contents.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ZipWriterSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.compression.ZipWriterSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="ErrorStorageElementGroup">
    <xs:choice>
      <xs:element name="ErrorStorage">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element ref="Param" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="errorStorage" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ErrorStorageElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ErrorStorageElementGroupBase">
    <xs:choice>
      <xs:element name="DummyErrorStorage">
        <xs:annotation>
          <xs:documentation>DummyErrorStorage - nl.nn.adapterframework.jdbc.DummyTransactionalStorage used as ErrorStorage

Class for a messageLog element to be used in combination with a
 {@link MessageStoreSender} who's messaged are processed by a
 {@link MessageStoreListener}.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DummyTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorStorage" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.DummyTransactionalStorage" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbJmsErrorStorage">
        <xs:annotation>
          <xs:documentation>EsbJmsErrorStorage - nl.nn.adapterframework.extensions.esb.EsbJmsTransactionalStorage used as ErrorStorage

ESB (Enterprise Service Bus) extension of JmsTransactionalStorage.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbJmsTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorStorage" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.esb.EsbJmsTransactionalStorage" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JdbcErrorStorage">
        <xs:annotation>
          <xs:documentation>JdbcErrorStorage - nl.nn.adapterframework.jdbc.JdbcTransactionalStorage used as ErrorStorage

JDBC implementation of {@link ITransactionalStorage}.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JdbcTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorStorage" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.JdbcTransactionalStorage" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JmsErrorStorage">
        <xs:annotation>
          <xs:documentation>JmsErrorStorage - nl.nn.adapterframework.jms.JmsTransactionalStorage used as ErrorStorage

JMS implementation of &lt;code&gt;ITransactionalStorage&lt;/code&gt;.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JmsTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorStorage" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jms.JmsTransactionalStorage" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MessageStoreSenderErrorStorage">
        <xs:annotation>
          <xs:documentation>MessageStoreSenderErrorStorage - nl.nn.adapterframework.jdbc.MessageStoreSender used as ErrorStorage

Send messages to the ibisstore to have them processed exactly-once by another
 adapter which will read the messages using a {@link MessageStoreListener}.
 This other adapter will process the messages asynchronously and (optionally)
 under transaction control. Duplicate messages are ignored based on the
 messageId (except when onlyStoreWhenMessageIdUnique is set to false), hence
 the sender of the message can retry sending the message until a valid reply
 is received in which case it can be certain that the message is stored in the
 ibisstore.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MessageStoreSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorStorage" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.MessageStoreSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="DummyTransactionalStorageType">
    <xs:attributeGroup ref="JdbcTransactionalStorageCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="EsbJmsTransactionalStorageType">
    <xs:attributeGroup ref="JmsTransactionalStorageCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="JmsTransactionalStorageType">
    <xs:attributeGroup ref="JmsTransactionalStorageCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="JmsTransactionalStorageDeclaredAttributeGroup">
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional identifier for this storage, to be able to share the physical storage between a number of receivers and pipes</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>Possible values are E (error store), M (message store), L (message log for pipe) or A (message log for receiver). Receiver will always set type to E for errorStorage and always set type to A for messageLog. SenderPipe will set type to L for messageLog (when type isn't specified). See {@link MessagestoreSender} for type M Default: E for errorstorage on receiver, A for messageLog on receiver and L for messageLog on Pipe</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:boolean" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JmsTransactionalStorageCumulativeAttributeGroup">
    <xs:attributeGroup ref="JmsTransactionalStorageDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JmsMessageBrowserCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JmsMessageBrowserDeclaredAttributeGroup">
    <xs:attribute name="hideMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Only used when hideRegex is not empty) either &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;firstHalf&lt;/code&gt;. When &lt;code&gt;firstHalf&lt;/code&gt; only the first half of the string is masked, otherwise (&lt;code&gt;all&lt;/code&gt;) the entire string is masked Default: all</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>Regular expression to mask strings in the errorStore/logStore. Every character between to the strings in this expression will be replaced by a '*'. For example, the regular expression (?&amp;lt;=&amp;lt;party&amp;gt;).*?(?=&amp;lt;/party&amp;gt;) will replace every character between keys&lt;party&gt; and &lt;/party&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOut" type="xs:integer">
      <xs:annotation>
        <xs:documentation>timeout for receiving a message from the queue Default: 3000 ms</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JmsMessageBrowserCumulativeAttributeGroup">
    <xs:attributeGroup ref="JmsMessageBrowserDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JMSFacadeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="MessageLogElementGroup">
    <xs:choice>
      <xs:element name="MessageLog">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element ref="Param" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="messageLog" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="MessageLogElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="MessageLogElementGroupBase">
    <xs:choice>
      <xs:element name="DummyMessageLog">
        <xs:annotation>
          <xs:documentation>DummyMessageLog - nl.nn.adapterframework.jdbc.DummyTransactionalStorage used as MessageLog

Class for a messageLog element to be used in combination with a
 {@link MessageStoreSender} who's messaged are processed by a
 {@link MessageStoreListener}.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DummyTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="messageLog" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.DummyTransactionalStorage" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbJmsMessageLog">
        <xs:annotation>
          <xs:documentation>EsbJmsMessageLog - nl.nn.adapterframework.extensions.esb.EsbJmsTransactionalStorage used as MessageLog

ESB (Enterprise Service Bus) extension of JmsTransactionalStorage.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbJmsTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="messageLog" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.esb.EsbJmsTransactionalStorage" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JdbcMessageLog">
        <xs:annotation>
          <xs:documentation>JdbcMessageLog - nl.nn.adapterframework.jdbc.JdbcTransactionalStorage used as MessageLog

JDBC implementation of {@link ITransactionalStorage}.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JdbcTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="messageLog" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.JdbcTransactionalStorage" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JmsMessageLog">
        <xs:annotation>
          <xs:documentation>JmsMessageLog - nl.nn.adapterframework.jms.JmsTransactionalStorage used as MessageLog

JMS implementation of &lt;code&gt;ITransactionalStorage&lt;/code&gt;.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JmsTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="messageLog" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jms.JmsTransactionalStorage" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MessageStoreSenderMessageLog">
        <xs:annotation>
          <xs:documentation>MessageStoreSenderMessageLog - nl.nn.adapterframework.jdbc.MessageStoreSender used as MessageLog

Send messages to the ibisstore to have them processed exactly-once by another
 adapter which will read the messages using a {@link MessageStoreListener}.
 This other adapter will process the messages asynchronously and (optionally)
 under transaction control. Duplicate messages are ignored based on the
 messageId (except when onlyStoreWhenMessageIdUnique is set to false), hence
 the sender of the message can retry sending the message until a valid reply
 is received in which case it can be certain that the message is stored in the
 ibisstore.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MessageStoreSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="messageLog" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.MessageStoreSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="InProcessStorageElementGroup">
    <xs:choice>
      <xs:element name="InProcessStorage">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element ref="Param" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="inProcessStorage" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="InProcessStorageElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="InProcessStorageElementGroupBase">
    <xs:choice>
      <xs:element name="DummyInProcessStorage">
        <xs:annotation>
          <xs:documentation>DummyInProcessStorage - nl.nn.adapterframework.jdbc.DummyTransactionalStorage used as InProcessStorage

Class for a messageLog element to be used in combination with a
 {@link MessageStoreSender} who's messaged are processed by a
 {@link MessageStoreListener}.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DummyTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inProcessStorage" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.DummyTransactionalStorage" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbJmsInProcessStorage">
        <xs:annotation>
          <xs:documentation>EsbJmsInProcessStorage - nl.nn.adapterframework.extensions.esb.EsbJmsTransactionalStorage used as InProcessStorage

ESB (Enterprise Service Bus) extension of JmsTransactionalStorage.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbJmsTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inProcessStorage" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.esb.EsbJmsTransactionalStorage" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JdbcInProcessStorage">
        <xs:annotation>
          <xs:documentation>JdbcInProcessStorage - nl.nn.adapterframework.jdbc.JdbcTransactionalStorage used as InProcessStorage

JDBC implementation of {@link ITransactionalStorage}.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JdbcTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inProcessStorage" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.JdbcTransactionalStorage" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JmsInProcessStorage">
        <xs:annotation>
          <xs:documentation>JmsInProcessStorage - nl.nn.adapterframework.jms.JmsTransactionalStorage used as InProcessStorage

JMS implementation of &lt;code&gt;ITransactionalStorage&lt;/code&gt;.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JmsTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inProcessStorage" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jms.JmsTransactionalStorage" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MessageStoreSenderInProcessStorage">
        <xs:annotation>
          <xs:documentation>MessageStoreSenderInProcessStorage - nl.nn.adapterframework.jdbc.MessageStoreSender used as InProcessStorage

Send messages to the ibisstore to have them processed exactly-once by another
 adapter which will read the messages using a {@link MessageStoreListener}.
 This other adapter will process the messages asynchronously and (optionally)
 under transaction control. Duplicate messages are ignored based on the
 messageId (except when onlyStoreWhenMessageIdUnique is set to false), hence
 the sender of the message can retry sending the message until a valid reply
 is received in which case it can be certain that the message is stored in the
 ibisstore.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MessageStoreSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inProcessStorage" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.MessageStoreSender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:simpleType name="OnErrorAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="CONTINUE" />
      <xs:enumeration value="RECOVER" />
      <xs:enumeration value="CLOSE" />
    </xs:restriction>
  </xs:simpleType>
  <xs:group name="ErrorMessageFormatterElementGroup">
    <xs:choice>
      <xs:element name="ErrorMessageFormatter">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element ref="Param" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="errorMessageFormatter" />
          <xs:attribute name="className" type="xs:string" default="nl.nn.adapterframework.errormessageformatters.ErrorMessageFormatter" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ErrorMessageFormatterElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ErrorMessageFormatterElementGroupBase">
    <xs:choice>
      <xs:element name="FixedErrorMessageErrorMessageFormatter">
        <xs:annotation>
          <xs:documentation>FixedErrorMessageErrorMessageFormatter - nl.nn.adapterframework.errormessageformatters.FixedErrorMessage used as ErrorMessageFormatter

ErrorMessageFormatter that returns a fixed message with replacements.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FixedErrorMessageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorMessageFormatter" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.errormessageformatters.FixedErrorMessage" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SoapErrorMessageErrorMessageFormatter">
        <xs:annotation>
          <xs:documentation>SoapErrorMessageErrorMessageFormatter - nl.nn.adapterframework.errormessageformatters.SoapErrorMessage used as ErrorMessageFormatter

ErrorMessageFormatter that returns a soap fault message.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SoapErrorMessageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorMessageFormatter" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.errormessageformatters.SoapErrorMessage" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XslErrorMessageFormatter">
        <xs:annotation>
          <xs:documentation>XslErrorMessageFormatter - nl.nn.adapterframework.errormessageformatters.XslErrorMessageFormatter used as ErrorMessageFormatter

Applies a XSLT-stylesheet to the standard error generated by
 {@link ErrorMessageFormatter}.
 &lt;p&gt;If the transformation does not succeed, this standard error message
 is returned and an exception is logged.
 &lt;p&gt;&lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;nested elements&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link Parameter param}&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XslErrorMessageFormatterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorMessageFormatter" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.errormessageformatters.XslErrorMessageFormatter" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Y01ErrorMessageFormatter">
        <xs:annotation>
          <xs:documentation>Y01ErrorMessageFormatter - nl.nn.adapterframework.errormessageformatters.Y01ErrorMessageFormatter used as ErrorMessageFormatter

ErrorMessageFormatter for JUICE, introduced with the Y01-project.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Y01ErrorMessageFormatterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorMessageFormatter" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.errormessageformatters.Y01ErrorMessageFormatter" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="FixedErrorMessageType">
    <xs:attributeGroup ref="FixedErrorMessageDeclaredAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FixedErrorMessageDeclaredAttributeGroup">
    <xs:attribute name="fileName" type="xs:string" />
    <xs:attribute name="filename" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the file containing the resultmessage</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceFrom" type="xs:string" />
    <xs:attribute name="replaceTo" type="xs:string" />
    <xs:attribute name="returnString" type="xs:string">
      <xs:annotation>
        <xs:documentation>returned message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string" />
  </xs:attributeGroup>
  <xs:complexType name="SoapErrorMessageType" />
  <xs:complexType name="XslErrorMessageFormatterType">
    <xs:group ref="XslErrorMessageFormatterDeclaredChildGroup" />
    <xs:attributeGroup ref="XslErrorMessageFormatterDeclaredAttributeGroup" />
  </xs:complexType>
  <xs:group name="XslErrorMessageFormatterDeclaredChildGroup">
    <xs:sequence>
      <xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="XslErrorMessageFormatterDeclaredAttributeGroup">
    <xs:attribute name="styleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to use for transformation</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpathexpression to use for transformation</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:complexType name="Y01ErrorMessageFormatterType" />
  <xs:group name="InputValidatorElementGroup">
    <xs:choice>
      <xs:element name="InputValidator">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element ref="Forward" />
              <xs:element ref="Locker" />
              <xs:element ref="Param" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="InputValidatorElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="InputValidatorElementGroupBase">
    <xs:choice>
      <xs:element name="ApiWsdlXmlInputValidator">
        <xs:annotation>
          <xs:documentation>ApiWsdlXmlInputValidator - nl.nn.adapterframework.extensions.api.ApiWsdlXmlValidator used as InputValidator

Extension to WsdlXmlValidator for API Management.
 &lt;p&gt;
 &lt;b&gt;Configuration &lt;/b&gt;&lt;i&gt;(where deviating from WsdlXmlValidator)&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setMultipart(boolean) boolean}&lt;/td&gt;&lt;td&gt;indicates whether the message is multipart/form-data. If so, the wsdl only represents the first part, other parts are attachments. This attribute is only used for generating the 'real' wsdl which is available in the ibis console (../rest/webservices)&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;p&gt;
 The SOAP header can only contain the following schema (or it's empty):
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;mandatory&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;xmlns="http://api.nn.nl/MessageHeader"&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;no&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ApiWsdlXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.api.ApiWsdlXmlValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbSoapInputValidator">
        <xs:annotation>
          <xs:documentation>EsbSoapInputValidator - nl.nn.adapterframework.extensions.esb.EsbSoapValidator used as InputValidator

XmlValidator that will automatically add the SOAP envelope XSD and the ESB
 XSD (e.g. CommonMessageHeader.xsd) to the set of XSD's used for validation.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbSoapValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.esb.EsbSoapValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FxfXmlInputValidator">
        <xs:annotation>
          <xs:documentation>FxfXmlInputValidator - nl.nn.adapterframework.extensions.fxf.FxfXmlValidator used as InputValidator

FxF XML validator to be used with FxF3. When receiving files
 (direction=receive) the message is validated against the
 OnCompletedTransferNotify WSDL (a P2P connection, hence same WSDL (provided
 by Tibco) for all queues (every Ibis receiving FxF files has it's own
 queue)). When sending files (direction=send) the message is validated against
 the StartTransfer WSDL (ESB service provided by Tibco).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FxfXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.fxf.FxfXmlValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Json2XmlInputValidator">
        <xs:annotation>
          <xs:documentation>Json2XmlInputValidator - nl.nn.adapterframework.pipes.Json2XmlValidator used as InputValidator

&lt;code&gt;Pipe&lt;/code&gt; that validates the XML or JSON input message against a XML-Schema and returns either XML or JSON.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Json2XmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.Json2XmlValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SoapInputValidator">
        <xs:annotation>
          <xs:documentation>SoapInputValidator - nl.nn.adapterframework.soap.SoapValidator used as InputValidator

XmlValidator that will automatically add the SOAP envelope XSD to the set of
 XSD's used for validation.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SoapValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.soap.SoapValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="WsdlXmlInputValidator">
        <xs:annotation>
          <xs:documentation>WsdlXmlInputValidator - nl.nn.adapterframework.pipes.WsdlXmlValidator used as InputValidator

XmlValidator that will read the XSD's to use from a WSDL. As it extends the
 SoapValidator is will also add the SOAP envelope XSD.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="WsdlXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.WsdlXmlValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlInputValidator">
        <xs:annotation>
          <xs:documentation>XmlInputValidator - nl.nn.adapterframework.pipes.XmlValidator used as InputValidator

&lt;code&gt;Pipe&lt;/code&gt; that validates the input message against a XML-Schema.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.XmlValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlWellFormedCheckerInputValidator">
        <xs:annotation>
          <xs:documentation>XmlWellFormedCheckerInputValidator - nl.nn.adapterframework.pipes.XmlWellFormedChecker used as InputValidator

&lt;code&gt;Pipe&lt;/code&gt; that checks the well-formedness of the input message.
 If &lt;code&gt;root&lt;/code&gt; is given then this is also checked.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlWellFormedCheckerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.XmlWellFormedChecker" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="ApiWsdlXmlValidatorType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="ApiWsdlXmlValidatorCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ApiWsdlXmlValidatorDeclaredAttributeGroup">
    <xs:attribute name="multipart" type="xs:boolean" />
  </xs:attributeGroup>
  <xs:attributeGroup name="ApiWsdlXmlValidatorCumulativeAttributeGroup">
    <xs:attributeGroup ref="ApiWsdlXmlValidatorDeclaredAttributeGroup" />
    <xs:attributeGroup ref="WsdlXmlValidatorCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="AbstractPipeDeclaredChildGroup">
    <xs:sequence>
      <xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
      <xs:element ref="Locker" minOccurs="0" maxOccurs="1" />
      <xs:element ref="Forward" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="AbstractPipeDeclaredAttributeGroup">
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, input is taken from this session key, instead of regular input</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the pipe</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, this fixed value is taken as input, instead of regular input</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set and the input is empty, this fixed value is taken as input</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the result of the pipe is replaced with the original input (i.e. the input before configured replacements of &lt;code&gt;getInputFromSessionKey&lt;/code&gt;, &lt;code&gt;getInputFromFixedValue&lt;/code&gt; or &lt;code&gt;emptyInputReplacement&lt;/code&gt;) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the result (before replacing when &lt;code&gt;true&lt;/code&gt;) is stored under this session key</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementToMoveSessionKey&lt;/code&gt; + }</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Only used when &lt;code&gt;elementToMove&lt;/code&gt; is set) Name of the session key under which the character data is stored Default: ref_ + the name of the element</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>Like &lt;code&gt;elementToMove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe')</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:integer">
      <xs:annotation>
        <xs:documentation>If durationThreshold &gt;=0 and the duration of the message processing exceeded the value specified (in milliseconds) the message is logged informatory Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>Regular expression to mask strings in the log. For example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:integer">
      <xs:annotation>
        <xs:documentation>maximum number of threads that may call {@link #doPipe(java.lang.Object, nl.nn.adapterframework.core.PipeLineSession)} simultaneously Default: 0 (unlimited)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes Default: application default</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:boolean" />
    <xs:attribute name="restoreMovedElements" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, compacted messages in the result are restored to their original format (see also  {@link #setElementToMove(java.lang.String)}) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default: (Only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) Comma separated list of keys of session variables that is appended to the security log record</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sizeStatistics" type="xs:boolean" />
    <xs:attribute name="writeToSecLog" type="xs:boolean" />
  </xs:attributeGroup>
  <xs:attributeGroup name="AbstractPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="AbstractPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="TransactionAttributesDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="TransactionAttributesType">
    <xs:attributeGroup ref="TransactionAttributesDeclaredAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="TransactionAttributesDeclaredAttributeGroup">
    <xs:attribute name="transactionAttribute" type="xs:string">
      <xs:annotation>
        <xs:documentation>The &lt;code&gt;transactionAttribute&lt;/code&gt; declares transactional behavior of execution. It applies both to database transactions and XA transactions.The pipeline uses this to start a new transaction or suspend the current one when required. For developers: it is equalto &lt;a href="https://docs.oracle.com/javaee/7/tutorial/transactions003.htm"&gt;EJB transaction attribute&lt;/a&gt;. Possible values for transactionAttribute:  &lt;table border="1"&gt;    &lt;tr&gt;&lt;th&gt;transactionAttribute&lt;/th&gt;&lt;th&gt;callers Transaction&lt;/th&gt;&lt;th&gt;Pipeline excecuted in Transaction&lt;/th&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Required&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;RequiresNew&lt;/td&gt; &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Mandatory&lt;/td&gt;   &lt;td&gt;none&lt;/td&gt;&lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;NotSupported&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Supports&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt; 										      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td colspan="1" rowspan="2"&gt;Never&lt;/td&gt;       &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;  &lt;/table&gt; Default: Supports</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttributeNum" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Like &lt;code&gt;transactionAttribute&lt;/code&gt;, but the chosen option is represented with a number. The numbers mean:&lt;table&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Supports&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;Mandatory&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;RequiresNew&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;NotSupported&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;Never&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionTimeout" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Timeout (in seconds) of transaction started to process a message. Default: &lt;code&gt;0&lt;/code&gt; (use system default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:boolean" />
  </xs:attributeGroup>
  <xs:complexType name="WsdlXmlValidatorType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="WsdlXmlValidatorCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="WsdlXmlValidatorDeclaredAttributeGroup">
    <xs:attribute name="schemaLocationToAdd" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references which will be added to the wsdl Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>creates &lt;code&gt;schemalocation&lt;/code&gt; attribute based on the wsdl and replaces the namespace of the soap body element Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wsdl" type="xs:string">
      <xs:annotation>
        <xs:documentation>the wsdl to read the xsd's from Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="WsdlXmlValidatorCumulativeAttributeGroup">
    <xs:attributeGroup ref="WsdlXmlValidatorDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SoapValidatorCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SoapValidatorType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="SoapValidatorCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="SoapValidatorDeclaredAttributeGroup">
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap body. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap body, for example to allow element x and an empty soap body use: x,)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputSoapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>identical to the &lt;code&gt;soapbody&lt;/code&gt; attribute except that it's used for the output message instead of the input message. for more information see &lt;a href="#note1"&gt;note 1&lt;/a&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap header. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap header, for example to allow element x and an empty soap header use: x,)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be used when the soap header element exists multiple times</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="SoapVersionAttributeValuesType">
      <xs:annotation>
        <xs:documentation>soap envelope xsd version to use: 1.1, 1.2 or any (both 1.1 and 1.2) Default: 1.1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowPlainXml" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>allow plain xml, without a SOAP Envelope, too Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>always envelope (not allowed to change) Default: envelope</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:simpleType name="SoapVersionAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="SOAP11" />
      <xs:enumeration value="SOAP12" />
      <xs:enumeration value="NONE" />
      <xs:enumeration value="AUTO" />
    </xs:restriction>
  </xs:simpleType>
  <xs:attributeGroup name="SoapValidatorCumulativeAttributeGroup">
    <xs:attributeGroup ref="SoapValidatorDeclaredAttributeGroup" />
    <xs:attributeGroup ref="Json2XmlValidatorDeclaredAttributeGroup" />
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as noNamespaceSchemaLocation)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>Pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>A uri reference as a hint as to the location of a schema document with no target namespace.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key for retrieving a schema</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="responseRoot" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the response root element, or a comma separated list of names to choose from (only one is allowed)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardFailureToSuccess" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the failure forward is replaced by the success forward (like a warning mode) Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rootElementSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable to store the name of the root element</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rootNamespaceSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable to store the namespace of the root element</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Characterset used for reading file, only used when &lt;code&gt;validateFile&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; Default: utf-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Perform addional memory intensive checks Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCaching" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the number for caching validators in appConstants is ignored and no caching is done (for this validator only) Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:boolean" />
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of namespaces which are excluded from an import or include in the schema document</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of schemaLocations which are excluded from an import or include in the schema document</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set: key of session variable to store reasons of mis-validation in Default: failureReason</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>The namespace of the SOAP envelope, when this property has a value and the input message is a SOAP message, the content of the SOAP Body is used for validation, hence the SOAP Envelope and SOAP Body elements are not considered part of the message to validate. Please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.SoapValidator} is now the preferred solution in case a SOAP message needs to be validated, in other cases give this property an empty value Default: http://schemas.xmlsoap.org/soap/envelope/</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Should the XmlValidator throw a PipeRunexception on a validation error. If not, a forward with name 'failure' must be defined. Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the comparison for importedSchemaLocationsToIgnore is done on base filename without any path Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. Otherwise the input itself is validated Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="warn" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, send warnings to logging and console about syntax problems in the configured schema('s) Default: &lt;code&gt;true&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Like &lt;code&gt;reasonSessionKey&lt;/code&gt; but stores reasons in xml format and more extensive Default: xmlFailureReason</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlSchemaVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;1.0&lt;/code&gt;, Xerces's previous XML Schema factory will be used, which would make all XSD 1.1 features illegal. The default behaviour can also be set with &lt;code&gt;xsd.processor.version&lt;/code&gt; property.  Default: &lt;code&gt;1.1&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Json2XmlValidatorType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="Json2XmlValidatorCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="Json2XmlValidatorDeclaredAttributeGroup">
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>Only for json input: namespace of the resulting xml. Need only be specified when the namespace of root name is ambiguous in the schema</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default format of the result. Either 'xml' or 'json' Default: xml</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key to retrieve outputformat from. Default: outputformat</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key to store the inputformat in, to be able to set the outputformat when autoForamat=true. Default: Json2XmlValidator.inputformat +&lt;name of the pipe&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true, the format on 'output' is set to the same as the format of the input message on 'input'. The format of the input message is stored in and retrieved from the session variable specified by outputFormatSessionKey Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compactJsonArrays" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true assume arrays in json do not have the element containers like in xml Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true, assume that json contains/must contain a root element Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true, and converting from json to xml, parameter substitutions are searched for optional sub elements too. By default, only mandatory elements are searched for parameter substitutions. N.B. Currenlty this option might cause problems. Please try using more qualified parameters names (using '/') first Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. This often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true, all xml is allowed to be without namespaces. If no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true, all xml that is generated is without a namespace set Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateJsonToRootElementOnly" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true, and converting to or from json, then the message root is the only rootValidation, ignoring root validations like for SOAP envelope and header set by descender classes like SoapValidator Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Json2XmlValidatorCumulativeAttributeGroup">
    <xs:attributeGroup ref="Json2XmlValidatorDeclaredAttributeGroup" />
    <xs:attributeGroup ref="XmlValidatorCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XmlValidatorType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="XmlValidatorCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="XmlValidatorDeclaredAttributeGroup">
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as noNamespaceSchemaLocation)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>Pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>A uri reference as a hint as to the location of a schema document with no target namespace.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key for retrieving a schema</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the root element, or a comma separated list of names to choose from (only one is allowed)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="responseRoot" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the response root element, or a comma separated list of names to choose from (only one is allowed)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardFailureToSuccess" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the failure forward is replaced by the success forward (like a warning mode) Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rootElementSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable to store the name of the root element</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rootNamespaceSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable to store the namespace of the root element</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Characterset used for reading file, only used when &lt;code&gt;validateFile&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; Default: utf-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Perform addional memory intensive checks Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCaching" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the number for caching validators in appConstants is ignored and no caching is done (for this validator only) Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:boolean" />
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of namespaces which are excluded from an import or include in the schema document</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of schemaLocations which are excluded from an import or include in the schema document</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set: key of session variable to store reasons of mis-validation in Default: failureReason</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>The namespace of the SOAP envelope, when this property has a value and the input message is a SOAP message, the content of the SOAP Body is used for validation, hence the SOAP Envelope and SOAP Body elements are not considered part of the message to validate. Please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.SoapValidator} is now the preferred solution in case a SOAP message needs to be validated, in other cases give this property an empty value Default: http://schemas.xmlsoap.org/soap/envelope/</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Should the XmlValidator throw a PipeRunexception on a validation error. If not, a forward with name 'failure' must be defined. Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the comparison for importedSchemaLocationsToIgnore is done on base filename without any path Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. Otherwise the input itself is validated Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="warn" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, send warnings to logging and console about syntax problems in the configured schema('s) Default: &lt;code&gt;true&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Like &lt;code&gt;reasonSessionKey&lt;/code&gt; but stores reasons in xml format and more extensive Default: xmlFailureReason</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlSchemaVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;1.0&lt;/code&gt;, Xerces's previous XML Schema factory will be used, which would make all XSD 1.1 features illegal. The default behaviour can also be set with &lt;code&gt;xsd.processor.version&lt;/code&gt; property.  Default: &lt;code&gt;1.1&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XmlValidatorCumulativeAttributeGroup">
    <xs:attributeGroup ref="XmlValidatorDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="FixedForwardPipeDeclaredAttributeGroup">
    <xs:attribute name="skipOnEmptyInput" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set, the processing continues directly at the forward of this pipe, without executing the pipe itself Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FixedForwardPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="FixedForwardPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="EsbSoapValidatorType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="EsbSoapValidatorCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="EsbSoapValidatorDeclaredAttributeGroup">
    <xs:attribute name="cmhVersion" type="xs:integer" />
    <xs:attribute name="direction" type="xs:string" />
    <xs:attribute name="mode" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="EsbSoapValidatorCumulativeAttributeGroup">
    <xs:attributeGroup ref="EsbSoapValidatorDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SoapValidatorCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FxfXmlValidatorType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FxfXmlValidatorCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FxfXmlValidatorDeclaredAttributeGroup">
    <xs:attribute name="direction" type="xs:string" />
    <xs:attribute name="fxfVersion" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="FxfXmlValidatorCumulativeAttributeGroup">
    <xs:attributeGroup ref="FxfXmlValidatorDeclaredAttributeGroup" />
    <xs:attributeGroup ref="WsdlXmlValidatorCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XmlWellFormedCheckerType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="XmlWellFormedCheckerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="XmlWellFormedCheckerDeclaredAttributeGroup">
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the root element</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XmlWellFormedCheckerCumulativeAttributeGroup">
    <xs:attributeGroup ref="XmlWellFormedCheckerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="OutputValidatorElementGroup">
    <xs:choice>
      <xs:element name="OutputValidator">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element ref="Forward" />
              <xs:element ref="Locker" />
              <xs:element ref="Param" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="OutputValidatorElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="OutputValidatorElementGroupBase">
    <xs:choice>
      <xs:element name="ApiWsdlXmlOutputValidator">
        <xs:annotation>
          <xs:documentation>ApiWsdlXmlOutputValidator - nl.nn.adapterframework.extensions.api.ApiWsdlXmlValidator used as OutputValidator

Extension to WsdlXmlValidator for API Management.
 &lt;p&gt;
 &lt;b&gt;Configuration &lt;/b&gt;&lt;i&gt;(where deviating from WsdlXmlValidator)&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setMultipart(boolean) boolean}&lt;/td&gt;&lt;td&gt;indicates whether the message is multipart/form-data. If so, the wsdl only represents the first part, other parts are attachments. This attribute is only used for generating the 'real' wsdl which is available in the ibis console (../rest/webservices)&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;p&gt;
 The SOAP header can only contain the following schema (or it's empty):
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;mandatory&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;xmlns="http://api.nn.nl/MessageHeader"&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;no&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ApiWsdlXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.api.ApiWsdlXmlValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbSoapOutputValidator">
        <xs:annotation>
          <xs:documentation>EsbSoapOutputValidator - nl.nn.adapterframework.extensions.esb.EsbSoapValidator used as OutputValidator

XmlValidator that will automatically add the SOAP envelope XSD and the ESB
 XSD (e.g. CommonMessageHeader.xsd) to the set of XSD's used for validation.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbSoapValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.esb.EsbSoapValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FxfXmlOutputValidator">
        <xs:annotation>
          <xs:documentation>FxfXmlOutputValidator - nl.nn.adapterframework.extensions.fxf.FxfXmlValidator used as OutputValidator

FxF XML validator to be used with FxF3. When receiving files
 (direction=receive) the message is validated against the
 OnCompletedTransferNotify WSDL (a P2P connection, hence same WSDL (provided
 by Tibco) for all queues (every Ibis receiving FxF files has it's own
 queue)). When sending files (direction=send) the message is validated against
 the StartTransfer WSDL (ESB service provided by Tibco).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FxfXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.fxf.FxfXmlValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Json2XmlOutputValidator">
        <xs:annotation>
          <xs:documentation>Json2XmlOutputValidator - nl.nn.adapterframework.pipes.Json2XmlValidator used as OutputValidator

&lt;code&gt;Pipe&lt;/code&gt; that validates the XML or JSON input message against a XML-Schema and returns either XML or JSON.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Json2XmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.Json2XmlValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SoapOutputValidator">
        <xs:annotation>
          <xs:documentation>SoapOutputValidator - nl.nn.adapterframework.soap.SoapValidator used as OutputValidator

XmlValidator that will automatically add the SOAP envelope XSD to the set of
 XSD's used for validation.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SoapValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.soap.SoapValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="WsdlXmlOutputValidator">
        <xs:annotation>
          <xs:documentation>WsdlXmlOutputValidator - nl.nn.adapterframework.pipes.WsdlXmlValidator used as OutputValidator

XmlValidator that will read the XSD's to use from a WSDL. As it extends the
 SoapValidator is will also add the SOAP envelope XSD.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="WsdlXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.WsdlXmlValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlOutputValidator">
        <xs:annotation>
          <xs:documentation>XmlOutputValidator - nl.nn.adapterframework.pipes.XmlValidator used as OutputValidator

&lt;code&gt;Pipe&lt;/code&gt; that validates the input message against a XML-Schema.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.XmlValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlWellFormedCheckerOutputValidator">
        <xs:annotation>
          <xs:documentation>XmlWellFormedCheckerOutputValidator - nl.nn.adapterframework.pipes.XmlWellFormedChecker used as OutputValidator

&lt;code&gt;Pipe&lt;/code&gt; that checks the well-formedness of the input message.
 If &lt;code&gt;root&lt;/code&gt; is given then this is also checked.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlWellFormedCheckerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.XmlWellFormedChecker" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="InputWrapperElementGroup">
    <xs:choice>
      <xs:element name="InputWrapper">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element ref="Forward" />
              <xs:element ref="Locker" />
              <xs:element ref="Param" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="inputWrapper" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="InputWrapperElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="InputWrapperElementGroupBase">
    <xs:choice>
      <xs:element name="ApiSoapInputWrapper">
        <xs:annotation>
          <xs:documentation>ApiSoapInputWrapper - nl.nn.adapterframework.extensions.api.ApiSoapWrapperPipe used as InputWrapper

Extension to SoapWrapperPipe for API Management.
 &lt;p&gt;
 &lt;b&gt;Configuration &lt;/b&gt;&lt;i&gt;(where deviating from SoapWrapperPipe)&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setSoapHeaderSessionKey(String) soapHeaderSessionKey}&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt;: &lt;/td&gt;&lt;td&gt;soapHeader&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setSoapHeaderStyleSheet(String) soapHeaderStyleSheet}&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt;: &lt;/td&gt;&lt;td&gt;/xml/xsl/api/soapHeader.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;p&gt;
 &lt;b&gt;/xml/xsl/api/soapHeader.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;&lt;code&gt;MessageHeader&lt;/code&gt; is only created when $conversationId is filled (otherwise skipped)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&lt;code&gt;From&lt;/code&gt; is only created when $from_in is filled (otherwise skipped) and it's created with the value of $from_out&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$conversationId&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://api.nn.nl/MessageHeader"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;from_in&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;from_out&lt;/td&gt;&lt;td&gt;property 'instance.name'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;conversationId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ApiSoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputWrapper" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.api.ApiSoapWrapperPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="BisInputWrapper">
        <xs:annotation>
          <xs:documentation>BisInputWrapper - nl.nn.adapterframework.extensions.bis.BisWrapperPipe used as InputWrapper

Pipe to wrap or unwrap a message conformable to the BIS (Business Integration Services) standard.
 &lt;p&gt;
 Example request in case of bis provider:&lt;br/&gt;&lt;code&gt;&lt;pre&gt;
	&amp;lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;
		&amp;lt;soap:Header&amp;gt;
			&amp;lt;bis:MessageHeader xmlns:bis="http://www.ing.com/CSP/XSD/General/Message_2"&amp;gt;
				&amp;lt;bis:From&amp;gt;
					&amp;lt;bis:Id&amp;gt;PolicyConversion_01_ServiceAgents_01&amp;lt;/bis:Id&amp;gt;
				&amp;lt;/bis:From&amp;gt;
				&amp;lt;bis:HeaderFields&amp;gt;
					&amp;lt;bis:ConversationId&amp;gt;1790257_10000050_04&amp;lt;/bis:ConversationId&amp;gt;
					&amp;lt;bis:MessageId&amp;gt;1790257&amp;lt;/bis:MessageId&amp;gt;
					&amp;lt;bis:Timestamp&amp;gt;2011-03-02T10:26:31.464+01:00&amp;lt;/bis:Timestamp&amp;gt;
				&amp;lt;/bis:HeaderFields&amp;gt;
			&amp;lt;/bis:MessageHeader&amp;gt;
		&amp;lt;/soap:Header&amp;gt;
		&amp;lt;soap:Body&amp;gt;
			&lt;i&gt;&amp;lt;pcr:GetRequest xmlns:pcr="http://www.ing.com/nl/pcretail/ts/migrationauditdata_01"&amp;gt;
				&amp;lt;pcr:PolicyDetails&amp;gt;
					&amp;lt;pcr:RVS_PARTY_ID&amp;gt;1790257&amp;lt;/pcr:RVS_PARTY_ID&amp;gt;
					&amp;lt;pcr:RVS_POLICY_NUMBER&amp;gt;10000050&amp;lt;/pcr:RVS_POLICY_NUMBER&amp;gt;
					&amp;lt;pcr:RVS_BRANCH_CODE&amp;gt;04&amp;lt;/pcr:RVS_BRANCH_CODE&amp;gt;
				&amp;lt;/pcr:PolicyDetails&amp;gt;
			&amp;lt;/pcr:GetRequest&amp;gt;&lt;/i&gt;
		&amp;lt;/soap:Body&amp;gt;
	&amp;lt;/soap:Envelope&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;&lt;br/&gt;
 The element MessageHeader in the soap header is mandatory.
 &lt;/p&gt;&lt;p&gt;
 Example response in case of bis requester:&lt;br/&gt;&lt;code&gt;&lt;pre&gt;
	&amp;lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;
		&amp;lt;soap:Header&amp;gt;
			&amp;lt;bis:MessageHeader xmlns:bis="http://www.ing.com/CSP/XSD/General/Message_2"&amp;gt;
				&amp;lt;bis:From&amp;gt;
					&amp;lt;bis:Id&amp;gt;IJA_DB4CONV&amp;lt;/bis:Id&amp;gt;
				&amp;lt;/bis:From&amp;gt;
				&amp;lt;bis:HeaderFields&amp;gt;
					&amp;lt;bis:ConversationId&amp;gt;1790257_10000050_04&amp;lt;/bis:ConversationId&amp;gt;
					&amp;lt;bis:MessageId&amp;gt;rn09ce_0a3b8d2d--33192359_12e588118c1_-612f&amp;lt;/bis:MessageId&amp;gt;
					&amp;lt;bis:ExternalRefToMessageId&amp;gt;1790257&amp;lt;/bis:ExternalRefToMessageId&amp;gt;
					&amp;lt;bis:Timestamp&amp;gt;2011-03-02T10:26:31&amp;lt;/bis:Timestamp&amp;gt;
				&amp;lt;/bis:HeaderFields&amp;gt;
			&amp;lt;/bis:MessageHeader&amp;gt;
		&amp;lt;/soap:Header&amp;gt;
		&amp;lt;soap:Body&amp;gt;
			&lt;i&gt;&amp;lt;GetResponse xmlns="http://www.ing.com/nl/pcretail/ts/migrationcasedata_01"&amp;gt;&lt;/i&gt;
				&lt;i&gt;&amp;lt;CaseData&amp;gt;...&amp;lt;/CaseData&amp;gt;&lt;/i&gt;
				&amp;lt;bis:Result xmlns:bis="http://www.ing.com/CSP/XSD/General/Message_2"&amp;gt;
					&amp;lt;bis:Status&amp;gt;OK&amp;lt;/bis:Status&amp;gt;
				&amp;lt;/bis:Result&amp;gt;
			&lt;i&gt;&amp;lt;/GetResponse&amp;gt;&lt;/i&gt;
		&amp;lt;/soap:Body&amp;gt;
	&amp;lt;/soap:Envelope&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;&lt;br/&gt;
 The elements MessageHeader in the soap header and Result in the soap body are mandatory.
 &lt;/p&gt;&lt;p&gt;
 Example element Result in case of an error response:&lt;br/&gt;&lt;code&gt;&lt;pre&gt;
	&amp;lt;bis:Result xmlns:bis="http://www.ing.com/CSP/XSD/General/Message_2"&amp;gt;
		&amp;lt;bis:Status&amp;gt;ERROR&amp;lt;/bis:Status&amp;gt;
		&amp;lt;bis:ErrorList&amp;gt;
			&amp;lt;bis:Error&amp;gt;
				&amp;lt;bis:Code&amp;gt;ERR6003&amp;lt;/bis:Code&amp;gt;
				&amp;lt;bis:Reason&amp;gt;Invalid Request Message&amp;lt;/bis:Reason&amp;gt;
				&amp;lt;bis:Service&amp;gt;
					&amp;lt;bis:Name&amp;gt;migrationauditdata_01&amp;lt;/bis:Name&amp;gt;
					&amp;lt;bis:Context&amp;gt;1&amp;lt;/bis:Context&amp;gt;
					&amp;lt;bis:Action&amp;gt;
						&amp;lt;bis:Name&amp;gt;SetPolicyDetails_Action&amp;lt;/bis:Name&amp;gt;
						&amp;lt;bis:Version&amp;gt;1&amp;lt;/bis:Version&amp;gt;
					&amp;lt;/bis:Action&amp;gt;
				&amp;lt;/bis:Service&amp;gt;
				&amp;lt;bis:DetailList&amp;gt;
					&amp;lt;bis:Detail&amp;gt;
						&amp;lt;bis:Code/&amp;gt;
						&amp;lt;bis:Text&amp;gt;Pipe [Validate tibco request] msgId [Test Tool correlation id] got invalid xml according to schema [....&amp;lt;/bis:Text&amp;gt;
					&amp;lt;/bis:Detail&amp;gt;
				&amp;lt;/bis:DetailList&amp;gt;
			&amp;lt;/bis:Error&amp;gt;
		&amp;lt;/bis:ErrorList&amp;gt;
	&amp;lt;/bis:Result&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;
 &lt;/p&gt;&lt;p&gt;
 If direction=unwrap and one of the following conditions is true a PipeRunException is thrown:
 &lt;ul&gt;&lt;li&gt;Result/Status in the response soap body equals 'ERROR'&lt;/li&gt;
 &lt;li&gt;faultcode in the response soap fault is not empty&lt;/li&gt;&lt;/ul&gt;
 &lt;/p&gt;
 &lt;p&gt;&lt;b&gt;Configuration:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setName(String) name}&lt;/td&gt;&lt;td&gt;name of the Pipe&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setDirection(String) direction}&lt;/td&gt;&lt;td&gt;either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt;&lt;/td&gt;&lt;td&gt;wrap&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setInputXPath(String) inputXPath}&lt;/td&gt;&lt;td&gt;(only used when direction=unwrap) xpath expression to extract the message which is returned. The initial message is the content of the soap body. If empty, the content of the soap body is passed (without the root body)&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setInputNamespaceDefs(String) inputNamespaceDefs}&lt;/td&gt;&lt;td&gt;(only used when direction=unwrap) namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisMessageHeaderInSoapBody(boolean) bisMessageHeaderInSoapBody}&lt;/td&gt;&lt;td&gt;when &lt;code&gt;true&lt;/code&gt;, the bis message header is put in the SOAP body instead of in the SOAP header (first one is the old bis standard)&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisMessageHeaderSessionKey(String) bisMessageHeaderSessionKey}&lt;/td&gt;&lt;td&gt;
 &lt;table&gt; 
 &lt;tr&gt;&lt;td&gt;&lt;code&gt;direction=unwrap&lt;/code&gt;&lt;/td&gt;&lt;td&gt;name of the session key to store the bis message header from the request in&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;code&gt;direction=wrap&lt;/code&gt;&lt;/td&gt;&lt;td&gt;name of the session key the original bis message header from the request is stored in; used to create the bis message header for the response&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt; 
 &lt;/td&gt;&lt;td&gt;bisMessageHeader&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisResultInPayload(boolean) bisResultInPayload}&lt;/td&gt;&lt;td&gt;when &lt;code&gt;true&lt;/code&gt;, the bis result is put in the payload (as last child in root tag) instead of in the SOAP body as sibling of the payload (last one is the old bis standard)&lt;/td&gt;&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisConversationIdSessionKey(String) bisConversationIdSessionKey}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap and the original bis message header from the request doesn't exist) key of session variable to retrieve ConversationId for the bis message header from&lt;/td&gt;&lt;td&gt;bisConversationId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisExternalRefToMessageIdSessionKey(String) bisExternalRefToMessageIdSessionKey}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap and the original bis message header from the request doesn't exist) key of session variable to retrieve ExternalRefToMessageId for the bis message header from&lt;/td&gt;&lt;td&gt;bisExternalRefToMessageId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisErrorCodeSessionKey(String) bisErrorCodeSessionKey}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap) key of session variable to store bis error code in (if an error occurs)&lt;/td&gt;&lt;td&gt;bisErrorCode&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisErrorTextSessionKey(String) bisErrorTextSessionKey}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap) key of session variable to store bis error text in (if an error occurs). If not specified or no value retrieved, the following error text is derived from the error code: 
   &lt;table border="1"&gt;
   &lt;tr&gt;&lt;th&gt;errorCode&lt;/th&gt;&lt;th&gt;errorText&lt;/th&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6002&lt;/td&gt;&lt;td&gt;Service Interface Request Time Out&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6003&lt;/td&gt;&lt;td&gt;Invalid Request Message&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6004&lt;/td&gt;&lt;td&gt;Invalid Backend system response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6005&lt;/td&gt;&lt;td&gt;Backend system failure response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6999&lt;/td&gt;&lt;td&gt;Unspecified Errors&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;&lt;/td&gt;&lt;td&gt;bisErrorText&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisErrorReasonSessionKey(String) bisErrorReasonSessionKey}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap and an error occurs) key of session variable to store bis error reason in&lt;/td&gt;&lt;td&gt;bisErrorReason&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setOutputRoot(String) outputRoot}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap and an error occurs) name of output root element in the SOAP body. If empty, the input message is used in the response&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setOutputNamespace(String) outputNamespace}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap and an error occurs) namespace of the output root element in the SOAP body&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisServiceName(String) bisServiceName}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap) name of the bis service; used in the bis error response&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisActionName(String) bisActionName}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap) name of the bis operation; used in the bis error response&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/p&gt;
 &lt;p&gt;&lt;b&gt;The following attributes are created for the purpose of the migration from IFSA to TIBCO (and will be removed afterwards):&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setRemoveOutputNamespaces(boolean) removeOutputNamespaces}&lt;/td&gt;&lt;td&gt;(only used when direction=unwrap) when set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the output are removed&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setOmitResult(boolean) omitResult}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap) when &lt;code&gt;true&lt;/code&gt;, the Result is omitted and instead of Result/Status 'ERROR' a PipeRunException is thrown&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setAddOutputNamespace(boolean) addOutputNamespace}&lt;/td&gt;&lt;td&gt;(only used when direction=unwrap) when set &lt;code&gt;true&lt;/code&gt; the &lt;code&gt;outputNamespace&lt;/code&gt; is added to the output root element in the SOAP body&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="BisWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputWrapper" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.bis.BisWrapperPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbSoapInputWrapper">
        <xs:annotation>
          <xs:documentation>EsbSoapInputWrapper - nl.nn.adapterframework.extensions.esb.EsbSoapWrapperPipe used as InputWrapper

Extension to SoapWrapperPipe for separate modes.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbSoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputWrapper" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.esb.EsbSoapWrapperPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FxfInputWrapper">
        <xs:annotation>
          <xs:documentation>FxfInputWrapper - nl.nn.adapterframework.extensions.fxf.FxfWrapperPipe used as InputWrapper

FxF wrapper to be used with FxF3. When receiving files (direction=unwrap)
 the message handed to the pipeline is the local filename extracted from an
 ESB SOAP message. When sending files (direction=wrap) input should be a local
 filename which will be wrapped into an ESB SOAP message. Please note: When
 writing files which need to be send through FxF they should be written to
 ${fxf.dir}/NNX00000/out. The property ${fxf.dir} will automatically be
 available on the OTAP environment (define it in StageSpecifics_LOC.properties
 only). Replace NNX00000 with the specific flowId and generate a unique
 filename (files will automatically be cleaned after 30 days or any other
 value specified by ${fxf.retention}).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FxfWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputWrapper" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.fxf.FxfWrapperPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SoapInputWrapper">
        <xs:annotation>
          <xs:documentation>SoapInputWrapper - nl.nn.adapterframework.soap.SoapWrapperPipe used as InputWrapper

Pipe to wrap or unwrap a message from/into a SOAP Envelope.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputWrapper" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.soap.SoapWrapperPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="ApiSoapWrapperPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="SoapWrapperPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="SoapWrapperPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="SoapWrapperPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="SoapWrapperPipeDeclaredAttributeGroup">
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>Either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt; Default: wrap</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>Soap version to use: one of &lt;code&gt;soap1.1&lt;/code&gt;, &lt;code&gt;soap1.2&lt;/code&gt;, &lt;code&gt;none&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;. &lt;code&gt;none&lt;/code&gt; means that no wrapping or unwrapping will be done, &lt;code&gt;auto&lt;/code&gt; means auto-detect Default: auto</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespaceSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of session variable to store auto detected soapNamespace Default: soapVersion</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) Namespace of the soap envelope Default: auto determined from soapVersion</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of session variable to store soap header Default: soapHeader, when direction is 'unwrap'</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>The encodingstyle to be set in the soap header</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>The default for the namespace of the message sent. Identifies the service to be called. May be overriden by an actual namespace setting in the message to be sent</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) Stylesheet to create the content of the soap header. As input for this stylesheet a dummy xml string is used. Note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) Stylesheet to apply to the input message. Note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeOutputNamespaces" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) If &lt;code&gt;true&lt;/code&gt;, namespaces (and prefixes) in the content of the soap body are removed Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeUnusedOutputNamespaces" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt; and &lt;code&gt;removeoutputnamespaces=false&lt;/code&gt;) If &lt;code&gt;true&lt;/code&gt;, unused namespaces in the content of the soap body are removed Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) If not empty, this namespace is added to the root element in the soap body</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>If not empty, the root element in the soap body is changed to this value</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreSoapFault" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) If &lt;code&gt;false&lt;/code&gt; and the soap body contains a soap fault, a PipeRunException is thrown Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowPlainXml" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>For direction=&lt;code&gt;unwrap&lt;/code&gt; only: if true, allow unwrapped xml too Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to WebServiceSecurity</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default username for WebServiceSecurity Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password for WebServiceSecurity Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true, the password is sent digested; Otherwise it is sent in clear text Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onlyIfSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of session variable to check if action must be executed. The wrap or unwrap action is only executed if the session variable exists</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onlyIfValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of session variable 'onlyIfSessionKey' to check if action must be executed. The wrap or unwrap action is only executed if the session variable has the specified value</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="unlessSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of session variable to check if action must be executed. The wrap or unwrap action is not executed if the session variable exists</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="unlessValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of session variable 'unlessSessionKey' to check if action must be executed. The wrap or unwrap action is not executed if the session variable has the specified value</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SoapWrapperPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="SoapWrapperPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="BisWrapperPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="BisWrapperPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="BisWrapperPipeDeclaredAttributeGroup">
    <xs:attribute name="addOutputNamespace" type="xs:boolean" />
    <xs:attribute name="bisActionName" type="xs:string" />
    <xs:attribute name="bisConversationIdSessionKey" type="xs:string" />
    <xs:attribute name="bisErrorCodeSessionKey" type="xs:string" />
    <xs:attribute name="bisErrorReasonSessionKey" type="xs:string" />
    <xs:attribute name="bisErrorTextSessionKey" type="xs:string" />
    <xs:attribute name="bisExternalRefToMessageIdSessionKey" type="xs:string" />
    <xs:attribute name="bisMessageHeaderInSoapBody" type="xs:boolean" />
    <xs:attribute name="bisMessageHeaderSessionKey" type="xs:string" />
    <xs:attribute name="bisResultInPayload" type="xs:boolean" />
    <xs:attribute name="bisServiceName" type="xs:string" />
    <xs:attribute name="inputNamespaceDefs" type="xs:string" />
    <xs:attribute name="inputXPath" type="xs:string" />
    <xs:attribute name="omitResult" type="xs:boolean" />
    <xs:attribute name="outputRoot" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="BisWrapperPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="BisWrapperPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SoapWrapperPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="EsbSoapWrapperPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="EsbSoapWrapperPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="EsbSoapWrapperPipeDeclaredAttributeGroup">
    <xs:attribute name="addOutputNamespace" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;outputNamespace&lt;/code&gt; is automatically set using the parameters (if $messagingLayer='P2P' then 'http://nn.nl/XSD/$businessDomain/$applicationName/$applicationFunction' else is serviceContext is not empty 'http://nn.nl/XSD/$businessDomain/$serviceName/$serviceContext/$serviceContextVersion/$operationName/$operationVersion' else 'http://nn.nl/XSD/$businessDomain/$serviceName/$serviceVersion/$operationName/$operationVersion') Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cmhVersion" type="xs:integer">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;mode=reg&lt;/code&gt;) Common Message Header version (1 or 2) Default: 1 when &lt;code&gt;mode=reg&lt;/code&gt;, 0 otherwise</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="esbAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>When the messagingLayer part of the destination has this value interpret it as ESB Default: &lt;code&gt;&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fixResultNamespace" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt; and the Result tag already exists, the namespace is changed Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mode" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;i2t&lt;/code&gt; (ifsa2tibco), &lt;code&gt;reg&lt;/code&gt; (regular) or &lt;code&gt;bis&lt;/code&gt; (Business Integration Services) Default: reg</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="p2pAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>When the messagingLayer part of the destination has this value interpret it as P2P Default: &lt;code&gt;&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retrievePhysicalDestination" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, the physical destination is retrieved from the queue instead of using the parameter &lt;code&gt;destination&lt;/code&gt; Default: &lt;code&gt;true&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useFixedValues" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the fields CorrelationId, MessageId and Timestamp will have a fixed value (for testing purposes only) Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="EsbSoapWrapperPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="EsbSoapWrapperPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SoapWrapperPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FxfWrapperPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FxfWrapperPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FxfWrapperPipeDeclaredAttributeGroup">
    <xs:attribute name="flowId" type="xs:string">
      <xs:annotation>
        <xs:documentation>specifies the id of the transfer flow</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="flowOutFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>specifies the output folder if transformFilename=&lt;code&gt;false&lt;/code&gt; and direction=wrap</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transformFilename" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; and direction=wrap, the folder the output folder &lt;code&gt;flowOutFolder&lt;/code&gt; will be constructed as &lt;code&gt;/opt/data/FXF/&amp;lt;instanceNameLowerCase&amp;gt;/&amp;lt;flowId&amp;gt;/out/&lt;/code&gt;  Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clientFilenameSessionKey" type="xs:string" />
    <xs:attribute name="createFolder" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the folder corresponding fxf.dir property will be created in case it does not exist Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="flowIdSessionKey" type="xs:string" />
    <xs:attribute name="fxfDirSessionKey" type="xs:string" />
    <xs:attribute name="fxfFileSessionKey" type="xs:string" />
    <xs:attribute name="fxfVersion" type="xs:string" />
    <xs:attribute name="soapBodySessionKey" type="xs:string" />
    <xs:attribute name="transferFlowIdSessionKey" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="FxfWrapperPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="FxfWrapperPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="EsbSoapWrapperPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="OutputWrapperElementGroup">
    <xs:choice>
      <xs:element name="OutputWrapper">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element ref="Forward" />
              <xs:element ref="Locker" />
              <xs:element ref="Param" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="outputWrapper" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="OutputWrapperElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="OutputWrapperElementGroupBase">
    <xs:choice>
      <xs:element name="ApiSoapOutputWrapper">
        <xs:annotation>
          <xs:documentation>ApiSoapOutputWrapper - nl.nn.adapterframework.extensions.api.ApiSoapWrapperPipe used as OutputWrapper

Extension to SoapWrapperPipe for API Management.
 &lt;p&gt;
 &lt;b&gt;Configuration &lt;/b&gt;&lt;i&gt;(where deviating from SoapWrapperPipe)&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setSoapHeaderSessionKey(String) soapHeaderSessionKey}&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt;: &lt;/td&gt;&lt;td&gt;soapHeader&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setSoapHeaderStyleSheet(String) soapHeaderStyleSheet}&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt;: &lt;/td&gt;&lt;td&gt;/xml/xsl/api/soapHeader.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;p&gt;
 &lt;b&gt;/xml/xsl/api/soapHeader.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;&lt;code&gt;MessageHeader&lt;/code&gt; is only created when $conversationId is filled (otherwise skipped)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&lt;code&gt;From&lt;/code&gt; is only created when $from_in is filled (otherwise skipped) and it's created with the value of $from_out&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$conversationId&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://api.nn.nl/MessageHeader"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;from_in&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;from_out&lt;/td&gt;&lt;td&gt;property 'instance.name'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;conversationId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ApiSoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputWrapper" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.api.ApiSoapWrapperPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="BisOutputWrapper">
        <xs:annotation>
          <xs:documentation>BisOutputWrapper - nl.nn.adapterframework.extensions.bis.BisWrapperPipe used as OutputWrapper

Pipe to wrap or unwrap a message conformable to the BIS (Business Integration Services) standard.
 &lt;p&gt;
 Example request in case of bis provider:&lt;br/&gt;&lt;code&gt;&lt;pre&gt;
	&amp;lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;
		&amp;lt;soap:Header&amp;gt;
			&amp;lt;bis:MessageHeader xmlns:bis="http://www.ing.com/CSP/XSD/General/Message_2"&amp;gt;
				&amp;lt;bis:From&amp;gt;
					&amp;lt;bis:Id&amp;gt;PolicyConversion_01_ServiceAgents_01&amp;lt;/bis:Id&amp;gt;
				&amp;lt;/bis:From&amp;gt;
				&amp;lt;bis:HeaderFields&amp;gt;
					&amp;lt;bis:ConversationId&amp;gt;1790257_10000050_04&amp;lt;/bis:ConversationId&amp;gt;
					&amp;lt;bis:MessageId&amp;gt;1790257&amp;lt;/bis:MessageId&amp;gt;
					&amp;lt;bis:Timestamp&amp;gt;2011-03-02T10:26:31.464+01:00&amp;lt;/bis:Timestamp&amp;gt;
				&amp;lt;/bis:HeaderFields&amp;gt;
			&amp;lt;/bis:MessageHeader&amp;gt;
		&amp;lt;/soap:Header&amp;gt;
		&amp;lt;soap:Body&amp;gt;
			&lt;i&gt;&amp;lt;pcr:GetRequest xmlns:pcr="http://www.ing.com/nl/pcretail/ts/migrationauditdata_01"&amp;gt;
				&amp;lt;pcr:PolicyDetails&amp;gt;
					&amp;lt;pcr:RVS_PARTY_ID&amp;gt;1790257&amp;lt;/pcr:RVS_PARTY_ID&amp;gt;
					&amp;lt;pcr:RVS_POLICY_NUMBER&amp;gt;10000050&amp;lt;/pcr:RVS_POLICY_NUMBER&amp;gt;
					&amp;lt;pcr:RVS_BRANCH_CODE&amp;gt;04&amp;lt;/pcr:RVS_BRANCH_CODE&amp;gt;
				&amp;lt;/pcr:PolicyDetails&amp;gt;
			&amp;lt;/pcr:GetRequest&amp;gt;&lt;/i&gt;
		&amp;lt;/soap:Body&amp;gt;
	&amp;lt;/soap:Envelope&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;&lt;br/&gt;
 The element MessageHeader in the soap header is mandatory.
 &lt;/p&gt;&lt;p&gt;
 Example response in case of bis requester:&lt;br/&gt;&lt;code&gt;&lt;pre&gt;
	&amp;lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;
		&amp;lt;soap:Header&amp;gt;
			&amp;lt;bis:MessageHeader xmlns:bis="http://www.ing.com/CSP/XSD/General/Message_2"&amp;gt;
				&amp;lt;bis:From&amp;gt;
					&amp;lt;bis:Id&amp;gt;IJA_DB4CONV&amp;lt;/bis:Id&amp;gt;
				&amp;lt;/bis:From&amp;gt;
				&amp;lt;bis:HeaderFields&amp;gt;
					&amp;lt;bis:ConversationId&amp;gt;1790257_10000050_04&amp;lt;/bis:ConversationId&amp;gt;
					&amp;lt;bis:MessageId&amp;gt;rn09ce_0a3b8d2d--33192359_12e588118c1_-612f&amp;lt;/bis:MessageId&amp;gt;
					&amp;lt;bis:ExternalRefToMessageId&amp;gt;1790257&amp;lt;/bis:ExternalRefToMessageId&amp;gt;
					&amp;lt;bis:Timestamp&amp;gt;2011-03-02T10:26:31&amp;lt;/bis:Timestamp&amp;gt;
				&amp;lt;/bis:HeaderFields&amp;gt;
			&amp;lt;/bis:MessageHeader&amp;gt;
		&amp;lt;/soap:Header&amp;gt;
		&amp;lt;soap:Body&amp;gt;
			&lt;i&gt;&amp;lt;GetResponse xmlns="http://www.ing.com/nl/pcretail/ts/migrationcasedata_01"&amp;gt;&lt;/i&gt;
				&lt;i&gt;&amp;lt;CaseData&amp;gt;...&amp;lt;/CaseData&amp;gt;&lt;/i&gt;
				&amp;lt;bis:Result xmlns:bis="http://www.ing.com/CSP/XSD/General/Message_2"&amp;gt;
					&amp;lt;bis:Status&amp;gt;OK&amp;lt;/bis:Status&amp;gt;
				&amp;lt;/bis:Result&amp;gt;
			&lt;i&gt;&amp;lt;/GetResponse&amp;gt;&lt;/i&gt;
		&amp;lt;/soap:Body&amp;gt;
	&amp;lt;/soap:Envelope&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;&lt;br/&gt;
 The elements MessageHeader in the soap header and Result in the soap body are mandatory.
 &lt;/p&gt;&lt;p&gt;
 Example element Result in case of an error response:&lt;br/&gt;&lt;code&gt;&lt;pre&gt;
	&amp;lt;bis:Result xmlns:bis="http://www.ing.com/CSP/XSD/General/Message_2"&amp;gt;
		&amp;lt;bis:Status&amp;gt;ERROR&amp;lt;/bis:Status&amp;gt;
		&amp;lt;bis:ErrorList&amp;gt;
			&amp;lt;bis:Error&amp;gt;
				&amp;lt;bis:Code&amp;gt;ERR6003&amp;lt;/bis:Code&amp;gt;
				&amp;lt;bis:Reason&amp;gt;Invalid Request Message&amp;lt;/bis:Reason&amp;gt;
				&amp;lt;bis:Service&amp;gt;
					&amp;lt;bis:Name&amp;gt;migrationauditdata_01&amp;lt;/bis:Name&amp;gt;
					&amp;lt;bis:Context&amp;gt;1&amp;lt;/bis:Context&amp;gt;
					&amp;lt;bis:Action&amp;gt;
						&amp;lt;bis:Name&amp;gt;SetPolicyDetails_Action&amp;lt;/bis:Name&amp;gt;
						&amp;lt;bis:Version&amp;gt;1&amp;lt;/bis:Version&amp;gt;
					&amp;lt;/bis:Action&amp;gt;
				&amp;lt;/bis:Service&amp;gt;
				&amp;lt;bis:DetailList&amp;gt;
					&amp;lt;bis:Detail&amp;gt;
						&amp;lt;bis:Code/&amp;gt;
						&amp;lt;bis:Text&amp;gt;Pipe [Validate tibco request] msgId [Test Tool correlation id] got invalid xml according to schema [....&amp;lt;/bis:Text&amp;gt;
					&amp;lt;/bis:Detail&amp;gt;
				&amp;lt;/bis:DetailList&amp;gt;
			&amp;lt;/bis:Error&amp;gt;
		&amp;lt;/bis:ErrorList&amp;gt;
	&amp;lt;/bis:Result&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;
 &lt;/p&gt;&lt;p&gt;
 If direction=unwrap and one of the following conditions is true a PipeRunException is thrown:
 &lt;ul&gt;&lt;li&gt;Result/Status in the response soap body equals 'ERROR'&lt;/li&gt;
 &lt;li&gt;faultcode in the response soap fault is not empty&lt;/li&gt;&lt;/ul&gt;
 &lt;/p&gt;
 &lt;p&gt;&lt;b&gt;Configuration:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setName(String) name}&lt;/td&gt;&lt;td&gt;name of the Pipe&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setDirection(String) direction}&lt;/td&gt;&lt;td&gt;either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt;&lt;/td&gt;&lt;td&gt;wrap&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setInputXPath(String) inputXPath}&lt;/td&gt;&lt;td&gt;(only used when direction=unwrap) xpath expression to extract the message which is returned. The initial message is the content of the soap body. If empty, the content of the soap body is passed (without the root body)&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setInputNamespaceDefs(String) inputNamespaceDefs}&lt;/td&gt;&lt;td&gt;(only used when direction=unwrap) namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisMessageHeaderInSoapBody(boolean) bisMessageHeaderInSoapBody}&lt;/td&gt;&lt;td&gt;when &lt;code&gt;true&lt;/code&gt;, the bis message header is put in the SOAP body instead of in the SOAP header (first one is the old bis standard)&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisMessageHeaderSessionKey(String) bisMessageHeaderSessionKey}&lt;/td&gt;&lt;td&gt;
 &lt;table&gt; 
 &lt;tr&gt;&lt;td&gt;&lt;code&gt;direction=unwrap&lt;/code&gt;&lt;/td&gt;&lt;td&gt;name of the session key to store the bis message header from the request in&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;code&gt;direction=wrap&lt;/code&gt;&lt;/td&gt;&lt;td&gt;name of the session key the original bis message header from the request is stored in; used to create the bis message header for the response&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt; 
 &lt;/td&gt;&lt;td&gt;bisMessageHeader&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisResultInPayload(boolean) bisResultInPayload}&lt;/td&gt;&lt;td&gt;when &lt;code&gt;true&lt;/code&gt;, the bis result is put in the payload (as last child in root tag) instead of in the SOAP body as sibling of the payload (last one is the old bis standard)&lt;/td&gt;&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisConversationIdSessionKey(String) bisConversationIdSessionKey}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap and the original bis message header from the request doesn't exist) key of session variable to retrieve ConversationId for the bis message header from&lt;/td&gt;&lt;td&gt;bisConversationId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisExternalRefToMessageIdSessionKey(String) bisExternalRefToMessageIdSessionKey}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap and the original bis message header from the request doesn't exist) key of session variable to retrieve ExternalRefToMessageId for the bis message header from&lt;/td&gt;&lt;td&gt;bisExternalRefToMessageId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisErrorCodeSessionKey(String) bisErrorCodeSessionKey}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap) key of session variable to store bis error code in (if an error occurs)&lt;/td&gt;&lt;td&gt;bisErrorCode&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisErrorTextSessionKey(String) bisErrorTextSessionKey}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap) key of session variable to store bis error text in (if an error occurs). If not specified or no value retrieved, the following error text is derived from the error code: 
   &lt;table border="1"&gt;
   &lt;tr&gt;&lt;th&gt;errorCode&lt;/th&gt;&lt;th&gt;errorText&lt;/th&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6002&lt;/td&gt;&lt;td&gt;Service Interface Request Time Out&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6003&lt;/td&gt;&lt;td&gt;Invalid Request Message&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6004&lt;/td&gt;&lt;td&gt;Invalid Backend system response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6005&lt;/td&gt;&lt;td&gt;Backend system failure response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6999&lt;/td&gt;&lt;td&gt;Unspecified Errors&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;&lt;/td&gt;&lt;td&gt;bisErrorText&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisErrorReasonSessionKey(String) bisErrorReasonSessionKey}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap and an error occurs) key of session variable to store bis error reason in&lt;/td&gt;&lt;td&gt;bisErrorReason&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setOutputRoot(String) outputRoot}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap and an error occurs) name of output root element in the SOAP body. If empty, the input message is used in the response&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setOutputNamespace(String) outputNamespace}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap and an error occurs) namespace of the output root element in the SOAP body&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisServiceName(String) bisServiceName}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap) name of the bis service; used in the bis error response&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisActionName(String) bisActionName}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap) name of the bis operation; used in the bis error response&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/p&gt;
 &lt;p&gt;&lt;b&gt;The following attributes are created for the purpose of the migration from IFSA to TIBCO (and will be removed afterwards):&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setRemoveOutputNamespaces(boolean) removeOutputNamespaces}&lt;/td&gt;&lt;td&gt;(only used when direction=unwrap) when set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the output are removed&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setOmitResult(boolean) omitResult}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap) when &lt;code&gt;true&lt;/code&gt;, the Result is omitted and instead of Result/Status 'ERROR' a PipeRunException is thrown&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setAddOutputNamespace(boolean) addOutputNamespace}&lt;/td&gt;&lt;td&gt;(only used when direction=unwrap) when set &lt;code&gt;true&lt;/code&gt; the &lt;code&gt;outputNamespace&lt;/code&gt; is added to the output root element in the SOAP body&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="BisWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputWrapper" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.bis.BisWrapperPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbSoapOutputWrapper">
        <xs:annotation>
          <xs:documentation>EsbSoapOutputWrapper - nl.nn.adapterframework.extensions.esb.EsbSoapWrapperPipe used as OutputWrapper

Extension to SoapWrapperPipe for separate modes.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbSoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputWrapper" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.esb.EsbSoapWrapperPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FxfOutputWrapper">
        <xs:annotation>
          <xs:documentation>FxfOutputWrapper - nl.nn.adapterframework.extensions.fxf.FxfWrapperPipe used as OutputWrapper

FxF wrapper to be used with FxF3. When receiving files (direction=unwrap)
 the message handed to the pipeline is the local filename extracted from an
 ESB SOAP message. When sending files (direction=wrap) input should be a local
 filename which will be wrapped into an ESB SOAP message. Please note: When
 writing files which need to be send through FxF they should be written to
 ${fxf.dir}/NNX00000/out. The property ${fxf.dir} will automatically be
 available on the OTAP environment (define it in StageSpecifics_LOC.properties
 only). Replace NNX00000 with the specific flowId and generate a unique
 filename (files will automatically be cleaned after 30 days or any other
 value specified by ${fxf.retention}).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FxfWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputWrapper" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.fxf.FxfWrapperPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SoapOutputWrapper">
        <xs:annotation>
          <xs:documentation>SoapOutputWrapper - nl.nn.adapterframework.soap.SoapWrapperPipe used as OutputWrapper

Pipe to wrap or unwrap a message from/into a SOAP Envelope.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputWrapper" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.soap.SoapWrapperPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="PipeElementGroup">
    <xs:choice>
      <xs:element name="Pipe">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:group ref="CacheElementGroup" />
              <xs:group ref="ChildElementGroup" />
              <xs:element ref="Forward" />
              <xs:group ref="InputValidatorElementGroup" />
              <xs:group ref="InputWrapperElementGroup" />
              <xs:group ref="ListenerElementGroup" />
              <xs:element ref="Locker" />
              <xs:group ref="ManagerElementGroup" />
              <xs:group ref="MessageLogElementGroup" />
              <xs:group ref="OutputValidatorElementGroup" />
              <xs:group ref="OutputWrapperElementGroup" />
              <xs:element ref="Param" />
              <xs:group ref="ReaderFactoryElementGroup" />
              <xs:group ref="RecordHandlerElementGroup" />
              <xs:group ref="ResultHandlerElementGroup" />
              <xs:group ref="SenderElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="PipeElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ChildElementGroup">
    <xs:choice>
      <xs:element name="Child">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:group ref="ChildElementGroup_2" />
              <xs:element ref="Flow" />
              <xs:element ref="InputFields" />
              <xs:element ref="OutputFields" />
              <xs:element ref="Param" />
              <xs:group ref="SenderElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="child" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ChildElementGroupBase_3" />
      <xs:group ref="ChildElementGroupBase_4" />
      <xs:group ref="ChildElementGroupBase_5" />
    </xs:choice>
  </xs:group>
  <xs:group name="ChildElementGroup_2">
    <xs:choice>
      <xs:element name="Child">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded" />
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="child" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="ChildElementGroupBase_3">
    <xs:choice>
      <xs:element name="RecordTransformerChild">
        <xs:annotation>
          <xs:documentation>RecordTransformerChild - nl.nn.adapterframework.batch.RecordTransformer used as Child

Translate a record using an outputFields description.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RecordTransformerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="child" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.RecordTransformer" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="RecordXml2SenderChild">
        <xs:annotation>
          <xs:documentation>RecordXml2SenderChild - nl.nn.adapterframework.batch.RecordXml2Sender used as Child

Translate a record into XML, then send it using a sender.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RecordXml2SenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="child" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.RecordXml2Sender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="RecordXmlTransformerChild">
        <xs:annotation>
          <xs:documentation>RecordXmlTransformerChild - nl.nn.adapterframework.batch.RecordXmlTransformer used as Child

Encapsulates a record in XML, optionally translates it using XSLT or XPath.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RecordXmlTransformerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="child" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.RecordXmlTransformer" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="RecordTransformerType">
    <xs:group ref="RecordTransformerPluralConfigChildGroup" />
    <xs:attributeGroup ref="RecordTransformerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:group name="RecordTransformerPluralConfigChildGroup">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="ChildElementGroup_2" />
        <xs:element ref="InputFields" />
        <xs:element ref="OutputFields" />
        <xs:element ref="Param" />
      </xs:choice>
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="RecordTransformerDeclaredAttributeGroup">
    <xs:attribute name="outputFields" type="xs:string">
      <xs:annotation>
        <xs:documentation>semicolon separated list of output record field specifications (see table below)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputSeparator" type="xs:string">
      <xs:annotation>
        <xs:documentation>optional separator to add between the fields</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="RecordTransformerCumulativeAttributeGroup">
    <xs:attributeGroup ref="RecordTransformerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractRecordHandlerDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="AbstractRecordHandlerDeclaredChildGroup">
    <xs:sequence>
      <xs:element ref="InputFields" minOccurs="0" maxOccurs="unbounded" />
      <xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="AbstractRecordHandlerDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the recordhandler</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputFields" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated specification of field lengths. if neither this attribute nor &lt;code&gt;inputSeparator&lt;/code&gt; is specified then the entire record is parsed</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputSeparator" type="xs:string">
      <xs:annotation>
        <xs:documentation>Separator that separates the fields in the input record. If neither this attribute nor &lt;code&gt;inputFields&lt;/code&gt; is specified then the entire record is parsed</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trim" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, trailing spaces are removed from each field Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fieldsDifferConditionForPrefix" type="xs:string" />
    <xs:attribute name="recordIdentifyingFields" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of numbers of those fields that are compared with the previous record to determine if a prefix must be written. if any of these fields is not equal in both records, the record types are assumed to be different</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:complexType name="RecordXml2SenderType">
    <xs:group ref="RecordXml2SenderCumulativeChildGroup" />
    <xs:attributeGroup ref="RecordXmlTransformerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:group name="RecordXml2SenderDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="SenderElementGroup" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:group name="RecordXml2SenderCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="RecordXml2SenderDeclaredChildGroup" />
      <xs:group ref="AbstractRecordHandlerDeclaredChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:complexType name="RecordXmlTransformerType">
    <xs:group ref="AbstractRecordHandlerDeclaredChildGroup" />
    <xs:attributeGroup ref="RecordXmlTransformerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="RecordXmlTransformerDeclaredAttributeGroup">
    <xs:attribute name="rootTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>Root tag for the generated xml document that will be send to the Sender Default: record</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of stylesheet to transform an individual record</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alternatively: xpath-expression to create stylesheet from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions. One entry can be without a prefix, that will define the default namespace.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>Either 'text' or 'xml'. Only valid for xpathexpression Default: text</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Force the transformer generated from the xpath-expression to omit the xml declaration Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="endOfRecord" type="xs:string">
      <xs:annotation>
        <xs:documentation>String which ends the record and must be ignored</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFields" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated string with tagnames for the individual input fields (related using there positions). if you leave a tagname empty, the field is not xml-ized</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="RecordXmlTransformerCumulativeAttributeGroup">
    <xs:attributeGroup ref="RecordXmlTransformerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractRecordHandlerDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="ChildElementGroupBase_4">
    <xs:choice>
      <xs:element name="FieldPositionChild">
        <xs:annotation>
          <xs:documentation>FieldPositionChild - nl.nn.adapterframework.batch.FieldPositionRecordHandlerManager used as Child

Manager that decides the handlers based on the content of a field in the specified 
 position in a record. The fields in the record are separated by a separator.
 The value of the specified field is taken as key in the flow-table.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FieldPositionRecordHandlerManagerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="child" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.FieldPositionRecordHandlerManager" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FixedPositionChild">
        <xs:annotation>
          <xs:documentation>FixedPositionChild - nl.nn.adapterframework.batch.FixedPositionRecordHandlerManager used as Child

Manager that decides the handlers based on the content of a field in the specified 
 position in a record. The fields in the record are of a fixed length.
 The data beween the start position and end position is taken as key in the flow-table.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FixedPositionRecordHandlerManagerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="child" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.FixedPositionRecordHandlerManager" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="FieldPositionRecordHandlerManagerType">
    <xs:group ref="RecordHandlerManagerDeclaredChildGroup" />
    <xs:attributeGroup ref="FieldPositionRecordHandlerManagerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FieldPositionRecordHandlerManagerDeclaredAttributeGroup">
    <xs:attribute name="fieldNr" type="xs:integer">
      <xs:annotation>
        <xs:documentation>position of field that identifies the recordtype (position of first field is 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="separator" type="xs:string">
      <xs:annotation>
        <xs:documentation>separator that separates the fields in the record</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FieldPositionRecordHandlerManagerCumulativeAttributeGroup">
    <xs:attributeGroup ref="FieldPositionRecordHandlerManagerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="RecordHandlerManagerDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="RecordHandlerManagerType">
    <xs:group ref="RecordHandlerManagerDeclaredChildGroup" />
    <xs:attributeGroup ref="RecordHandlerManagerDeclaredAttributeGroup" />
  </xs:complexType>
  <xs:group name="RecordHandlerManagerDeclaredChildGroup">
    <xs:sequence>
      <xs:element ref="Flow" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="RecordHandlerManagerDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the manager</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initial" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>This manager is the initial manager, i.e. to be used for the first record Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:complexType name="FixedPositionRecordHandlerManagerType">
    <xs:group ref="RecordHandlerManagerDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedPositionRecordHandlerManagerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FixedPositionRecordHandlerManagerDeclaredAttributeGroup">
    <xs:attribute name="startPosition" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Start position of the field in the record that identifies the recordtype (first character is 0) Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="endPosition" type="xs:integer">
      <xs:annotation>
        <xs:documentation>If endposition &gt;= 0 then this field contains the endPosition of the recordtype field in the record; All characters beyond this position are ignored. Else, if endPosition &lt; 0 then it depends on the length of the recordkey in the flow Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FixedPositionRecordHandlerManagerCumulativeAttributeGroup">
    <xs:attributeGroup ref="FixedPositionRecordHandlerManagerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="RecordHandlerManagerDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="ChildElementGroupBase_5">
    <xs:choice>
      <xs:element name="Result2BlobWriterChild">
        <xs:annotation>
          <xs:documentation>Result2BlobWriterChild - nl.nn.adapterframework.jdbc.Result2BlobWriter used as Child

{@link nl.nn.adapterframework.batch.IResultHandler ResultHandler} that writes the transformed record to a BLOB.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Result2BlobWriterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="child" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.Result2BlobWriter" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Result2ClobWriterChild">
        <xs:annotation>
          <xs:documentation>Result2ClobWriterChild - nl.nn.adapterframework.jdbc.Result2ClobWriter used as Child

{@link nl.nn.adapterframework.batch.IResultHandler ResultHandler} that writes the transformed record to a CLOB.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Result2ClobWriterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="child" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.Result2ClobWriter" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Result2FilewriterChild">
        <xs:annotation>
          <xs:documentation>Result2FilewriterChild - nl.nn.adapterframework.batch.Result2Filewriter used as Child

Resulthandler that writes the transformed record to a file.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Result2FilewriterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="child" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.Result2Filewriter" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Result2StringWriterChild">
        <xs:annotation>
          <xs:documentation>Result2StringWriterChild - nl.nn.adapterframework.batch.Result2StringWriter used as Child

Resulthandler that writes the transformed record to a String, that is passed to the next Pipe literally.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Result2StringWriterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="child" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.Result2StringWriter" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ResultBlock2SenderChild">
        <xs:annotation>
          <xs:documentation>ResultBlock2SenderChild - nl.nn.adapterframework.batch.ResultBlock2Sender used as Child

ResultHandler that collects a number of records and sends them together to a sender.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ResultBlock2SenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="child" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.ResultBlock2Sender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="Result2BlobWriterType">
    <xs:group ref="AbstractResultHandlerDeclaredChildGroup" />
    <xs:attributeGroup ref="Result2BlobWriterCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="Result2BlobWriterDeclaredAttributeGroup">
    <xs:attribute name="blobColumn" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Column that contains the BLOB to be updated Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is stored compressed in the database Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Charset that is used to read and write BLOBs. This assumes the blob contains character data. If blobCharset and blobSmartGet are not set, BLOBs are returned as bytes. Before version 7.6, blobs were base64 encoded after being read to accommodate for the fact that senders need to return a String. This is no longer the case</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Result2BlobWriterCumulativeAttributeGroup">
    <xs:attributeGroup ref="Result2BlobWriterDeclaredAttributeGroup" />
    <xs:attributeGroup ref="Result2LobWriterBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="AbstractResultHandlerDeclaredChildGroup">
    <xs:sequence>
      <xs:element ref="Param" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="AbstractResultHandlerDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the resulthandler</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="default" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>if set &lt;code&gt;true&lt;/code&gt;, this resulthandler is the default for all {@link recordhandlingflow flow}s that do not have a handler specified Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockByRecordType" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;(default), every group of records, as indicated by {@link IRecordHandler#isNewRecordType(PipeLineSession, boolean, List, List) RecordHandler.newRecordType} is handled as a block. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>&lt;i&gt;deprecated&lt;/i&gt; prefix that has to be written before record, if the record is in another block than the previous record</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="suffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>&lt;i&gt;deprecated&lt;/i&gt; suffix that has to be written after the record, if the record is in another block than the next record. &lt;br/&gt;n.b. if a suffix is set without a prefix, it is only used at the end of processing (i.e. at the end of the file) as a final close</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Result2LobWriterBaseDeclaredAttributeGroup">
    <xs:attribute name="query" type="xs:string">
      <xs:annotation>
        <xs:documentation>The SQL query text</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>JNDI name of datasource to be used, can be configured via jmsRealm, too Default: ${jdbc.datasource.default}</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsRealm" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="Result2LobWriterBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="Result2LobWriterBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="ResultWriterCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="ResultWriterDeclaredAttributeGroup">
    <xs:attribute name="blockNamePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>string that is replaced by name of block or name of stream in above strings Default: #name#</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onCloseBlock" type="xs:string">
      <xs:annotation>
        <xs:documentation>string that is written after the end of each logical block, as defined in the flow Default: &amp;lt;/#name#&amp;gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onCloseDocument" type="xs:string">
      <xs:annotation>
        <xs:documentation>string that is written after all data of results is written Default: &amp;lt;/document&amp;gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onOpenBlock" type="xs:string">
      <xs:annotation>
        <xs:documentation>string that is written before the start of each logical block, as defined in the flow Default: &amp;lt;#name#&amp;gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onOpenDocument" type="xs:string">
      <xs:annotation>
        <xs:documentation>string that is written before any data of results is written Default: &amp;lt;document name=&amp;quot;#name#&amp;quot;&amp;gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ResultWriterCumulativeAttributeGroup">
    <xs:attributeGroup ref="ResultWriterDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractResultHandlerDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Result2ClobWriterType">
    <xs:group ref="AbstractResultHandlerDeclaredChildGroup" />
    <xs:attributeGroup ref="Result2ClobWriterCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="Result2ClobWriterDeclaredAttributeGroup">
    <xs:attribute name="clobColumn" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Column that contains the CLOB to be updated Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Result2ClobWriterCumulativeAttributeGroup">
    <xs:attributeGroup ref="Result2ClobWriterDeclaredAttributeGroup" />
    <xs:attributeGroup ref="Result2LobWriterBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Result2FilewriterType">
    <xs:group ref="AbstractResultHandlerDeclaredChildGroup" />
    <xs:attributeGroup ref="Result2FilewriterCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="Result2FilewriterDeclaredAttributeGroup">
    <xs:attribute name="outputDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>Directory in which the resultfile must be stored</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="move2dirAfterFinalize" type="xs:string">
      <xs:annotation>
        <xs:documentation>Directory to which the created file must be moved after finalization (is optional)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filenamePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the file is created using the messageformat. Params: 1=inputfilename, 2=extension of file, 3=current date</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Result2FilewriterCumulativeAttributeGroup">
    <xs:attributeGroup ref="Result2FilewriterDeclaredAttributeGroup" />
    <xs:attributeGroup ref="ResultWriterCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Result2StringWriterType">
    <xs:group ref="AbstractResultHandlerDeclaredChildGroup" />
    <xs:attributeGroup ref="ResultWriterCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="ResultBlock2SenderType">
    <xs:group ref="ResultBlock2SenderCumulativeChildGroup" />
    <xs:attributeGroup ref="ResultWriterCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:group name="ResultBlock2SenderDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="SenderElementGroup" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:group name="ResultBlock2SenderCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="ResultBlock2SenderDeclaredChildGroup" />
      <xs:group ref="AbstractResultHandlerDeclaredChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:group name="ManagerElementGroup">
    <xs:choice>
      <xs:element name="Manager">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element ref="Flow" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="manager" />
          <xs:attribute name="className" type="xs:string" default="nl.nn.adapterframework.batch.RecordHandlerManager" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ManagerElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ManagerElementGroupBase">
    <xs:choice>
      <xs:element name="FieldPositionManager">
        <xs:annotation>
          <xs:documentation>FieldPositionManager - nl.nn.adapterframework.batch.FieldPositionRecordHandlerManager used as Manager

Manager that decides the handlers based on the content of a field in the specified 
 position in a record. The fields in the record are separated by a separator.
 The value of the specified field is taken as key in the flow-table.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FieldPositionRecordHandlerManagerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="manager" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.FieldPositionRecordHandlerManager" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FixedPositionManager">
        <xs:annotation>
          <xs:documentation>FixedPositionManager - nl.nn.adapterframework.batch.FixedPositionRecordHandlerManager used as Manager

Manager that decides the handlers based on the content of a field in the specified 
 position in a record. The fields in the record are of a fixed length.
 The data beween the start position and end position is taken as key in the flow-table.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FixedPositionRecordHandlerManagerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="manager" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.FixedPositionRecordHandlerManager" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="ReaderFactoryElementGroup">
    <xs:choice>
      <xs:element name="ReaderFactory">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded" />
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="readerFactory" />
          <xs:attribute name="className" type="xs:string" default="nl.nn.adapterframework.batch.InputStreamReaderFactory" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ReaderFactoryElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ReaderFactoryElementGroupBase">
    <xs:choice>
      <xs:element name="DelphiStringRecordReaderFactoryReaderFactory">
        <xs:annotation>
          <xs:documentation>DelphiStringRecordReaderFactoryReaderFactory - nl.nn.adapterframework.batch.DelphiStringRecordReaderFactory used as ReaderFactory

{@link IInputStreamReaderFactory} that provides a reader that reads Delphi records containing Strings.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DelphiStringRecordReaderFactoryType">
              <xs:attribute name="elementRole" type="xs:string" fixed="readerFactory" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.DelphiStringRecordReaderFactory" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="DelphiStringRecordReaderFactoryType">
    <xs:attributeGroup ref="DelphiStringRecordReaderFactoryDeclaredAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="DelphiStringRecordReaderFactoryDeclaredAttributeGroup">
    <xs:attribute name="separator" type="xs:string">
      <xs:annotation>
        <xs:documentation>separator placed between each string read Default: |</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="separatorReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>replacement character, used when separator is found in string read Default: _</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stringLength" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the maximum length of each string. each string is preceded by a one byte length indication. Default: 50</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stringsPerRecord" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the number of strings read for each record. 0 means file consists of one logical record Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:group name="RecordHandlerElementGroup">
    <xs:choice>
      <xs:element name="RecordHandler">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:group ref="ChildElementGroup_2" />
              <xs:element ref="InputFields" />
              <xs:element ref="OutputFields" />
              <xs:element ref="Param" />
              <xs:group ref="SenderElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="recordHandler" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="RecordHandlerElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="RecordHandlerElementGroupBase">
    <xs:choice>
      <xs:element name="RecordTransformerRecordHandler">
        <xs:annotation>
          <xs:documentation>RecordTransformerRecordHandler - nl.nn.adapterframework.batch.RecordTransformer used as RecordHandler

Translate a record using an outputFields description.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RecordTransformerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="recordHandler" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.RecordTransformer" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="RecordXml2SenderRecordHandler">
        <xs:annotation>
          <xs:documentation>RecordXml2SenderRecordHandler - nl.nn.adapterframework.batch.RecordXml2Sender used as RecordHandler

Translate a record into XML, then send it using a sender.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RecordXml2SenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="recordHandler" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.RecordXml2Sender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="RecordXmlTransformerRecordHandler">
        <xs:annotation>
          <xs:documentation>RecordXmlTransformerRecordHandler - nl.nn.adapterframework.batch.RecordXmlTransformer used as RecordHandler

Encapsulates a record in XML, optionally translates it using XSLT or XPath.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RecordXmlTransformerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="recordHandler" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.RecordXmlTransformer" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="ResultHandlerElementGroup">
    <xs:choice>
      <xs:element name="ResultHandler">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element ref="Param" />
              <xs:group ref="SenderElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="resultHandler" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ResultHandlerElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ResultHandlerElementGroupBase">
    <xs:choice>
      <xs:element name="Result2BlobWriterResultHandler">
        <xs:annotation>
          <xs:documentation>Result2BlobWriterResultHandler - nl.nn.adapterframework.jdbc.Result2BlobWriter used as ResultHandler

{@link nl.nn.adapterframework.batch.IResultHandler ResultHandler} that writes the transformed record to a BLOB.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Result2BlobWriterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="resultHandler" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.Result2BlobWriter" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Result2ClobWriterResultHandler">
        <xs:annotation>
          <xs:documentation>Result2ClobWriterResultHandler - nl.nn.adapterframework.jdbc.Result2ClobWriter used as ResultHandler

{@link nl.nn.adapterframework.batch.IResultHandler ResultHandler} that writes the transformed record to a CLOB.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Result2ClobWriterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="resultHandler" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.Result2ClobWriter" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Result2FilewriterResultHandler">
        <xs:annotation>
          <xs:documentation>Result2FilewriterResultHandler - nl.nn.adapterframework.batch.Result2Filewriter used as ResultHandler

Resulthandler that writes the transformed record to a file.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Result2FilewriterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="resultHandler" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.Result2Filewriter" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Result2StringWriterResultHandler">
        <xs:annotation>
          <xs:documentation>Result2StringWriterResultHandler - nl.nn.adapterframework.batch.Result2StringWriter used as ResultHandler

Resulthandler that writes the transformed record to a String, that is passed to the next Pipe literally.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Result2StringWriterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="resultHandler" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.Result2StringWriter" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ResultBlock2SenderResultHandler">
        <xs:annotation>
          <xs:documentation>ResultBlock2SenderResultHandler - nl.nn.adapterframework.batch.ResultBlock2Sender used as ResultHandler

ResultHandler that collects a number of records and sends them together to a sender.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ResultBlock2SenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="resultHandler" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.ResultBlock2Sender" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="PipeElementGroupBase">
    <xs:choice>
      <xs:element name="Adios2XmlPipe">
        <xs:annotation>
          <xs:documentation>Adios2XmlPipe - nl.nn.adapterframework.extensions.rekenbox.Adios2XmlPipe used as Pipe

Transforms between ascii-ADIOS and an XML representation of ADIOS.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Adios2XmlPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.rekenbox.Adios2XmlPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ApiPrincipalPipe">
        <xs:annotation>
          <xs:documentation>ApiPrincipalPipe - nl.nn.adapterframework.http.rest.ApiPrincipalPipe used as Pipe

Pipe to manage the ApiPrincipal handling</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ApiPrincipalPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.http.rest.ApiPrincipalPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ApiSoapWrapperPipe">
        <xs:annotation>
          <xs:documentation>ApiSoapWrapperPipe - nl.nn.adapterframework.extensions.api.ApiSoapWrapperPipe used as Pipe

Extension to SoapWrapperPipe for API Management.
 &lt;p&gt;
 &lt;b&gt;Configuration &lt;/b&gt;&lt;i&gt;(where deviating from SoapWrapperPipe)&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setSoapHeaderSessionKey(String) soapHeaderSessionKey}&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt;: &lt;/td&gt;&lt;td&gt;soapHeader&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setSoapHeaderStyleSheet(String) soapHeaderStyleSheet}&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt;: &lt;/td&gt;&lt;td&gt;/xml/xsl/api/soapHeader.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;p&gt;
 &lt;b&gt;/xml/xsl/api/soapHeader.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;&lt;code&gt;MessageHeader&lt;/code&gt; is only created when $conversationId is filled (otherwise skipped)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&lt;code&gt;From&lt;/code&gt; is only created when $from_in is filled (otherwise skipped) and it's created with the value of $from_out&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$conversationId&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://api.nn.nl/MessageHeader"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;from_in&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;from_out&lt;/td&gt;&lt;td&gt;property 'instance.name'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;conversationId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ApiSoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.api.ApiSoapWrapperPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ApiStreamPipe">
        <xs:annotation>
          <xs:documentation>ApiStreamPipe - nl.nn.adapterframework.extensions.api.ApiStreamPipe used as Pipe

Extension to StreamPipe for API Management.
 &lt;p&gt;
 In {@link nl.nn.adapterframework.pipes.StreamPipe} for parameter &lt;code&gt;httpRequest&lt;/code&gt; and attribute 
 &lt;code&gt;extractFirstStringPart=true&lt;/code&gt; the first part is returned to the pipeline.
 In this class the first part is checked. If it contains a 'MessageID' with namespace "http://www.w3.org/2005/08/addressing",
 then the message to return to the pipeline is retrieved from the MessageStore.
 &lt;p&gt;
 This class is created for applications which can not perform one multipart call with a business request in the first (string) part
 and one or more filestreams in the next (file) parts. Instead of one multipart call, two calls are performed:
 &lt;ol&gt;
    &lt;li&gt;text/xml call with the business request. The API Management application returns on this call an unique messageId (which is
     saved in the MessageStore together with the business request)&lt;/li&gt;
    &lt;li&gt;multipart call with in the first (string) part the unique messageId and in the following (file) parts the filestreams&lt;/li&gt;
 &lt;/ol&gt;
 &lt;p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ApiStreamPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.api.ApiStreamPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ApiWsdlXmlValidatorPipe">
        <xs:annotation>
          <xs:documentation>ApiWsdlXmlValidatorPipe - nl.nn.adapterframework.extensions.api.ApiWsdlXmlValidator used as Pipe

Extension to WsdlXmlValidator for API Management.
 &lt;p&gt;
 &lt;b&gt;Configuration &lt;/b&gt;&lt;i&gt;(where deviating from WsdlXmlValidator)&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setMultipart(boolean) boolean}&lt;/td&gt;&lt;td&gt;indicates whether the message is multipart/form-data. If so, the wsdl only represents the first part, other parts are attachments. This attribute is only used for generating the 'real' wsdl which is available in the ibis console (../rest/webservices)&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;p&gt;
 The SOAP header can only contain the following schema (or it's empty):
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;mandatory&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;xmlns="http://api.nn.nl/MessageHeader"&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;no&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ApiWsdlXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.api.ApiWsdlXmlValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Base64Pipe">
        <xs:annotation>
          <xs:documentation>Base64Pipe - nl.nn.adapterframework.pipes.Base64Pipe used as Pipe

Pipe that performs base64 encoding and decoding.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Base64PipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.Base64Pipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="BatchBlobTransformerPipe">
        <xs:annotation>
          <xs:documentation>BatchBlobTransformerPipe - nl.nn.adapterframework.jdbc.BatchBlobTransformerPipe used as Pipe

Pipe that batch-transforms the lines in a CLOB.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="BatchBlobTransformerPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.BatchBlobTransformerPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="BatchClobTransformerPipe">
        <xs:annotation>
          <xs:documentation>BatchClobTransformerPipe - nl.nn.adapterframework.jdbc.BatchClobTransformerPipe used as Pipe

Pipe that batch-transforms the lines in a CLOB.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="BatchClobTransformerPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.BatchClobTransformerPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="BatchFileTransformerPipe">
        <xs:annotation>
          <xs:documentation>BatchFileTransformerPipe - nl.nn.adapterframework.batch.BatchFileTransformerPipe used as Pipe

Pipe for transforming a (batch)file with records. Records in the file must be separated
 with new line characters.
 You can use the &amp;lt;child&amp;gt; tag to register RecordHandlers, RecordHandlerManagers, ResultHandlers
 and RecordHandlingFlow elements. This is deprecated, however. Since 4.7 one should use &amp;lt;manager&amp;gt;,
 &amp;lt;recordHandler&amp;gt;, &amp;lt;resultHandler&amp;gt; and &amp;lt;flow&amp;gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="BatchFileTransformerPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.BatchFileTransformerPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="BisWrapperPipe">
        <xs:annotation>
          <xs:documentation>BisWrapperPipe - nl.nn.adapterframework.extensions.bis.BisWrapperPipe used as Pipe

Pipe to wrap or unwrap a message conformable to the BIS (Business Integration Services) standard.
 &lt;p&gt;
 Example request in case of bis provider:&lt;br/&gt;&lt;code&gt;&lt;pre&gt;
	&amp;lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;
		&amp;lt;soap:Header&amp;gt;
			&amp;lt;bis:MessageHeader xmlns:bis="http://www.ing.com/CSP/XSD/General/Message_2"&amp;gt;
				&amp;lt;bis:From&amp;gt;
					&amp;lt;bis:Id&amp;gt;PolicyConversion_01_ServiceAgents_01&amp;lt;/bis:Id&amp;gt;
				&amp;lt;/bis:From&amp;gt;
				&amp;lt;bis:HeaderFields&amp;gt;
					&amp;lt;bis:ConversationId&amp;gt;1790257_10000050_04&amp;lt;/bis:ConversationId&amp;gt;
					&amp;lt;bis:MessageId&amp;gt;1790257&amp;lt;/bis:MessageId&amp;gt;
					&amp;lt;bis:Timestamp&amp;gt;2011-03-02T10:26:31.464+01:00&amp;lt;/bis:Timestamp&amp;gt;
				&amp;lt;/bis:HeaderFields&amp;gt;
			&amp;lt;/bis:MessageHeader&amp;gt;
		&amp;lt;/soap:Header&amp;gt;
		&amp;lt;soap:Body&amp;gt;
			&lt;i&gt;&amp;lt;pcr:GetRequest xmlns:pcr="http://www.ing.com/nl/pcretail/ts/migrationauditdata_01"&amp;gt;
				&amp;lt;pcr:PolicyDetails&amp;gt;
					&amp;lt;pcr:RVS_PARTY_ID&amp;gt;1790257&amp;lt;/pcr:RVS_PARTY_ID&amp;gt;
					&amp;lt;pcr:RVS_POLICY_NUMBER&amp;gt;10000050&amp;lt;/pcr:RVS_POLICY_NUMBER&amp;gt;
					&amp;lt;pcr:RVS_BRANCH_CODE&amp;gt;04&amp;lt;/pcr:RVS_BRANCH_CODE&amp;gt;
				&amp;lt;/pcr:PolicyDetails&amp;gt;
			&amp;lt;/pcr:GetRequest&amp;gt;&lt;/i&gt;
		&amp;lt;/soap:Body&amp;gt;
	&amp;lt;/soap:Envelope&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;&lt;br/&gt;
 The element MessageHeader in the soap header is mandatory.
 &lt;/p&gt;&lt;p&gt;
 Example response in case of bis requester:&lt;br/&gt;&lt;code&gt;&lt;pre&gt;
	&amp;lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;
		&amp;lt;soap:Header&amp;gt;
			&amp;lt;bis:MessageHeader xmlns:bis="http://www.ing.com/CSP/XSD/General/Message_2"&amp;gt;
				&amp;lt;bis:From&amp;gt;
					&amp;lt;bis:Id&amp;gt;IJA_DB4CONV&amp;lt;/bis:Id&amp;gt;
				&amp;lt;/bis:From&amp;gt;
				&amp;lt;bis:HeaderFields&amp;gt;
					&amp;lt;bis:ConversationId&amp;gt;1790257_10000050_04&amp;lt;/bis:ConversationId&amp;gt;
					&amp;lt;bis:MessageId&amp;gt;rn09ce_0a3b8d2d--33192359_12e588118c1_-612f&amp;lt;/bis:MessageId&amp;gt;
					&amp;lt;bis:ExternalRefToMessageId&amp;gt;1790257&amp;lt;/bis:ExternalRefToMessageId&amp;gt;
					&amp;lt;bis:Timestamp&amp;gt;2011-03-02T10:26:31&amp;lt;/bis:Timestamp&amp;gt;
				&amp;lt;/bis:HeaderFields&amp;gt;
			&amp;lt;/bis:MessageHeader&amp;gt;
		&amp;lt;/soap:Header&amp;gt;
		&amp;lt;soap:Body&amp;gt;
			&lt;i&gt;&amp;lt;GetResponse xmlns="http://www.ing.com/nl/pcretail/ts/migrationcasedata_01"&amp;gt;&lt;/i&gt;
				&lt;i&gt;&amp;lt;CaseData&amp;gt;...&amp;lt;/CaseData&amp;gt;&lt;/i&gt;
				&amp;lt;bis:Result xmlns:bis="http://www.ing.com/CSP/XSD/General/Message_2"&amp;gt;
					&amp;lt;bis:Status&amp;gt;OK&amp;lt;/bis:Status&amp;gt;
				&amp;lt;/bis:Result&amp;gt;
			&lt;i&gt;&amp;lt;/GetResponse&amp;gt;&lt;/i&gt;
		&amp;lt;/soap:Body&amp;gt;
	&amp;lt;/soap:Envelope&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;&lt;br/&gt;
 The elements MessageHeader in the soap header and Result in the soap body are mandatory.
 &lt;/p&gt;&lt;p&gt;
 Example element Result in case of an error response:&lt;br/&gt;&lt;code&gt;&lt;pre&gt;
	&amp;lt;bis:Result xmlns:bis="http://www.ing.com/CSP/XSD/General/Message_2"&amp;gt;
		&amp;lt;bis:Status&amp;gt;ERROR&amp;lt;/bis:Status&amp;gt;
		&amp;lt;bis:ErrorList&amp;gt;
			&amp;lt;bis:Error&amp;gt;
				&amp;lt;bis:Code&amp;gt;ERR6003&amp;lt;/bis:Code&amp;gt;
				&amp;lt;bis:Reason&amp;gt;Invalid Request Message&amp;lt;/bis:Reason&amp;gt;
				&amp;lt;bis:Service&amp;gt;
					&amp;lt;bis:Name&amp;gt;migrationauditdata_01&amp;lt;/bis:Name&amp;gt;
					&amp;lt;bis:Context&amp;gt;1&amp;lt;/bis:Context&amp;gt;
					&amp;lt;bis:Action&amp;gt;
						&amp;lt;bis:Name&amp;gt;SetPolicyDetails_Action&amp;lt;/bis:Name&amp;gt;
						&amp;lt;bis:Version&amp;gt;1&amp;lt;/bis:Version&amp;gt;
					&amp;lt;/bis:Action&amp;gt;
				&amp;lt;/bis:Service&amp;gt;
				&amp;lt;bis:DetailList&amp;gt;
					&amp;lt;bis:Detail&amp;gt;
						&amp;lt;bis:Code/&amp;gt;
						&amp;lt;bis:Text&amp;gt;Pipe [Validate tibco request] msgId [Test Tool correlation id] got invalid xml according to schema [....&amp;lt;/bis:Text&amp;gt;
					&amp;lt;/bis:Detail&amp;gt;
				&amp;lt;/bis:DetailList&amp;gt;
			&amp;lt;/bis:Error&amp;gt;
		&amp;lt;/bis:ErrorList&amp;gt;
	&amp;lt;/bis:Result&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;
 &lt;/p&gt;&lt;p&gt;
 If direction=unwrap and one of the following conditions is true a PipeRunException is thrown:
 &lt;ul&gt;&lt;li&gt;Result/Status in the response soap body equals 'ERROR'&lt;/li&gt;
 &lt;li&gt;faultcode in the response soap fault is not empty&lt;/li&gt;&lt;/ul&gt;
 &lt;/p&gt;
 &lt;p&gt;&lt;b&gt;Configuration:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setName(String) name}&lt;/td&gt;&lt;td&gt;name of the Pipe&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setDirection(String) direction}&lt;/td&gt;&lt;td&gt;either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt;&lt;/td&gt;&lt;td&gt;wrap&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setInputXPath(String) inputXPath}&lt;/td&gt;&lt;td&gt;(only used when direction=unwrap) xpath expression to extract the message which is returned. The initial message is the content of the soap body. If empty, the content of the soap body is passed (without the root body)&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setInputNamespaceDefs(String) inputNamespaceDefs}&lt;/td&gt;&lt;td&gt;(only used when direction=unwrap) namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisMessageHeaderInSoapBody(boolean) bisMessageHeaderInSoapBody}&lt;/td&gt;&lt;td&gt;when &lt;code&gt;true&lt;/code&gt;, the bis message header is put in the SOAP body instead of in the SOAP header (first one is the old bis standard)&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisMessageHeaderSessionKey(String) bisMessageHeaderSessionKey}&lt;/td&gt;&lt;td&gt;
 &lt;table&gt; 
 &lt;tr&gt;&lt;td&gt;&lt;code&gt;direction=unwrap&lt;/code&gt;&lt;/td&gt;&lt;td&gt;name of the session key to store the bis message header from the request in&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;code&gt;direction=wrap&lt;/code&gt;&lt;/td&gt;&lt;td&gt;name of the session key the original bis message header from the request is stored in; used to create the bis message header for the response&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt; 
 &lt;/td&gt;&lt;td&gt;bisMessageHeader&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisResultInPayload(boolean) bisResultInPayload}&lt;/td&gt;&lt;td&gt;when &lt;code&gt;true&lt;/code&gt;, the bis result is put in the payload (as last child in root tag) instead of in the SOAP body as sibling of the payload (last one is the old bis standard)&lt;/td&gt;&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisConversationIdSessionKey(String) bisConversationIdSessionKey}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap and the original bis message header from the request doesn't exist) key of session variable to retrieve ConversationId for the bis message header from&lt;/td&gt;&lt;td&gt;bisConversationId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisExternalRefToMessageIdSessionKey(String) bisExternalRefToMessageIdSessionKey}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap and the original bis message header from the request doesn't exist) key of session variable to retrieve ExternalRefToMessageId for the bis message header from&lt;/td&gt;&lt;td&gt;bisExternalRefToMessageId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisErrorCodeSessionKey(String) bisErrorCodeSessionKey}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap) key of session variable to store bis error code in (if an error occurs)&lt;/td&gt;&lt;td&gt;bisErrorCode&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisErrorTextSessionKey(String) bisErrorTextSessionKey}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap) key of session variable to store bis error text in (if an error occurs). If not specified or no value retrieved, the following error text is derived from the error code: 
   &lt;table border="1"&gt;
   &lt;tr&gt;&lt;th&gt;errorCode&lt;/th&gt;&lt;th&gt;errorText&lt;/th&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6002&lt;/td&gt;&lt;td&gt;Service Interface Request Time Out&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6003&lt;/td&gt;&lt;td&gt;Invalid Request Message&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6004&lt;/td&gt;&lt;td&gt;Invalid Backend system response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6005&lt;/td&gt;&lt;td&gt;Backend system failure response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6999&lt;/td&gt;&lt;td&gt;Unspecified Errors&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;&lt;/td&gt;&lt;td&gt;bisErrorText&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisErrorReasonSessionKey(String) bisErrorReasonSessionKey}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap and an error occurs) key of session variable to store bis error reason in&lt;/td&gt;&lt;td&gt;bisErrorReason&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setOutputRoot(String) outputRoot}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap and an error occurs) name of output root element in the SOAP body. If empty, the input message is used in the response&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setOutputNamespace(String) outputNamespace}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap and an error occurs) namespace of the output root element in the SOAP body&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisServiceName(String) bisServiceName}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap) name of the bis service; used in the bis error response&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setBisActionName(String) bisActionName}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap) name of the bis operation; used in the bis error response&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/p&gt;
 &lt;p&gt;&lt;b&gt;The following attributes are created for the purpose of the migration from IFSA to TIBCO (and will be removed afterwards):&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setRemoveOutputNamespaces(boolean) removeOutputNamespaces}&lt;/td&gt;&lt;td&gt;(only used when direction=unwrap) when set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the output are removed&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setOmitResult(boolean) omitResult}&lt;/td&gt;&lt;td&gt;(only used when direction=wrap) when &lt;code&gt;true&lt;/code&gt;, the Result is omitted and instead of Result/Status 'ERROR' a PipeRunException is thrown&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setAddOutputNamespace(boolean) addOutputNamespace}&lt;/td&gt;&lt;td&gt;(only used when direction=unwrap) when set &lt;code&gt;true&lt;/code&gt; the &lt;code&gt;outputNamespace&lt;/code&gt; is added to the output root element in the SOAP body&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="BisWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.bis.BisWrapperPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="BlobLineIteratingPipe">
        <xs:annotation>
          <xs:documentation>BlobLineIteratingPipe - nl.nn.adapterframework.jdbc.BlobLineIteratingPipe used as Pipe

Pipe that iterates over the lines in a blob.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="BlobLineIteratingPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.BlobLineIteratingPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="BytesOutputPipe">
        <xs:annotation>
          <xs:documentation>BytesOutputPipe - nl.nn.adapterframework.pipes.BytesOutputPipe used as Pipe

Output bytes as specified by the input XML.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="BytesOutputPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.BytesOutputPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ChecksumPipe">
        <xs:annotation>
          <xs:documentation>ChecksumPipe - nl.nn.adapterframework.pipes.ChecksumPipe used as Pipe

Pipe to calculate checksum on input.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ChecksumPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.ChecksumPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CleanupOldFilesPipe">
        <xs:annotation>
          <xs:documentation>CleanupOldFilesPipe - nl.nn.adapterframework.pipes.CleanupOldFilesPipe used as Pipe

Pipe for deleting files.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CleanupOldFilesPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.CleanupOldFilesPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ClobLineIteratingPipe">
        <xs:annotation>
          <xs:documentation>ClobLineIteratingPipe - nl.nn.adapterframework.jdbc.ClobLineIteratingPipe used as Pipe

Pipe that iterates over the lines in a clob.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ClobLineIteratingPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.ClobLineIteratingPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CompareIntegerPipe">
        <xs:annotation>
          <xs:documentation>CompareIntegerPipe - nl.nn.adapterframework.pipes.CompareIntegerPipe used as Pipe

Pipe that compares the two integer values read from {@link Parameter the parameters} &lt;code&gt;operand1&lt;/code&gt; and &lt;code&gt;operand2&lt;/code&gt;.
 If one of the parameters is missing then the input message will be used as the missing operand.
 This pipe can be used in combination with {@link IncreaseIntegerPipe} to construct loops.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CompareIntegerPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.CompareIntegerPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CompareStringPipe">
        <xs:annotation>
          <xs:documentation>CompareStringPipe - nl.nn.adapterframework.pipes.CompareStringPipe used as Pipe

Pipe that compares lexicographically two strings.
 &lt;table&gt;
 &lt;tr&gt;&lt;th&gt;nested elements&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link Parameter param}&lt;/td&gt;&lt;td&gt;the parameters &lt;code&gt;operand1&lt;/code&gt; and &lt;code&gt;operand2&lt;/code&gt; are compared. If one of these parameters doesn't exist the input message is taken.
 If parameter &lt;code&gt;ignorepatterns&lt;/code&gt; exists it contains a xml table with references to substrings which have to be ignored during the comparison. This xml table has the following layout:
 &lt;br/&gt;&lt;code&gt;&lt;pre&gt;
	&amp;lt;ignores&amp;gt;
		&amp;lt;ignore&amp;gt;
			&amp;lt;after&amp;gt;...&amp;lt;/after&amp;gt;
			&amp;lt;before&amp;gt;...&amp;lt;/before&amp;gt;
		&amp;lt;/ignore&amp;gt;
		&amp;lt;ignore&amp;gt;
			&amp;lt;after&amp;gt;...&amp;lt;/after&amp;gt;
			&amp;lt;before&amp;gt;...&amp;lt;/before&amp;gt;
		&amp;lt;/ignore&amp;gt;
	&amp;lt;/ignores&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;&lt;br/&gt;Substrings between "after" and "before" are ignored&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;
 &lt;p&gt;&lt;b&gt;Exits:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;state&lt;/th&gt;&lt;th&gt;condition&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;lessthan&lt;/td&gt;&lt;td&gt;when v1 &amp;lt; v2&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;greaterthan&lt;/td&gt;&lt;td&gt;when v1 &amp;gt; v2&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;equals&lt;/td&gt;&lt;td&gt;when v1 = v2&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CompareStringPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.CompareStringPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CompressPipe">
        <xs:annotation>
          <xs:documentation>CompressPipe - nl.nn.adapterframework.pipes.CompressPipe used as Pipe

Pipe to zip or unzip a message or file.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CompressPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.CompressPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CounterSwitchPipe">
        <xs:annotation>
          <xs:documentation>CounterSwitchPipe - nl.nn.adapterframework.pipes.CounterSwitchPipe used as Pipe

Selects an exitState, based on the number of received messages by this pipe.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CounterSwitchPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.CounterSwitchPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CredentialCheckingPipe">
        <xs:annotation>
          <xs:documentation>CredentialCheckingPipe - nl.nn.adapterframework.pipes.CredentialCheckingPipe used as Pipe

Pipe to check the the CredentialFactory (for testing only).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CredentialCheckingPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.CredentialCheckingPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CrlPipe">
        <xs:annotation>
          <xs:documentation>CrlPipe - nl.nn.adapterframework.pipes.CrlPipe used as Pipe

Pipe that reads a CRL from an input stream and transforms it to an XML.
 The steam is closed after reading.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CrlPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.CrlPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CsvParserPipe">
        <xs:annotation>
          <xs:documentation>CsvParserPipe - nl.nn.adapterframework.pipes.CsvParserPipe used as Pipe</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CsvParserPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.CsvParserPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DelayPipe">
        <xs:annotation>
          <xs:documentation>DelayPipe - nl.nn.adapterframework.pipes.DelayPipe used as Pipe

Pipe that sleeps for a specified time, which defaults to 5000 msecs.
 Usefull for testing purposes.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DelayPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.DelayPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DigesterPipe">
        <xs:annotation>
          <xs:documentation>DigesterPipe - nl.nn.adapterframework.pipes.DigesterPipe used as Pipe

Converts an XML string (input) to a set of java objects using the
 &lt;a href="http://jakarta.apache.org/commons/digester"&gt;digester&lt;/a&gt;.
 &lt;p&gt;The result is an anonymous object. Your digester-rules file should specify
 how the xml file is parsed, and what the root object will be.&lt;/p&gt;
 &lt;p&gt;&lt;b&gt;Exits:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;state&lt;/th&gt;&lt;th&gt;condition&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;"success"&lt;/td&gt;&lt;td&gt;default&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DigesterPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.DigesterPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DirectWrapperPipe">
        <xs:annotation>
          <xs:documentation>DirectWrapperPipe - nl.nn.adapterframework.extensions.esb.DirectWrapperPipe used as Pipe

Kind of extension to EsbSoapWrapperPipe for real time destinations.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DirectWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.esb.DirectWrapperPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DomainTransformerPipe">
        <xs:annotation>
          <xs:documentation>DomainTransformerPipe - nl.nn.adapterframework.pipes.DomainTransformerPipe used as Pipe

Pipe that performs domain transforming on the basis of a database table.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DomainTransformerPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.DomainTransformerPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EchoPipe">
        <xs:annotation>
          <xs:documentation>EchoPipe - nl.nn.adapterframework.pipes.EchoPipe used as Pipe

Returns simply the input message.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EchoPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.EchoPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbSoapValidatorPipe">
        <xs:annotation>
          <xs:documentation>EsbSoapValidatorPipe - nl.nn.adapterframework.extensions.esb.EsbSoapValidator used as Pipe

XmlValidator that will automatically add the SOAP envelope XSD and the ESB
 XSD (e.g. CommonMessageHeader.xsd) to the set of XSD's used for validation.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbSoapValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.esb.EsbSoapValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbSoapWrapperPipe">
        <xs:annotation>
          <xs:documentation>EsbSoapWrapperPipe - nl.nn.adapterframework.extensions.esb.EsbSoapWrapperPipe used as Pipe

Extension to SoapWrapperPipe for separate modes.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbSoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.esb.EsbSoapWrapperPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EscapePipe">
        <xs:annotation>
          <xs:documentation>EscapePipe - nl.nn.adapterframework.pipes.EscapePipe used as Pipe

Pipe that performs translations between special characters and their xml equivalents.
 &lt;p&gt;When direction=cdata2text all cdata nodes are converted to text nodes without any other translations.&lt;/p&gt;
 &lt;p&gt;&lt;b&gt;Exits:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;state&lt;/th&gt;&lt;th&gt;condition&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;"success"&lt;/td&gt;&lt;td&gt;default&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EscapePipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.EscapePipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EtagHandlerPipe">
        <xs:annotation>
          <xs:documentation>EtagHandlerPipe - nl.nn.adapterframework.pipes.EtagHandlerPipe used as Pipe

Pipe to manage RESTFUL etag caching</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EtagHandlerPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.EtagHandlerPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ExceptionPipe">
        <xs:annotation>
          <xs:documentation>ExceptionPipe - nl.nn.adapterframework.pipes.ExceptionPipe used as Pipe

Pipe that throws an exception, based on the input message.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ExceptionPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.ExceptionPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ExecuteJdbcPropertiesPipe">
        <xs:annotation>
          <xs:documentation>ExecuteJdbcPropertiesPipe - nl.nn.adapterframework.webcontrol.pipes.ExecuteJdbcProperties used as Pipe

Execute (insert, update and delete) jdbc properties.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ExecuteJdbcPropertiesType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.webcontrol.pipes.ExecuteJdbcProperties" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FileLineIteratorPipe">
        <xs:annotation>
          <xs:documentation>FileLineIteratorPipe - nl.nn.adapterframework.pipes.FileLineIteratorPipe used as Pipe

Sends a message to a Sender for each line of the file that the input message refers to.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FileLineIteratorPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.FileLineIteratorPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FilePipe">
        <xs:annotation>
          <xs:documentation>FilePipe - nl.nn.adapterframework.pipes.FilePipe used as Pipe

&lt;p&gt;See {@link FileHandler}&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FilePipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.FilePipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FileSystemPipe">
        <xs:annotation>
          <xs:documentation>FileSystemPipe - nl.nn.adapterframework.filesystem.FileSystemPipe used as Pipe

Base class for Pipes that use a {@link IBasicFileSystem FileSystem}.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FileSystemPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.filesystem.FileSystemPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FilenameSwitchPipe">
        <xs:annotation>
          <xs:documentation>FilenameSwitchPipe - nl.nn.adapterframework.pipes.FilenameSwitch used as Pipe

Selects an exitState, based on the last (filename) part of the path that is the input.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FilenameSwitchType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.FilenameSwitch" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FixedResultPipe">
        <xs:annotation>
          <xs:documentation>FixedResultPipe - nl.nn.adapterframework.pipes.FixedResultPipe used as Pipe

Provides an example of a pipe. It may return the contents of a file
 (in the classpath) when &lt;code&gt;fileName&lt;/code&gt; or &lt;code&gt;fileNameSessionKey&lt;/code&gt; is specified, otherwise the
 input of &lt;code&gt;returnString&lt;/code&gt; is returned.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FixedResultPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.FixedResultPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ForEachAttachmentPipe">
        <xs:annotation>
          <xs:documentation>ForEachAttachmentPipe - nl.nn.adapterframework.filesystem.ForEachAttachmentPipe used as Pipe</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ForEachAttachmentPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.filesystem.ForEachAttachmentPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ForEachChildElementPipe">
        <xs:annotation>
          <xs:documentation>ForEachChildElementPipe - nl.nn.adapterframework.pipes.ForEachChildElementPipe used as Pipe

Sends a message to a Sender for each child element of the input XML.
 Input can be a String containing XML, a filename (set processFile true), an InputStream or a Reader.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ForEachChildElementPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.ForEachChildElementPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FtpFileRetrieverPipe">
        <xs:annotation>
          <xs:documentation>FtpFileRetrieverPipe - nl.nn.adapterframework.ftp.FtpFileRetrieverPipe used as Pipe

Pipe for retreiving files via (s)ftp. The path of the created local file is returned.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FtpFileRetrieverPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.ftp.FtpFileRetrieverPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FxfWrapperPipe">
        <xs:annotation>
          <xs:documentation>FxfWrapperPipe - nl.nn.adapterframework.extensions.fxf.FxfWrapperPipe used as Pipe

FxF wrapper to be used with FxF3. When receiving files (direction=unwrap)
 the message handed to the pipeline is the local filename extracted from an
 ESB SOAP message. When sending files (direction=wrap) input should be a local
 filename which will be wrapped into an ESB SOAP message. Please note: When
 writing files which need to be send through FxF they should be written to
 ${fxf.dir}/NNX00000/out. The property ${fxf.dir} will automatically be
 available on the OTAP environment (define it in StageSpecifics_LOC.properties
 only). Replace NNX00000 with the specific flowId and generate a unique
 filename (files will automatically be cleaned after 30 days or any other
 value specified by ${fxf.retention}).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FxfWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.fxf.FxfWrapperPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FxfXmlValidatorPipe">
        <xs:annotation>
          <xs:documentation>FxfXmlValidatorPipe - nl.nn.adapterframework.extensions.fxf.FxfXmlValidator used as Pipe

FxF XML validator to be used with FxF3. When receiving files
 (direction=receive) the message is validated against the
 OnCompletedTransferNotify WSDL (a P2P connection, hence same WSDL (provided
 by Tibco) for all queues (every Ibis receiving FxF files has it's own
 queue)). When sending files (direction=send) the message is validated against
 the StartTransfer WSDL (ESB service provided by Tibco).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FxfXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.fxf.FxfXmlValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="GenericMessageSendingPipe">
        <xs:annotation>
          <xs:documentation>GenericMessageSendingPipe - nl.nn.adapterframework.pipes.GenericMessageSendingPipe used as Pipe

Plain extension to {@link MessageSendingPipe} that can be used directly in configurations.
 Only extension is that the setters for listener and sender have been made public, and can therefore
 be set from the configuration file.
 &lt;tr&gt;&lt;td&gt;{@link #setResultOnTimeOut(String) resultOnTimeOut}&lt;/td&gt;&lt;td&gt;result returned when no return-message was received within the timeout limit (e.g. "receiver timed out").&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setLinkMethod(String) linkMethod}&lt;/td&gt;&lt;td&gt;Indicates wether the server uses the correlationID or the messageID in the correlationID field of the reply&lt;/td&gt;&lt;td&gt;CORRELATIONID&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setAuditTrailXPath(String) auditTrailXPath}&lt;/td&gt;&lt;td&gt;xpath expression to extract audit trail from message&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setCorrelationIDXPath(String) correlationIDXPath}&lt;/td&gt;&lt;td&gt;xpath expression to extract correlationID from message&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;nested elements&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link ISender sender}&lt;/td&gt;&lt;td&gt;specification of sender to send messages with&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link ICorrelatedPullingListener listener}&lt;/td&gt;&lt;td&gt;specification of listener to listen to for replies&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link nl.nn.adapterframework.parameters.Parameter param}&lt;/td&gt;&lt;td&gt;any parameters defined on the pipe will be handed to the sender, if this is a {@link nl.nn.adapterframework.core.ISenderWithParameters ISenderWithParameters}&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;code&gt;inputValidator&lt;/code&gt;&lt;/td&gt;&lt;td&gt;specification of Pipe to validate input messages&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;code&gt;outputValidator&lt;/code&gt;&lt;/td&gt;&lt;td&gt;specification of Pipe to validate output messages&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link ITransactionalStorage messageLog}&lt;/td&gt;&lt;td&gt;log of all messages sent&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;
 &lt;p&gt;&lt;b&gt;Exits:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;state&lt;/th&gt;&lt;th&gt;condition&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;"success"&lt;/td&gt;&lt;td&gt;default when a good message was retrieved (synchronous sender), or the message was successfully sent and no listener was specified and the sender was not synchronous&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;"timeout"&lt;/td&gt;&lt;td&gt;no data was received (timeout on listening), if the sender was synchronous or a listener was specified.&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;"exception"&lt;/td&gt;&lt;td&gt;an exception was thrown by the Sender or its reply-Listener. The result passed to the next pipe is the exception that was caught.&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="GenericMessageSendingPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.GenericMessageSendingPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="GetFromSessionPipe">
        <xs:annotation>
          <xs:documentation>GetFromSessionPipe - nl.nn.adapterframework.pipes.GetFromSession used as Pipe

Gets the contents of the {@link PipeLineSession pipeLineSession} by a key specified by
 &lt;code&gt;{@link #setSessionKey(String) sessionKey}&lt;/code&gt;.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="GetFromSessionType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.GetFromSession" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="GetPrincipalPipe">
        <xs:annotation>
          <xs:documentation>GetPrincipalPipe - nl.nn.adapterframework.pipes.GetPrincipalPipe used as Pipe

Returns the name of the user executing the request.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="GetPrincipalPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.GetPrincipalPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="HashPipe">
        <xs:annotation>
          <xs:documentation>HashPipe - nl.nn.adapterframework.pipes.HashPipe used as Pipe

Pipe that hashes the input.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="HashPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.HashPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IfMultipartPipe">
        <xs:annotation>
          <xs:documentation>IfMultipartPipe - nl.nn.adapterframework.pipes.IfMultipart used as Pipe

Selects an exitState, based on the content-type of a httpServletRequest
 object as input.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IfMultipartType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.IfMultipart" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IncreaseIntegerPipe">
        <xs:annotation>
          <xs:documentation>IncreaseIntegerPipe - nl.nn.adapterframework.pipes.IncreaseIntegerPipe used as Pipe

Pipe that increases the integer value of a session variable.
 Can be used in combination with {@link CompareIntegerPipe} to construct loops.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IncreaseIntegerPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.IncreaseIntegerPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IsUserInRolePipe">
        <xs:annotation>
          <xs:documentation>IsUserInRolePipe - nl.nn.adapterframework.pipes.IsUserInRolePipe used as Pipe

Pipe that checks if the calling user has a specified role. 
 Uses the PipeLineSessions methods.
 &lt;p&gt;
 If the role is not specified by the role attribute, the input of
 the pipe is used as role.
 &lt;/p&gt;
 &lt;p&gt;&lt;b&gt;Exits:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;state&lt;/th&gt;&lt;th&gt;condition&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;"success"&lt;/td&gt;&lt;td&gt;user may assume role&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;"notInRole" or value set by {@link #setNotInRoleForwardName(String) notInRoleForwardName}&lt;/td&gt;&lt;td&gt;user may not assume role&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;i&gt;&lt;/i&gt;&lt;/td&gt;&lt;td&gt;if specified&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IsUserInRolePipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.IsUserInRolePipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IsXmlIfPipe">
        <xs:annotation>
          <xs:documentation>IsXmlIfPipe - nl.nn.adapterframework.pipes.IsXmlIfPipe used as Pipe

Selects an exitState, based on if the input is a XML string.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IsXmlIfPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.IsXmlIfPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Json2XmlValidatorPipe">
        <xs:annotation>
          <xs:documentation>Json2XmlValidatorPipe - nl.nn.adapterframework.pipes.Json2XmlValidator used as Pipe

&lt;code&gt;Pipe&lt;/code&gt; that validates the XML or JSON input message against a XML-Schema and returns either XML or JSON.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Json2XmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.Json2XmlValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JsonPipe">
        <xs:annotation>
          <xs:documentation>JsonPipe - nl.nn.adapterframework.pipes.JsonPipe used as Pipe

Perform an JSON to XML transformation</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JsonPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.JsonPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JsonWellFormedCheckerPipe">
        <xs:annotation>
          <xs:documentation>JsonWellFormedCheckerPipe - nl.nn.adapterframework.pipes.JsonWellFormedChecker used as Pipe

&lt;code&gt;Pipe&lt;/code&gt; that checks the well-formedness of the input message.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JsonWellFormedCheckerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.JsonWellFormedChecker" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JsonXsltPipe">
        <xs:annotation>
          <xs:documentation>JsonXsltPipe - nl.nn.adapterframework.pipes.JsonXsltPipe used as Pipe

Perform an XSLT transformation with a specified stylesheet on a JSON input, yielding JSON, XML or text.
 JSON input is transformed into XML map, array, string, integer and boolean elements, in the namespace http://www.w3.org/2013/XSL/json.
 The XSLT stylesheet or XPathExpression operates on these element.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JsonXsltPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.JsonXsltPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LabelFormatPipe">
        <xs:annotation>
          <xs:documentation>LabelFormatPipe - nl.nn.adapterframework.extensions.rekenbox.LabelFormat used as Pipe

Transforms between ascii and an XML representation.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LabelFormatType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.rekenbox.LabelFormat" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LdapChallengePipe">
        <xs:annotation>
          <xs:documentation>LdapChallengePipe - nl.nn.adapterframework.ldap.LdapChallengePipe used as Pipe

Pipe to check if a username and password are valid in LDAP.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LdapChallengePipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.ldap.LdapChallengePipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LdapFindGroupMembershipsPipe">
        <xs:annotation>
          <xs:documentation>LdapFindGroupMembershipsPipe - nl.nn.adapterframework.ldap.LdapFindGroupMembershipsPipe used as Pipe

Pipe that returns the memberships of a userDN.
 The input is a fullDn, of a user or a group.
 &lt;/pre&gt;&lt;/code&gt; &lt;br/&gt;
 Sample result:&lt;br/&gt;&lt;code&gt;&lt;pre&gt;
	&amp;lt;ldap&amp;gt;
	 &amp;lt;entry name="CN=ni83nz,OU=Users,OU=PRD,OU=AB,OU=Tenants,DC=INSIM,DC=BIZ"&amp;gt;
	   &amp;lt;attributes&amp;gt;
	    &amp;lt;attribute&amp;gt;
	    &amp;lt;attribute name="memberOf" value="Extern"/&amp;gt;
	    &amp;lt;attribute name="roomNumber" value="DP 2.13.025"/&amp;gt;
	    &amp;lt;attribute name="departmentCode" value="358000"/&amp;gt;
	    &amp;lt;attribute name="organizationalHierarchy"&amp;gt;
	        &amp;lt;item value="ou=ING-EUR,ou=Group,ou=Organization,o=ing"/&amp;gt;
	        &amp;lt;item value="ou=OPS&amp;amp;IT,ou=NL,ou=ING-EUR,ou=Group,ou=Organization,o=ing"/&amp;gt;
	        &amp;lt;item value="ou=000001,ou=OPS&amp;amp;IT,ou=NL,ou=ING-EUR,ou=Group,ou=Organization,o=ing"/&amp;gt;
	    &amp;lt;/attribute&gt;
	    &amp;lt;attribute name="givenName" value="Gerrit"/&gt;
	   &amp;lt;/attributes&amp;gt;
	  &amp;lt;/entry&amp;gt;
   &amp;lt;entry&amp;gt; .... &amp;lt;/entry&amp;gt;
   .....
	&amp;lt;/ldap&amp;gt;
 &lt;/pre&gt;&lt;/code&gt; &lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LdapFindGroupMembershipsPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.ldap.LdapFindGroupMembershipsPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LdapFindMemberPipe">
        <xs:annotation>
          <xs:documentation>LdapFindMemberPipe - nl.nn.adapterframework.ldap.LdapFindMemberPipe used as Pipe

Pipe that checks if a specified dn exists as 'member' in another specified dn
 in LDAP.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LdapFindMemberPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.ldap.LdapFindMemberPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LocalFileSystemPipe">
        <xs:annotation>
          <xs:documentation>LocalFileSystemPipe - nl.nn.adapterframework.pipes.LocalFileSystemPipe used as Pipe</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LocalFileSystemPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.LocalFileSystemPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MailSenderPipe">
        <xs:annotation>
          <xs:documentation>MailSenderPipe - nl.nn.adapterframework.pipes.MailSenderPipe used as Pipe

Pipe that sends a mail-message using a {@link MailSender} as its sender.
 &lt;br/&gt;
 Sample email.xml:&lt;br/&gt;&lt;code&gt;&lt;pre&gt;
	&amp;lt;email&amp;gt;
	    &amp;lt;recipients&amp;gt;
	        &amp;lt;recipient&amp;gt;***@natned&amp;lt;/recipient&amp;gt;
	        &amp;lt;recipient&amp;gt;***@nn.nl&amp;lt;/recipient&amp;gt;
	    &amp;lt;/recipients&amp;gt;
	    &amp;lt;from&amp;gt;***@nn.nl&amp;lt;/from&amp;gt;
	    &amp;lt;subject&amp;gt;this is the subject&amp;lt;/subject&amp;gt;
	    &amp;lt;message&amp;gt;dit is de message&amp;lt;/message&amp;gt;
	&amp;lt;/email&amp;gt;
 &lt;/pre&gt;&lt;/code&gt; &lt;br/&gt;
 Notice: it must be valid XML. Therefore, especially the message element
 must be plain text or be wrapped as CDATA.&lt;br/&gt;&lt;br/&gt;
 example:&lt;br/&gt;&lt;code&gt;&lt;pre&gt;
 &amp;lt;message&amp;gt;&amp;lt;![CDATA[&amp;lt;h1&amp;gt;This is a HtmlMessage&amp;lt;/h1&amp;gt;]]&amp;gt;&amp;lt;/message&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;&lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MailSenderPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.MailSenderPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MoveFilePipe">
        <xs:annotation>
          <xs:documentation>MoveFilePipe - nl.nn.adapterframework.pipes.MoveFilePipe used as Pipe

Pipe for moving files to another directory.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MoveFilePipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.MoveFilePipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PGPPipe">
        <xs:annotation>
          <xs:documentation>PGPPipe - nl.nn.adapterframework.pipes.PGPPipe used as Pipe

&lt;p&gt;Performs various PGP (Pretty Good Privacy) actions such as Encrypt, Sign, Decrypt, Verify.&lt;/p&gt;
 &lt;p&gt;To use this pipe action parameter has to be set to one of the actions above.&lt;/p&gt;
 &lt;p&gt;
 &lt;br/&gt;&lt;strong&gt;Encrypt:&lt;/strong&gt;
 &lt;p&gt;
 Requires the publicKey to be set to recipients public key,
 and recipients to be set to recipients email addresses.
 &lt;/p&gt;
 &lt;p&gt;
 &lt;br/&gt;&lt;strong&gt;Sign:&lt;/strong&gt;
 &lt;p&gt;
 On top of the requirements for &lt;i&gt;Encrypt&lt;/i&gt; action,
 signing requires senders to bet set for user's email;
 and secretKey &amp; secretPassword to be set to private key's path and it's password
 (password is optional, if private key does not have protection).
 &lt;/p&gt;
 &lt;p&gt;
 &lt;br/&gt;&lt;strong&gt;Decrypt:&lt;/strong&gt;
 &lt;p&gt;
 Requires secretKey and secretPassword to bet set to private key's path and it's password.
 Just like signing, password is not required, if private key does not have protection.
 &lt;/p&gt;
 &lt;p&gt;
 &lt;br/&gt;&lt;strong&gt;Verify:&lt;/strong&gt;
 &lt;p&gt;
 On top of the requirements for &lt;i&gt;Decrypt&lt;/i&gt; action,
 verification expects list of senders' email's and corresponding public keys.
 However, sender emails does not have to be set, and in that case,
 this pipe will only validate that someone signed the input.
 &lt;/p&gt;
 &lt;p&gt;
 &lt;br/&gt;
 &lt;p&gt;
 &lt;strong&gt;Note:&lt;/strong&gt; When secret key is required in any of the actions,
 the related public key should also be included in public keys.
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PGPPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.PGPPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PasswordGeneratorPipe">
        <xs:annotation>
          <xs:documentation>PasswordGeneratorPipe - nl.nn.adapterframework.pipes.PasswordGeneratorPipe used as Pipe

Returns random password.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PasswordGeneratorPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.PasswordGeneratorPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PasswordHashPipe">
        <xs:annotation>
          <xs:documentation>PasswordHashPipe - nl.nn.adapterframework.pipes.PasswordHashPipe used as Pipe

Hash a password or validate a password against a hash using PasswordHash.java
 from &lt;a href="https://crackstation.net/hashing-security.htm"&gt;https://crackstation.net/hashing-security.htm&lt;/a&gt;.
 Input of the pipe is expected to be the password. In case hashSessionKey
 isn't used a hash of the password is returned. In case hashSessionKey is used
 it is validated against the hash in the session key which will determine
 the forward to be used (success or failure).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PasswordHashPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.PasswordHashPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PostboxRetrieverPipe">
        <xs:annotation>
          <xs:documentation>PostboxRetrieverPipe - nl.nn.adapterframework.pipes.PostboxRetrieverPipe used as Pipe

Retrieves a message using an {@link IPostboxListener}.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PostboxRetrieverPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.PostboxRetrieverPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PutInSessionPipe">
        <xs:annotation>
          <xs:documentation>PutInSessionPipe - nl.nn.adapterframework.pipes.PutInSession used as Pipe

Puts the input in the PipeLineSession, under the key specified by
 &lt;code&gt;{@link #setSessionKey(String) sessionKey}&lt;/code&gt;.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PutInSessionType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.PutInSession" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PutParametersInSessionPipe">
        <xs:annotation>
          <xs:documentation>PutParametersInSessionPipe - nl.nn.adapterframework.pipes.PutParametersInSession used as Pipe

Puts each parameter value in the PipeLineSession, under the key specified by the parameter name.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PutParametersInSessionType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.PutParametersInSession" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PutSystemDateInSessionPipe">
        <xs:annotation>
          <xs:documentation>PutSystemDateInSessionPipe - nl.nn.adapterframework.pipes.PutSystemDateInSession used as Pipe

Puts the system date/time under a key in the {@link PipeLineSession pipeLineSession}.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PutSystemDateInSessionType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.PutSystemDateInSession" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="RekenBoxCallerPipe">
        <xs:annotation>
          <xs:documentation>RekenBoxCallerPipe - nl.nn.adapterframework.extensions.rekenbox.RekenBoxCaller used as Pipe

Perform a call to a RekenBox.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RekenBoxCallerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.rekenbox.RekenBoxCaller" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="RemoveCacheKeyPipe">
        <xs:annotation>
          <xs:documentation>RemoveCacheKeyPipe - nl.nn.adapterframework.cache.RemoveCacheKeyPipe used as Pipe

Remove specified cache key from cache with specified name.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RemoveCacheKeyPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.cache.RemoveCacheKeyPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="RemoveFromSessionPipe">
        <xs:annotation>
          <xs:documentation>RemoveFromSessionPipe - nl.nn.adapterframework.pipes.RemoveFromSession used as Pipe

Removes a key specified by &lt;code&gt;{@link #setSessionKey(String) sessionKey}&lt;/code&gt;
 from the {@link PipeLineSession pipeLineSession}.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RemoveFromSessionType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.RemoveFromSession" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ReplacerPipe">
        <xs:annotation>
          <xs:documentation>ReplacerPipe - nl.nn.adapterframework.pipes.ReplacerPipe used as Pipe

Replaces all occurrences of one string with another.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ReplacerPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.ReplacerPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ResultSetIteratingPipe">
        <xs:annotation>
          <xs:documentation>ResultSetIteratingPipe - nl.nn.adapterframework.jdbc.ResultSetIteratingPipe used as Pipe

Pipe that iterates over rows in in ResultSet.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ResultSetIteratingPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jdbc.ResultSetIteratingPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="RhinoPipe">
        <xs:annotation>
          <xs:documentation>RhinoPipe - nl.nn.adapterframework.pipes.RhinoPipe used as Pipe

Rhino JavaScript Runtime Factory Pipe.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RhinoPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.RhinoPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Samba1Pipe">
        <xs:annotation>
          <xs:documentation>Samba1Pipe - nl.nn.adapterframework.pipes.Samba1Pipe used as Pipe</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Samba1PipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.Samba1Pipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Samba2Pipe">
        <xs:annotation>
          <xs:documentation>Samba2Pipe - nl.nn.adapterframework.pipes.Samba2Pipe used as Pipe</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Samba2PipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.Samba2Pipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SambaPipe">
        <xs:annotation>
          <xs:documentation>SambaPipe - nl.nn.adapterframework.pipes.SambaPipe used as Pipe</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SambaPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.SambaPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ScanTibcoSolutionPipe">
        <xs:annotation>
          <xs:documentation>ScanTibcoSolutionPipe - nl.nn.adapterframework.extensions.svn.ScanTibcoSolutionPipe used as Pipe

Pipe which scans TIBCO sources in Subversion and creates a report in xml.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ScanTibcoSolutionPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.extensions.svn.ScanTibcoSolutionPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SenderPipe">
        <xs:annotation>
          <xs:documentation>SenderPipe - nl.nn.adapterframework.pipes.SenderPipe used as Pipe

Plain extension to {@link MessageSendingPipe} that can be used directly in configurations.
 Only extension is that the setters for listener and sender have been made public, and can therefore
 be set from the configuration file.
 &lt;tr&gt;&lt;td&gt;{@link #setResultOnTimeOut(String) resultOnTimeOut}&lt;/td&gt;&lt;td&gt;result returned when no return-message was received within the timeout limit (e.g. "receiver timed out").&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setLinkMethod(String) linkMethod}&lt;/td&gt;&lt;td&gt;Indicates wether the server uses the correlationID or the messageID in the correlationID field of the reply&lt;/td&gt;&lt;td&gt;CORRELATIONID&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setAuditTrailXPath(String) auditTrailXPath}&lt;/td&gt;&lt;td&gt;xpath expression to extract audit trail from message&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link #setCorrelationIDXPath(String) correlationIDXPath}&lt;/td&gt;&lt;td&gt;xpath expression to extract correlationID from message&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;nested elements&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link ISender sender}&lt;/td&gt;&lt;td&gt;specification of sender to send messages with&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link ICorrelatedPullingListener listener}&lt;/td&gt;&lt;td&gt;specification of listener to listen to for replies&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link nl.nn.adapterframework.parameters.Parameter param}&lt;/td&gt;&lt;td&gt;any parameters defined on the pipe will be handed to the sender, if this is a {@link nl.nn.adapterframework.core.ISenderWithParameters ISenderWithParameters}&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;code&gt;inputValidator&lt;/code&gt;&lt;/td&gt;&lt;td&gt;specification of Pipe to validate input messages&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;code&gt;outputValidator&lt;/code&gt;&lt;/td&gt;&lt;td&gt;specification of Pipe to validate output messages&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link ITransactionalStorage messageLog}&lt;/td&gt;&lt;td&gt;log of all messages sent&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;
 &lt;p&gt;&lt;b&gt;Exits:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;state&lt;/th&gt;&lt;th&gt;condition&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;"success"&lt;/td&gt;&lt;td&gt;default when a good message was retrieved (synchronous sender), or the message was successfully sent and no listener was specified and the sender was not synchronous&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;"timeout"&lt;/td&gt;&lt;td&gt;no data was received (timeout on listening), if the sender was synchronous or a listener was specified.&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;"exception"&lt;/td&gt;&lt;td&gt;an exception was thrown by the Sender or its reply-Listener. The result passed to the next pipe is the exception that was caught.&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SenderPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.SenderPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ShowConfigPipe">
        <xs:annotation>
          <xs:documentation>ShowConfigPipe - nl.nn.adapterframework.webcontrol.pipes.ShowConfig used as Pipe

Show configurations.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ShowConfigType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.webcontrol.pipes.ShowConfig" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ShowConfigExePipe">
        <xs:annotation>
          <xs:documentation>ShowConfigExePipe - nl.nn.adapterframework.webcontrol.pipes.ShowConfigExe used as Pipe

Execute actions for Show configurations.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ShowConfigExeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.webcontrol.pipes.ShowConfigExe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ShowConfigurationPipe">
        <xs:annotation>
          <xs:documentation>ShowConfigurationPipe - nl.nn.adapterframework.webcontrol.pipes.ShowConfiguration used as Pipe

Shows the configuration (with resolved variables).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ShowConfigurationType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.webcontrol.pipes.ShowConfiguration" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ShowConfigurationStatusPipe">
        <xs:annotation>
          <xs:documentation>ShowConfigurationStatusPipe - nl.nn.adapterframework.webcontrol.pipes.ShowConfigurationStatus used as Pipe

Prepare the main screen of the IbisConsole.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ShowConfigurationStatusType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.webcontrol.pipes.ShowConfigurationStatus" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ShowEnvironmentVariablesPipe">
        <xs:annotation>
          <xs:documentation>ShowEnvironmentVariablesPipe - nl.nn.adapterframework.webcontrol.pipes.ShowEnvironmentVariables used as Pipe

Shows the environment variables.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ShowEnvironmentVariablesType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.webcontrol.pipes.ShowEnvironmentVariables" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ShowFlowDiagramPipe">
        <xs:annotation>
          <xs:documentation>ShowFlowDiagramPipe - nl.nn.adapterframework.webcontrol.pipes.ShowFlowDiagram used as Pipe

ShowFlowDiagram.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ShowFlowDiagramType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.webcontrol.pipes.ShowFlowDiagram" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SignaturePipe">
        <xs:annotation>
          <xs:documentation>SignaturePipe - nl.nn.adapterframework.pipes.SignaturePipe used as Pipe</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SignaturePipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.SignaturePipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SizePipe">
        <xs:annotation>
          <xs:documentation>SizePipe - nl.nn.adapterframework.pipes.SizePipe used as Pipe

Returns the number of bytes or characters in the input.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SizePipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.SizePipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SkipPipe">
        <xs:annotation>
          <xs:documentation>SkipPipe - nl.nn.adapterframework.pipes.SkipPipe used as Pipe

Skip a number of bytes or characters from the input.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SkipPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.SkipPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SoapValidatorPipe">
        <xs:annotation>
          <xs:documentation>SoapValidatorPipe - nl.nn.adapterframework.soap.SoapValidator used as Pipe

XmlValidator that will automatically add the SOAP envelope XSD to the set of
 XSD's used for validation.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SoapValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.soap.SoapValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SoapWrapperPipe">
        <xs:annotation>
          <xs:documentation>SoapWrapperPipe - nl.nn.adapterframework.soap.SoapWrapperPipe used as Pipe

Pipe to wrap or unwrap a message from/into a SOAP Envelope.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.soap.SoapWrapperPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Stream2StringPipe">
        <xs:annotation>
          <xs:documentation>Stream2StringPipe - nl.nn.adapterframework.pipes.Stream2StringPipe used as Pipe

Return simply the input message from stream to string.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Stream2StringPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.Stream2StringPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="StreamLineIteratorPipe">
        <xs:annotation>
          <xs:documentation>StreamLineIteratorPipe - nl.nn.adapterframework.pipes.StreamLineIteratorPipe used as Pipe

Sends a message to a Sender for each line of its input, that must be an InputStream.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="StreamLineIteratorPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.StreamLineIteratorPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="StreamPipe">
        <xs:annotation>
          <xs:documentation>StreamPipe - nl.nn.adapterframework.pipes.StreamPipe used as Pipe

Stream an input stream to an output stream.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="StreamPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.StreamPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="StreamTransformerPipe">
        <xs:annotation>
          <xs:documentation>StreamTransformerPipe - nl.nn.adapterframework.batch.StreamTransformerPipe used as Pipe

Pipe for transforming a stream with records. Records in the stream must be separated
 with new line characters.
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;nested elements&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link IInputStreamReaderFactory readerFactory}&lt;/td&gt;&lt;td&gt;Factory for reader of inputstream. Default implementation {@link InputStreamReaderFactory} just converts using the specified characterset&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link IRecordHandlerManager manager}&lt;/td&gt;&lt;td&gt;Manager determines which handlers are to be used for the current line.
 			If no manager is specified, a default manager and flow are created. The default manager 
 			always uses the default flow. The default flow always uses the first registered recordHandler 
 			(if available) and the first registered resultHandler (if available).&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link RecordHandlingFlow manager/flow}&lt;/td&gt;&lt;td&gt;Element that contains the handlers for a specific record type, to be assigned to the manager&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link IRecordHandler recordHandler}&lt;/td&gt;&lt;td&gt;Handler for transforming records of a specific type&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;{@link IResultHandler resultHandler}&lt;/td&gt;&lt;td&gt;Handler for processing transformed records&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="StreamTransformerPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.batch.StreamTransformerPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="StringIteratorPipe">
        <xs:annotation>
          <xs:documentation>StringIteratorPipe - nl.nn.adapterframework.pipes.StringIteratorPipe used as Pipe

IteratingPipe that has Strings as items.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="StringIteratorPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.StringIteratorPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="TestPipeLinePipe">
        <xs:annotation>
          <xs:documentation>TestPipeLinePipe - nl.nn.adapterframework.webcontrol.pipes.TestPipeLine used as Pipe

Test a PipeLine.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="TestPipeLineType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.webcontrol.pipes.TestPipeLine" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Text2XmlPipe">
        <xs:annotation>
          <xs:documentation>Text2XmlPipe - nl.nn.adapterframework.pipes.Text2XmlPipe used as Pipe

Pipe for converting text to or from xml.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Text2XmlPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.Text2XmlPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="TextSplitterPipe">
        <xs:annotation>
          <xs:documentation>TextSplitterPipe - nl.nn.adapterframework.pipes.TextSplitterPipe used as Pipe

Breaks up the text input in blocks of a maximum length. 
 By default the maximum block length is 160 characters, to enable them to be send as SMS messages.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="TextSplitterPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.TextSplitterPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="UUIDGeneratorPipe">
        <xs:annotation>
          <xs:documentation>UUIDGeneratorPipe - nl.nn.adapterframework.pipes.UUIDGeneratorPipe used as Pipe

Pipe that generates an UUID (Universally Unique Identifier).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="UUIDGeneratorPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.UUIDGeneratorPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="UnzipPipe">
        <xs:annotation>
          <xs:documentation>UnzipPipe - nl.nn.adapterframework.pipes.UnzipPipe used as Pipe

Assumes input to be the file name of a ZIP archive, and unzips it to a
 directory and/or an XML message.
 &lt;br&gt;
 The output of each unzipped item is returned in XML as follows when
 collectFileContents is false:
 &lt;pre&gt;
  &amp;lt;results count="num_of_items"&amp;gt;
    &amp;lt;result item="1"&amp;gt;
      &amp;lt;zipEntry&amp;gt;name in ZIP archive of first item&amp;lt;/zipEntry&amp;gt;
      &amp;lt;fileName&amp;gt;filename of first item&amp;lt;/fileName&amp;gt;
    &amp;lt;/result&amp;gt;
    &amp;lt;result item="2"&amp;gt;
      &amp;lt;zipEntry&amp;gt;name in ZIP archive of second item&amp;lt;/zipEntry&amp;gt;
      &amp;lt;fileName&amp;gt;filename of second item&amp;lt;/fileName&amp;gt;
    &amp;lt;/result&amp;gt;
       ...
  &amp;lt;/results&amp;gt;
 &lt;/pre&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="UnzipPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.UnzipPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="UploadConfigPipe">
        <xs:annotation>
          <xs:documentation>UploadConfigPipe - nl.nn.adapterframework.webcontrol.pipes.UploadConfig used as Pipe

Upload a configuration.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="UploadConfigType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.webcontrol.pipes.UploadConfig" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="UploadConfigServicePipe">
        <xs:annotation>
          <xs:documentation>UploadConfigServicePipe - nl.nn.adapterframework.webcontrol.pipes.UploadConfigService used as Pipe</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="UploadConfigServiceType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.webcontrol.pipes.UploadConfigService" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="UploadFilePipe">
        <xs:annotation>
          <xs:documentation>UploadFilePipe - nl.nn.adapterframework.pipes.UploadFilePipe used as Pipe

Uploads a zip file (inputstream in a sessionKey) and unzips it to a directory.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="UploadFilePipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.UploadFilePipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="WebservicesPipe">
        <xs:annotation>
          <xs:documentation>WebservicesPipe - nl.nn.adapterframework.webcontrol.pipes.Webservices used as Pipe

Webservices.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="WebservicesType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.webcontrol.pipes.Webservices" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="WsdlGeneratorPipe">
        <xs:annotation>
          <xs:documentation>WsdlGeneratorPipe - nl.nn.adapterframework.pipes.WsdlGeneratorPipe used as Pipe

Generate WSDL of parent or specified adapter.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="WsdlGeneratorPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.WsdlGeneratorPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="WsdlXmlValidatorPipe">
        <xs:annotation>
          <xs:documentation>WsdlXmlValidatorPipe - nl.nn.adapterframework.pipes.WsdlXmlValidator used as Pipe

XmlValidator that will read the XSD's to use from a WSDL. As it extends the
 SoapValidator is will also add the SOAP envelope XSD.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="WsdlXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.WsdlXmlValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XQueryPipe">
        <xs:annotation>
          <xs:documentation>XQueryPipe - nl.nn.adapterframework.pipes.XQueryPipe used as Pipe

Perform an XQuery.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XQueryPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.XQueryPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlBuilderPipe">
        <xs:annotation>
          <xs:documentation>XmlBuilderPipe - nl.nn.adapterframework.pipes.XmlBuilderPipe used as Pipe

Pipe for converting special characters to their xml equivalents.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlBuilderPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.XmlBuilderPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlFileElementIteratorPipe">
        <xs:annotation>
          <xs:documentation>XmlFileElementIteratorPipe - nl.nn.adapterframework.pipes.XmlFileElementIteratorPipe used as Pipe

Sends a message to a Sender for each element in the XML file that the input message refers to.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlFileElementIteratorPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.XmlFileElementIteratorPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlIfPipe">
        <xs:annotation>
          <xs:documentation>XmlIfPipe - nl.nn.adapterframework.pipes.XmlIf used as Pipe

Selects an exitState, based on xpath evaluation</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlIfType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.XmlIf" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlSwitchPipe">
        <xs:annotation>
          <xs:documentation>XmlSwitchPipe - nl.nn.adapterframework.pipes.XmlSwitch used as Pipe

Selects an exitState, based on either the content of the input message, by means
 of a XSLT-stylesheet, the content of a session variable or, by default, by returning the name of the root-element.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlSwitchType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.XmlSwitch" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlValidatorPipe">
        <xs:annotation>
          <xs:documentation>XmlValidatorPipe - nl.nn.adapterframework.pipes.XmlValidator used as Pipe

&lt;code&gt;Pipe&lt;/code&gt; that validates the input message against a XML-Schema.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.XmlValidator" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlWellFormedCheckerPipe">
        <xs:annotation>
          <xs:documentation>XmlWellFormedCheckerPipe - nl.nn.adapterframework.pipes.XmlWellFormedChecker used as Pipe

&lt;code&gt;Pipe&lt;/code&gt; that checks the well-formedness of the input message.
 If &lt;code&gt;root&lt;/code&gt; is given then this is also checked.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlWellFormedCheckerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.XmlWellFormedChecker" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XsltPipe">
        <xs:annotation>
          <xs:documentation>XsltPipe - nl.nn.adapterframework.pipes.XsltPipe used as Pipe

Perform an XSLT transformation with a specified stylesheet.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XsltPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.pipes.XsltPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ZipIteratorPipe">
        <xs:annotation>
          <xs:documentation>ZipIteratorPipe - nl.nn.adapterframework.compression.ZipIteratorPipe used as Pipe

Sends a message to a Sender for each entry of its input, that must be an ZipInputStream. The input of the pipe must be one of:
 &lt;ul&gt;
 	&lt;li&gt;String refering to a filename&lt;/li&gt;
  &lt;li&gt;File&lt;/li&gt;
  &lt;li&gt;InputStream&lt;/li&gt; 
 &lt;/ul&gt;
 The message sent each time to the sender is the filename of the entry found in the archive. 
 The contents of the archive is available as a Stream or a String in a session variable.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ZipIteratorPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.compression.ZipIteratorPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ZipWriterPipe">
        <xs:annotation>
          <xs:documentation>ZipWriterPipe - nl.nn.adapterframework.compression.ZipWriterPipe used as Pipe

Pipe that creates a ZipStream.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ZipWriterPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.compression.ZipWriterPipe" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="Adios2XmlPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="Adios2XmlPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="Adios2XmlPipeDeclaredAttributeGroup">
    <xs:attribute name="adiosDefinities" type="xs:string" />
    <xs:attribute name="direction" type="xs:string" />
    <xs:attribute name="noConversionForwardName" type="xs:string" />
    <xs:attribute name="rekenbox" type="xs:string" />
    <xs:attribute name="rekenboxSessionKey" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="Adios2XmlPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="Adios2XmlPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ApiPrincipalPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="ApiPrincipalPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ApiPrincipalPipeDeclaredAttributeGroup">
    <xs:attribute name="action" type="xs:string" />
    <xs:attribute name="authenticationMethod" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="ApiPrincipalPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ApiPrincipalPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ApiStreamPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="ApiStreamPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ApiStreamPipeDeclaredAttributeGroup">
    <xs:attribute name="jmsRealm" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="ApiStreamPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ApiStreamPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="StreamPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="StreamPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="StreamPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="StreamPipeDeclaredAttributeGroup">
    <xs:attribute name="antiVirusFailureAsSoapFault" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) when true and the antivirusfailed forward is specified and the antivirus scan did not pass, a soap fault is returned instead of only a plain error message Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusFailureReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) if not empty and the antivirusfailed forward is specified and the antivirus scan did not pass, the error message (or soap fault) is stored in this session key and the first string part is returned to the pipeline</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusMessagePartName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) name of antivirus scan message parts Default: &lt;code&gt;antivirus_msg&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusPartName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) name of antivirus scan status parts Default: &lt;code&gt;antivirus_rc&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusPassedMessage" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) message of antivirus scan parts which indicates the antivirus scan passed Default: &lt;code&gt;pass&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkAntiVirus" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt;) when true parts are checked for antivirus scan returncode. these antivirus scan parts have been added by another application (so the antivirus scan is not performed in this pipe). for each file part an antivirus scan part have been added by this other application (directly after this file part) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="extractFirstStringPart" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt;) when true the first part is not put in a session key but returned to the pipeline (as the result of this pipe) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartXmlSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;extractfirststringpart=true&lt;/code&gt;) the session key to put the xml in with info about the stored parts Default: &lt;code&gt;multipartxml&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="StreamPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="StreamPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Base64PipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="Base64PipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="Base64PipeDeclaredAttributeGroup">
    <xs:attribute name="direction" type="DirectionAttributeValuesType">
      <xs:annotation>
        <xs:documentation>Either &lt;code&gt;encode&lt;/code&gt; or &lt;code&gt;decode&lt;/code&gt; Default: encode</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="OutputTypesAttributeValuesType">
      <xs:annotation>
        <xs:documentation>Either &lt;code&gt;string&lt;/code&gt; for character output or &lt;code&gt;bytes&lt;/code&gt; for binary output. The value &lt;code&gt;stream&lt;/code&gt; is no longer used. Streaming is automatic where possible Default: string for direction=encode, bytes for direction=decode</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Character encoding to be used to when reading input from strings for direction=encode or writing data for direction=decode.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineSeparator" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Only used when direction=encode) Defines separator between lines. Special values: &lt;code&gt;auto&lt;/code&gt;: platform default, &lt;code&gt;dos&lt;/code&gt;: crlf, &lt;code&gt;unix&lt;/code&gt;: lf Default: auto</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineLength" type="xs:integer">
      <xs:annotation>
        <xs:documentation>(Only used when direction=encode) Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4). If linelength &amp;lt;= 0, then the output will not be divided into lines Default: 76</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="convert2String" type="xs:boolean" />
  </xs:attributeGroup>
  <xs:simpleType name="DirectionAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ENCODE" />
      <xs:enumeration value="DECODE" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="OutputTypesAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="STRING" />
      <xs:enumeration value="BYTES" />
    </xs:restriction>
  </xs:simpleType>
  <xs:attributeGroup name="Base64PipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="Base64PipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="StreamingPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="StreamingPipeDeclaredAttributeGroup">
    <xs:attribute name="streamingActive" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true, then this pipe can provide an OutputStream to the previous pipe, to write its output to. Can be used to switch this streaming off for debugging purposes Default: set by appconstant streaming.auto</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="StreamingPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="StreamingPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="BatchBlobTransformerPipeType">
    <xs:group ref="StreamTransformerPipePluralConfigChildGroup" />
    <xs:attributeGroup ref="BatchBlobTransformerPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="BatchBlobTransformerPipeDeclaredAttributeGroup">
    <xs:attribute name="blobCharset" type="xs:string" />
    <xs:attribute name="blobsCompressed" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is stored compressed in the database Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="BatchBlobTransformerPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="BatchBlobTransformerPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="BatchTransformerPipeBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="StreamTransformerPipeType">
    <xs:group ref="StreamTransformerPipePluralConfigChildGroup" />
    <xs:attributeGroup ref="StreamTransformerPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:group name="StreamTransformerPipePluralConfigChildGroup">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="ChildElementGroup" />
        <xs:element ref="Forward" />
        <xs:element ref="Locker" />
        <xs:group ref="ManagerElementGroup" />
        <xs:element ref="Param" />
        <xs:group ref="ReaderFactoryElementGroup" />
        <xs:group ref="RecordHandlerElementGroup" />
        <xs:group ref="ResultHandlerElementGroup" />
      </xs:choice>
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="StreamTransformerPipeDeclaredAttributeGroup">
    <xs:attribute name="storeOriginalBlock" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; the original block is stored under the session key originalblock Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>characterset used for reading file or inputstream Default: utf-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="StreamTransformerPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="StreamTransformerPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="BatchTransformerPipeBaseDeclaredAttributeGroup">
    <xs:attribute name="query" type="xs:string">
      <xs:annotation>
        <xs:documentation>The SQL query text to be excecuted each time sendMessage() is called</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>JNDI name of datasource to be used, can be configured via jmsRealm, too Default: ${jdbc.datasource.default}</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsRealm" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="BatchTransformerPipeBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="BatchTransformerPipeBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="StreamTransformerPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="BatchClobTransformerPipeType">
    <xs:group ref="StreamTransformerPipePluralConfigChildGroup" />
    <xs:attributeGroup ref="BatchTransformerPipeBaseCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="BatchFileTransformerPipeType">
    <xs:group ref="StreamTransformerPipePluralConfigChildGroup" />
    <xs:attributeGroup ref="BatchFileTransformerPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="BatchFileTransformerPipeDeclaredAttributeGroup">
    <xs:attribute name="move2dirAfterTransform" type="xs:string">
      <xs:annotation>
        <xs:documentation>Directory in which the transformed file(s) is stored</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="move2dirAfterError" type="xs:string">
      <xs:annotation>
        <xs:documentation>Directory to which the inputfile is moved in case an error occurs</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numberOfBackups" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Number of copies held of a file with the same name. Backup files have a dot and a number suffixed to their name. If set to 0, no backups will be kept. Default: 5</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="overwrite" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the destination file will be deleted if it already exists Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="delete" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the file processed will deleted after being processed, and not stored Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="BatchFileTransformerPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="BatchFileTransformerPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="StreamTransformerPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="BlobLineIteratingPipeType">
    <xs:group ref="IteratingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="BlobLineIteratingPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="BlobLineIteratingPipeDeclaredAttributeGroup">
    <xs:attribute name="blobCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used to read and write blobs Default: utf-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is stored compressed in the database Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="BlobLineIteratingPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="BlobLineIteratingPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcIteratingPipeBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="IteratingPipeDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="SenderElementGroup" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:group name="IteratingPipeCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="IteratingPipeDeclaredChildGroup" />
      <xs:group ref="MessageSendingPipeCumulativeChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="IteratingPipeDeclaredAttributeGroup">
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Stylesheet to apply to each message, before sending it</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alternatively: xpath-expression to create stylesheet from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions. For some use other cases (NOT xpathExpression), one entry can be without a prefix, that will define the default namespace.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>Either 'text' or 'xml'. only valid for xpathexpression Default: text</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Force the transformer generated from the xpath-expression to omit the xml declaration Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="itemNoSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of session variable to store number of items processed, i.e. the position or index in the set of items to be processed.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxItems" type="xs:integer">
      <xs:annotation>
        <xs:documentation>The maximum number of items returned. The (default) value of 0 means unlimited, all available items will be returned Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stopConditionXPathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>Expression evaluated on each result if set. Iteration stops if condition returns anything other than an empty result. To test for the root element to have an attribute 'finished' with the value 'yes', the expression &lt;code&gt;*[@finished='yes']&lt;/code&gt; can be used. This can be used if the condition to stop can be derived from the item result. To stop after a maximum number of items has been processed, use &lt;code&gt;maxItems&lt;/code&gt;.Previous versions documented that &lt;code&gt;position()=2&lt;/code&gt; could be used. This is not working as expected; Use maxItems instead</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreExceptions" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When &lt;code&gt;true&lt;/code&gt; ignore any exception thrown by executing sender Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectResults" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Controls whether all the results of each iteration will be collected in one result message. If set &lt;code&gt;false&lt;/code&gt;, only a small summary is returned. Setting this attributes to &lt;code&gt;false&lt;/code&gt; is often required to enable processing of very large files. N.B. Remember in such a case that setting transactionAttribute to NotSupported might be necessary too Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeXmlDeclarationInResults" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Postprocess each partial result, to remove the xml-declaration, as this is not allowed inside an xml-document Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addInputToResult" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When &lt;code&gt;true&lt;/code&gt; the input is added to the result in an input element Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeDuplicates" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When &lt;code&gt;true&lt;/code&gt; duplicate input elements are removed, i.e. they are handled only once Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="parallel" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When set &lt;code&gt;true&lt;/code&gt;, the calls for all items are done in parallel (a new thread is started for each call). when collectresults set &lt;code&gt;true&lt;/code&gt;, this pipe will wait for all calls to finish before results are collected and pipe result is returned Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxChildThreads" type="xs:integer">
      <xs:annotation>
        <xs:documentation>maximum number of child threads that may run in parallel simultaneously (combined total of all threads calling this pipe) Default: 0 (unlimited)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSize" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Controls multiline behaviour. when set to a value greater than 0, it specifies the number of rows send in a block to the sender. Default: 0 (one line at a time, no prefix of suffix)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="IteratingPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="IteratingPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="MessageSendingPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="MessageSendingPipeType">
    <xs:group ref="MessageSendingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="MessageSendingPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:group name="MessageSendingPipeDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="MessageLogElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="InputValidatorElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="OutputValidatorElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="InputWrapperElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="OutputWrapperElementGroup" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:group name="MessageSendingPipeCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="MessageSendingPipeDeclaredChildGroup" />
      <xs:group ref="AbstractPipeDeclaredChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="MessageSendingPipeDeclaredAttributeGroup">
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>either MESSAGEID or CORRELATIONID. For asynchronous communication, the server side may either use the messageID or the correlationID in the correlationID field of the reply message. Use this property to set the behaviour of the reply-listener. Default: correlationid</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract correlationid from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract correlationid from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for correlationidxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. is specified, the value of the pipelinesession variable is used as input for the xpathexpression or stylesheet, instead of the current input message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract label from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract label from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for labelxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract audit trail from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for audittrailxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. if specified, the value of the pipelinesession variable is used as audit trail (instead of the default 'no audit trail)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useInputForExtract" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is used to extract audit trail, correlationid and label (instead of the wrapped input) Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>next to common usage in {@link AbstractPipe}, also strings in the error/logstore are masked</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when hideregex is not empty and only applies to error/logstore) either &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;firsthalf&lt;/code&gt;. when &lt;code&gt;firsthalf&lt;/code&gt; only the first half of the string is masked, otherwise (&lt;code&gt;all&lt;/code&gt;) the entire string is masked Default: all</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkXmlWellFormed" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the xml well-formedness of the result is checked Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkRootTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, besides the xml well-formedness the root element of the result is checked to be equal to the value set</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultOnTimeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>result returned when no return-message was received within the timeout limit (e.g. 'receiver timed out').</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRetries" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the number of times a processing attempt is retried after a timeout or an exception is caught or after a incorrect reply is received (see also &lt;code&gt;retryxpath&lt;/code&gt;) Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMinInterval" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the starting number of seconds waited after an unsuccessful processing attempt before another processing attempt is made. each next retry this interval is doubled with a upper limit of &lt;code&gt;retrymaxinterval&lt;/code&gt; Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMaxInterval" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the maximum number of seconds waited after an unsuccessful processing attempt before another processing attempt is made Default: 600</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression evaluated on each technical successful reply. retry is done if condition returns true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for retryxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="presumedTimeOutInterval" type="xs:integer">
      <xs:annotation>
        <xs:documentation>when the previous call was a timeout, the maximum time (in seconds) after this timeout to presume the current call is also a timeout. a value of -1 indicates to never presume timeouts Default: 10 s</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>if set, the result is first base64 decoded and then streamed to the httpservletresponse object Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stubFilename" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the pipe returns a message from a file, instead of doing the regular process</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOutOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a timeoutexception is thrown when the result equals this value (for testing purposes only)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exceptionOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a piperunexception is thrown when the result equals this value (for testing purposes only)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the pipe</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stubFileName" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="MessageSendingPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="MessageSendingPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="StreamingPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeDeclaredAttributeGroup" />
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, input is taken from this session key, instead of regular input</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, this fixed value is taken as input, instead of regular input</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set and the input is empty, this fixed value is taken as input</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the result of the pipe is replaced with the original input (i.e. the input before configured replacements of &lt;code&gt;getInputFromSessionKey&lt;/code&gt;, &lt;code&gt;getInputFromFixedValue&lt;/code&gt; or &lt;code&gt;emptyInputReplacement&lt;/code&gt;) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the result (before replacing when &lt;code&gt;true&lt;/code&gt;) is stored under this session key</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementToMoveSessionKey&lt;/code&gt; + }</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Only used when &lt;code&gt;elementToMove&lt;/code&gt; is set) Name of the session key under which the character data is stored Default: ref_ + the name of the element</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>Like &lt;code&gt;elementToMove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe')</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:integer">
      <xs:annotation>
        <xs:documentation>If durationThreshold &gt;=0 and the duration of the message processing exceeded the value specified (in milliseconds) the message is logged informatory Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:integer">
      <xs:annotation>
        <xs:documentation>maximum number of threads that may call {@link #doPipe(java.lang.Object, nl.nn.adapterframework.core.PipeLineSession)} simultaneously Default: 0 (unlimited)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes Default: application default</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:boolean" />
    <xs:attribute name="restoreMovedElements" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, compacted messages in the result are restored to their original format (see also  {@link #setElementToMove(java.lang.String)}) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default: (Only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) Comma separated list of keys of session variables that is appended to the security log record</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sizeStatistics" type="xs:boolean" />
    <xs:attribute name="writeToSecLog" type="xs:boolean" />
    <xs:attributeGroup ref="TransactionAttributesDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcIteratingPipeBaseDeclaredAttributeGroup">
    <xs:attribute name="query" type="xs:string">
      <xs:annotation>
        <xs:documentation>The SQL query text to be excecuted each time sendMessage() is called. When not set, the input message is taken as the query</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>JNDI name of datasource to be used, can be configured via jmsRealm, too Default: ${jdbc.datasource.default}</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useNamedParams" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When &lt;code&gt;true&lt;/code&gt;, every string in the message which equals &lt;code&gt;?{paramname}&lt;/code&gt; will be replaced by the value of the corresponding parameter. The parameters don't need to be in the correct order and unused parameters are skipped. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trimSpaces" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Remove trailing blanks from all result values. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sqlDialect" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the SQL dialect in which the queries are written and should be translated from to the actual SQL dialect</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockRows" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When set &lt;code&gt;true&lt;/code&gt;, exclusive row-level locks are obtained on all the rows identified by the select statement (e.g. by appending ' FOR UPDATE NOWAIT SKIP LOCKED' to the end of the query) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWait" type="xs:integer">
      <xs:annotation>
        <xs:documentation>when set and &gt;=0, ' FOR UPDATE WAIT #' is used instead of ' FOR UPDATE NOWAIT SKIP LOCKED' Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="avoidLocking" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true, then select queries are executed in a way that avoids taking locks, e.g. with isolation mode 'read committed' instead of 'repeatable read'. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsRealm" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcIteratingPipeBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcIteratingPipeBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="StringIteratorPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="StringIteratorPipeType">
    <xs:group ref="IteratingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="StringIteratorPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="StringIteratorPipeDeclaredAttributeGroup">
    <xs:attribute name="blockSize" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Controls multiline behaviour. If set to a value greater than 0, it specifies the number of rows send in a block to the sender. Default: 0 (one line at a time, no prefix of suffix)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startPosition" type="xs:integer">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;startPosition &amp;gt;= 0&lt;/code&gt;, this field contains the start position of the key in the current record (first character is 0); A sequence of lines with the same key is put in one block and send to the sender. Cannot be used in combination with blockSize. Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="endPosition" type="xs:integer">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;endPosition &amp;gt;= startPosition&lt;/code&gt;, this field contains the end position of the key in the current record Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="combineBlocks" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, all items in a block are sent at once. If set false, items are sent individually, potentially leveraging block enabled sending capabilities of the sender Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockPrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;combineBlocks = true&lt;/code&gt;, this string is inserted at the start of each block. Requires &lt;code&gt;blockSize&lt;/code&gt; or &lt;code&gt;startPosition&lt;/code&gt; and &lt;code&gt;endPosition&lt;/code&gt; to be set too. Default: &amp;lt;block&amp;gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;combineBlocks = true&lt;/code&gt;, this string is inserted at the end of the set of lines. Requires &lt;code&gt;blockSize&lt;/code&gt; or &lt;code&gt;startPosition&lt;/code&gt; and &lt;code&gt;endPosition&lt;/code&gt; to be set too. Default: &amp;lt;/block&amp;gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linePrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>This string is inserted at the start of each item</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>This string is appended at the end of each item</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="escapeXml" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Escape XML characters in each item Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="StringIteratorPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="StringIteratorPipeDeclaredAttributeGroup" />
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Stylesheet to apply to each message, before sending it</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alternatively: xpath-expression to create stylesheet from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions. For some use other cases (NOT xpathExpression), one entry can be without a prefix, that will define the default namespace.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>Either 'text' or 'xml'. only valid for xpathexpression Default: text</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Force the transformer generated from the xpath-expression to omit the xml declaration Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="itemNoSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of session variable to store number of items processed, i.e. the position or index in the set of items to be processed.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxItems" type="xs:integer">
      <xs:annotation>
        <xs:documentation>The maximum number of items returned. The (default) value of 0 means unlimited, all available items will be returned Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stopConditionXPathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>Expression evaluated on each result if set. Iteration stops if condition returns anything other than an empty result. To test for the root element to have an attribute 'finished' with the value 'yes', the expression &lt;code&gt;*[@finished='yes']&lt;/code&gt; can be used. This can be used if the condition to stop can be derived from the item result. To stop after a maximum number of items has been processed, use &lt;code&gt;maxItems&lt;/code&gt;.Previous versions documented that &lt;code&gt;position()=2&lt;/code&gt; could be used. This is not working as expected; Use maxItems instead</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreExceptions" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When &lt;code&gt;true&lt;/code&gt; ignore any exception thrown by executing sender Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectResults" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Controls whether all the results of each iteration will be collected in one result message. If set &lt;code&gt;false&lt;/code&gt;, only a small summary is returned. Setting this attributes to &lt;code&gt;false&lt;/code&gt; is often required to enable processing of very large files. N.B. Remember in such a case that setting transactionAttribute to NotSupported might be necessary too Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeXmlDeclarationInResults" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Postprocess each partial result, to remove the xml-declaration, as this is not allowed inside an xml-document Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addInputToResult" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When &lt;code&gt;true&lt;/code&gt; the input is added to the result in an input element Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeDuplicates" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When &lt;code&gt;true&lt;/code&gt; duplicate input elements are removed, i.e. they are handled only once Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="parallel" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When set &lt;code&gt;true&lt;/code&gt;, the calls for all items are done in parallel (a new thread is started for each call). when collectresults set &lt;code&gt;true&lt;/code&gt;, this pipe will wait for all calls to finish before results are collected and pipe result is returned Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxChildThreads" type="xs:integer">
      <xs:annotation>
        <xs:documentation>maximum number of child threads that may run in parallel simultaneously (combined total of all threads calling this pipe) Default: 0 (unlimited)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="MessageSendingPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="BytesOutputPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="ChecksumPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="ChecksumPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ChecksumPipeDeclaredAttributeGroup">
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>character encoding to be used to encode message before calculating checksum Default: utf-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputIsFile" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be a filename; otherwise the input itself is used in the calculations Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of checksum to be calculated. must be one of md5, sha, crc32, adler32 Default: md5</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ChecksumPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ChecksumPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="CleanupOldFilesPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="CleanupOldFilesPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="CleanupOldFilesPipeDeclaredAttributeGroup">
    <xs:attribute name="deleteEmptySubdirectories" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, empty subdirectories will be deleted, too Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="excludeWildcard" type="xs:string">
      <xs:annotation>
        <xs:documentation>filter of files to be excluded for deletion</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>files that match this pattern will be deleted. parameters of the pipe are applied to this pattern. if this attribute is not set, the input of the pipe is interpreted as the file to be removed</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filePatternSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lastModifiedDelta" type="xs:integer">
      <xs:annotation>
        <xs:documentation>time in milliseconds after last modification that must have passed at least before a file will be deleted (set to negative value to disable) Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="minStableTime" type="xs:integer">
      <xs:annotation>
        <xs:documentation>minimal age of file in milliseconds, to avoid deleting a file while it is still being written (only used when wildcard is set) (set to 0 or negative value to disable) Default: 1000 [ms]</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="subdirectories" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, files  in subdirectories will be deleted, too Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wildcard" type="xs:string">
      <xs:annotation>
        <xs:documentation>filter of files to delete. if not set and a directory is specified, all files in the directory are interpreted to be deleted</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CleanupOldFilesPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="CleanupOldFilesPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ClobLineIteratingPipeType">
    <xs:group ref="IteratingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="JdbcIteratingPipeBaseCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="CompareIntegerPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="CompareIntegerPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="CompareIntegerPipeDeclaredAttributeGroup">
    <xs:attribute name="sessionKey1" type="xs:string">
      <xs:annotation>
        <xs:documentation>reference to one of the session variables to be compared</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey2" type="xs:string">
      <xs:annotation>
        <xs:documentation>reference to the other session variables to be compared</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CompareIntegerPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="CompareIntegerPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="CompareStringPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="CompareStringPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="CompareStringPipeDeclaredAttributeGroup">
    <xs:attribute name="sessionKey1" type="xs:string">
      <xs:annotation>
        <xs:documentation>reference to one of the session variables to be compared. Do not use, but use Parameter operand1 instead</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey2" type="xs:string">
      <xs:annotation>
        <xs:documentation>reference to the other session variables to be compared. Do not use, but use Parameter operand2 instead</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xml" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; the string values to compare are considered to be xml strings and before the actual compare both xml strings are transformed to a canonical form Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CompareStringPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="CompareStringPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="CompressPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="CompressPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="CompressPipeDeclaredAttributeGroup">
    <xs:attribute name="compress" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>if &lt;code&gt;true&lt;/code&gt; the pipe compresses, otherwise it decompress Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="convert2String" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>if &lt;code&gt;true&lt;/code&gt; result is returned as a string, otherwise as a byte array Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to gz, the gzip format is used. when set to another value, the zip format is used. if not set and direction is compress, the resultiscontent specifies the output format used (resultiscontent=&lt;code&gt;true&lt;/code&gt; -&gt; gzip format, resultiscontent=&lt;code&gt;false&lt;/code&gt; -&gt; zip format) if not set and direction is decompress, the messageiscontent specifies the output format used (messageiscontent=&lt;code&gt;true&lt;/code&gt; -&gt; gzip format, messageiscontent=&lt;code&gt;false&lt;/code&gt; -&gt; zip format)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filenamePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>required if result is a file, the pattern for the result filename</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageIsContent" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>flag indicates whether the message is the content or the path to a file with the contents. for multiple files use ';' as delimiter Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>required if result is a file, the directory in which to store the result file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultIsContent" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>flag indicates whether the result must be written to the message or to a file (filename = message) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="zipEntryPattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>the pattern for the zipentry name in case a zipfile is read or written</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CompressPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="CompressPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="CounterSwitchPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="CounterSwitchPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="CounterSwitchPipeDeclaredAttributeGroup">
    <xs:attribute name="divisor" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Default: 2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CounterSwitchPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="CounterSwitchPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="CredentialCheckingPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="CredentialCheckingPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="CredentialCheckingPipeDeclaredAttributeGroup">
    <xs:attribute name="authAlias" type="xs:string" />
    <xs:attribute name="defaultPassword" type="xs:string" />
    <xs:attribute name="defaultUserid" type="xs:string" />
    <xs:attribute name="targetPassword" type="xs:string" />
    <xs:attribute name="targetUserid" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="CredentialCheckingPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="CredentialCheckingPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="CrlPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="CrlPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="CrlPipeDeclaredAttributeGroup">
    <xs:attribute name="issuerSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the sessionkey that holds a stream to the certificate of the issuer who signed the crl. the steam is closed after reading</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CrlPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="CrlPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="CsvParserPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="CsvParserPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="CsvParserPipeDeclaredAttributeGroup">
    <xs:attribute name="fileContainsHeader" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Specifies if the first line should be treated as header or as data Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fieldNames" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of header names. If set, then fileContainsHeader defaults to false. If not set, headers are taken from the first line</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fieldSeparator" type="xs:string">
      <xs:annotation>
        <xs:documentation>Character that separates fields Default: ,</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CsvParserPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="CsvParserPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="StreamingPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="DelayPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="DelayPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="DelayPipeDeclaredAttributeGroup">
    <xs:attribute name="delayTime" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the time the thread will be put to sleep Default: 5000 [ms]</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="DelayPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="DelayPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="DigesterPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="DigesterPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="DigesterPipeDeclaredAttributeGroup">
    <xs:attribute name="digesterRulesFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of file that containts the rules for xml parsing Default: (none)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="DigesterPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="DigesterPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="DirectWrapperPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="TimeoutGuardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="TimeoutGuardPipeDeclaredAttributeGroup">
    <xs:attribute name="throwException" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a piperunexception is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:integer">
      <xs:annotation>
        <xs:documentation>timeout in seconds of obtaining a result Default: 30</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="TimeoutGuardPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="TimeoutGuardPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="DomainTransformerPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="DomainTransformerPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="DomainTransformerPipeDeclaredAttributeGroup">
    <xs:attribute name="jmsRealm" type="xs:string" />
    <xs:attribute name="labelField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column labels are stored in Default: label</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tableName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the table that contains the mapping Default: mapping</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueInField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column source values are stored in Default: valuein</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueOutField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column destination values are stored in Default: valueout</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="DomainTransformerPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="DomainTransformerPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="EchoPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="StreamingPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="EscapePipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="EscapePipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="EscapePipeDeclaredAttributeGroup">
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;encode&lt;/code&gt;, &lt;code&gt;decode&lt;/code&gt; or &lt;code&gt;cdata2text&lt;/code&gt; Default: encode</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodeSubstring" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; special characters in &lt;code&gt;substringstart&lt;/code&gt; and &lt;code&gt;substringend&lt;/code&gt; are first translated to their xml equivalents Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="substringEnd" type="xs:string">
      <xs:annotation>
        <xs:documentation>substring to end translation</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="substringStart" type="xs:string">
      <xs:annotation>
        <xs:documentation>substring to start translation</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="EscapePipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="EscapePipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="EtagHandlerPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="EtagHandlerPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="EtagHandlerPipeDeclaredAttributeGroup">
    <xs:attribute name="action" type="xs:string" />
    <xs:attribute name="restPath" type="xs:string" />
    <xs:attribute name="uriPattern" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="EtagHandlerPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="EtagHandlerPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ExceptionPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="ExceptionPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ExceptionPipeDeclaredAttributeGroup">
    <xs:attribute name="throwException" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a piperunexception is thrown. otherwise the output is only logged as an error (and no rollback is performed). Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ExceptionPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ExceptionPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ExecuteJdbcPropertiesType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="TimeoutGuardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="FileLineIteratorPipeType">
    <xs:group ref="IteratingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="FileLineIteratorPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FileLineIteratorPipeDeclaredAttributeGroup">
    <xs:attribute name="move2dirAfterError" type="xs:string">
      <xs:annotation>
        <xs:documentation>directory to which the inputfile is moved in case an error occurs</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="move2dirAfterTransform" type="xs:string">
      <xs:annotation>
        <xs:documentation>directory in which the transformed file(s) is stored</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FileLineIteratorPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="FileLineIteratorPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="StreamLineIteratorPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="StreamLineIteratorPipeType">
    <xs:group ref="IteratingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="StreamLineIteratorPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="StreamLineIteratorPipeDeclaredAttributeGroup">
    <xs:attribute name="endOfLineString" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, each record has to end with this string. If a line read doesn't end with this string more lines are added (including line separators) until the total record ends with the given string</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startOfLineString" type="xs:string">
      <xs:annotation>
        <xs:documentation>Marks the start of a new record. If set, a new record is started when this line is read.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="StreamLineIteratorPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="StreamLineIteratorPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="StringIteratorPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FilePipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FilePipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FilePipeDeclaredAttributeGroup">
    <xs:attribute name="actions" type="xs:string" />
    <xs:attribute name="charset" type="xs:string" />
    <xs:attribute name="createDirectory" type="xs:boolean" />
    <xs:attribute name="deleteEmptyDirectory" type="xs:boolean" />
    <xs:attribute name="directory" type="xs:string" />
    <xs:attribute name="fileName" type="xs:string" />
    <xs:attribute name="fileNameSessionKey" type="xs:string" />
    <xs:attribute name="fileSource" type="xs:string" />
    <xs:attribute name="filename" type="xs:string" />
    <xs:attribute name="filenameSessionKey" type="xs:string" />
    <xs:attribute name="outputType" type="xs:string" />
    <xs:attribute name="skipBOM" type="xs:boolean" />
    <xs:attribute name="streamResultToServlet" type="xs:boolean" />
    <xs:attribute name="testCanWrite" type="xs:boolean" />
    <xs:attribute name="testExists" type="xs:boolean" />
    <xs:attribute name="writeLineSeparator" type="xs:boolean" />
    <xs:attribute name="writeSuffix" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="FilePipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="FilePipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FileSystemPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FileSystemPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FileSystemPipeDeclaredAttributeGroup">
    <xs:attribute name="action" type="xs:string">
      <xs:annotation>
        <xs:documentation>Possible values: list, info, read, readDelete, move, copy, delete, mkdir, rmdir, write, append, rename. If parameter [action] is set, then the attribute action value will be overridden with the value of the parameter.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destination" type="xs:string">
      <xs:annotation>
        <xs:documentation>destination for move, copy or rename. If not set, the parameter destination is used. When that is not set either, the input is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filename" type="xs:string">
      <xs:annotation>
        <xs:documentation>filename to operate on. When not set, the parameter filename is used. When that is not set either, the input is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder that is scanned for files when action=list. When not set, the root is scanned</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createFolder" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the folder to move or copy to is created if it does not exist Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="overwrite" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, for actions move, copy or rename, the destination file is overwritten if it already exists Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rotateDays" type="xs:integer">
      <xs:annotation>
        <xs:documentation>for action=append: when set to a positive number, the file is rotated each day, and this number of files is kept. The inputFolder must point to the directory where the file resides Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rotateSize" type="xs:integer">
      <xs:annotation>
        <xs:documentation>for action=append: when set to a positive number, the file is rotated when it has reached the specified size, and the number of files specified in numberOfBackups is kept. Size is specified in plain bytes, suffixes like 'K', 'M' or 'G' are not recognized. The inputFolder must point to the directory where the file resides Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numberOfBackups" type="xs:integer">
      <xs:annotation>
        <xs:documentation>for action=write, and for action=append with rotateSize&gt;0: the number of backup files that is kept. The inputFolder must point to the directory where the file resides Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="base64" type="xs:string">
      <xs:annotation>
        <xs:documentation>Can be set to 'encode' or 'decode' for actions read, write and append. When set the stream is base64 encoded or decoded, respectively</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wildCard" type="xs:string">
      <xs:annotation>
        <xs:documentation>Filter of files to look for in inputFolder e.g. '*.inp'. Works with actions move, copy, delete and list</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="excludeWildCard" type="xs:string">
      <xs:annotation>
        <xs:documentation>Filter of files to be excluded when looking in inputFolder. Works with actions move, copy, delete and list</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNonEmptyFolder" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to true then the folder and the content of the non empty folder will be deleted.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FileSystemPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="FileSystemPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="StreamingPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FilenameSwitchType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FilenameSwitchCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FilenameSwitchDeclaredAttributeGroup">
    <xs:attribute name="notFoundForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when the forward or pipename derived from the filename that was the input could not be found.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="toLowercase" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>convert the result to lowercase, before searching for a corresponding forward Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FilenameSwitchCumulativeAttributeGroup">
    <xs:attributeGroup ref="FilenameSwitchDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FixedResultPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedResultPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FixedResultPipeDeclaredAttributeGroup">
    <xs:attribute name="fileName" type="xs:string" />
    <xs:attribute name="fileNameSessionKey" type="xs:string" />
    <xs:attribute name="filename" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the file containing the resultmessage</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filenameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the session key containing the file name of the file containing the result message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lookupAtRuntime" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the lookup of the file will be done at runtime instead of at configuration time Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceFixedParams" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, any parameter is used for replacements but with &lt;code&gt;name-of-parameter&lt;/code&gt; and not &lt;code&gt;${name-of-parameter}&lt;/code&gt; Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceFrom" type="xs:string" />
    <xs:attribute name="replaceTo" type="xs:string" />
    <xs:attribute name="returnString" type="xs:string">
      <xs:annotation>
        <xs:documentation>returned message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string" />
    <xs:attribute name="substituteVars" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>should values between ${ and } be resolved from the pipelinesession (search order: 1) system properties 2) pipelinesession variables 3) application properties) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FixedResultPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="FixedResultPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ForEachAttachmentPipeType">
    <xs:group ref="IteratingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="ForEachAttachmentPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ForEachAttachmentPipeDeclaredAttributeGroup">
    <xs:attribute name="excludeProperties" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of attachment properties not to list. When specified, 'onlyProperties' is ignored</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onlyProperties" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of attachment properties to list</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ForEachAttachmentPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ForEachAttachmentPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="IteratingPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ForEachChildElementPipeType">
    <xs:group ref="IteratingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="ForEachChildElementPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ForEachChildElementPipeDeclaredAttributeGroup">
    <xs:attribute name="processFile" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of a file to be processed. Otherwise, the input itself is transformed. The character encoding will be read from the XML declaration Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="containerElement" type="xs:string">
      <xs:annotation>
        <xs:documentation>Element name (not an XPath-expression), qualified via attribute &lt;code&gt;namespaceDefs&lt;/code&gt;, used to determine the 'root' of elements to be iterated over, i.e. the root of the set of child elements. When empty, the pipe will iterate over each direct child element of the root</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetElement" type="xs:string">
      <xs:annotation>
        <xs:documentation>Element name (not an XPath-expression), qualified via attribute &lt;code&gt;namespaceDefs&lt;/code&gt;, used to determine the type of elements to be iterated over, i.e. the element name of each of the child elements. When empty, the pipe will iterate over any direct child element of the root or specified containerElement</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementXPathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>XPath-expression used to determine the set of elements to be iterated over, i.e. the set of child elements. When empty, the effective value is /*/*, i.e. the pipe will iterate over each direct child element of the root. Be aware that memory consumption appears to increase with file size when this attribute is used. When possible, use containerElement and/or targetElement instead.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Characterset used for reading file or inputstream, only used when {@link #setProcessFile(boolean) processFile} is &lt;code&gt;true&lt;/code&gt;, or the input is of type InputStream Default: utf-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xsltVersion" type="xs:integer">
      <xs:annotation>
        <xs:documentation>When set to &lt;code&gt;2&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, supporting XPath 2.0, otherwise xslt processor 1.0 (org.apache.xalan), supporting XPath 1.0. N.B. Be aware that setting this other than 1 might cause the input file being read as a whole in to memory, as Xslt Streaming is currently only supported by the XsltProcessor that is used for xsltVersion=1 Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNamespaces" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed before transformation Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ForEachChildElementPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ForEachChildElementPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="StringIteratorPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FtpFileRetrieverPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FtpFileRetrieverPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="FtpFileRetrieverPipeDeclaredAttributeGroup">
    <xs:attribute name="allowSelfSignedCertificates" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(ftps) if true, the server certificate can be self signed Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the alias to obtain credentials to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificate" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) resource url to certificate to be used for authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) alias used to obtain certificate password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificatePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  Default: pkcs12</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="consoleKnownHostsVerifier" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(sftp)  Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deleteAfterGet" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>if true, the remote file is deleted after it is retrieved Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileType" type="xs:string">
      <xs:annotation>
        <xs:documentation>file type, one of ascii, binary</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ftpTypeDescription" type="xs:string">
      <xs:annotation>
        <xs:documentation>one of ftp, sftp, ftps(i) or ftpsi, ftpsx(ssl), ftpsx(tls) Default: ftp</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="host" type="xs:string">
      <xs:annotation>
        <xs:documentation>name or ip adres of remote host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>selects the algorithm to generate keymanagers. can be left empty to use the servers default algorithm Default: websphere: ibmx509</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyboardInteractive" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true, keyboardinteractive is used to login Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="knownHostsPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) path to file with knownhosts</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="localDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>local directory in which files have to be downloaded</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="localFilenamePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>pattern (in messageformat) of the local filename</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageIsContent" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>if true, the contents of the message is send, otherwise it message contains the local filenames of the files to be send Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="passive" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>if true, passive ftp is used: before data is sent, a pasv command is issued, and the connection is set up by the server Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the password to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="xs:integer">
      <xs:annotation>
        <xs:documentation>portnumber of remote host Default: 21</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefCSEncryption" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) optional preferred encryption from client to server for sftp protocol</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefSCEncryption" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) optional preferred encryption from server to client for sftp protocol</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) name of the alias to obtain credentials for passphrase of private key file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyFilePath" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) path to private key file for sftp authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) passphrase of private key file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="protP" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(ftps) if true, the server returns data via another socket Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the alias to obtain credentials to authenticate on proxy</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy host name</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>default password in case proxy requires authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:integer">
      <xs:annotation>
        <xs:documentation>proxy port Default: 1080</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyTransportType" type="xs:integer">
      <xs:annotation>
        <xs:documentation>(sftp) transport type in case of sftp (1=standard, 2=http, 3=socks4, 4=socks5) Default: 4</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>default user name in case proxy requires authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>remote directory</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>selects the algorithm to generate trustmanagers. can be left empty to use the servers default algorithm Default: websphere: ibmx509</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) resource url to truststore to be used for authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) alias used to obtain truststore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  Default: jks</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the user to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>(ftps) when true, the hostname in the certificate will be checked against the actual hostname Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FtpFileRetrieverPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="FtpFileRetrieverPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="GenericMessageSendingPipeType">
    <xs:group ref="SenderPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="MessageSendingPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="SenderPipeType">
    <xs:group ref="SenderPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="MessageSendingPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:group name="SenderPipeDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="SenderElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="ListenerElementGroup_2" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:group name="ListenerElementGroup_2">
    <xs:choice>
      <xs:element name="Listener">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element ref="Param" />
              <xs:group ref="SenderElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ListenerElementGroupBase_2" />
    </xs:choice>
  </xs:group>
  <xs:group name="ListenerElementGroupBase_2">
    <xs:choice>
      <xs:element name="PullingJmsListenerListener">
        <xs:annotation>
          <xs:documentation>PullingJmsListenerListener - nl.nn.adapterframework.jms.PullingJmsListener used as Listener

A true multi-threaded {@link nl.nn.adapterframework.core.IPullingListener Listener}-class.
 &lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PullingJmsListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jms.PullingJmsListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="SenderPipeCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="SenderPipeDeclaredChildGroup" />
      <xs:group ref="MessageSendingPipeCumulativeChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:complexType name="GetFromSessionType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="GetFromSessionCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="GetFromSessionDeclaredAttributeGroup">
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of the session variable to retrieve the output message from. When left unspecified, the input message is used as the key of the session variable</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>&lt;ul&gt;&lt;li&gt;&lt;code&gt;string&lt;/code&gt;: renders the contents&lt;/li&gt;&lt;li&gt;&lt;code&gt;map&lt;/code&gt;: converts a Map&amp;lt;String, String&amp;gt; object to a xml-string (&amp;lt;items&amp;gt;&amp;lt;item name='...'&amp;gt;...&amp;lt;/item&amp;gt;&amp;lt;item name='...'&amp;gt;...&amp;lt;/item&amp;gt;&amp;lt;/items&amp;gt;)&lt;/li&gt;&lt;/ul&gt; Default: string</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="GetFromSessionCumulativeAttributeGroup">
    <xs:attributeGroup ref="GetFromSessionDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="GetPrincipalPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="HashPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="HashPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="HashPipeDeclaredAttributeGroup">
    <xs:attribute name="algorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Hashing algoritm to use, one of HmacMD5, HmacSHA1, HmacSHA256, HmacSHA384 or HmacSHA512 Default: hmacsha256</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Character set to use for converting the secret from String to bytes Default: UTF-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="binaryToTextEncoding" type="xs:string">
      <xs:annotation>
        <xs:documentation>method to use for converting the hash from bytes to String, one of Base64 or Hex Default: Base64</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secret" type="xs:string">
      <xs:annotation>
        <xs:documentation>The secret to hash with. Only used if no parameter secret is configured. The secret is only used when there is no authAlias specified, by attribute or parameter</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authAlias to retrieve the secret from (password field). Only used if no parameter authAlias is configured</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encoding" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="HashPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="HashPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="IfMultipartType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="IfMultipartCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="IfMultipartDeclaredAttributeGroup">
    <xs:attribute name="elseForwardName" type="xs:string" />
    <xs:attribute name="thenForwardName" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="IfMultipartCumulativeAttributeGroup">
    <xs:attributeGroup ref="IfMultipartDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="IncreaseIntegerPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="IncreaseIntegerPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="IncreaseIntegerPipeDeclaredAttributeGroup">
    <xs:attribute name="increment" type="xs:integer">
      <xs:annotation>
        <xs:documentation>amount to increment the value. Can be set from the attribute or the parameter 'increment' Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>reference to the session variable whose value is to be increased</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="IncreaseIntegerPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="IncreaseIntegerPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="IsUserInRolePipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="IsUserInRolePipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="IsUserInRolePipeDeclaredAttributeGroup">
    <xs:attribute name="notInRoleForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of forward returned if user is not allowed to assume the specified role Default: notInRole</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="role" type="xs:string">
      <xs:annotation>
        <xs:documentation>the j2ee role to check.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="IsUserInRolePipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="IsUserInRolePipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="IsXmlIfPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="IsXmlIfPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="IsXmlIfPipeDeclaredAttributeGroup">
    <xs:attribute name="elseForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when 'false' Default: else</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elseForwardOnEmptyInput" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>return elseforward when input is empty (or thenforward) Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="thenForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when &lt;code&gt;'true'&lt;/code&gt; Default: then</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="IsXmlIfPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="IsXmlIfPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JsonPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="JsonPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="JsonPipeDeclaredAttributeGroup">
    <xs:attribute name="addXmlRootElement" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when true, and direction is json2xml, it wraps a root element around the converted message Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>Direction of the transformation. Either json2xml or xml2json Default: json2xml</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="version" type="xs:string">
      <xs:annotation>
        <xs:documentation>Version of the jsonpipe. Either 1 or 2. Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JsonPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="JsonPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JsonWellFormedCheckerType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="JsonXsltPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="JsonXsltPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="JsonXsltPipeDeclaredAttributeGroup">
    <xs:attribute name="jsonResult" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>When &lt;code&gt;true&lt;/code&gt;, the xml result of the transformation is converted back to json Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions Default: j=http://www.w3.org/2013/XSL/json</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JsonXsltPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="JsonXsltPipeDeclaredAttributeGroup" />
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Location of stylesheet to apply to the input message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key to retrieve stylesheet location. Overrides stylesheetName or xpathExpression attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetCacheSize" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Size of cache of stylesheets retrieved from styleSheetNameSessionKey Default: 100</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alternatively: xpath-expression to create stylesheet from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>omit the xml declaration on top of the output. When not set, the value specified in the stylesheet is followed Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>For xpathExpression only: either 'text' or 'xml'. Default: text</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indentXml" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, result is pretty-printed. When not set, the value specified in the stylesheet is followed Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNamespaces" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed before transformation Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipEmptyTags" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; empty tags in the output are removed after transformation Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xsltVersion" type="xs:integer">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;2&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan). &lt;code&gt;0&lt;/code&gt; will auto detect Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, then the XsltPipe stores it result in the session using the supplied sessionKey, and returns its input as result</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="StreamingPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeDeclaredAttributeGroup" />
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, input is taken from this session key, instead of regular input</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the pipe</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, this fixed value is taken as input, instead of regular input</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set and the input is empty, this fixed value is taken as input</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the result of the pipe is replaced with the original input (i.e. the input before configured replacements of &lt;code&gt;getInputFromSessionKey&lt;/code&gt;, &lt;code&gt;getInputFromFixedValue&lt;/code&gt; or &lt;code&gt;emptyInputReplacement&lt;/code&gt;) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the result (before replacing when &lt;code&gt;true&lt;/code&gt;) is stored under this session key</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementToMoveSessionKey&lt;/code&gt; + }</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Only used when &lt;code&gt;elementToMove&lt;/code&gt; is set) Name of the session key under which the character data is stored Default: ref_ + the name of the element</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>Like &lt;code&gt;elementToMove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe')</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:integer">
      <xs:annotation>
        <xs:documentation>If durationThreshold &gt;=0 and the duration of the message processing exceeded the value specified (in milliseconds) the message is logged informatory Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>Regular expression to mask strings in the log. For example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:integer">
      <xs:annotation>
        <xs:documentation>maximum number of threads that may call {@link #doPipe(java.lang.Object, nl.nn.adapterframework.core.PipeLineSession)} simultaneously Default: 0 (unlimited)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:boolean" />
    <xs:attribute name="restoreMovedElements" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, compacted messages in the result are restored to their original format (see also  {@link #setElementToMove(java.lang.String)}) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default: (Only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) Comma separated list of keys of session variables that is appended to the security log record</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sizeStatistics" type="xs:boolean" />
    <xs:attribute name="writeToSecLog" type="xs:boolean" />
    <xs:attributeGroup ref="TransactionAttributesDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XsltPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="XsltPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="XsltPipeDeclaredAttributeGroup">
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Location of stylesheet to apply to the input message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key to retrieve stylesheet location. Overrides stylesheetName or xpathExpression attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetCacheSize" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Size of cache of stylesheets retrieved from styleSheetNameSessionKey Default: 100</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alternatively: xpath-expression to create stylesheet from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>omit the xml declaration on top of the output. When not set, the value specified in the stylesheet is followed Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions. For some use other cases (NOT xpathExpression), one entry can be without a prefix, that will define the default namespace.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>For xpathExpression only: either 'text' or 'xml'. Default: text</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indentXml" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, result is pretty-printed. When not set, the value specified in the stylesheet is followed Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNamespaces" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed before transformation Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipEmptyTags" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; empty tags in the output are removed after transformation Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xsltVersion" type="xs:integer">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;2&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan). &lt;code&gt;0&lt;/code&gt; will auto detect Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, then the XsltPipe stores it result in the session using the supplied sessionKey, and returns its input as result</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XsltPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="XsltPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="StreamingPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeDeclaredAttributeGroup" />
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, input is taken from this session key, instead of regular input</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the pipe</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, this fixed value is taken as input, instead of regular input</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set and the input is empty, this fixed value is taken as input</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the result of the pipe is replaced with the original input (i.e. the input before configured replacements of &lt;code&gt;getInputFromSessionKey&lt;/code&gt;, &lt;code&gt;getInputFromFixedValue&lt;/code&gt; or &lt;code&gt;emptyInputReplacement&lt;/code&gt;) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the result (before replacing when &lt;code&gt;true&lt;/code&gt;) is stored under this session key</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementToMoveSessionKey&lt;/code&gt; + }</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Only used when &lt;code&gt;elementToMove&lt;/code&gt; is set) Name of the session key under which the character data is stored Default: ref_ + the name of the element</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>Like &lt;code&gt;elementToMove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe')</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:integer">
      <xs:annotation>
        <xs:documentation>If durationThreshold &gt;=0 and the duration of the message processing exceeded the value specified (in milliseconds) the message is logged informatory Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>Regular expression to mask strings in the log. For example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:integer">
      <xs:annotation>
        <xs:documentation>maximum number of threads that may call {@link #doPipe(java.lang.Object, nl.nn.adapterframework.core.PipeLineSession)} simultaneously Default: 0 (unlimited)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:boolean" />
    <xs:attribute name="restoreMovedElements" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, compacted messages in the result are restored to their original format (see also  {@link #setElementToMove(java.lang.String)}) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default: (Only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) Comma separated list of keys of session variables that is appended to the security log record</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sizeStatistics" type="xs:boolean" />
    <xs:attribute name="writeToSecLog" type="xs:boolean" />
    <xs:attributeGroup ref="TransactionAttributesDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LabelFormatType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="LabelFormatCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="LabelFormatDeclaredAttributeGroup">
    <xs:attribute name="direction" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="LabelFormatCumulativeAttributeGroup">
    <xs:attributeGroup ref="LabelFormatDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LdapChallengePipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="LdapChallengePipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="LdapChallengePipeDeclaredAttributeGroup">
    <xs:attribute name="errorSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable used to store cause of errors</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory Default: com.sun.jndi.ldap.ldapctxfactory</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ldapProviderURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>url to the ldap server. &lt;br/&gt;example: ldap://su05b9.itc.intranet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LdapChallengePipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="LdapChallengePipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LdapFindGroupMembershipsPipeType">
    <xs:group ref="LdapFindGroupMembershipsPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="LdapFindGroupMembershipsPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:group name="LdapFindGroupMembershipsPipeDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="CacheElementGroup" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:group name="LdapFindGroupMembershipsPipeCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="LdapFindGroupMembershipsPipeDeclaredChildGroup" />
      <xs:group ref="AbstractPipeDeclaredChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="LdapFindGroupMembershipsPipeDeclaredAttributeGroup">
    <xs:attribute name="recursiveSearch" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the memberOf attribute is also searched in all the found members Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LdapFindGroupMembershipsPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="LdapFindGroupMembershipsPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="LdapQueryPipeBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="LdapQueryPipeBaseDeclaredAttributeGroup">
    <xs:attribute name="ldapProviderURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>Url to context to search in, e.g. 'ldaps://insim.biz'.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="host" type="xs:string">
      <xs:annotation>
        <xs:documentation>Host part of ldapProviderUrl. Only used when ldapProviderUrl not specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Port of ldapProviderUrl. Only used when ldapProviderUrl not specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useSsl" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Indication to use ldap or ldaps in ldapProviderUrl. Only used when ldapProviderUrl not specified Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="baseDN" type="xs:string">
      <xs:annotation>
        <xs:documentation>BaseDN, e.g. OU=Tenants,DC=INSIM,DC=BIZ Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain credentials to connect to ldap server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="userName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Username used to obtain credentials to connect to ldap server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password used to obtain credentials to connect to ldap server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exceptionForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>PipeForward used when an exception is caught</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="notFoundForwardName" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="LdapQueryPipeBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="LdapQueryPipeBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LdapFindMemberPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="LdapFindMemberPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="LdapFindMemberPipeDeclaredAttributeGroup">
    <xs:attribute name="dnSearchIn" type="xs:string">
      <xs:annotation>
        <xs:documentation>The dn of the group to search in when the parameter dnSearchIn is not set</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dnFind" type="xs:string">
      <xs:annotation>
        <xs:documentation>The dn of the member to search for when the parameter dnFind is not set</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="recursiveSearch" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the member attribute is also searched in all the found members Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LdapFindMemberPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="LdapFindMemberPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="LdapQueryPipeBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LocalFileSystemPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="LocalFileSystemPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="LocalFileSystemPipeDeclaredAttributeGroup">
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>the folder that serves as the root of this virtual filesystem</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LocalFileSystemPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="LocalFileSystemPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="MailSenderPipeType">
    <xs:group ref="MessageSendingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="MessageSendingPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="MoveFilePipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="MoveFilePipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="MoveFilePipeDeclaredAttributeGroup">
    <xs:attribute name="append" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; and the destination file already exists, the content of the file to move is written to the end of the destination file. this implies &lt;code&gt;overwrite=false&lt;/code&gt; Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createDirectory" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the directory to move to is created if it does not exist Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deleteEmptyDirectory" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the directory from which a file is moved is deleted when it contains no other files Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directory" type="xs:string">
      <xs:annotation>
        <xs:documentation>base directory where files are moved from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filename" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the file to move (if not specified, the input for this pipe is assumed to be the name of the file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="move2dir" type="xs:string">
      <xs:annotation>
        <xs:documentation>destination directory</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="move2file" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the destination file (if not specified, the name of the file to move is taken)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="move2fileSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key that contains the name of the file to use (only used if move2file is not set)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numberOfAttempts" type="xs:integer">
      <xs:annotation>
        <xs:documentation>maximum number of attempts before throwing an exception Default: 10</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numberOfBackups" type="xs:integer">
      <xs:annotation>
        <xs:documentation>number of copies held of a file with the same name. backup files have a dot and a number suffixed to their name. if set to 0, no backups will be kept. Default: 5</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="overwrite" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the destination file will be deleted if it already exists. when set &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;numberofbackups&lt;/code&gt; set to 0, a counter is added to the destination filename ('basename_###.ext') Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>string which is inserted at the start of the destination file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="suffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>string which is inserted at the end of the destination file (and replaces the extension if present)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;numberofbackups&lt;/code&gt; is set to 0 and the destination file already exists a piperunexception is thrown (instead of adding a counter to the destination filename) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="waitBeforeRetry" type="xs:integer">
      <xs:annotation>
        <xs:documentation>time between attempts Default: 1000 [ms]</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wildcard" type="xs:string">
      <xs:annotation>
        <xs:documentation>filter of files to replace</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wildcardSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key that contains the name of the filter to use (only used if wildcard is not set)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="MoveFilePipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="MoveFilePipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="PGPPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="PGPPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="PGPPipeDeclaredAttributeGroup">
    <xs:attribute name="action" type="xs:string">
      <xs:annotation>
        <xs:documentation>Action to be taken when pipe is executed. It can be one of the followed: Encrypt (encrypts the input), Sign (Encrypts and Signs the input), Decrypt (Decrypts the input), Verify (Decrypts and verifies the input)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="publicKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Path to the recipient's public key. It will be used for encryption and verification.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="recipients" type="xs:string">
      <xs:annotation>
        <xs:documentation>Recipients to be used during encryption stage. If multiple, separate with ';' (semicolon)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secretKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Path to the private key. It will be used when signing or decrypting.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secretPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password for the private key.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verificationAddresses" type="xs:string">
      <xs:annotation>
        <xs:documentation>Emails of the senders. This will be used to verify that all the senders have signed the given message. If not set, and the action is verify; this pipe will validate that at least one person has signed. For signing action, it needs to be set to the email that was used to generate the private key that is being used for this process.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="PGPPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="PGPPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="StreamingPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="PasswordGeneratorPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="PasswordGeneratorPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="PasswordGeneratorPipeDeclaredAttributeGroup">
    <xs:attribute name="lCharacters" type="xs:string">
      <xs:annotation>
        <xs:documentation>the lowercase characters to use Default: ('a'..'z')</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numOfDigits" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the number of digits in the generated password Default: 2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numOfLCharacters" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the number of lowercase characters in the generated password Default: 2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numOfSigns" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the number of sign characters in the generated password Default: 2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numOfUCharacters" type="xs:integer">
      <xs:annotation>
        <xs:documentation>the number of uppercase characters in the generated password Default: 2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numbers" type="xs:string">
      <xs:annotation>
        <xs:documentation>the numbers to use Default: ('0'..'9')</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="signs" type="xs:string">
      <xs:annotation>
        <xs:documentation>the signs to use Default: (;:_%$#@!&amp;gt;&amp;lt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="uCharacters" type="xs:string">
      <xs:annotation>
        <xs:documentation>the uppercase characters to use Default: ('a'..'z')</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useSecureRandom" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>whether the securerandom algorithm is to be used (slower) Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="PasswordGeneratorPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="PasswordGeneratorPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="PasswordHashPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="PasswordHashPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="PasswordHashPipeDeclaredAttributeGroup">
    <xs:attribute name="hashSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of sessionkey that holds the hash which will be used to validate the password (input of the pipe)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rounds" type="xs:integer" />
    <xs:attribute name="roundsSessionKey" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="PasswordHashPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="PasswordHashPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="PostboxRetrieverPipeType">
    <xs:group ref="PostboxRetrieverPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="PostboxRetrieverPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:group name="PostboxRetrieverPipeDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="ListenerElementGroup_3" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:group name="ListenerElementGroup_3">
    <xs:choice>
      <xs:element name="Listener">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element ref="Param" />
              <xs:group ref="SenderElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ListenerElementGroupBase_3" />
    </xs:choice>
  </xs:group>
  <xs:group name="ListenerElementGroupBase_3">
    <xs:choice>
      <xs:element name="PullingJmsListenerListener">
        <xs:annotation>
          <xs:documentation>PullingJmsListenerListener - nl.nn.adapterframework.jms.PullingJmsListener used as Listener

A true multi-threaded {@link nl.nn.adapterframework.core.IPullingListener Listener}-class.
 &lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PullingJmsListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.jms.PullingJmsListener" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="PostboxRetrieverPipeCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="PostboxRetrieverPipeDeclaredChildGroup" />
      <xs:group ref="AbstractPipeDeclaredChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="PostboxRetrieverPipeDeclaredAttributeGroup">
    <xs:attribute name="resultOnEmptyPostbox" type="xs:string">
      <xs:annotation>
        <xs:documentation>result when no object is on postbox Default: empty postbox</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="PostboxRetrieverPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="PostboxRetrieverPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="PutInSessionType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="PutInSessionCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="PutInSessionDeclaredAttributeGroup">
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of the session variable to store the input in</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value to store in the &lt;code&gt;pipeLineSession&lt;/code&gt;. If not set, the input of the pipe is stored</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="PutInSessionCumulativeAttributeGroup">
    <xs:attributeGroup ref="PutInSessionDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="PutParametersInSessionType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="PutSystemDateInSessionType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="PutSystemDateInSessionCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="PutSystemDateInSessionDeclaredAttributeGroup">
    <xs:attribute name="dateFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>Format to store date in Default: full ISO format: yyyy-MM-dd'T'HH:mm:sszzz</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getCurrentTimeStampInMillis" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to 'true' then current time stamp in millisecond will be stored in the sessionKey Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="returnFixedDate" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the date/time returned will always be 2001-12-17 09:30:47 (for testing purposes only). It is overridden by the value of the pipelinesession key &lt;code&gt;stub4testtool.fixeddate&lt;/code&gt; when it exists Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of session variable to store systemdate in Default: systemdate</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sleepWhenEqualToPrevious" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Set to a time in millisecond to create a value that is different to the previous returned value by a PutSystemDateInSession pipe in this virtual machine. The thread will sleep for the specified time before recalculating a new value. Set the timezone to a value without Daylight Saving Time (like GMT+1) to prevent this pipe to generate two equal value's when the clock is set back. &lt;b&gt;note:&lt;/b&gt; When you're looking for a GUID parameter for your XSLT it might be better to use &amp;lt;param name=&amp;quot;guid&amp;quot; pattern=&amp;quot;{hostname}_{uid}&amp;quot;/&amp;gt;, see {@link nl.nn.adapterframework.parameters.Parameter} Default: -1 (disabled)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeZone" type="xs:string">
      <xs:annotation>
        <xs:documentation>Time zone to use for the formatter Default: the default time zone for the JVM</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="PutSystemDateInSessionCumulativeAttributeGroup">
    <xs:attributeGroup ref="PutSystemDateInSessionDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="RekenBoxCallerType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="RekenBoxCallerCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="RekenBoxCallerDeclaredAttributeGroup">
    <xs:attribute name="cleanup" type="xs:boolean" />
    <xs:attribute name="commandLineType" type="xs:string" />
    <xs:attribute name="dataFilenamePrefix" type="xs:string" />
    <xs:attribute name="executableExtension" type="xs:string" />
    <xs:attribute name="inputOutputDirectory" type="xs:string" />
    <xs:attribute name="maxRequestNumber" type="xs:integer" />
    <xs:attribute name="rekenBoxName" type="xs:string" />
    <xs:attribute name="rekenboxSessionKey" type="xs:string" />
    <xs:attribute name="runPath" type="xs:string" />
    <xs:attribute name="templateDir" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="RekenBoxCallerCumulativeAttributeGroup">
    <xs:attributeGroup ref="RekenBoxCallerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="RemoveCacheKeyPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="RemoveCacheKeyPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="RemoveCacheKeyPipeDeclaredAttributeGroup">
    <xs:attribute name="cacheName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the cache from which items are to be removed</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>XPath expression to extract cache key from request message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyXPathOutputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>Output type of xpath expression to extract cache key from request message, must be 'xml' or 'text' Default: text</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for keyXPath. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>Stylesheet to extract cache key from request message. Use in combination with {@link #setCacheEmptyKeys(boolean) cacheEmptyKeys} to inhibit caching for certain groups of request messages</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyInputSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key to use as input for transformation of request message to key by keyXPath or keyStyleSheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="RemoveCacheKeyPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="RemoveCacheKeyPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="RemoveFromSessionType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="RemoveFromSessionCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="RemoveFromSessionDeclaredAttributeGroup">
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the key of the entry in the &lt;code&gt;pipelinesession&lt;/code&gt; to remove. if this key is empty the input message is interpretted as key. for multiple keys use ',' as delimiter</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="RemoveFromSessionCumulativeAttributeGroup">
    <xs:attributeGroup ref="RemoveFromSessionDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ReplacerPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="ReplacerPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ReplacerPipeDeclaredAttributeGroup">
    <xs:attribute name="allowUnicodeSupplementaryCharacters" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Whether to allow Unicode supplementary characters (like a smiley) during {@link nl.nn.adapterframework.util.XmlUtils#replaceNonValidXmlCharacters(String, char, boolean, boolean) replaceNonValidXmlCharacters} Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="find" type="xs:string">
      <xs:annotation>
        <xs:documentation>string to search for</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineSeparatorSymbol" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets the string the representation in find and replace of the line separator</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replace" type="xs:string">
      <xs:annotation>
        <xs:documentation>string that will replace each of the strings found</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceNonXmlChar" type="xs:string">
      <xs:annotation>
        <xs:documentation>character that will replace each non valid xml character (empty string is also possible) (use &amp;amp;#x00bf; for inverted question mark) Default: empty string</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceNonXmlChars" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Replace all non XML chars (not in the &lt;a href="http://www.w3.org/TR/2006/REC-xml-20060816/#NT-Char"&gt;character range as specified by the XML specification&lt;/a&gt;) with {@link nl.nn.adapterframework.util.XmlUtils#replaceNonValidXmlCharacters(String, char, boolean, boolean) replaceNonValidXmlCharacters} Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ReplacerPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ReplacerPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ResultSetIteratingPipeType">
    <xs:group ref="IteratingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="JdbcIteratingPipeBaseCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="RhinoPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="RhinoPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="RhinoPipeDeclaredAttributeGroup">
    <xs:attribute name="debug" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; or set to something else then "true", (even set to the empty string), the debugging is not active Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the file containing the Java-script Functions as base input</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsfunctionArguments" type="xs:string">
      <xs:annotation>
        <xs:documentation>The arguments to run the function in the java-script library to run</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsfunctionName" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the function in the java-script library to run</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lookupAtRuntime" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the lookup of the file will be done at runtime instead of at configuration time Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="RhinoPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="RhinoPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Samba1PipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="Samba1PipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="Samba1PipeDeclaredAttributeGroup">
    <xs:attribute name="share" type="xs:string">
      <xs:annotation>
        <xs:documentation>Shared folder name in the samba server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for the smb share</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="domain" type="xs:string">
      <xs:annotation>
        <xs:documentation>in case the user account is bound to a domain</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="force" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether hidden files are seen or not Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Samba1PipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="Samba1PipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Samba2PipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="Samba2PipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="Samba2PipeDeclaredAttributeGroup">
    <xs:attribute name="share" type="xs:string">
      <xs:annotation>
        <xs:documentation>the destination, aka smb://xxx/yyy share</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for the smb share</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="domain" type="xs:string">
      <xs:annotation>
        <xs:documentation>domain, in case the user account is bound to a domain</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authType" type="xs:string">
      <xs:annotation>
        <xs:documentation>Type of the authentication either 'NTLM' or 'SPNEGO'  Default: SPNEGO</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="kdc" type="xs:string">
      <xs:annotation>
        <xs:documentation>Kerberos Domain Controller, as set in java.security.krb5.kdc. If authentication type specified as SPNEGO and realm is specified then this field must be filled.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="realm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Kerberos Realm, as set in java.security.krb5.realm. If authentication type specified as SPNEGO this field must be filled. If not filled then default realm is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Samba2PipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="Samba2PipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SambaPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="Samba2PipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="ScanTibcoSolutionPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="ScanTibcoSolutionPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ScanTibcoSolutionPipeDeclaredAttributeGroup">
    <xs:attribute name="level" type="xs:integer" />
    <xs:attribute name="url" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="ScanTibcoSolutionPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ScanTibcoSolutionPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ShowConfigType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="TimeoutGuardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="ShowConfigExeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="TimeoutGuardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="ShowConfigurationType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="TimeoutGuardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="ShowConfigurationStatusType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="TimeoutGuardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="ShowEnvironmentVariablesType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="TimeoutGuardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="ShowFlowDiagramType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="TimeoutGuardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="SignaturePipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="SignaturePipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="SignaturePipeDeclaredAttributeGroup">
    <xs:attribute name="action" type="xs:string">
      <xs:annotation>
        <xs:documentation>Action to be taken when pipe is executed. It can be one of the followed: sign (Signs the input), verify (verifies a signature) Default: sign</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="algorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>The signing algorithm Default: SHA256withRSA</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="provider" type="xs:string" />
    <xs:attribute name="signatureBase64" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>if true, the signature is (expected to be) base64 encoded Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystore" type="xs:string">
      <xs:annotation>
        <xs:documentation>Keystore to obtain signing key</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>Type of keystore, can be pkcs12 or pem Default: pkcs12</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain keystore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Keystore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias in keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default:</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SignaturePipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="SignaturePipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SizePipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="SkipPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="SkipPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="SkipPipeDeclaredAttributeGroup">
    <xs:attribute name="length" type="xs:integer">
      <xs:annotation>
        <xs:documentation>if length&gt;=0 only these number of bytes (for byte array input) or characters (for string input) is returned. Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skip" type="xs:integer">
      <xs:annotation>
        <xs:documentation>number of bytes (for byte array input) or characters (for string input) to skip. an empty byte array or string is returned when skip is larger then the length of the input Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SkipPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="SkipPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Stream2StringPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="TestPipeLineType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="TimeoutGuardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="Text2XmlPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="Text2XmlPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="Text2XmlPipeDeclaredAttributeGroup">
    <xs:attribute name="includeXmlDeclaration" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether a declation is included above the xml text Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceNonXmlChars" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>replace all non xml chars (not in the &lt;a href="http://www.w3.org/tr/2006/rec-xml-20060816/#nt-char"&gt;character range as specified by the xml specification&lt;/a&gt;) with the inverted question mark (0x00bf) Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="splitLines" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether the lines of the input are places in separated &amp;lt;line&amp;gt; tags Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useCdataSection" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>controls whether the text to encapsulate should be put in a cdata section Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>the xml tag to encapsulate the text in</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Text2XmlPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="Text2XmlPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="TextSplitterPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="TextSplitterPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="TextSplitterPipeDeclaredAttributeGroup">
    <xs:attribute name="maxBlockLength" type="xs:integer">
      <xs:annotation>
        <xs:documentation>Set the maximum number of characters of a block Default: 160</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="softSplit" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true, try to break up the message at spaces, instead of in the middle of words Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="TextSplitterPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="TextSplitterPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="StreamingPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="UUIDGeneratorPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="UUIDGeneratorPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="UUIDGeneratorPipeDeclaredAttributeGroup">
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;alphanumeric&lt;/code&gt; or &lt;code&gt;numeric&lt;/code&gt; Default: alphanumeric</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="UUIDGeneratorPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="UUIDGeneratorPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="UnzipPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="UnzipPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="UnzipPipeDeclaredAttributeGroup">
    <xs:attribute name="directory" type="xs:string">
      <xs:annotation>
        <xs:documentation>Directory to extract the archive to</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directorySessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Sessionkey with a directory value to extract the archive to</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deleteOnExit" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true, file is automatically deleted upon normal JVM termination Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectResults" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;false&lt;/code&gt;, only a small summary (count of items in zip) is returned Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectFileContents" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the contents of the files in the zip are returned in the result xml message of this pipe. Please note this can consume a lot of memory for large files or a large number of files Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectFileContentsBase64Encoded" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of file extensions. Files with an extension which is part of this list will be base64 encoded. All other files are assumed to have UTF-8 when reading it from the zip and are added as escaped xml with non-unicode-characters being replaced by inverted question mark appended with #, the character number and ; Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keepOriginalFileName" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;false&lt;/code&gt;, a suffix is added to the original filename to be sure it is unique Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createSubdirectories" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, subdirectories in the zip file are created in the directory to extract the archive to Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="assumeDirectoryExists" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>if set &lt;code&gt;true&lt;/code&gt;, validation of directory is ignored Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkDirectory" type="xs:boolean" />
  </xs:attributeGroup>
  <xs:attributeGroup name="UnzipPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="UnzipPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="UploadConfigType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="TimeoutGuardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="UploadConfigServiceType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="UploadFilePipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="UploadFilePipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="UploadFilePipeDeclaredAttributeGroup">
    <xs:attribute name="directory" type="xs:string">
      <xs:annotation>
        <xs:documentation>base directory where files are unzipped to</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directorySessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>the session key that contains the base directory where files are unzipped to Default: destination</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the key in the &lt;code&gt;pipelinesession&lt;/code&gt; which contains the inputstream Default: file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="UploadFilePipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="UploadFilePipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="WebservicesType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="TimeoutGuardPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="WsdlGeneratorPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="WsdlGeneratorPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="WsdlGeneratorPipeDeclaredAttributeGroup">
    <xs:attribute name="from" type="xs:string">
      <xs:annotation>
        <xs:documentation>either parent (adapter of pipeline which contains this pipe) or input (name of adapter specified by input of pipe) Default: parent</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="WsdlGeneratorPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="WsdlGeneratorPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XQueryPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="XQueryPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="XQueryPipeDeclaredAttributeGroup">
    <xs:attribute name="xqueryFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the file on the file system to read the xquery from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xqueryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the file (resource) on the classpath to read the xquery from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XQueryPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="XQueryPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XmlBuilderPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="XmlBuilderPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="XmlBuilderPipeDeclaredAttributeGroup">
    <xs:attribute name="substringEnd" type="xs:string">
      <xs:annotation>
        <xs:documentation>substring to end translation</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="substringStart" type="xs:string">
      <xs:annotation>
        <xs:documentation>substring to start translation</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XmlBuilderPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="XmlBuilderPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XmlFileElementIteratorPipeType">
    <xs:group ref="IteratingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="XmlFileElementIteratorPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="XmlFileElementIteratorPipeDeclaredAttributeGroup">
    <xs:attribute name="elementChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the element to iterate over, preceded with all ancestor elements and separated by semicolons (e.g. adapter;pipeline;pipe)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the element to iterate over (alternatively: &lt;code&gt;elementchain&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XmlFileElementIteratorPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="XmlFileElementIteratorPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="IteratingPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XmlIfType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="XmlIfCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="XmlIfDeclaredAttributeGroup">
    <xs:attribute name="elseForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when 'false' Default: else</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expressionValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>a string to compare the result of the xpathexpression (or the input-message itself) to. if not specified, a non-empty result leads to the 'then'-forward, an empty result to 'else'-forward</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="regex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to be applied to the input-message (ignored if xpathexpression is specified). the input-message matching the given regular expression leads to the 'then'-forward</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the key in the &lt;code&gt;pipelinesession&lt;/code&gt; to retrieve the input-message from. if not set, the current input message of the pipe is taken. n.b. same as &lt;code&gt;getinputfromsessionkey&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="thenForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when &lt;code&gt;'true'&lt;/code&gt; Default: then</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to be applied to the input-message. if not set, no transformation is done</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xsltVersion" type="xs:integer">
      <xs:annotation>
        <xs:documentation>specifies the version of xslt to use Default: 2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XmlIfCumulativeAttributeGroup">
    <xs:attributeGroup ref="XmlIfDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XmlSwitchType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="XmlSwitchCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="XmlSwitchDeclaredAttributeGroup">
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet may return a string representing the forward to look up Default: &lt;i&gt;a stylesheet that returns the name of the root-element&lt;/i&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath-expression that returns a string representing the forward to look up. It's possible to refer to a parameter (which e.g. contains a value from a sessionkey) by using the parameter name prefixed with $</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions. For some use other cases (NOT xpathExpression), one entry can be without a prefix, that will define the default namespace.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the key in the &lt;code&gt;PipeLineSession&lt;/code&gt; to retrieve the input message from, if a styleSheetName or a xpathExpression is specified. If no styleSheetName or xpathExpression is specified, the value of the session variable is used as the name of the forward. If none of sessionKey, styleSheetName or xpathExpression are specified, the element name of the root node of the input message is taken as the name of forward.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="notFoundForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Forward returned when the pipename derived from the stylesheet could not be found.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Forward returned when the content, on which the switch is performed, is empty. if &lt;code&gt;emptyforwardname&lt;/code&gt; is not specified, &lt;code&gt;notfoundforwardname&lt;/code&gt; is used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xsltVersion" type="xs:integer">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;2&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan). &lt;code&gt;0&lt;/code&gt; will auto detect Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeForwardInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Selected forward name will be stored in the specified session key.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceSelectionStylesheetFilename" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet may return a string representing the forward to look up Default: &lt;i&gt;a stylesheet that returns the name of the root-element&lt;/i&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XmlSwitchCumulativeAttributeGroup">
    <xs:attributeGroup ref="XmlSwitchDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ZipIteratorPipeType">
    <xs:group ref="IteratingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="ZipIteratorPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ZipIteratorPipeDeclaredAttributeGroup">
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used when reading the contents of the entry (only used if streamingcontens=false&gt; Default: utf-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeStreamOnExit" type="xs:boolean" />
    <xs:attribute name="contentsSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key used to store contents of each zip entry Default: zipdata</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipBOM" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, a possible bytes order mark (bom) at the start of the file is skipped (only used for encoding uft-8) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamingContents" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, a string containing the contents of the entry is placed under the session key, instead of the inputstream to the contents Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ZipIteratorPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ZipIteratorPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="IteratingPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ZipWriterPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="ZipWriterPipeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="ZipWriterPipeDeclaredAttributeGroup">
    <xs:attribute name="action" type="xs:string">
      <xs:annotation>
        <xs:documentation>one of &lt;ul&gt;&lt;li&gt;open: to open a new zip file or stream&lt;/li&gt; &lt;li&gt;close: to close the zip file or stream&lt;/li&gt; &lt;li&gt;write: write the input to the zip as a new entry&lt;/li&gt; &lt;li&gt;stream: create a new zip entry, and provide an outputstream that another pipe can use to write the contents&lt;/li&gt; &lt;/ul&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for action='write': charset used to write strings to zip entries Default: utf-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>only for action='write': when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after the zip entry is written Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeOutputstreamOnExit" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>only for action='open': when set to &lt;code&gt;false&lt;/code&gt;, the outputstream is not closed after the zip creation is finished Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeStreamOnExit" type="xs:boolean" />
    <xs:attribute name="completeFileHeader" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>only for action='write': when set to &lt;code&gt;true&lt;/code&gt;, the fields 'crc-32', 'compressed size' and 'uncompressed size' in the zip entry file header are set explicitly (note: compression ratio is zero) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="zipWriterHandle" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key used to refer to zip session. must be used if zipwriterpipes are nested Default: zipwriterhandle</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ZipWriterPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ZipWriterPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:simpleType name="JobDefFunctionsAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="STOP_ADAPTER" />
      <xs:enumeration value="START_ADAPTER" />
      <xs:enumeration value="STOP_RECEIVER" />
      <xs:enumeration value="START_RECEIVER" />
      <xs:enumeration value="SEND_MESSAGE" />
      <xs:enumeration value="QUERY" />
      <xs:enumeration value="DUMPSTATS" />
      <xs:enumeration value="DUMPSTATSFULL" />
      <xs:enumeration value="CLEANUPDB" />
      <xs:enumeration value="CLEANUPFS" />
      <xs:enumeration value="RECOVER_ADAPTERS" />
      <xs:enumeration value="CHECK_RELOAD" />
      <xs:enumeration value="LOAD_DATABASE_SCHEDULES" />
    </xs:restriction>
  </xs:simpleType>
  <xs:group name="StatisticsHandlerElementGroup">
    <xs:choice>
      <xs:element name="StatisticsHandler">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:group ref="StatisticsHandlerElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="elementRole" type="xs:string" fixed="statisticsHandler" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="StatisticsHandlerElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="StatisticsHandlerElementGroupBase">
    <xs:choice>
      <xs:element name="StatisticsKeeperIterationHandlerCollectionStatisticsHandler">
        <xs:annotation>
          <xs:documentation>StatisticsKeeperIterationHandlerCollectionStatisticsHandler - nl.nn.adapterframework.statistics.StatisticsKeeperIterationHandlerCollection used as StatisticsHandler

Collection of StatisticsKeeperIterationHandler, that each will be handled.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="StatisticsKeeperIterationHandlerCollectionType">
              <xs:attribute name="elementRole" type="xs:string" fixed="statisticsHandler" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.statistics.StatisticsKeeperIterationHandlerCollection" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="StatisticsKeeperLoggerStatisticsHandler">
        <xs:annotation>
          <xs:documentation>StatisticsKeeperLoggerStatisticsHandler - nl.nn.adapterframework.statistics.StatisticsKeeperLogger used as StatisticsHandler

Logs statistics-keeper contents to log.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="StatisticsKeeperLoggerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="statisticsHandler" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.statistics.StatisticsKeeperLogger" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="StatisticsKeeperStoreStatisticsHandler">
        <xs:annotation>
          <xs:documentation>StatisticsKeeperStoreStatisticsHandler - nl.nn.adapterframework.statistics.jdbc.StatisticsKeeperStore used as StatisticsHandler

StatisticsKeeperIterationHandler that stores all statisticsdata in a database.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="StatisticsKeeperStoreType">
              <xs:attribute name="elementRole" type="xs:string" fixed="statisticsHandler" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.statistics.jdbc.StatisticsKeeperStore" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="StatisticsKeeperXmlBuilderStatisticsHandler">
        <xs:annotation>
          <xs:documentation>StatisticsKeeperXmlBuilderStatisticsHandler - nl.nn.adapterframework.statistics.StatisticsKeeperXmlBuilder used as StatisticsHandler

Make XML of all statistics info.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="StatisticsKeeperXmlBuilderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="statisticsHandler" />
              <xs:attribute name="className" type="xs:string" fixed="nl.nn.adapterframework.statistics.StatisticsKeeperXmlBuilder" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="StatisticsKeeperIterationHandlerCollectionType">
    <xs:group ref="StatisticsKeeperIterationHandlerCollectionDeclaredChildGroup" />
  </xs:complexType>
  <xs:group name="StatisticsKeeperIterationHandlerCollectionDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="StatisticsHandlerElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:complexType name="StatisticsKeeperLoggerType">
    <xs:attributeGroup ref="StatisticsKeeperLoggerDeclaredAttributeGroup" />
  </xs:complexType>
  <xs:attributeGroup name="StatisticsKeeperLoggerDeclaredAttributeGroup">
    <xs:attribute name="directory" type="xs:string" />
    <xs:attribute name="retentionDays" type="xs:integer" />
  </xs:attributeGroup>
  <xs:complexType name="StatisticsKeeperStoreType">
    <xs:attributeGroup ref="JdbcFacadeCumulativeAttributeGroup" />
  </xs:complexType>
  <xs:complexType name="StatisticsKeeperXmlBuilderType" />
</xs:schema>
