<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" version="8.0-SNAPSHOT">
  <xs:element name="Configuration">
    <xs:annotation>
      <xs:documentation>Container of Adapters that belong together.
 A configuration may be deployed independently from other configurations.
 Names of nested elements like Adapters, Receivers, listeners and senders
 can be reused in other configurations.
 &lt;br/&gt;&lt;br/&gt;
 Configurations are shown in the Frank!Console along with their Adapters,
 Receivers, listeners and senders. The Adapter Status page of the Frank!Console
 has a tab for each configuration that only shows information
 about that configuration. See the Frank!Manual for details.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="ConfigurationType" />
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="Module">
    <xs:annotation>
      <xs:documentation>Wrapper element to help split up large configuration files into smaller valid XML files. It may be used as root tag when an XML file contains multiple adapters and/or jobs. The Module element itself does not influence the behavior of Frank configurations.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:group ref="ConfigurationDeclaredChildGroup" />
      <xs:attribute ref="active" />
      <xs:anyAttribute namespace="##other" processContents="skip" />
    </xs:complexType>
  </xs:element>
  <xs:complexType name="IncludeType">
    <xs:attribute name="ref" type="xs:string">
      <xs:annotation>
        <xs:documentation>reference to a configuration to be included in the current.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.configuration.Include" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="include" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="AdapterType">
    <xs:annotation>
      <xs:documentation>An Adapter receives a specific type of messages and processes them. It has Receivers
 that receive the messages and a PipeLine that transforms the incoming messages. Each adapter is part of a Configuration.
 &lt;br/&gt;
 If an adapter can receive its messages through multiple channels (e.g. RESTful HTTP requests, incoming files, etc),
 each channel appears as a separate Receiver nested in the adapter. Each Receiver is also responsible
 for dealing with
 the result of its received messages; the result is the output of the PipeLine. The result
 consists of the transformed message and a state. The Frank!Framework distinguishes between exit states
 SUCCESS and ERROR. There is also a state REJECTED for messages that are not accepted by the Frank!Framework
 and that are not processed by the PipeLine. If the exit state is ERROR, the result message may
 not be usable by the calling system. This can be fixed by adding an
 errorMessageFormatter that formats the result message if the state is ERROR.
 &lt;br/&gt;&lt;br/&gt;
 Adapters gather statistics about the messages they process.
 &lt;br/&gt;
 Adapters can process messages in parallel. They are thread-safe.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Receiver" minOccurs="1" maxOccurs="unbounded" type="ReceiverType" />
      <xs:group ref="ErrorMessageFormatterElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:element name="Pipeline" minOccurs="1" maxOccurs="1" type="PipelineType" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the adapter</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="description" type="xs:string">
      <xs:annotation>
        <xs:documentation>some functional description of the &lt;code&gt;Adapter&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoStart" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>AutoStart indicates that the adapter should be started when the configuration
 is started. Default: &lt;code&gt;true&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceNullMessage" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt; a null message is replaced by an empty message Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageKeeperSize" type="frankInt">
      <xs:annotation>
        <xs:documentation>number of message displayed in ibisconsole Default: 10</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="msgLogLevel">
      <xs:annotation>
        <xs:documentation>Defines behaviour for logging messages. Configuration is done in the MSG appender in log4j4ibis.properties. Default: &lt;code&gt;INFO, unless overridden by property msg.log.level.default&lt;/code&gt;</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="MessageLogLevelAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="msgLogHidden" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the length of the message is shown in the msg log instead of the content of the message Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetDesignDocument" type="xs:string" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.Adapter" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="adapter" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="ReceiverType">
    <xs:annotation>
      <xs:documentation>Wrapper for a listener that specifies a channel for the incoming messages of a specific Adapter.
 By choosing a listener, the Frank developer determines how the messages are received.
 For example, an org.frankframework.http.rest.ApiListener receives RESTful HTTP requests and a
 JavaListener receives messages from direct Java calls.
 &lt;br/&gt;&lt;br/&gt;
 Apart from wrapping the listener, a Receiver can be configured
 to store received messages and to keep track of the processed / failed
 status of these messages.
 &lt;br/&gt;&lt;br/&gt;
 There are two kinds of listeners: synchronous listeners and asynchronous listeners.
 Synchronous listeners are expected to return a response. The system that triggers the
 receiver typically waits for a response before proceeding its operation. When a
 org.frankframework.http.rest.ApiListener receives a HTTP request, the listener is expected to return a
 HTTP response. Asynchronous listeners are not expected to return a response. The system that
 triggers the listener typically continues without waiting for the adapter to finish. When a
 receiver contains an asynchronous listener, it can have a sender that sends the transformed
 message to its destination. Receivers with an asynchronous listener can also have an error sender that is used
 by the receiver to send error messages. In other words: if the result state is SUCCESS then the
 message is sent by the ordinary sender, while the error sender is used if the result state
 is ERROR.
 &lt;br/&gt;&lt;br/&gt;
 &lt;b&gt;Transaction control&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;
 If transacted is set to &lt;code&gt;true&lt;/code&gt;, messages will be received and processed under transaction control.
 This means that after a message has been read and processed and the transaction has ended, one of the following apply:
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;situation&lt;/th&gt;&lt;th&gt;input listener&lt;/th&gt;&lt;th&gt;Pipeline&lt;/th&gt;&lt;th&gt;inProcess storage&lt;/th&gt;&lt;th&gt;errorSender&lt;/th&gt;&lt;th&gt;summary of effect&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;successful&lt;/td&gt;&lt;td&gt;message read and committed&lt;/td&gt;&lt;td&gt;message processed&lt;/td&gt;&lt;td&gt;unchanged&lt;/td&gt;&lt;td&gt;unchanged&lt;/td&gt;&lt;td&gt;message processed&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;procesing failed&lt;/td&gt;&lt;td&gt;message read and committed&lt;/td&gt;&lt;td&gt;message processing failed and rolled back&lt;/td&gt;&lt;td&gt;unchanged&lt;/td&gt;&lt;td&gt;message sent&lt;/td&gt;&lt;td&gt;message only transferred from listener to errroSender&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;listening failed&lt;/td&gt;&lt;td&gt;unchanged: listening rolled back&lt;/td&gt;&lt;td&gt;no processing performed&lt;/td&gt;&lt;td&gt;unchanged&lt;/td&gt;&lt;td&gt;unchanged&lt;/td&gt;&lt;td&gt;no changes, input message remains on input available for listener&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;transfer to inprocess storage failed&lt;/td&gt;&lt;td&gt;unchanged: listening rolled back&lt;/td&gt;&lt;td&gt;no processing performed&lt;/td&gt;&lt;td&gt;unchanged&lt;/td&gt;&lt;td&gt;unchanged&lt;/td&gt;&lt;td&gt;no changes, input message remains on input available for listener&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;transfer to errorSender failed&lt;/td&gt;&lt;td&gt;message read and committed&lt;/td&gt;&lt;td&gt;message processing failed and rolled back&lt;/td&gt;&lt;td&gt;message present&lt;/td&gt;&lt;td&gt;unchanged&lt;/td&gt;&lt;td&gt;message only transferred from listener to inProcess storage&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 If the application or the server crashes in the middle of one or more transactions, these transactions
 will be recovered and rolled back after the server/application is restarted. Then always exactly one of
 the following applies for any message touched at any time by Ibis by a transacted receiver:
 &lt;ul&gt;
 &lt;li&gt;It is processed correctly by the pipeline and removed from the input-queue,
     not present in inProcess storage and not send to the errorSender&lt;/li&gt;
 &lt;li&gt;It is not processed at all by the pipeline, or processing by the pipeline has been rolled back;
     the message is removed from the input queue and either (one of) still in inProcess storage &lt;i&gt;or&lt;/i&gt; sent to the errorSender&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;&lt;b&gt;commit or rollback&lt;/b&gt;&lt;br/&gt;
 If transacted is set to &lt;code&gt;true&lt;/code&gt;, messages will be either committed or rolled back.
 All message-processing transactions are committed, unless one or more of the following apply:
 &lt;ul&gt;
 &lt;li&gt;The PipeLine is transacted and the exitState of the pipeline is not equal to SUCCESS&lt;/li&gt;
 &lt;li&gt;a PipeRunException or another runtime-exception has been thrown by any Pipe or by the PipeLine&lt;/li&gt;
 &lt;li&gt;the setRollBackOnly() method has been called on the userTransaction (not accessible by Pipes)&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/p&gt;</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ListenerElementGroup" minOccurs="1" maxOccurs="1" />
      <xs:group ref="SenderElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="ErrorSenderElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="ErrorStorageElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="MessageLogElementGroup" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Sets the name of the Receiver, as known to the Adapter.
 If the listener implements the name interface and &lt;code&gt;getName()&lt;/code&gt;
 of the listener is empty, the name of this object is given to the listener.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onError">
      <xs:annotation>
        <xs:documentation>One of 'continue' or 'close'. Controls the behaviour of the Receiver when it encounters an error sending a reply or receives an exception asynchronously Default: CONTINUE</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="OnErrorAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="numThreads" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of threads that may execute a Pipeline concurrently (only for pulling listeners) Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numThreadsPolling" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of threads that are actively polling for messages concurrently. '0' means 'limited only by &lt;code&gt;numthreads&lt;/code&gt;' (only for pulling listeners) Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pollInterval" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of seconds waited after an unsuccessful poll attempt, before another poll attempt is made. Only for polling listeners, not for e.g. jms, webservice or javaListeners Default: 10</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) to start receiver. If this timeout is exceeded, the Receiver startup is
  aborted and all resources closed and the receiver will be in state {@code EXCEPTION_STARTING}
  and a new start command may be issued again.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stopTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) to stop receiver. If this timeout is exceeded, stopping will be aborted
  and the receiver will be in state {@code EXCEPTION_STOPPING}.
  The receiver will no longer be running but some resources might not have been cleaned up properly.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkForDuplicates" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, each message is checked for presence in the messageLog. If already present, it is not processed again. Only required for non XA compatible messaging. Requires messageLog! Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkForDuplicatesMethod">
      <xs:annotation>
        <xs:documentation>(Only used when &lt;code&gt;checkForDuplicates=true&lt;/code&gt;) Indicates whether the messageid or the correlationid is used for checking presence in the message log Default: MESSAGEID</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="CheckForDuplicatesMethodAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="maxDeliveries" type="frankInt">
      <xs:annotation>
        <xs:documentation>The maximum delivery count after which to stop processing the message (only for listeners that know the delivery count of received messages). If -1 the delivery count is ignored Default: 5</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRetries" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of times a processing attempt is automatically retried after an exception is caught or rollback is experienced. If &lt;code&gt;maxRetries &amp;lt; 0&lt;/code&gt; the number of attempts is infinite Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="processResultCacheSize" type="frankInt">
      <xs:annotation>
        <xs:documentation>Size of the cache to keep process results, used by maxRetries Default: 100</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>XPath expression to extract correlationid from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for correlationIDXPath. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>Stylesheet to extract correlationID from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>XPath expression to extract label from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for labelXPath. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>Stylesheet to extract label from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the character data in this XML element is stored inside a session key and in the message it is replaced by a reference to this session key: {sessionKey: + &lt;code&gt;elementToMoveSessionKey&lt;/code&gt; + }</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Only used when &lt;code&gt;elementToMove&lt;/code&gt; or &lt;code&gt;elementToMoveChain&lt;/code&gt; is set) Name of the session key wherein the character data is stored Default: ref_ + the name of the element</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>Like &lt;code&gt;elementToMove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. adapter;pipeline;pipe)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="frankBoolean" />
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>Regular expression to mask strings in the errorStore/logStore. Every character between to the strings in this expression will be replaced by a '*'. For example, the regular expression (?&amp;lt;=&amp;lt;party&amp;gt;).*?(?=&amp;lt;/party&amp;gt;) will replace every character between keys &amp;lt;party&amp;gt; and &amp;lt;/party&amp;gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod">
      <xs:annotation>
        <xs:documentation>Only used when hideRegex is not empty Default: all</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="HideMethodAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="hiddenInputSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of keys of session variables which are available when the &lt;code&gt;PipelineSession&lt;/code&gt; is created and of which the value will not be shown in the log (replaced by asterisks)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forceRetryFlag" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, every message read will be processed as if it is being retried, by setting a session variable to retry. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numberOfExceptionsCaughtWithoutMessageBeingReceivedThreshold" type="frankInt">
      <xs:annotation>
        <xs:documentation>Number of connection attempts to put the adapter in warning status Default: 5</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="transactionTimeout" />
    <xs:attribute ref="transactionAttribute" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.receivers.Receiver" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="receiver" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="PipelineType">
    <xs:annotation>
      <xs:documentation>Required in each Adapter to transform incoming messages. A pipeline
 is a sequence of pipes. A
 pipeline also defines its allowed end states using the &lt;code&gt;&amp;lt;Exits&amp;gt;&lt;/code&gt;
 tag.
 &lt;br/&gt;&lt;br/&gt;
 The pipes in a PipeLine may not be executed in sequential order, see PipeForward.
 &lt;br/&gt;&lt;br/&gt;
 A pipeline gathers statistics about the messages it processes.
 &lt;br/&gt;&lt;br/&gt;
 In the AppConstants there may be a property named &lt;code&gt;log.logIntermediaryResults&lt;/code&gt; (true/false)
 which indicates whether the intermediary results (between calling pipes) have to be logged.
 &lt;br/&gt;&lt;br/&gt;
 &lt;b&gt;Transaction control&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;
 THE FOLLOWING TO BE UPDATED, attribute 'transacted' replaced by 'transactionAttribute'

 If transacted is set to &lt;code&gt;true&lt;/code&gt;, messages will be processed
 under transaction control. Processing by XA-compliant pipes (i.e. Pipes that implement the
 IXAEnabled-interface, set their transacted-attribute to &lt;code&gt;true&lt;/code&gt; and use XA-compliant
 resources) will then either be committed or rolled back in one transaction.

 If transacted is set to &lt;code&gt;true&lt;/code&gt;, either an existing transaction
 (started by a transactional receiver) is joined, or new one is created (if the message processing request
 is not initiated by a receiver under transaction control.
 Messages are only committed or rolled back by the Pipeline if it started the transaction itself. If
 the pipeline joined an existing transaction, the commit or rollback is left to the object that started
 the transaction, i.e. the receiver. In the latter case the pipeline can indicate to the receiver that the
 transaction should be rolled back (by calling UserTransaction.setRollBackOnly()).

 The choice whether to either commit (by Pipeline or Receiver) or rollback (by Pipeline or Receiver)
 is made as follows:

 If the processing of the message concluded without exceptions and the status of the transaction is
 STATUS_ACTIVE (i.e. normal) the transaction will be committed. Otherwise it will be rolled back,
 or marked for roll back by the calling party.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="InputValidatorElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="OutputValidatorElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="InputWrapperElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="OutputWrapperElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:element name="Exits" minOccurs="0" maxOccurs="1" type="ExitsType" />
      <xs:element name="GlobalForwards" minOccurs="0" maxOccurs="1" type="GlobalForwardsType" />
      <xs:element name="Locker" minOccurs="0" maxOccurs="1" type="LockerType" />
      <xs:group ref="CacheElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="PipeElementGroup" minOccurs="1" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="firstPipe" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the first pipe to execute when a message is to be processed Default: first pipe of the pipeline</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxThreads" type="frankInt">
      <xs:annotation>
        <xs:documentation>Maximum number of threads that may execute this Pipeline simultaneously, use 0 to disable limit Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeOriginalMessageWithoutNamespaces" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; the original message without namespaces (and prefixes) is stored under the session key originalMessageWithoutNamespaces Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageSizeWarn" type="xs:string">
      <xs:annotation>
        <xs:documentation>If messageSizeWarn&gt;=0 and the size of the input or result pipe message exceeds the value specified a warning message is logged. You can specify the value with the suffixes &lt;code&gt;KB&lt;/code&gt;, &lt;code&gt;MB&lt;/code&gt; or &lt;code&gt;GB&lt;/code&gt; Default: application default (30MB)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transformNullMessage" type="xs:string">
      <xs:annotation>
        <xs:documentation>when specified and &lt;code&gt;null&lt;/code&gt; is received as a message the message is changed to the specified value</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="transactionTimeout" />
    <xs:attribute ref="transactionAttribute" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.PipeLine" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="pipeline" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="ExitsType">
    <xs:annotation>
      <xs:documentation>Pipeline exit container in which all (required) Exits must be defined.
 Multiple exits may be provided each with their unique name.
 &lt;br/&gt;&lt;br/&gt;
 If no exits are specified, a default one is created with name="READY" and state="SUCCESS".
 &lt;br/&gt;&lt;br/&gt;
 &lt;b&gt;example:&lt;/b&gt; &lt;code&gt;&lt;pre&gt;
   &amp;lt;Exits&amp;gt;
      &amp;lt;Exit name="READY" state="SUCCESS" /&amp;gt;
      &amp;lt;Exit name="Created" state="ERROR" code="201" empty="true" /&amp;gt;
      &amp;lt;Exit name="NotModified" state="ERROR" code="304" empty="true" /&amp;gt;
      &amp;lt;Exit name="BadRequest" state="ERROR" code="400" empty="true" /&amp;gt;
      &amp;lt;Exit name="NotAuthorized" state="ERROR" code="401" empty="true" /&amp;gt;
      &amp;lt;Exit name="NotAllowed" state="ERROR" code="403" empty="true" /&amp;gt;
      &amp;lt;Exit name="Teapot" state="SUCCESS" code="418" /&amp;gt;
      &amp;lt;Exit name="ServerError" state="ERROR" code="500" /&amp;gt;
   &amp;lt;/Exits&amp;gt;
 &lt;/pre&gt;&lt;/code&gt;</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Exit" minOccurs="1" maxOccurs="unbounded" type="ExitType" />
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.PipeLineExits" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="exits" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="ExitType">
    <xs:annotation>
      <xs:documentation>The Exit of a Pipeline that specifies the end state of a PipeLine. The state is returned to the receiver as well as
 the optionally specified http status code. Each Exit should have a unique name. See Exits
 for examples.
 &lt;br/&gt;&lt;br/&gt;
 When a Pipeline doesn't have an Exits element configured it will be initialized with one Exit having name READY and
 state SUCCESS.
 &lt;br/&gt;&lt;br/&gt;
 The name of an Exit can be referenced by the &lt;code&gt;path&lt;/code&gt; attribute of a Forward within a Pipe.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>The name of the Exit that can be referenced by a PipeForward's &lt;code&gt;path&lt;/code&gt; attribute. When a Pipeline doesn't have an Exits
 element configured it will be initialized with one Exit having name READY (and state SUCCESS)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="state" use="required">
      <xs:annotation>
        <xs:documentation>The state of the Pipeline that is returned to the Receiver for this Exit. When a Pipeline doesn't have an Exits
 element configured it will be initialized with one Exit having state SUCCESS (and name READY)</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="ExitStateAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="code" type="frankInt">
      <xs:annotation>
        <xs:documentation>HTTP statusCode e.g. &lt;code&gt;500&lt;/code&gt; Default: 200</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="responseRoot" type="xs:string">
      <xs:annotation>
        <xs:documentation>Configures the responseRoot in the OpenAPI schema for this exit. If not set, the responseRoot value of the validator will be used. If that contains multiple (comma separated) values, the first will be used for the exits with state &lt;code&gt;SUCCESS&lt;/code&gt;, the last for the other exits.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="empty" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If using RestListener and set to &lt;code&gt;true&lt;/code&gt;, this removes the output and shows a blank page, the output is still logged in the ladybug testtool Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipWrapping" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the output will not be wrapped by the OutputWrapper. Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipValidation" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the output will not be validated or transformed by the validator. Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.PipeLineExit" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="exit" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="GlobalForwardsType">
    <xs:annotation>
      <xs:documentation>Optional element in a pipeline. Global forwards that will be added to every pipe, when the forward name has not been explicitly set.
 For example the &lt;code&gt;&amp;lt;forward name="exception" path="error_exception" /&amp;gt;&lt;/code&gt;, which will add the '&lt;code&gt;exception&lt;/code&gt;' forward to every pipe in the pipeline.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Forward" minOccurs="0" maxOccurs="unbounded" type="ForwardType" />
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.PipeForwards" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="globalForwards" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="ForwardType">
    <xs:annotation>
      <xs:documentation>Appears inside a pipe and defines what pipe or exit to execute next. When the
 execution of a pipe is done, the pipe looks up the next pipe or exit to execute.
 This pipe or exit is searched based on a key that describes what happened during
 pipe execution. For example a FixedResultPipe searches for key
 &lt;code&gt;filenotfound&lt;/code&gt; if it tried to read a file that did not exist,
 preventing it from producing the desired output message. If there was
 no error, the FixedResultPipe searches for key &lt;code&gt;success&lt;/code&gt;.
 &lt;br/&gt;&lt;br/&gt;
 Each &lt;code&gt;&amp;lt;Forward&amp;gt;&lt;/code&gt; tag is used to link a search key (&lt;code&gt;name&lt;/code&gt; attribute)
 to a pipe or exit to execute next (&lt;code&gt;path&lt;/code&gt; attribute). The forward's &lt;code&gt;path&lt;/code&gt;
 attribute references the target pipe or exit by its &lt;code&gt;name&lt;/code&gt; attribute, see
 AbstractPipe and PipeLineExit. For most pipes and most keys, the next
 pipe is executed if no forward is found. By default, the pipes in a pipeline are executed consecutively.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>the &lt;code&gt;name&lt;/code&gt; is a symbolic reference to a &lt;code&gt;path&lt;/code&gt;.&lt;br/&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="path" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>The name of the next Pipe or Exit. When the Pipeline doesn't have an Exits element configured it will be
 initialized with one Exit having name READY and state SUCCESS</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.PipeForward" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="forward" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="LockerType">
    <xs:annotation>
      <xs:documentation>Locker of scheduler jobs and pipes.

 Tries to set a lock (by inserting a record in the database table IbisLock) and only if this is done
 successfully the job is executed.

 For an Oracle database the following objects are used:
  &lt;pre&gt;
	CREATE TABLE &amp;lt;schema_owner&amp;gt;.IBISLOCK
	(
	OBJECTID VARCHAR2(100 CHAR),
	TYPE CHAR(1 CHAR),
	HOST VARCHAR2(100 CHAR),
	CREATIONDATE TIMESTAMP(6),
	EXPIRYDATE TIMESTAMP(6)
	CONSTRAINT PK_IBISLOCK PRIMARY KEY (OBJECTID)
	);

	CREATE INDEX &amp;lt;schema_owner&amp;gt;.IX_IBISLOCK ON &amp;lt;schema_owner&amp;gt;.IBISLOCK
	(EXPIRYDATE);

	GRANT DELETE, INSERT, SELECT, UPDATE ON &amp;lt;schema_owner&amp;gt;.IBISLOCK TO &amp;lt;rolename&amp;gt;;
	GRANT SELECT ON SYS.DBA_PENDING_TRANSACTIONS TO &amp;lt;rolename&amp;gt;;

	COMMIT;
  &lt;/pre&gt;</xs:documentation>
    </xs:annotation>
    <xs:attribute name="objectId" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Identifier for this lock</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type">
      <xs:annotation>
        <xs:documentation>Type for this lock: P(ermanent) or T(emporary). A temporary lock is released after the job has completed Default: T</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="LockTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="dateFormatSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>Format for date which is added after &lt;code&gt;objectid&lt;/code&gt; (e.g. yyyyMMdd to be sure the job is executed only once a day)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retention" type="frankInt">
      <xs:annotation>
        <xs:documentation>The time (for type=P in days and for type=T in hours) to keep the record in the database before making it eligible for deletion by a cleanup process Default: 30 days (type=P), 4 hours (type=T)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numRetries" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of times an attempt should be made to acquire a lock, after this many times an exception is thrown when no lock could be acquired, when -1 the number of retries is unlimited Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="firstDelay" type="frankInt">
      <xs:annotation>
        <xs:documentation>The time in ms to wait before the first attempt to acquire a lock is made Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryDelay" type="frankInt">
      <xs:annotation>
        <xs:documentation>The time in ms to wait before another attempt to acquire a lock is made Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWaitTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>If &gt; 0: The time in s to wait before the INSERT statement to obtain the lock is canceled. N.B. On Oracle hitting this lockWaitTimeout may cause the error: (SQLRecoverableException) SQLState [08003], errorCode [17008] connection closed Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreTableNotExist" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; and the IBISLOCK table does not exist in the database, the process continues as if the lock was obtained</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute">
      <xs:annotation>
        <xs:documentation>The &lt;code&gt;transactionAttribute&lt;/code&gt; declares transactional behavior of execution. It applies both to database transactions and XA transactions.
 The pipeline uses this to start a new transaction or suspend the current one when required.
 For developers: it is equal to &lt;a href=\"https://docs.oracle.com/javaee/7/tutorial/transactions003.htm\"&gt;EJB transaction attribute&lt;/a&gt;.
 Possible values for transactionAttribute:
   &lt;table border=\"1\"&gt;
     &lt;tr&gt;&lt;th&gt;transactionAttribute&lt;/th&gt;&lt;th&gt;callers Transaction&lt;/th&gt;&lt;th&gt;Pipeline excecuted in Transaction&lt;/th&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Required&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;RequiresNew&lt;/td&gt; &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Mandatory&lt;/td&gt;   &lt;td&gt;none&lt;/td&gt;&lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;NotSupported&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Supports&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
  										      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Never&lt;/td&gt;       &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;
   &lt;/table&gt; Default: Supports</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="TransactionAttributeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="transactionTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Timeout (in seconds) of transaction started to process a message. Default: &lt;code&gt;0&lt;/code&gt; (use system default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>JNDI name of datasource to be used, can be configured via jmsRealm, too Default: jdbc.datasource.default</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used to authenticate when connecting to database</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>User name for authentication when connecting to database, when none found from &lt;code&gt;authAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password for authentication when connecting to database, when none found from &lt;code&gt;authAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>controls the use of transactions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>informs the sender that the obtained connection is from a pool (and thus connections are reused and never closed) Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>Sets the value of providerURL</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the sender or the listener</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.util.Locker" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="locker" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="SchedulerType">
    <xs:annotation>
      <xs:documentation>Container for jobs that are scheduled for periodic execution.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="JobElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.configuration.ScheduleManager" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="scheduler" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="SapSystemsType">
    <xs:sequence>
      <xs:group ref="SapSystemElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.configuration.extensions.SapSystems" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="sapSystems" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="JmsRealmsType">
    <xs:annotation>
      <xs:documentation>Singleton that has the different jmsRealms.&lt;br/&gt;
 Typical use: JmsRealmFactory.getInstance().&amp;lt;method to execute&amp;gt;
 &lt;br/&gt;</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="JmsRealm" minOccurs="0" maxOccurs="unbounded" type="JmsRealmType" />
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jms.JmsRealmFactory" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="jmsRealms" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="JmsRealmType">
    <xs:annotation>
      <xs:documentation>A JmsRealm is a definition of a JMS provider, and is kind of a utility
 class to prevent the tedeous work of repeatedly defining all parameters
 to connect to a queue or topic.
 &lt;br/&gt;
 This class is not an extension of JNDIBase, which would be logical, because
 in the JMSBase class the function PropertyUtils.copyProperties is used, which cannot
 handle this.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="aliasForRealm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Includes another realm into this one</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="realmName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Set the name of this realm&lt;br/&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Set the name of the QueueConnectionFactory&lt;br/&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Set the name of the TopicConnectionFactory&lt;br/&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string" />
    <xs:attribute name="urlPkgPrefixes" type="xs:string" />
    <xs:attribute name="authentication" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string" />
    <xs:attribute name="providerURL" type="xs:string" />
    <xs:attribute name="userTransactionUrl" type="xs:string" />
    <xs:attribute name="principal" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string" />
    <xs:attribute name="authAlias" type="xs:string" />
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jms.JmsRealm" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="jmsRealm" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="MonitoringType">
    <xs:annotation>
      <xs:documentation>Manager for Monitoring.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="DestinationElementGroup" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Monitor" minOccurs="0" maxOccurs="unbounded" type="MonitorType" />
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.monitoring.MonitorManager" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="monitoring" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="MonitorType">
    <xs:annotation>
      <xs:documentation>&lt;p&gt;Example configuration:&lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;
 {@literal
 &lt;monitor name="Receiver Shutdown" destinations="MONITOR_LOG"&gt;
    &lt;trigger className="org.frankframework.monitoring.Alarm" severity="WARNING"&gt;
        &lt;event&gt;Receiver Shutdown&lt;/event&gt;
    &lt;/trigger&gt;
    &lt;trigger className="org.frankframework.monitoring.Clearing" severity="WARNING"&gt;
        &lt;event&gt;Receiver Shutdown&lt;/event&gt;
    &lt;/trigger&gt;
 &lt;/monitor&gt;
 }

 &lt;/code&gt;&lt;/pre&gt;</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="TriggerElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="destinations" type="xs:string" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of the object.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="raised" type="frankBoolean" />
    <xs:attribute name="additionalHitCount" type="frankInt" />
    <xs:attribute name="type">
      <xs:simpleType>
        <xs:union memberTypes="EventTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="alarmSeverity">
      <xs:simpleType>
        <xs:union memberTypes="SeverityAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.monitoring.Monitor" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="monitor" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="SharedResourcesType">
    <xs:sequence>
      <xs:group ref="SharedResourceElementGroup" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="HttpSession" minOccurs="0" maxOccurs="unbounded" type="HttpSessionType" />
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.configuration.SharedResources" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="sharedResources" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="HttpSessionType">
    <xs:annotation>
      <xs:documentation>Shared HTTPSession, implements SharedResource so it can be set in the Configuration.xml</xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of the object.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Timeout in ms of obtaining a connection/result. 0 means no timeout Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConnections" type="frankInt">
      <xs:annotation>
        <xs:documentation>The maximum number of concurrent connections Default: 10</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxExecuteRetries" type="frankInt">
      <xs:annotation>
        <xs:documentation>The maximum number of times the execution is retried Default: 1 (for repeatable messages) else 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Username used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tokenEndpoint" type="xs:string">
      <xs:annotation>
        <xs:documentation>Endpoint to obtain OAuth accessToken. If &lt;code&gt;authAlias&lt;/code&gt; or &lt;code&gt;username&lt;/code&gt;( and &lt;code&gt;password&lt;/code&gt;) are specified,
 then a PasswordGrant is used, otherwise a ClientCredentials grant. The obtained accessToken will be added to the regular requests
 in an HTTP Header 'Authorization' with a 'Bearer' prefix.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tokenExpiry" type="frankInt">
      <xs:annotation>
        <xs:documentation>If set to a non-negative value, then determines the time (in seconds) after which the token will be refreshed. Otherwise the token
 will be refreshed when it is half way its lifetime as defined by the &lt;code&gt;expires_in&lt;/code&gt; clause of the token response,
 or when the regular server returns a 401 status with a challenge.
 If not specified, and the accessTokens lifetime is not found in the token response, the accessToken will not be refreshed preemptively. Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clientAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain client_id and client_secret for authentication to &lt;code&gt;tokenEndpoint&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clientId" type="xs:string">
      <xs:annotation>
        <xs:documentation>Client_id used in authentication to &lt;code&gt;tokenEndpoint&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clientSecret" type="xs:string">
      <xs:annotation>
        <xs:documentation>Client_secret used in authentication to &lt;code&gt;tokenEndpoint&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scope" type="xs:string">
      <xs:annotation>
        <xs:documentation>Space or comma separated list of scope items requested for accessToken, e.g. &lt;code&gt;read write&lt;/code&gt;. Only used when &lt;code&gt;tokenEndpoint&lt;/code&gt; is specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authenticatedTokenRequest" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>if set true, clientId and clientSecret will be added as Basic Authentication header to the tokenRequest, instead of as request parameters</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="frankInt">
      <xs:annotation>
        <xs:documentation>Proxy port Default: 80</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain credentials for authentication to proxy</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyRealm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy realm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefillProxyAuthCache" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Create a pre-emptive login context for the proxy connection(s).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="disableCookies" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Disables the use of cookies, making the sender completely stateless Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystore" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource URL to keystore or certificate to be used for authentication. If none specified, the JVMs default keystore will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType">
      <xs:annotation>
        <xs:documentation>Type of keystore Default: pkcs12</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="keystoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used to obtain keystore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to access keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias to obtain specific certificate or key in keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>Resource URL to truststore to be used for authenticating peer. If none specified, the JVMs default truststore will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used to obtain truststore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to access truststore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType">
      <xs:annotation>
        <xs:documentation>Type of truststore Default: jks</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Trust manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the hostname in the certificate will be checked against the actual hostname of the peer</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowSelfSignedCertificates" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, self signed certificates are accepted Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCertificateExpiredException" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, CertificateExpiredExceptions are ignored Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="followRedirects" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, a redirect request will be honoured, e.g. to switch to HTTPS Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreRedirects" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, besides http status code 200 (OK) also the code 301 (MOVED_PERMANENTLY), 302 (MOVED_TEMPORARILY) and 307 (TEMPORARY_REDIRECT) are considered successful Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleChecking" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Controls whether connections checked to be stale, i.e. appear open, but are not. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Used when StaleChecking=&lt;code&gt;true&lt;/code&gt;. Timeout after which an idle connection will be validated before being used. Default: 5000 ms</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionTimeToLive" type="frankInt">
      <xs:annotation>
        <xs:documentation>Maximum Time to Live for connections in the pool. No connection will be re-used past its timeToLive value. Default: 900 s</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionIdleTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Maximum Time for connection to stay idle in the pool. Connections that are idle longer will periodically be evicted from the pool Default: 10 s</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="protocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>Secure socket protocol (such as 'TLSv1.2') to use when a SSLContext object is generated. Default: TLSv1.2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="supportedCipherSuites" type="xs:string">
      <xs:annotation>
        <xs:documentation>Allows you to choose which CipherSuites are used when connecting to an endpoint. Works in tandem with {@code protocol} as the provided Suite may not be valid for the provided Protocol
 See the Java Security Standard Algorithm Names Specification for all available options. Note that these may differ depending on the JRE you're using.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.http.HttpSession" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="httpSession" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="ConfigurationType">
    <xs:group ref="ConfigurationDeclaredChildGroup" />
    <xs:attributeGroup ref="ConfigurationDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.configuration.Configuration" use="prohibited" />
  </xs:complexType>
  <xs:group name="ConfigurationDeclaredChildGroup">
    <xs:sequence>
      <xs:element ref="Module" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Include" minOccurs="0" maxOccurs="unbounded" type="IncludeType" />
      <xs:element name="Adapter" minOccurs="0" maxOccurs="unbounded" type="AdapterType" />
      <xs:element name="Scheduler" minOccurs="0" maxOccurs="1" type="SchedulerType" />
      <xs:element name="SapSystems" minOccurs="0" maxOccurs="1" type="SapSystemsType" />
      <xs:element name="JmsRealms" minOccurs="0" maxOccurs="1" type="JmsRealmsType" />
      <xs:element name="Monitoring" minOccurs="0" maxOccurs="1" type="MonitoringType" />
      <xs:element name="SharedResources" minOccurs="0" maxOccurs="1" type="SharedResourcesType" />
    </xs:sequence>
  </xs:group>
  <xs:group name="ListenerElementGroup">
    <xs:choice>
      <xs:element name="Listener">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ListenerElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ListenerElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="SenderElementGroup">
    <xs:choice>
      <xs:element name="Sender">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="SenderElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="SenderElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="ErrorSenderElementGroup">
    <xs:choice>
      <xs:element name="ErrorSender">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ErrorSenderElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ErrorSenderElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="ErrorStorageElementGroup">
    <xs:choice>
      <xs:element name="ErrorStorage">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="errorStorage" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ErrorStorageElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ErrorStorageElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="MessageLogElementGroup">
    <xs:choice>
      <xs:element name="MessageLog">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="messageLog" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="MessageLogElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="MessageLogElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="ErrorMessageFormatterElementGroup">
    <xs:choice>
      <xs:element name="ErrorMessageFormatter">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="errorMessageFormatter" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ErrorMessageFormatterElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ErrorMessageFormatterElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="InputValidatorElementGroup">
    <xs:choice>
      <xs:element name="InputValidator">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="InputValidatorElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="InputValidatorElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="OutputValidatorElementGroup">
    <xs:choice>
      <xs:element name="OutputValidator">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="OutputValidatorElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="OutputValidatorElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="InputWrapperElementGroup">
    <xs:choice>
      <xs:element name="InputWrapper">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="inputWrapper" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="InputWrapperElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="InputWrapperElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="OutputWrapperElementGroup">
    <xs:choice>
      <xs:element name="OutputWrapper">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="outputWrapper" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="OutputWrapperElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="OutputWrapperElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="CacheElementGroup">
    <xs:choice>
      <xs:element name="Cache">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="cache" use="prohibited" />
          <xs:attribute name="className" type="xs:string" default="org.frankframework.cache.EhCache" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="CacheElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="CacheElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="PipeElementGroup">
    <xs:choice>
      <xs:element name="Pipe">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
          <xs:attribute name="className" type="xs:string" default="org.frankframework.pipes.SenderPipe" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="PipeElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="PipeElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="JobElementGroup">
    <xs:choice>
      <xs:element name="Job">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="job" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="JobElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="JobElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="SapSystemElementGroup">
    <xs:choice>
      <xs:element name="SapSystem">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="sapSystem" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="SapSystemElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="SapSystemElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="DestinationElementGroup">
    <xs:choice>
      <xs:element name="Destination">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="destination" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="DestinationElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="DestinationElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="TriggerElementGroup">
    <xs:choice>
      <xs:element name="Trigger">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="trigger" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="TriggerElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="TriggerElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="SharedResourceElementGroup">
    <xs:choice>
      <xs:element name="SharedResource">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="sharedResource" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="SharedResourceElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="SharedResourceElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:attributeGroup name="ConfigurationDeclaredAttributeGroup">
    <xs:attribute name="autoStart" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If the Configuration should automatically start all Adapters and Jobs.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Configurations should be wired through Spring, which in turn should call #setBeanName(String).
 Once the ConfigurationContext has a name it should not be changed anymore, hence
 super.setBeanName(String) only sets the name once.
 If not created by Spring, the setIdCalled flag in AbstractRefreshableConfigApplicationContext wont be set, allowing the name to be updated.

 The DisplayName will always be updated, which is purely used for logging purposes.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:simpleType name="OnErrorAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="CONTINUE">
        <xs:annotation>
          <xs:documentation>Don't stop the receiver when an error occurs.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="RECOVER">
        <xs:annotation>
          <xs:documentation>If an error occurs (eg. connection is lost) the receiver will be stopped and marked as ERROR
 Once every &lt;code&gt;recover.adapters.interval&lt;/code&gt; it will be attempted to (re-) start the receiver.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="CLOSE">
        <xs:annotation>
          <xs:documentation>Stop the receiver when an error occurs.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="CheckForDuplicatesMethodAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="MESSAGEID" />
      <xs:enumeration value="CORRELATIONID" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="HideMethodAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ALL">
        <xs:annotation>
          <xs:documentation>to mask the entire string</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FIRSTHALF">
        <xs:annotation>
          <xs:documentation>to only mask the first half of the string</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TransactionAttributeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Required">
        <xs:annotation>
          <xs:documentation>Support a current transaction; create a new one if none exists.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Supports">
        <xs:annotation>
          <xs:documentation>Support a current transaction; execute non-transactionally if none exists.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Mandatory">
        <xs:annotation>
          <xs:documentation>Support a current transaction; throw an exception if no current transaction exists.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="RequiresNew">
        <xs:annotation>
          <xs:documentation>Create a new transaction, suspending the current transaction if one exists.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NotSupported">
        <xs:annotation>
          <xs:documentation>Do not support a current transaction; rather always execute non-transactionally.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Never">
        <xs:annotation>
          <xs:documentation>Do not support a current transaction; throw an exception if a current transaction exists.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ExitStateAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="SUCCESS" />
      <xs:enumeration value="ERROR" />
      <xs:enumeration value="REJECTED" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="LockTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="T">
        <xs:annotation>
          <xs:documentation>Temporary</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="P">
        <xs:annotation>
          <xs:documentation>Permanent</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="MessageLogLevelAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="OFF">
        <xs:annotation>
          <xs:documentation>No logging</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="INFO">
        <xs:annotation>
          <xs:documentation>Logs information from adapter level messages</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DEBUG">
        <xs:annotation>
          <xs:documentation>Logs information from pipe messages</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="EventTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="TECHNICAL" />
      <xs:enumeration value="FUNCTIONAL" />
      <xs:enumeration value="HEARTBEAT" />
      <xs:enumeration value="CLEARING" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="SeverityAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="HARMLESS" />
      <xs:enumeration value="WARNING" />
      <xs:enumeration value="CRITICAL" />
      <xs:enumeration value="FATAL" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="KeystoreTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="PKCS12" />
      <xs:enumeration value="PEM" />
      <xs:enumeration value="JKS" />
      <xs:enumeration value="JCEKS" />
    </xs:restriction>
  </xs:simpleType>
  <xs:attribute name="transactionTimeout" type="frankInt">
    <xs:annotation>
      <xs:documentation>Timeout (in seconds) of transaction started to process a message. Default: &lt;code&gt;0&lt;/code&gt; (use system default)</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="transactionAttribute">
    <xs:annotation>
      <xs:documentation>The &lt;code&gt;transactionAttribute&lt;/code&gt; declares transactional behavior of execution. It applies both to database transactions and XA transactions.
 The pipeline uses this to start a new transaction or suspend the current one when required.
 For developers: it is equal to &lt;a href=\"https://docs.oracle.com/javaee/7/tutorial/transactions003.htm\"&gt;EJB transaction attribute&lt;/a&gt;.
 Possible values for transactionAttribute:
   &lt;table border=\"1\"&gt;
     &lt;tr&gt;&lt;th&gt;transactionAttribute&lt;/th&gt;&lt;th&gt;callers Transaction&lt;/th&gt;&lt;th&gt;Pipeline excecuted in Transaction&lt;/th&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Required&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;RequiresNew&lt;/td&gt; &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Mandatory&lt;/td&gt;   &lt;td&gt;none&lt;/td&gt;&lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;NotSupported&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Supports&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
  										      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Never&lt;/td&gt;       &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;
   &lt;/table&gt; Default: Supports</xs:documentation>
    </xs:annotation>
    <xs:simpleType>
      <xs:union memberTypes="TransactionAttributeAttributeValuesType variableRef" />
    </xs:simpleType>
  </xs:attribute>
  <xs:simpleType name="frankBoolean">
    <xs:restriction base="xs:string">
      <xs:pattern value="(true|false)|($\{[^\}]+\})" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="frankInt">
    <xs:restriction base="xs:string">
      <xs:pattern value="((\+|-)?[0-9]+)|($\{[^\}]+\})" />
    </xs:restriction>
  </xs:simpleType>
  <xs:attribute name="active">
    <xs:annotation>
      <xs:documentation>If defined and empty or false, then this element and all its children are ignored</xs:documentation>
    </xs:annotation>
    <xs:simpleType>
      <xs:restriction base="xs:string">
        <xs:pattern value="!?(($\{[^\}]+\})|([tT][rR][uU][eE])|([fF][aA][lL][sS][eE]))" />
      </xs:restriction>
    </xs:simpleType>
  </xs:attribute>
  <xs:simpleType name="variableRef">
    <xs:restriction base="xs:string">
      <xs:pattern value="$\{[^\}]+\}" />
    </xs:restriction>
  </xs:simpleType>
</xs:schema>
