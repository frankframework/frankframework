<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" version="8.3.0-SNAPSHOT">
  <xs:element name="Configuration">
    <xs:annotation>
      <xs:documentation>Container of Adapters that belong together.
 A configuration may be deployed independently from other configurations.
 Names of nested elements like Adapters, Receivers, listeners and senders
 can be reused in other configurations.
 &lt;br/&gt;&lt;br/&gt;
 Configurations are shown in the Frank!Console along with their Adapters,
 Receivers, listeners and senders. The Adapter Status page of the Frank!Console
 has a tab for each configuration that only shows information
 about that configuration. See the Frank!Manual for details.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="ConfigurationType" />
      </xs:complexContent>
    </xs:complexType>
  </xs:element>
  <xs:element name="Module">
    <xs:annotation>
      <xs:documentation>Wrapper element to help split up large configuration files into smaller valid XML files. It may be used as root tag when an XML file contains multiple adapters and/or jobs. The Module element itself does not influence the behavior of Frank configurations.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:group ref="ConfigurationDeclaredChildGroup" />
      <xs:attribute ref="active" />
      <xs:anyAttribute namespace="##other" processContents="skip" />
    </xs:complexType>
  </xs:element>
  <xs:complexType name="IncludeType">
    <xs:attribute name="ref" type="xs:string">
      <xs:annotation>
        <xs:documentation>reference to a configuration to be included in the current.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.configuration.Include" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="include" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="AdapterType">
    <xs:annotation>
      <xs:documentation>The Adapter is the central manager in the framework. It has knowledge of both
 Receivers as well as the PipeLine and statistics.
 The Adapter is the class that is responsible for configuring, initializing and
 accessing/activating Receivers, Pipelines, statistics etc.
 &lt;br/&gt;
 An Adapter receives a specific type of messages and processes them. It has Receivers
 that receive the messages and a PipeLine that transforms the incoming messages. Each adapter is part of a Configuration.
 &lt;br/&gt;
 If an adapter can receive its messages through multiple channels (e.g. RESTful HTTP requests, incoming files, etc),
 each channel appears as a separate Receiver nested in the adapter. Each Receiver is also responsible
 for dealing with
 the result of its received messages; the result is the output of the PipeLine. The result
 consists of the transformed message and a state. The Frank!Framework distinguishes between exit states
 SUCCESS and ERROR. There is also a state REJECTED for messages that are not accepted by the Frank!Framework
 and that are not processed by the PipeLine. If the exit state is ERROR, the result message may
 not be usable by the calling system. This can be fixed by adding an
 errorMessageFormatter that formats the result message if the state is ERROR.
 &lt;br/&gt;&lt;br/&gt;
 Adapters gather statistics about the messages they process.
 &lt;br/&gt;
 Adapters can process messages in parallel. They are thread-safe.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Receiver" minOccurs="1" maxOccurs="unbounded" type="ReceiverType" />
      <xs:group ref="ErrorMessageFormatterElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:element name="Pipeline" minOccurs="1" maxOccurs="1" type="PipelineType" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the adapter</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="description" type="xs:string">
      <xs:annotation>
        <xs:documentation>some functional description of the &lt;code&gt;Adapter&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoStart" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>AutoStart indicates that the adapter should be started when the configuration
 is started. Default: &lt;code&gt;true&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceNullMessage" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt; a null message is replaced by an empty message Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageKeeperSize" type="frankInt">
      <xs:annotation>
        <xs:documentation>number of message displayed in ibisconsole Default: 10</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="msgLogLevel">
      <xs:annotation>
        <xs:documentation>Defines behaviour for logging messages. Configuration is done in the MSG appender in log4j4ibis.properties. Default: &lt;code&gt;INFO&lt;/code&gt;, unless overridden by property &lt;code&gt;msg.log.level.default&lt;/code&gt;</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="MessageLogLevelAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="msgLogHidden" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the length of the message is shown in the msg log instead of the content of the message Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetDesignDocument" type="xs:string" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.Adapter" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="adapter" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="ReceiverType">
    <xs:annotation>
      <xs:documentation>Wrapper for a listener that specifies a channel for the incoming messages of a specific Adapter.
 By choosing a listener, the Frank developer determines how the messages are received.
 For example, an org.frankframework.http.rest.ApiListener receives RESTful HTTP requests and a
 JavaListener receives messages from direct Java calls.
 &lt;br/&gt;&lt;br/&gt;
 Apart from wrapping the listener, a Receiver can be configured
 to store received messages and to keep track of the processed / failed
 status of these messages.
 &lt;br/&gt;&lt;br/&gt;
 There are two kinds of listeners: synchronous listeners and asynchronous listeners.
 Synchronous listeners are expected to return a response. The system that triggers the
 receiver typically waits for a response before proceeding its operation. When a
 org.frankframework.http.rest.ApiListener receives a HTTP request, the listener is expected to return a
 HTTP response. Asynchronous listeners are not expected to return a response. The system that
 triggers the listener typically continues without waiting for the adapter to finish. When a
 receiver contains an asynchronous listener, it can have a sender that sends the transformed
 message to its destination. Receivers with an asynchronous listener can also have an error sender that is used
 by the receiver to send error messages. In other words: if the result state is SUCCESS then the
 message is sent by the ordinary sender, while the error sender is used if the result state
 is ERROR.
 &lt;br/&gt;&lt;br/&gt;
 &lt;b&gt;Transaction control&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;
 If transacted is set to &lt;code&gt;true&lt;/code&gt;, messages will be received and processed under transaction control.
 This means that after a message has been read and processed and the transaction has ended, one of the following apply:
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;situation&lt;/th&gt;&lt;th&gt;input listener&lt;/th&gt;&lt;th&gt;Pipeline&lt;/th&gt;&lt;th&gt;inProcess storage&lt;/th&gt;&lt;th&gt;errorSender&lt;/th&gt;&lt;th&gt;summary of effect&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;successful&lt;/td&gt;&lt;td&gt;message read and committed&lt;/td&gt;&lt;td&gt;message processed&lt;/td&gt;&lt;td&gt;unchanged&lt;/td&gt;&lt;td&gt;unchanged&lt;/td&gt;&lt;td&gt;message processed&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;procesing failed&lt;/td&gt;&lt;td&gt;message read and committed&lt;/td&gt;&lt;td&gt;message processing failed and rolled back&lt;/td&gt;&lt;td&gt;unchanged&lt;/td&gt;&lt;td&gt;message sent&lt;/td&gt;&lt;td&gt;message only transferred from listener to errroSender&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;listening failed&lt;/td&gt;&lt;td&gt;unchanged: listening rolled back&lt;/td&gt;&lt;td&gt;no processing performed&lt;/td&gt;&lt;td&gt;unchanged&lt;/td&gt;&lt;td&gt;unchanged&lt;/td&gt;&lt;td&gt;no changes, input message remains on input available for listener&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;transfer to inprocess storage failed&lt;/td&gt;&lt;td&gt;unchanged: listening rolled back&lt;/td&gt;&lt;td&gt;no processing performed&lt;/td&gt;&lt;td&gt;unchanged&lt;/td&gt;&lt;td&gt;unchanged&lt;/td&gt;&lt;td&gt;no changes, input message remains on input available for listener&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;transfer to errorSender failed&lt;/td&gt;&lt;td&gt;message read and committed&lt;/td&gt;&lt;td&gt;message processing failed and rolled back&lt;/td&gt;&lt;td&gt;message present&lt;/td&gt;&lt;td&gt;unchanged&lt;/td&gt;&lt;td&gt;message only transferred from listener to inProcess storage&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 If the application or the server crashes in the middle of one or more transactions, these transactions
 will be recovered and rolled back after the server/application is restarted. Then always exactly one of
 the following applies for any message touched at any time by Ibis by a transacted receiver:
 &lt;ul&gt;
 &lt;li&gt;It is processed correctly by the pipeline and removed from the input-queue,
     not present in inProcess storage and not send to the errorSender&lt;/li&gt;
 &lt;li&gt;It is not processed at all by the pipeline, or processing by the pipeline has been rolled back;
     the message is removed from the input queue and either (one of) still in inProcess storage &lt;i&gt;or&lt;/i&gt; sent to the errorSender&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;&lt;b&gt;commit or rollback&lt;/b&gt;&lt;br/&gt;
 If transacted is set to &lt;code&gt;true&lt;/code&gt;, messages will be either committed or rolled back.
 All message-processing transactions are committed, unless one or more of the following apply:
 &lt;ul&gt;
 &lt;li&gt;The PipeLine is transacted and the exitState of the pipeline is not equal to SUCCESS&lt;/li&gt;
 &lt;li&gt;a PipeRunException or another runtime-exception has been thrown by any Pipe or by the PipeLine&lt;/li&gt;
 &lt;li&gt;the setRollBackOnly() method has been called on the userTransaction (not accessible by Pipes)&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/p&gt;</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ListenerElementGroup" minOccurs="1" maxOccurs="1" />
      <xs:group ref="SenderElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="ErrorSenderElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="ErrorStorageElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="MessageLogElementGroup" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Sets the name of the Receiver, as known to the Adapter.
 If the listener implements the name interface and &lt;code&gt;getName()&lt;/code&gt;
 of the listener is empty, the name of this object is given to the listener.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onError">
      <xs:annotation>
        <xs:documentation>One of 'continue', 'recover' or 'close'. Controls the behaviour of the Receiver, when it encounters an error during processing of a message. Default: CONTINUE</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="OnErrorAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="numThreads" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of threads that may execute a Pipeline concurrently (only for pulling listeners) Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numThreadsPolling" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of threads that are actively polling for messages concurrently. '0' means 'limited only by &lt;code&gt;numthreads&lt;/code&gt;' (only for pulling listeners) Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pollInterval" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of seconds waited after an unsuccessful poll attempt, before another poll attempt is made. Only for polling listeners, not for e.g. jms, webservice or javaListeners Default: 10</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) to start receiver. If this timeout is exceeded, the Receiver startup is
  aborted and all resources closed and the receiver will be in state {@code EXCEPTION_STARTING}
  and a new start command may be issued again.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stopTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) to stop receiver. If this timeout is exceeded, stopping will be aborted
  and the receiver will be in state {@code EXCEPTION_STOPPING}.
  The receiver will no longer be running but some resources might not have been cleaned up properly.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkForDuplicates" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, each message is checked for presence in the messageLog. If already present, it is not processed again. Only required for non XA compatible messaging. Requires messageLog! Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkForDuplicatesMethod">
      <xs:annotation>
        <xs:documentation>(Only used when &lt;code&gt;checkForDuplicates=true&lt;/code&gt;) Indicates whether the messageid or the correlationid is used for checking presence in the message log Default: MESSAGEID</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="CheckForDuplicatesMethodAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="maxDeliveries" type="frankInt">
      <xs:annotation>
        <xs:documentation>The maximum delivery count after which to stop processing the message (only for listeners that know the delivery count of received messages). If -1 the delivery count is ignored Default: 5</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRetries" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of times a processing attempt is automatically retried after an exception is caught or rollback is experienced. If &lt;code&gt;maxRetries &amp;lt; 0&lt;/code&gt; the number of attempts is infinite Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="processResultCacheSize" type="frankInt">
      <xs:annotation>
        <xs:documentation>Size of the cache to keep process results, used by maxRetries Default: 100</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>XPath expression to extract correlationid from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for correlationIDXPath. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>Stylesheet to extract correlationID from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>XPath expression to extract label from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for labelXPath. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>Stylesheet to extract label from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the character data in this XML element is stored inside a session key and in the message it is replaced by a reference to this session key: &lt;code&gt;{sessionKey: elementToMoveSessionKey}&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Only used when &lt;code&gt;elementToMove&lt;/code&gt; or &lt;code&gt;elementToMoveChain&lt;/code&gt; is set) Name of the session key wherein the character data is stored Default: ref_ + the name of the element</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>Like &lt;code&gt;elementToMove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. adapter;pipeline;pipe)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="frankBoolean" />
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>Regular expression to mask strings in the errorStore/logStore and logfiles. Every character between to the strings in this expression will be replaced by a '*'. For example, the regular expression (?&amp;lt;=&amp;lt;party&amp;gt;).*?(?=&amp;lt;/party&amp;gt;) will replace every character between keys &amp;lt;party&amp;gt; and &amp;lt;/party&amp;gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod">
      <xs:annotation>
        <xs:documentation>Only used when hideRegex is not empty Default: all</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="HideMethodAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="hiddenInputSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of keys of session variables which are available when the &lt;code&gt;PipelineSession&lt;/code&gt; is created and of which the value will not be shown in the log (replaced by asterisks)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forceRetryFlag" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, every message read will be processed as if it is being retried, by setting a session variable to retry. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numberOfExceptionsCaughtWithoutMessageBeingReceivedThreshold" type="frankInt">
      <xs:annotation>
        <xs:documentation>Number of connection attempts to put the adapter in warning status Default: 5</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="transactionTimeout" />
    <xs:attribute ref="transactionAttribute" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.receivers.Receiver" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="receiver" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="ParamType">
    <xs:annotation>
      <xs:documentation>Placeholder class to allow legacy configuration notations &lt;code&gt;&amp;lt;param type='number' /&amp;gt;&lt;/code&gt; in the new Frank!Config XSD.
 &lt;p&gt;
 The attribute &lt;code&gt;type&lt;/code&gt; has been removed in favor of explicit ParameterTypes such as: &lt;code&gt;NumberParameter&lt;/code&gt;, &lt;code&gt;DateParameter&lt;/code&gt; and &lt;code&gt;BooleanParameter&lt;/code&gt;.
 Using the new elements enables the use of auto-completion for the specified type.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ParamElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="type">
      <xs:annotation>
        <xs:documentation>The target data type of the parameter, related to the database or XSLT stylesheet to which the parameter is applied. Default: STRING</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="ParameterTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the parameter</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="value" />
    <xs:attribute ref="sessionKey" />
    <xs:attribute ref="contextKey" />
    <xs:attribute ref="sessionKeyXPath" />
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>URL to a stylesheet that wil be applied to the contents of the message or the value of the session-variable.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>the XPath expression to extract the parameter value from the (xml formatted) input or session-variable.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xsltVersion" type="frankInt">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt; a Saxon (net.sf.saxon) xslt processor 2.0 or 3.0 respectively will be used, otherwise xslt processor 1.0 (org.apache.xalan). &lt;code&gt;0&lt;/code&gt; will auto-detect Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace definitions for xpathExpression. Must be in the form of a comma or space separated list of
 &lt;code&gt;prefix=namespaceuri&lt;/code&gt; definitions. One entry can be without a prefix, that will define the default namespace.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNamespaces" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>When set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed before the stylesheet/xpathExpression is executed Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="defaultValue" />
    <xs:attribute ref="defaultValueMethods" />
    <xs:attribute ref="pattern" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain username and password, used when a &lt;code&gt;pattern&lt;/code&gt; containing {username} or {password} is specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default username that is used when a &lt;code&gt;pattern&lt;/code&gt; containing {username} is specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password that is used when a &lt;code&gt;pattern&lt;/code&gt; containing {password} is specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="ignoreUnresolvablePatternElements" />
    <xs:attribute ref="minLength" />
    <xs:attribute ref="maxLength" />
    <xs:attribute ref="hidden" />
    <xs:attribute ref="mode" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.parameters.Parameter" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="param" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="PipelineType">
    <xs:annotation>
      <xs:documentation>Required in each Adapter to transform incoming messages. A pipeline
 is a sequence of pipes. A
 pipeline also defines its allowed end states using the &lt;code&gt;&amp;lt;Exits&amp;gt;&lt;/code&gt;
 tag.
 &lt;br/&gt;&lt;br/&gt;
 The pipes in a PipeLine may not be executed in sequential order, see PipeForward.
 &lt;br/&gt;&lt;br/&gt;
 A pipeline gathers statistics about the messages it processes.
 &lt;br/&gt;&lt;br/&gt;
 In the AppConstants there may be a property named &lt;code&gt;log.logIntermediaryResults&lt;/code&gt; (true/false)
 which indicates whether the intermediary results (between calling pipes) have to be logged.
 &lt;br/&gt;&lt;br/&gt;
 &lt;b&gt;Transaction control&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;
 THE FOLLOWING TO BE UPDATED, attribute 'transacted' replaced by 'transactionAttribute'

 If transacted is set to &lt;code&gt;true&lt;/code&gt;, messages will be processed
 under transaction control. Processing by XA-compliant pipes (i.e. Pipes that implement the
 IXAEnabled-interface, set their transacted-attribute to &lt;code&gt;true&lt;/code&gt; and use XA-compliant
 resources) will then either be committed or rolled back in one transaction.

 If transacted is set to &lt;code&gt;true&lt;/code&gt;, either an existing transaction
 (started by a transactional receiver) is joined, or new one is created (if the message processing request
 is not initiated by a receiver under transaction control.
 Messages are only committed or rolled back by the Pipeline if it started the transaction itself. If
 the pipeline joined an existing transaction, the commit or rollback is left to the object that started
 the transaction, i.e. the receiver. In the latter case the pipeline can indicate to the receiver that the
 transaction should be rolled back (by calling UserTransaction.setRollBackOnly()).

 The choice whether to either commit (by Pipeline or Receiver) or rollback (by Pipeline or Receiver)
 is made as follows:

 If the processing of the message concluded without exceptions and the status of the transaction is
 STATUS_ACTIVE (i.e. normal) the transaction will be committed. Otherwise it will be rolled back,
 or marked for roll back by the calling party.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="InputValidatorElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="OutputValidatorElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="InputWrapperElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="OutputWrapperElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:element name="Exits" minOccurs="0" maxOccurs="1" type="ExitsType" />
      <xs:element name="GlobalForwards" minOccurs="0" maxOccurs="1" type="GlobalForwardsType" />
      <xs:element name="Locker" minOccurs="0" maxOccurs="1" type="LockerType" />
      <xs:group ref="CacheElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="PipeElementGroup" minOccurs="1" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="firstPipe" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the first pipe to execute when a message is to be processed Default: first pipe of the pipeline</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxThreads" type="frankInt">
      <xs:annotation>
        <xs:documentation>Maximum number of threads that may execute this Pipeline simultaneously, use 0 to disable limit Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeOriginalMessageWithoutNamespaces" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; the original message without namespaces (and prefixes) is stored under the session key originalMessageWithoutNamespaces Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageSizeWarn" type="xs:string">
      <xs:annotation>
        <xs:documentation>If messageSizeWarn&gt;=0 and the size of the input or result pipe message exceeds the value specified a warning message is logged. You can specify the value with the suffixes &lt;code&gt;KB&lt;/code&gt;, &lt;code&gt;MB&lt;/code&gt; or &lt;code&gt;GB&lt;/code&gt; Default: application default (30MB)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transformNullMessage" type="xs:string">
      <xs:annotation>
        <xs:documentation>when specified and &lt;code&gt;null&lt;/code&gt; is received as a message the message is changed to the specified value</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="transactionTimeout" />
    <xs:attribute ref="transactionAttribute" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.PipeLine" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="pipeline" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="ForwardType">
    <xs:annotation>
      <xs:documentation>Appears inside a pipe and defines what pipe or exit to execute next. When the
 execution of a pipe is done, the pipe looks up the next pipe or exit to execute.
 This pipe or exit is searched based on a key that describes what happened during
 pipe execution. For example a FixedResultPipe searches for key
 &lt;code&gt;filenotfound&lt;/code&gt; if it tried to read a file that did not exist,
 preventing it from producing the desired output message. If there was
 no error, the FixedResultPipe searches for key &lt;code&gt;success&lt;/code&gt;.
 &lt;br/&gt;&lt;br/&gt;
 Each &lt;code&gt;&amp;lt;Forward&amp;gt;&lt;/code&gt; tag is used to link a search key (&lt;code&gt;name&lt;/code&gt; attribute)
 to a pipe or exit to execute next (&lt;code&gt;path&lt;/code&gt; attribute). The forward's &lt;code&gt;path&lt;/code&gt;
 attribute references the target pipe or exit by its &lt;code&gt;name&lt;/code&gt; attribute, see
 AbstractPipe and PipeLineExit. For most pipes and most keys, the next
 pipe is executed if no forward is found. By default, the pipes in a pipeline are executed consecutively.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>the &lt;code&gt;name&lt;/code&gt; is a symbolic reference to a &lt;code&gt;path&lt;/code&gt;.&lt;br/&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="path" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>The name of the next Pipe or Exit. When the Pipeline doesn't have an Exits element configured it will be
 initialized with one Exit having name READY and state SUCCESS</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.PipeForward" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="forward" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="LockerType">
    <xs:annotation>
      <xs:documentation>Locker of scheduler jobs and pipes.

 Tries to set a lock (by inserting a record in the database table IbisLock) and only if this is done
 successfully the job is executed.

 For an Oracle database the following objects are used:
  &lt;pre&gt;
	CREATE TABLE &amp;lt;schema_owner&amp;gt;.IBISLOCK
	(
	OBJECTID VARCHAR2(100 CHAR),
	TYPE CHAR(1 CHAR),
	HOST VARCHAR2(100 CHAR),
	CREATIONDATE TIMESTAMP(6),
	EXPIRYDATE TIMESTAMP(6)
	CONSTRAINT PK_IBISLOCK PRIMARY KEY (OBJECTID)
	);

	CREATE INDEX &amp;lt;schema_owner&amp;gt;.IX_IBISLOCK ON &amp;lt;schema_owner&amp;gt;.IBISLOCK
	(EXPIRYDATE);

	GRANT DELETE, INSERT, SELECT, UPDATE ON &amp;lt;schema_owner&amp;gt;.IBISLOCK TO &amp;lt;rolename&amp;gt;;
	GRANT SELECT ON SYS.DBA_PENDING_TRANSACTIONS TO &amp;lt;rolename&amp;gt;;

	COMMIT;
  &lt;/pre&gt;</xs:documentation>
    </xs:annotation>
    <xs:attribute name="objectId" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Identifier for this lock</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type">
      <xs:annotation>
        <xs:documentation>Type for this lock: P(ermanent) or T(emporary). A temporary lock is released after the job has completed Default: T</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="LockTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="dateFormatSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>Format for date which is added after &lt;code&gt;objectid&lt;/code&gt; (e.g. yyyyMMdd to be sure the job is executed only once a day)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retention" type="frankInt">
      <xs:annotation>
        <xs:documentation>The time (for type=P in days and for type=T in hours) to keep the record in the database before making it eligible for deletion by a cleanup process Default: 30 days (type=P), 4 hours (type=T)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numRetries" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of times an attempt should be made to acquire a lock, after this many times an exception is thrown when no lock could be acquired, when -1 the number of retries is unlimited Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="firstDelay" type="frankInt">
      <xs:annotation>
        <xs:documentation>The time in ms to wait before the first attempt to acquire a lock is made Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryDelay" type="frankInt">
      <xs:annotation>
        <xs:documentation>The time in ms to wait before another attempt to acquire a lock is made Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWaitTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>If &gt; 0: The time in s to wait before the INSERT statement to obtain the lock is canceled. N.B. On Oracle hitting this lockWaitTimeout may cause the error: (SQLRecoverableException) SQLState [08003], errorCode [17008] connection closed Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreTableNotExist" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; and the IBISLOCK table does not exist in the database, the process continues as if the lock was obtained</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute">
      <xs:annotation>
        <xs:documentation>The &lt;code&gt;transactionAttribute&lt;/code&gt; declares transactional behavior of execution. It applies both to database transactions and XA transactions.
 The pipeline uses this to start a new transaction or suspend the current one when required.
 For developers: it is equal to &lt;a href=\"https://docs.oracle.com/javaee/7/tutorial/transactions003.htm\"&gt;EJB transaction attribute&lt;/a&gt;.
 Possible values for transactionAttribute:
   &lt;table border=\"1\"&gt;
     &lt;tr&gt;&lt;th&gt;transactionAttribute&lt;/th&gt;&lt;th&gt;callers Transaction&lt;/th&gt;&lt;th&gt;Pipeline excecuted in Transaction&lt;/th&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Required&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;RequiresNew&lt;/td&gt; &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Mandatory&lt;/td&gt;   &lt;td&gt;none&lt;/td&gt;&lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;NotSupported&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Supports&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
  										      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Never&lt;/td&gt;       &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;
   &lt;/table&gt; Default: Supports</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="TransactionAttributeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="transactionTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Timeout (in seconds) of transaction started to process a message. Default: &lt;code&gt;0&lt;/code&gt; (use system default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="datasourceName" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used to authenticate when connecting to database</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>User name for authentication when connecting to database, when none found from &lt;code&gt;authAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password for authentication when connecting to database, when none found from &lt;code&gt;authAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>controls the use of transactions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="connectionsArePooled" />
    <xs:attribute ref="authentication" />
    <xs:attribute ref="credentials" />
    <xs:attribute ref="initialContextFactoryName" />
    <xs:attribute ref="providerURL" />
    <xs:attribute ref="securityProtocol" />
    <xs:attribute ref="urlPkgPrefixes" />
    <xs:attribute ref="principal" />
    <xs:attribute ref="jndiAuthAlias" />
    <xs:attribute ref="jndiContextPrefix" />
    <xs:attribute ref="jndiProperties" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the sender or the listener</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.util.Locker" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="locker" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="ExitsType">
    <xs:annotation>
      <xs:documentation>Pipeline exit container in which all (required) Exits must be defined.
 Multiple exits may be provided each with their unique name.
 &lt;br/&gt;&lt;br/&gt;
 If no exits are specified, a default one is created with name="READY" and state="SUCCESS".
 &lt;br/&gt;&lt;br/&gt;
 &lt;b&gt;example:&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;Exits&gt;
    &lt;Exit name="READY" state="SUCCESS" /&gt;
    &lt;Exit name="Created" state="ERROR" code="201" empty="true" /&gt;
    &lt;Exit name="NotModified" state="ERROR" code="304" empty="true" /&gt;
    &lt;Exit name="BadRequest" state="ERROR" code="400" empty="true" /&gt;
    &lt;Exit name="NotAuthorized" state="ERROR" code="401" empty="true" /&gt;
    &lt;Exit name="NotAllowed" state="ERROR" code="403" empty="true" /&gt;
    &lt;Exit name="Teapot" state="SUCCESS" code="418" /&gt;
    &lt;Exit name="ServerError" state="ERROR" code="500" /&gt;
 &lt;/Exits&gt;
 }&lt;/pre&gt;</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Exit" minOccurs="1" maxOccurs="unbounded" type="ExitType" />
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.PipeLineExits" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="exits" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="ExitType">
    <xs:annotation>
      <xs:documentation>The Exit of a Pipeline that specifies the end state of a PipeLine. The state is returned to the receiver as well as
 the optionally specified http status code. Each Exit should have a unique name. See Exits
 for examples.
 &lt;br/&gt;&lt;br/&gt;
 When a Pipeline doesn't have an Exits element configured it will be initialized with one Exit having name READY and
 state SUCCESS.
 &lt;br/&gt;&lt;br/&gt;
 The name of an Exit can be referenced by the &lt;code&gt;path&lt;/code&gt; attribute of a Forward within a Pipe.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>The name of the Exit that can be referenced by a PipeForward's &lt;code&gt;path&lt;/code&gt; attribute. When a Pipeline doesn't have an Exits
 element configured it will be initialized with one Exit having name READY (and state SUCCESS)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="state" use="required">
      <xs:annotation>
        <xs:documentation>The state of the Pipeline that is returned to the Receiver for this Exit. When a Pipeline doesn't have an Exits
 element configured it will be initialized with one Exit having state SUCCESS (and name READY)</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="ExitStateAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="code" type="frankInt">
      <xs:annotation>
        <xs:documentation>HTTP statusCode e.g. &lt;code&gt;500&lt;/code&gt; Default: 200</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="responseRoot" type="xs:string">
      <xs:annotation>
        <xs:documentation>Configures the responseRoot in the OpenAPI schema for this exit. If not set, the responseRoot value of the validator will be used. If that contains multiple (comma separated) values, the first will be used for the exits with state &lt;code&gt;SUCCESS&lt;/code&gt;, the last for the other exits.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="empty" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If using RestListener and set to &lt;code&gt;true&lt;/code&gt;, this removes the output and shows a blank page, the output is still logged in the ladybug testtool Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipWrapping" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the output will not be wrapped by the OutputWrapper. Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipValidation" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the output will not be validated or transformed by the validator. Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.PipeLineExit" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="exit" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="GlobalForwardsType">
    <xs:annotation>
      <xs:documentation>Optional element in a pipeline. Global forwards that will be added to every pipe, when the forward name has not been explicitly set.
 For example the &lt;code&gt;&amp;lt;forward name="exception" path="error_exception" /&amp;gt;&lt;/code&gt;, which will add the '&lt;code&gt;exception&lt;/code&gt;' forward to every pipe in the pipeline.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Forward" minOccurs="0" maxOccurs="unbounded" type="ForwardType" />
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.PipeForwards" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="globalForwards" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="SchedulerType">
    <xs:annotation>
      <xs:documentation>Container for jobs that are scheduled for periodic execution.
 &lt;p&gt;
 Configure/start/stop lifecycles are managed by Spring.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="JobElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.configuration.ScheduleManager" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="scheduler" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="DirectoryCleanerType">
    <xs:annotation>
      <xs:documentation>Cleans up a directory.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="directory" type="xs:string">
      <xs:annotation>
        <xs:documentation>directory to be cleaned up</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retention" type="xs:string">
      <xs:annotation>
        <xs:documentation>Minimum amount of time (with suffix 'd', 'h', 'm' or 's') that must have passed before a file will be deleted.
 You may only use one suffix! Default: 30d</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="subdirectories" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, files in subdirectories will be deleted, too Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deleteEmptySubdirectories" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, empty subdirectories will be deleted, too Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="notExistWarn" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, send warnings to logging and console about not existing directories Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.util.DirectoryCleaner" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="directoryCleaner" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="SapSystemsType">
    <xs:sequence>
      <xs:group ref="SapSystemElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.configuration.extensions.SapSystems" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="sapSystems" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="JmsRealmsType">
    <xs:annotation>
      <xs:documentation>Singleton that has the different jmsRealms.&lt;br/&gt;
 Typical use: JmsRealmFactory.getInstance().&amp;lt;method to execute&amp;gt;
 &lt;br/&gt;</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="JmsRealm" minOccurs="0" maxOccurs="unbounded" type="JmsRealmType" />
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jms.JmsRealmFactory" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="jmsRealms" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="JmsRealmType">
    <xs:annotation>
      <xs:documentation>A JmsRealm is a definition of a JMS provider, and is kind of a utility
 class to prevent the tedeous work of repeatedly defining all parameters
 to connect to a queue or topic.
 &lt;br/&gt;
 This class is not an extension of JNDIBase, which would be logical, because
 in the JMSBase class the function PropertyUtils.copyProperties is used, which cannot
 handle this.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="aliasForRealm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Includes another realm into this one</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="realmName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Set the name of this realm&lt;br/&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Set the name of the QueueConnectionFactory&lt;br/&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Set the name of the TopicConnectionFactory&lt;br/&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string" />
    <xs:attribute name="urlPkgPrefixes" type="xs:string" />
    <xs:attribute name="authentication" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string" />
    <xs:attribute name="providerURL" type="xs:string" />
    <xs:attribute name="userTransactionUrl" type="xs:string" />
    <xs:attribute name="principal" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string" />
    <xs:attribute name="authAlias" type="xs:string" />
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jms.JmsRealm" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="jmsRealm" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="MonitoringType">
    <xs:annotation>
      <xs:documentation>Manager for Monitoring.
 &lt;p&gt;
 Configure/start/stop lifecycles are managed by Spring.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="DestinationElementGroup" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Monitor" minOccurs="0" maxOccurs="unbounded" type="MonitorType" />
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.monitoring.MonitorManager" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="monitoring" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="MonitorType">
    <xs:annotation>
      <xs:documentation>&lt;p&gt;Example configuration:&lt;/p&gt;
 &lt;pre&gt;{@code
 &lt;monitor name="Receiver Shutdown" destinations="MONITOR_LOG"&gt;
    &lt;trigger className="org.frankframework.monitoring.Alarm" severity="WARNING"&gt;
        &lt;event&gt;Receiver Shutdown&lt;/event&gt;
    &lt;/trigger&gt;
    &lt;trigger className="org.frankframework.monitoring.Clearing" severity="WARNING"&gt;
        &lt;event&gt;Receiver Shutdown&lt;/event&gt;
    &lt;/trigger&gt;
 &lt;/monitor&gt;
 }&lt;/pre&gt;</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="TriggerElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="destinations" type="xs:string" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of the object.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="raised" type="frankBoolean" />
    <xs:attribute name="additionalHitCount" type="frankInt" />
    <xs:attribute name="type">
      <xs:simpleType>
        <xs:union memberTypes="EventTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="alarmSeverity">
      <xs:simpleType>
        <xs:union memberTypes="SeverityAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.monitoring.Monitor" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="monitor" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="AdapterfilterType">
    <xs:annotation>
      <xs:documentation>Filter on Adapters, used by Triggers.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Source" minOccurs="0" maxOccurs="unbounded" type="xs:string" />
    </xs:sequence>
    <xs:attribute name="adapter" type="xs:string">
      <xs:annotation>
        <xs:documentation>Set the name of the Adapter that this AdapterFilter filters on.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.monitoring.AdapterFilter" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="adapterfilter" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="SharedResourcesType">
    <xs:sequence>
      <xs:group ref="SharedResourceElementGroup" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="HttpSession" minOccurs="0" maxOccurs="unbounded" type="HttpSessionType" />
    </xs:sequence>
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.configuration.SharedResources" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:attribute name="elementRole" type="xs:string" fixed="sharedResources" use="prohibited" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="ConfigurationType">
    <xs:group ref="ConfigurationDeclaredChildGroup" />
    <xs:attributeGroup ref="ConfigurationDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.configuration.Configuration" use="prohibited" />
  </xs:complexType>
  <xs:group name="ConfigurationDeclaredChildGroup">
    <xs:sequence>
      <xs:element ref="Module" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Include" minOccurs="0" maxOccurs="unbounded" type="IncludeType" />
      <xs:element name="Adapter" minOccurs="0" maxOccurs="unbounded" type="AdapterType" />
      <xs:element name="Scheduler" minOccurs="0" maxOccurs="1" type="SchedulerType" />
      <xs:element name="SapSystems" minOccurs="0" maxOccurs="1" type="SapSystemsType" />
      <xs:element name="JmsRealms" minOccurs="0" maxOccurs="1" type="JmsRealmsType" />
      <xs:element name="Monitoring" minOccurs="0" maxOccurs="1" type="MonitoringType" />
      <xs:element name="SharedResources" minOccurs="0" maxOccurs="1" type="SharedResourcesType" />
    </xs:sequence>
  </xs:group>
  <xs:group name="ListenerElementGroup">
    <xs:choice>
      <xs:element name="Listener">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:group ref="ParamElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ListenerElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ParamElementGroup">
    <xs:choice>
      <xs:element name="Param">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:group ref="ParamElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="param" use="prohibited" />
          <xs:attribute name="className" type="xs:string" default="org.frankframework.parameters.Parameter" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ParamElementGroupBase_2" />
    </xs:choice>
  </xs:group>
  <xs:group name="ParamElementGroupBase_2">
    <xs:choice>
      <xs:element name="BooleanParam">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="BooleanParameterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="param" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DateParam">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DateParameterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="param" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="NumberParam">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="NumberParameterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="param" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="BooleanParameterType">
    <xs:group ref="AbstractParameterDeclaredChildGroup" />
    <xs:attributeGroup ref="AbstractParameterDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.parameters.BooleanParameter" use="prohibited" />
  </xs:complexType>
  <xs:group name="AbstractParameterDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="ParamElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="AbstractParameterDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the parameter</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="value" />
    <xs:attribute ref="sessionKey" />
    <xs:attribute ref="contextKey" />
    <xs:attribute ref="sessionKeyXPath" />
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>URL to a stylesheet that wil be applied to the contents of the message or the value of the session-variable.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>the XPath expression to extract the parameter value from the (xml formatted) input or session-variable.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xsltVersion" type="frankInt">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt; a Saxon (net.sf.saxon) xslt processor 2.0 or 3.0 respectively will be used, otherwise xslt processor 1.0 (org.apache.xalan). &lt;code&gt;0&lt;/code&gt; will auto-detect Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace definitions for xpathExpression. Must be in the form of a comma or space separated list of
 &lt;code&gt;prefix=namespaceuri&lt;/code&gt; definitions. One entry can be without a prefix, that will define the default namespace.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNamespaces" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>When set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed before the stylesheet/xpathExpression is executed Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="defaultValue" />
    <xs:attribute ref="defaultValueMethods" />
    <xs:attribute ref="pattern" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain username and password, used when a &lt;code&gt;pattern&lt;/code&gt; containing {username} or {password} is specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default username that is used when a &lt;code&gt;pattern&lt;/code&gt; containing {username} is specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password that is used when a &lt;code&gt;pattern&lt;/code&gt; containing {password} is specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="ignoreUnresolvablePatternElements" />
    <xs:attribute ref="minLength" />
    <xs:attribute ref="maxLength" />
    <xs:attribute ref="hidden" />
    <xs:attribute ref="mode" />
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="DateParameterType">
    <xs:group ref="AbstractParameterDeclaredChildGroup" />
    <xs:attributeGroup ref="DateParameterCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.parameters.DateParameter" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="DateParameterDeclaredAttributeGroup">
    <xs:attribute name="formatString" type="xs:string">
      <xs:annotation>
        <xs:documentation>Used in combination with types &lt;code&gt;DATE&lt;/code&gt;, &lt;code&gt;TIME&lt;/code&gt;, &lt;code&gt;DATETIME&lt;/code&gt; and &lt;code&gt;TIMESTAMP&lt;/code&gt; to parse the raw parameter string data into an object of the respective type Default: depends on type</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="formatType">
      <xs:simpleType>
        <xs:union memberTypes="DateFormatTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="DateParameterCumulativeAttributeGroup">
    <xs:attributeGroup ref="DateParameterDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractParameterDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="NumberParameterType">
    <xs:group ref="AbstractParameterDeclaredChildGroup" />
    <xs:attributeGroup ref="NumberParameterCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.parameters.NumberParameter" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="NumberParameterDeclaredAttributeGroup">
    <xs:attribute name="decimalSeparator" type="xs:string">
      <xs:annotation>
        <xs:documentation>Separate the integer part from the fractional part of a number. Default: system default</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="groupingSeparator" type="xs:string">
      <xs:annotation>
        <xs:documentation>In the United States, the comma is typically used for the grouping separator; however, several publication standards follow international standards in using either a space or a thin space character. Default: system default</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxInclusive" type="xs:string">
      <xs:annotation>
        <xs:documentation>Used in combination with type &lt;code&gt;number&lt;/code&gt;; if set and the value of the parameter exceeds this maximum value, this maximum value is taken</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="minInclusive" type="xs:string">
      <xs:annotation>
        <xs:documentation>Used in combination with type &lt;code&gt;number&lt;/code&gt;; if set and the value of the parameter falls short of this minimum value, this minimum value is taken</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="NumberParameterCumulativeAttributeGroup">
    <xs:attributeGroup ref="NumberParameterDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractParameterDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="ListenerElementGroupBase">
    <xs:choice>
      <xs:element name="ApiListener">
        <xs:annotation>
          <xs:documentation>Listener that allows a Receiver to receive messages as a REST webservice.
 Prepends the configured URI pattern with &lt;code&gt;api/&lt;/code&gt;. The structure of REST messages is described
 by OpenAPI specifications. The Frank!Framework generates an OpenAPI specification for each ApiListener and
 for all ApiListeners in all configurations combined. You can
 find them in the Frank!Console under main menu item Webservices, heading Available ApiListeners.
 &lt;p&gt;
 The generated OpenAPI specifications have &lt;code&gt;servers&lt;/code&gt; and &lt;code&gt;paths&lt;/code&gt; objects and
 therefore they document the full URLs of the provided services.
 &lt;p&gt;
 It is possible to automatically generate eTags over the listener result. This can be controlled by globally 
 setting the property &lt;code&gt;api.etag.enabled&lt;/code&gt; or by setting the attribute &lt;code&gt;updateEtag="true"&lt;/code&gt;.
 When enabled the listener will respond to the &lt;code&gt;If-Match&lt;/code&gt;, &lt;code&gt;If-None-Match&lt;/code&gt; headers and may return status code 304.
 &lt;p&gt;
 In order to enable eTags for multiple nodes you must configure Memcached to store the eTags.
 The following properties will need to be set:
 &lt;ul&gt;
 &lt;li&gt;&lt;code&gt;etag.cache.server=ip or hostname:port&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;etag.cache.type=memcached&lt;/code&gt;&lt;/li&gt;
 &lt;/ul&gt;
 In case authentication, is required the following application properties can be used:
 &lt;ul&gt;
 &lt;li&gt;&lt;code&gt;etag.cache.username&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;etag.cache.password&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;etag.cache.authalias&lt;/code&gt;&lt;/li&gt;
 &lt;/ul&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ApiListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CmisEventListener">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CmisEventListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DirectoryListener">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DirectoryListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbJmsListener">
        <xs:annotation>
          <xs:documentation>ESB (Enterprise Service Bus) extension of JmsListener.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbJmsListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ExchangeMailListener">
        <xs:annotation>
          <xs:documentation>Microsoft Exchange Implementation of a MailListener.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ExchangeMailListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FrankListener">
        <xs:annotation>
          <xs:documentation>Listener to receive messages sent by the org.frankframework.senders.FrankSender, for situations where
 calling an Adapter directly is not desired. This could be because message / error logging is required for messages
 sent to the subadapter.
 &lt;br/&gt;
 See the org.frankframework.senders.FrankSender documentation for more information.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FrankListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FtpFileSystemListener">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FtpFileSystemListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FxfListener">
        <xs:annotation>
          <xs:documentation>FxF extension of EsbJmsListener.

 &lt;p&gt;&lt;b&gt;Configuration &lt;/b&gt;&lt;i&gt;(where deviating from EsbJmsListener)&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;destinationName&lt;/td&gt;&lt;td&gt;name of the JMS destination (queue or topic) to use&lt;/td&gt;&lt;td&gt;"jms/FileTransferAction"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;jmsRealm&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;"qcf_tibco_p2p_ff"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;messageProtocol&lt;/td&gt;&lt;td&gt;protocol of ESB service to be called. Possible values
 &lt;ul&gt;
   &lt;li&gt;"FF": Fire &amp; Forget protocol&lt;/li&gt;
   &lt;li&gt;"RR": Request-Reply protocol&lt;/li&gt;
 &lt;/ul&gt;&lt;/td&gt;&lt;td&gt;"FF"&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FxfListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ImapListener">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ImapListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JavaListener">
        <xs:annotation>
          <xs:documentation>Use this listener to receive messages from other adapters or a scheduler within the same Frank-application or from other components residing in the same JVM.
 JavaListeners can receive calls made via de ibis-servicedispatcher, which should be located on the JVM classpath to receive calls from other components in the JVM. If you want to call an adapter in the same Frank-application, consider using the IbisLocalSender.
 &lt;br/&gt;
 To understand what this listener does exactly, please remember that the Frank!Framework is a Java application.
 The JavaListener listens to Java method calls. You can issue Java method calls using a IbisJavaSender (external call)
 or IbisLocalSender (internal call).
 For more information see the ibis-servicedispatcher project.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JavaListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JdbcListener">
        <xs:annotation>
          <xs:documentation>JdbcListener base class.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JdbcListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JdbcTableListener">
        <xs:annotation>
          <xs:documentation>Database Listener that operates on a table having at least a key and a status field.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JdbcTableListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JmsListener">
        <xs:annotation>
          <xs:documentation>A true multi-threaded Listener-class.
 &lt;br/&gt;

 Since version 4.1, Ibis supports distributed transactions using the XA-protocol. This feature is controlled by the
 transacted attribute. If this is set to &lt;code&gt;true&lt;/code&gt;, received messages are
 committed or rolled back, possibly together with other actions, by the receiver or the pipeline.
 In case of a failure, all actions within the transaction are rolled back.

 &lt;p&gt;&lt;b&gt;Using jmsTransacted and acknowledgement&lt;/b&gt;&lt;br/&gt;
 If jmsTransacted is set &lt;code&gt;true&lt;/code&gt;: it should ensure that a message is received and processed on a both or nothing basis.
 IBIS will commit the the message, otherwise perform rollback. However using jmsTransacted, IBIS does not bring transactions within
 the adapters under transaction control, compromising the idea of atomic transactions. In the roll-back situation messages sent to
 other destinations within the Pipeline are NOT rolled back if jmsTransacted is set &lt;code&gt;true&lt;/code&gt;! In the failure situation the
 message is therefore completely processed, and the roll back does not mean that the processing is rolled back! To obtain the correct
 (transactional) behaviour, transacted should be used instead of listener.transacted.
 &lt;/p&gt;&lt;p&gt;
 Setting listener.acknowledgeMode to "auto" means that messages are allways acknowledged (removed from
 the queue, regardless of what the status of the Adapter is. "client" means that the message will only be removed from the queue
 when the state of the Adapter equals the success state for committing.
 The "dups" mode instructs the session to lazily acknowledge the delivery of the messages. This is likely to result in the
 delivery of duplicate messages if JMS fails. It should be used by consumers who are tolerant in processing duplicate messages.
 In cases where the client is tolerant of duplicate messages, some enhancement in performance can be achieved using this mode,
 since a session has lower overhead in trying to prevent duplicate messages.
 &lt;/p&gt;
 &lt;p&gt;The setting for listener.acknowledgeMode will only be processed if
 the setting for listener.transacted as well as for
 listener.jmsTransacted is false.&lt;/p&gt;

 &lt;p&gt;If useReplyTo is set and a replyTo-destination is
 specified in the message, the JmsListener sends the result of the processing
 in the pipeline to this destination. Otherwise the result is sent using the (optionally)
 specified, that in turn sends the message to
 whatever it is configured to.&lt;/p&gt;

 &lt;p&gt;You can add parameters to the JmsListener, the values will be added as Headers to the JMS response message.&lt;/p&gt;

 &lt;p&gt;&lt;b&gt;Notice:&lt;/b&gt; the JmsListener is ONLY capable of processing
 jakarta.jms.TextMessages and jakarta.jms.BytesMessage&lt;br/&gt;&lt;br/&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JmsListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MessageStoreListener">
        <xs:annotation>
          <xs:documentation>Read messages from the IBISSTORE database table previously stored by a MessageStoreSender.
 &lt;p&gt;
 Example configuration:
 &lt;pre&gt;{@code
 	&lt;Receiver
 		name="03 MessageStoreReceiver"
 		numThreads="4"
 		transactionAttribute="Required"
 		pollInterval="1"&gt;
 		&lt;MessageStoreListener
 			name="03 MessageStoreListener"
 			slotId="${instance.name}/TestMessageStore"
 			statusValueInProcess="I" /&gt;
 	&lt;/Receiver&gt;
 }&lt;/pre&gt;

 If you have a &lt;code&gt;MessageStoreListener&lt;/code&gt;, failed messages are automatically kept in database
 table IBISSTORE. Messages are also kept after successful processing. The state of a message
 is distinguished by the &lt;code&gt;TYPE&lt;/code&gt; field, as follows:
 &lt;ul&gt;
 &lt;li&gt; &lt;code&gt;M&lt;/code&gt;: The message is new. From a functional perspective, it is in the message store.
 &lt;li&gt; &lt;code&gt;E&lt;/code&gt;: There was an error processing the message. From a functional perspective, it is in the error store.
 &lt;li&gt; &lt;code&gt;A&lt;/code&gt;: The message was successfully processed. From a functional perspective, it is in the message log.
 &lt;/ul&gt;
 Another way to say this is that a &lt;code&gt;MessageStoreListener&lt;/code&gt; acts as a message log and as an error store.
 If you have it, you do not need to add
 a &lt;code&gt;JdbcErrorStorage&lt;/code&gt; or &lt;code&gt;JdbcMessageLog&lt;/code&gt; within the same receiver.
 &lt;br/&gt;&lt;br/&gt;
 See /IAF_util/IAF_DatabaseChangelog.xml for the structure of table IBISSTORE.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MessageStoreListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MqttListener">
        <xs:annotation>
          <xs:documentation>MQTT listener which will connect to a broker and subscribe to a topic.

 Links to &lt;a href="https://www.eclipse.org/paho/files/javadoc" target="_blank"&gt;https://www.eclipse.org/paho/files/javadoc&lt;/a&gt; are opened in a new window/tab because the response from eclipse.org contains header X-Frame-Options:SAMEORIGIN which will make the browser refuse to open the link inside this frame.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MqttListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PullingJmsListener">
        <xs:annotation>
          <xs:documentation>A true multi-threaded Listener-class.
 &lt;br/&gt;

 Since version 4.1, Ibis supports distributed transactions using the XA-protocol. This feature is controlled by the
 transacted attribute. If this is set to &lt;code&gt;true&lt;/code&gt;, received messages are
 committed or rolled back, possibly together with other actions, by the receiver or the pipeline.
 In case of a failure, all actions within the transaction are rolled back.

 &lt;p&gt;&lt;b&gt;Using jmsTransacted and acknowledgement&lt;/b&gt;&lt;br/&gt;
 If jmsTransacted is set &lt;code&gt;true&lt;/code&gt;: it should ensure that a message is received and processed on a both or nothing basis.
 IBIS will commit the the message, otherwise perform rollback. However using jmsTransacted, IBIS does not bring transactions within
 the adapters under transaction control, compromising the idea of atomic transactions. In the roll-back situation messages sent to
 other destinations within the Pipeline are NOT rolled back if jmsTransacted is set &lt;code&gt;true&lt;/code&gt;! In the failure situation the
 message is therefore completely processed, and the roll back does not mean that the processing is rolled back! To obtain the correct
 (transactional) behaviour, transacted should be used instead of listener.transacted.
&lt;p&gt;
 Setting listener.acknowledgeMode to "auto" means that messages are allways acknowledged (removed from
 the queue, regardless of what the status of the Adapter is. "client" means that the message will only be removed from the queue
 when the state of the Adapter equals the success state.
 The "dups" mode instructs the session to lazily acknowledge the delivery of the messages. This is likely to result in the
 delivery of duplicate messages if JMS fails. It should be used by consumers who are tolerant in processing duplicate messages.
 In cases where the client is tolerant of duplicate messages, some enhancement in performance can be achieved using this mode,
 since a session has lower overhead in trying to prevent duplicate messages.
 &lt;/p&gt;
 &lt;p&gt;The setting for listener.acknowledgeMode will only be processed if
 the setting for listener.transacted as well as for
 listener.jmsTransacted is false.&lt;/p&gt;

 &lt;p&gt;If useReplyTo is set and a replyTo-destination is
 specified in the message, the JmsListener sends the result of the processing
 in the pipeline to this destination. Otherwise the result is sent using the (optionally)
 specified Sender, that in turn sends the message to
 whatever it is configured to.&lt;/p&gt;
 &lt;/p&gt;
 &lt;p&gt;&lt;b&gt;Notice:&lt;/b&gt; the JmsListener is ONLY capable of processing
 &lt;code&gt;jakarta.jms.TextMessage&lt;/code&gt;s &lt;br/&gt;&lt;br/&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PullingJmsListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PushingJmsListener">
        <xs:annotation>
          <xs:documentation>JMSListener re-implemented as a pushing listener rather than a pulling listener.
 The JMS messages have to come in from an external source: an MDB or a Spring
 message container.

 This version of the &lt;code&gt;JmsListener&lt;/code&gt; supports distributed transactions using the XA-protocol.
 No special action is required to have the listener join the transaction.

 &lt;p&gt;&lt;b&gt;Using jmsTransacted and acknowledgement&lt;/b&gt;&lt;br/&gt;
 If jmsTransacted is set &lt;code&gt;true&lt;/code&gt;, it should ensure that a message is received and processed on
 a both or nothing basis. IBIS will commit the the message, otherwise perform rollback. However, using
 jmsTransacted, IBIS does not bring transactions within the adapters under transaction control,
 compromising the idea of atomic transactions. In the roll-back situation messages sent to other
 destinations within the Pipeline are NOT rolled back if jmsTransacted is set &lt;code&gt;true&lt;/code&gt;! In
 the failure situation the message is therefore completely processed, and the roll back does not mean
 that the processing is rolled back! To obtain the correct (transactional) behaviour, set
 &lt;code&gt;transacted&lt;/code&gt;="true" for the enclosing Receiver. Do not use jmsTransacted for any new situation.

 &lt;/p&gt;&lt;p&gt;
 Setting listener.acknowledgeMode to "auto" means that messages are allways acknowledged (removed from
 the queue, regardless of what the status of the Adapter is. "client" means that the message will only be removed from the queue
 when the state of the Adapter equals the success state.
 The "dups" mode instructs the session to lazily acknowledge the delivery of the messages. This is likely to result in the
 delivery of duplicate messages if JMS fails. It should be used by consumers who are tolerant in processing duplicate messages.
 In cases where the client is tolerant of duplicate messages, some enhancement in performance can be achieved using this mode,
 since a session has lower overhead in trying to prevent duplicate messages.
 &lt;/p&gt;
 &lt;p&gt;The setting for listener.acknowledgeMode will only be processed if
 the setting for listener.transacted as well as for
 listener.jmsTransacted is false.&lt;/p&gt;

 &lt;p&gt;If useReplyTo is set and a replyTo-destination is
 specified in the message, the JmsListener sends the result of the processing
 in the pipeline to this destination. Otherwise the result is sent using the (optionally)
 specified Sender, that in turn sends the message to
 whatever it is configured to.&lt;/p&gt;

 &lt;p&gt;&lt;b&gt;Notice:&lt;/b&gt; the JmsListener is ONLY capable of processing
 jakarta.jms.TextMessages and jakarta.jms.BytesMessage&lt;br/&gt;&lt;br/&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PushingJmsListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="RestListener">
        <xs:annotation>
          <xs:documentation>Listener that allows a Receiver to receive messages as a REST webservice.
 Prepends the configured URI pattern with &lt;code&gt;rest/&lt;/code&gt;. When you are writing a new Frank config, you are recommended
 to use an ApiListener instead. You can find all serviced URI patterns
 in the Frank!Console: main menu item Webservice, heading Available REST Services.

 &lt;p&gt;
 Note:
 Servlets' multipart configuration expects a Content-Type of &lt;code&gt;multipart/form-data&lt;/code&gt; (see http://docs.oracle.com/javaee/6/api/javax/servlet/annotation/MultipartConfig.html).
 So do not use other multipart content types like &lt;code&gt;multipart/related&lt;/code&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RestListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Samba2Listener">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Samba2ListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SambaListener">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SambaListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SapListener">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SapListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SftpFileSystemListener">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SftpFileSystemListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SimpleJdbcListener">
        <xs:annotation>
          <xs:documentation>Database Listener that returns a count of messages available, but does not perform any locking or
 other management of processing messages in parallel.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SimpleJdbcListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="TibcoLogJmsListener">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="TibcoLogJmsListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="WebServiceListener">
        <xs:annotation>
          <xs:documentation>Listener that allows a Receiver to receive messages as a SOAP webservice.
 The structure of the SOAP messages is expressed in a WSDL (Web Services Description Language) document.
 The Frank!Framework generates a WSDL document for each adapter that contains WebServiceListeners. You can
 find these documents in the Frank!Console under main menu item Webservices, heading Available WSDL's.
 The WSDL documents that we generate document how the SOAP services can be accessed. In particular, the
 URL of a SOAP service can be found in an XML element &lt;code&gt;&amp;lt;soap:address&amp;gt;&lt;/code&gt; with
 &lt;code&gt;soap&lt;/code&gt; pointing to namespace &lt;code&gt;http://schemas.xmlsoap.org/wsdl/soap/&lt;/code&gt;.

 &lt;br/&gt;If &lt;code&gt;address&lt;/code&gt; is set, then for each request:&lt;ul&gt;
 &lt;li&gt;MIME headers are described in a 'mimeHeaders'-XML stored under session key 'mimeHeaders'&lt;/li&gt;
 &lt;li&gt;Attachments present in the request are described by an 'attachments'-XML stored under session key 'attachments'&lt;/li&gt;
 &lt;li&gt;SOAP protocol is stored under a session key 'soapProtocol'&lt;/li&gt;
 &lt;li&gt;SOAP action is stored under a session key 'SOAPAction'&lt;/li&gt;
 &lt;/ul&gt;
 and for each response a multipart message is constructed if a 'multipart'-XML is provided in sessionKey specified by multipartXmlSessionKey.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="WebServiceListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="ApiListenerType">
    <xs:attributeGroup ref="ApiListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.http.rest.ApiListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ApiListenerDeclaredAttributeGroup">
    <xs:attribute name="method">
      <xs:annotation>
        <xs:documentation>HTTP method to listen to Default: GET</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="HttpMethodAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="methods">
      <xs:annotation>
        <xs:documentation>HTTP method(s) to listen to. Inside XML Configurations: for multiple values, use a comma as separator. Default: GET</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="HttpMethodAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="uriPattern" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>URI pattern to register this listener on, eq. &lt;code&gt;/my-listener/{something}/here&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="consumes">
      <xs:annotation>
        <xs:documentation>The required contentType on requests, if it doesn't match a &lt;code&gt;415&lt;/code&gt; status (Unsupported Media Type) is returned. Default: ANY</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="MediaTypesAttributeValuesType_2 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="produces">
      <xs:annotation>
        <xs:documentation>The specified contentType on response. When &lt;code&gt;ANY&lt;/code&gt; the response will determine the content-type when it's known and will never calculate it. If no match is found &lt;code&gt;*&amp;#47;*&lt;/code&gt; will be used.
 When &lt;code&gt;DETECT&lt;/code&gt; the framework attempts to detect the MimeType (as well as charset) when not known. Default: ANY</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="MediaTypesAttributeValuesType_2 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="characterEncoding" type="xs:string">
      <xs:annotation>
        <xs:documentation>The specified character encoding on the response contentType header. NULL or empty
 values will be ignored. Default: UTF-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="updateEtag" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Automatically generate and validate etags Default: &lt;code&gt;false&lt;/code&gt;, can be changed by setting the property &lt;code&gt;api.etag.enabled&lt;/code&gt;.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authenticationMethod">
      <xs:annotation>
        <xs:documentation>Enables security for this listener. If you wish to use the application servers authorization roles [AUTHROLE], you need to enable them globally for all ApiListeners with the &lt;code&gt;servlet.ApiListenerServlet.securityRoles=IbisTester,IbisWebService&lt;/code&gt; property Default: &lt;code&gt;NONE&lt;/code&gt;</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="AuthenticationMethodsAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="authenticationRoles" type="xs:string">
      <xs:annotation>
        <xs:documentation>Only active when AuthenticationMethod=AUTHROLE. Comma separated list of authorization roles which are granted for this service, eq. &lt;code&gt;IbisTester,IbisObserver&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartBodyName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Specify the form-part you wish to enter the pipeline Default: name of the first form-part</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageIdHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the header which contains the Message-Id. Default: Message-Id</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the header which contains the Correlation-Id. Default: Correlation-Id</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="operationId" type="xs:string">
      <xs:annotation>
        <xs:documentation>Unique string used to identify the operation. The id MUST be unique among all operations described in the OpenApi schema.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="headerParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of parameters passed as http header. Parameters will be stored in 'headers' sessionkey.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="contentDispositionHeaderSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key that provides the &lt;code&gt;Content-Disposition&lt;/code&gt; header in the response</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="requiredIssuer" type="xs:string">
      <xs:annotation>
        <xs:documentation>Issuer to validate JWT</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jwksURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>Keysource URL to validate JWT</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jwtHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>Header to extract JWT from Default: &lt;code&gt;Authorization&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="requiredClaims" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of required claims</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exactMatchClaims" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated key value pairs to exactly match with JWT payload. e.g. &lt;code&gt;sub=UnitTest, aud=test&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="anyMatchClaims" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated key value pairs to one-of match with JWT payload. e.g. &lt;code&gt;appid=a,appid=b&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="roleClaim" type="xs:string">
      <xs:annotation>
        <xs:documentation>Claim name which specifies the role (maps to &lt;code&gt;IsUserInRolePipe&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principalNameClaim" type="xs:string">
      <xs:annotation>
        <xs:documentation>Claim name which specifies the principal name (maps to &lt;code&gt;GetPrincipalPipe&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ApiListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="ApiListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="PushingListenerAdapterDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="PushingListenerAdapterDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the listener as known to the adapter</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="applicationFaultsAsExceptions" type="frankBoolean" />
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="CmisEventListenerType">
    <xs:attributeGroup ref="CmisEventListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.cmis.CmisEventListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="CmisEventListenerDeclaredAttributeGroup">
    <xs:attribute name="eventListener" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="CmisEventListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="CmisEventListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="PushingListenerAdapterDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="DirectoryListenerType">
    <xs:attributeGroup ref="DirectoryListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.receivers.DirectoryListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="DirectoryListenerDeclaredAttributeGroup">
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional base folder, that serves as root for all other folders</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="DirectoryListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="DirectoryListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemListenerDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="FileSystemListenerDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the listener</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="inputFolder" />
    <xs:attribute ref="inProcessFolder" />
    <xs:attribute ref="processedFolder" />
    <xs:attribute ref="errorFolder" />
    <xs:attribute ref="holdFolder" />
    <xs:attribute ref="logFolder" />
    <xs:attribute ref="createFolders" />
    <xs:attribute ref="delete" />
    <xs:attribute ref="numberOfBackups" />
    <xs:attribute ref="overwrite" />
    <xs:attribute name="messageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>Determines the contents of the message that is sent to the pipeline. Can be 'name', for the filename, 'path', for the full file path, 'contents' for the contents of the file, 'info' for file information. For any other value, the attributes of the file are searched and used Default: path</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="fileTimeSensitive" />
    <xs:attribute ref="minStableTime" />
    <xs:attribute ref="messageIdPropertyKey" />
    <xs:attribute ref="disableMessageBrowsers" />
    <xs:attribute ref="wildcard" />
    <xs:attribute ref="excludeWildcard" />
    <xs:attribute ref="storeMetadataInSessionKey" />
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Charset to be used for extracting the contents</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat">
      <xs:annotation>
        <xs:documentation>OutputFormat of message for messageType=info Default: XML</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="DocumentFormatAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="EsbJmsListenerType">
    <xs:group ref="JmsListenerBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="EsbJmsListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.esb.EsbJmsListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="EsbJmsListenerDeclaredAttributeGroup">
    <xs:attribute name="messageProtocol" use="required">
      <xs:annotation>
        <xs:documentation>protocol of ESB service to be called</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="MessageProtocolAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="copyAEProperties" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>if true, all JMS properties in the request starting with "ae_" are copied to the reply. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forceMessageIdAsCorrelationId" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>if messageProtocol=RR, default value is: true Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useReplyTo" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>if messageProtocol=FF, default value is: false Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xPathLoggingKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of all XPath keys that need to be logged. (overrides &lt;code&gt;msg.log.keys&lt;/code&gt; property)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="EsbJmsListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="EsbJmsListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="PushingJmsListenerDeclaredAttributeGroup" />
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Receive timeout &lt;i&gt;in milliseconds&lt;/i&gt; as specified by the JMS API, see https://docs.oracle.com/javaee/7/api/javax/jms/MessageConsumer.html#receive-long- Default: 1000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="replyDestinationName" />
    <xs:attribute ref="replyMessageType" />
    <xs:attribute ref="replyDeliveryMode" />
    <xs:attribute ref="replyPriority" />
    <xs:attribute ref="replyMessageTimeToLive" />
    <xs:attribute name="soap" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, messages sent are put in a SOAP envelope Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="replyEncodingStyleURI" />
    <xs:attribute ref="replyNamespaceURI" />
    <xs:attribute ref="replySoapAction" />
    <xs:attribute ref="soapHeaderSessionKey" />
    <xs:attribute ref="messageClass" />
    <xs:attribute ref="destinationType" />
    <xs:attribute ref="acknowledgeMode" />
    <xs:attribute ref="subscriberType" />
    <xs:attribute ref="queueConnectionFactoryName" />
    <xs:attribute ref="topicConnectionFactoryName" />
    <xs:attribute name="transacted" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Controls whether messages are send under transaction control.
 If set &lt;code&gt;true&lt;/code&gt;, messages are committed or rolled back under control of an XA-transaction. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="correlationIdToHex" />
    <xs:attribute ref="correlationIdToHexPrefix" />
    <xs:attribute ref="messageTimeToLive" />
    <xs:attribute ref="correlationIdMaxLength" />
    <xs:attribute ref="messageSelector" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain credentials for authentication to JMS server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="lookupDestination" />
    <xs:attributeGroup ref="JndiBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="JmsListenerBaseDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="ParamElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="JmsListenerBaseDeclaredAttributeGroup">
    <xs:attribute name="forceMessageIdAsCorrelationId" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>By default, the JmsListener takes the Correlation-ID (if present) as the ID that has to be used as Correlation-ID of the reply.
 When set to &lt;code&gt;true&lt;/code&gt;, the messageID is used as Correlation-ID of the reply. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Receive timeout &lt;i&gt;in milliseconds&lt;/i&gt; as specified by the JMS API, see https://docs.oracle.com/javaee/7/api/javax/jms/MessageConsumer.html#receive-long- Default: 1000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useReplyTo" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Flag if reply-to queue from the request message should be used or not. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="replyDestinationName" />
    <xs:attribute ref="replyMessageType" />
    <xs:attribute ref="replyDeliveryMode" />
    <xs:attribute ref="replyPriority" />
    <xs:attribute ref="replyMessageTimeToLive" />
    <xs:attribute name="soap" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, messages sent are put in a SOAP envelope Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="replyEncodingStyleURI" />
    <xs:attribute ref="replyNamespaceURI" />
    <xs:attribute ref="replySoapAction" />
    <xs:attribute ref="soapHeaderSessionKey" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JmsListenerBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="JmsListenerBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JMSFacadeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JMSFacadeType">
    <xs:attributeGroup ref="JMSFacadeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jms.JMSFacade" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="JMSFacadeDeclaredAttributeGroup">
    <xs:attribute ref="messageClass" />
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the JMS destination (queue or topic) to use</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="destinationType" />
    <xs:attribute ref="acknowledgeMode" />
    <xs:attribute ref="subscriberType" />
    <xs:attribute ref="queueConnectionFactoryName" />
    <xs:attribute ref="topicConnectionFactoryName" />
    <xs:attribute name="transacted" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Controls whether messages are send under transaction control.
 If set &lt;code&gt;true&lt;/code&gt;, messages are committed or rolled back under control of an XA-transaction. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="correlationIdToHex" />
    <xs:attribute ref="correlationIdToHexPrefix" />
    <xs:attribute ref="messageTimeToLive" />
    <xs:attribute ref="correlationIdMaxLength" />
    <xs:attribute ref="messageSelector" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain credentials for authentication to JMS server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="lookupDestination" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JMSFacadeCumulativeAttributeGroup">
    <xs:attributeGroup ref="JMSFacadeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JndiBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JndiBaseType">
    <xs:attributeGroup ref="JndiBaseDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jndi.JndiBase" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="JndiBaseDeclaredAttributeGroup">
    <xs:attribute ref="authentication" />
    <xs:attribute ref="credentials" />
    <xs:attribute ref="initialContextFactoryName" />
    <xs:attribute ref="providerURL" />
    <xs:attribute ref="securityProtocol" />
    <xs:attribute ref="urlPkgPrefixes" />
    <xs:attribute name="jmsRealm" type="xs:string">
      <xs:annotation>
        <xs:documentation>loads JNDI (and other) properties from a JmsRealm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="principal" />
    <xs:attribute ref="jndiAuthAlias" />
    <xs:attribute ref="jndiContextPrefix" />
    <xs:attribute ref="jndiProperties" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the sender or the listener</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="PushingJmsListenerType">
    <xs:group ref="JmsListenerBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="PushingJmsListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jms.PushingJmsListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="PushingJmsListenerDeclaredAttributeGroup">
    <xs:attribute name="destinationName" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Name of the JMS destination (queue or topic) to use</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cacheMode">
      <xs:simpleType>
        <xs:union memberTypes="CacheModeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="pollGuardInterval" type="frankInt">
      <xs:annotation>
        <xs:documentation>Interval &lt;i&gt;in milliseconds&lt;/i&gt; for the poll guard to check whether a successful poll was done by the receive
 (https://docs.oracle.com/javaee/7/api/javax/jms/messageconsumer.html#receive-long-) since last check. If polling has stopped this will be logged
 and the listener will be stopped and started in an attempt to workaround problems with polling.
 Polling might stop due to bugs in the JMS driver/implementation which should be fixed by the supplier. As the poll time includes reading
 and processing of the message no successful poll might be registered since the last check when message processing takes a long time, hence
 while messages are being processed the check on last successful poll will be skipped. Set to -1 to disable. Default: ten times the specified timeout</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="PushingJmsListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="PushingJmsListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JmsListenerBaseDeclaredAttributeGroup" />
    <xs:attribute ref="messageClass" />
    <xs:attribute ref="destinationType" />
    <xs:attribute ref="acknowledgeMode" />
    <xs:attribute ref="subscriberType" />
    <xs:attribute ref="queueConnectionFactoryName" />
    <xs:attribute ref="topicConnectionFactoryName" />
    <xs:attribute name="transacted" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Controls whether messages are send under transaction control.
 If set &lt;code&gt;true&lt;/code&gt;, messages are committed or rolled back under control of an XA-transaction. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="correlationIdToHex" />
    <xs:attribute ref="correlationIdToHexPrefix" />
    <xs:attribute ref="messageTimeToLive" />
    <xs:attribute ref="correlationIdMaxLength" />
    <xs:attribute ref="messageSelector" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain credentials for authentication to JMS server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="lookupDestination" />
    <xs:attributeGroup ref="JndiBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ExchangeMailListenerType">
    <xs:attributeGroup ref="ExchangeMailListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.receivers.ExchangeMailListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ExchangeMailListenerDeclaredAttributeGroup">
    <xs:attribute name="mailAddress" type="xs:string">
      <xs:annotation>
        <xs:documentation>The mail address of the mailbox connected to (also used for auto discovery)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>Url of the Exchange server. Set to e.g. https://outlook.office365.com/EWS/Exchange.asmx to speed up startup, leave empty to use autodiscovery</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clientId" type="xs:string">
      <xs:annotation>
        <xs:documentation>Client ID that represents a registered application in Azure AD which could be found at Azure AD -&gt; App Registrations -&gt; MyApp -&gt; Overview.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clientSecret" type="xs:string">
      <xs:annotation>
        <xs:documentation>Client secret that belongs to registered application in Azure AD which could be found at Azure AD -&gt; App Registrations -&gt; MyApp -&gt; Certificates and Secrets</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tenantId" type="xs:string">
      <xs:annotation>
        <xs:documentation>Tenant ID that represents the tenant in which the registered application exists within Azure AD which could be found at Azure AD -&gt; App Registrations -&gt; MyApp -&gt; Overview.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain client ID and secret or username and password for authentication to Exchange mail server.
 If the attribute tenantId is empty, the deprecated Basic Authentication method is used.
 If the attribute tenantId is not empty, the username and password are treated as the client ID and secret.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="baseFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder (subfolder of root or of inbox) to look for mails. If empty, the inbox folder is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filter" type="xs:string">
      <xs:annotation>
        <xs:documentation>If empty, all mails are retrieved. If set to &lt;code&gt;NDR&lt;/code&gt; only Non-Delivery Report mails ('bounces') are retrieved</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyAddressFields" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of fields to try as response address Default: replyTo,from,sender,Return-Path</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="frankInt">
      <xs:annotation>
        <xs:documentation>proxy port Default: 8080</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy authAlias</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyDomain" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy domain</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mailboxObjectSeparator" type="xs:string">
      <xs:annotation>
        <xs:documentation>Separator character used when working with multiple mailboxes, specified before the separator in the object name &lt;code&gt;test@organisation.com|My sub folder&lt;/code&gt; or &lt;code&gt;test@organisation.com|AAMkADljZDMxYzIzLTFlMjYtNGY4Mi1hM2Y1LTc2MjE5ZjIyZmMyNABGAAAAAAAu/9EmV5M6QokBRZwID1Q6BwDXQXY+F44hRbDfTB9v8jRfAAAEUqUVAADXQXY+F44hRbDfTB9v8jRfAAKA4F+pAAA=&lt;/code&gt;.
 Please consider when moving emails across mailboxes that there will be a null value returned instead of the newly created identifier. Default: |</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystore" type="xs:string">
      <xs:annotation>
        <xs:documentation>Resource url to keystore or certificate. If none specified, the JVMs default keystore will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType">
      <xs:annotation>
        <xs:documentation>Type of keystore Default: pkcs12</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="keystoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used to obtain keystore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to access keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias to obtain specific certificate or key in keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>Resource url to truststore. If none specified, the JVMs default truststore will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType">
      <xs:annotation>
        <xs:documentation>Type of truststore Default: jks</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used to obtain truststore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to access truststore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Trust manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the hostname in the certificate will be checked against the actual hostname of the peer</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowSelfSignedCertificates" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, self signed certificates are accepted Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCertificateExpiredException" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, CertificateExpiredExceptions are ignored Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ExchangeMailListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="ExchangeMailListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="MailListenerCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="MailListenerDeclaredAttributeGroup">
    <xs:attribute name="messageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>Determines the contents of the message that is sent to the Pipeline. can be one of:
 &lt;ul&gt;
 &lt;li&gt;&lt;code&gt;email&lt;/code&gt;, for an XML containing most relevant information, except the body and the attachments&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;contents&lt;/code&gt;, for the body of the message&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;mime&lt;/code&gt;, for the MIME contents of the message&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;name&lt;/code&gt; or &lt;code&gt;path&lt;/code&gt;, for an internal handle of mail message, that can be used by a related MailFileSystemSender&lt;/li&gt;
 &lt;li&gt;the key of any header present in the message context&lt;/li&gt;
 &lt;/ul&gt; Default: email</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="MailListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="MailListenerDeclaredAttributeGroup" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the listener</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="inputFolder" />
    <xs:attribute ref="inProcessFolder" />
    <xs:attribute ref="processedFolder" />
    <xs:attribute ref="errorFolder" />
    <xs:attribute ref="holdFolder" />
    <xs:attribute ref="logFolder" />
    <xs:attribute ref="createFolders" />
    <xs:attribute ref="delete" />
    <xs:attribute ref="numberOfBackups" />
    <xs:attribute ref="overwrite" />
    <xs:attribute ref="fileTimeSensitive" />
    <xs:attribute ref="minStableTime" />
    <xs:attribute ref="messageIdPropertyKey" />
    <xs:attribute ref="disableMessageBrowsers" />
    <xs:attribute ref="wildcard" />
    <xs:attribute ref="excludeWildcard" />
    <xs:attribute ref="storeMetadataInSessionKey" />
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Charset to be used for extracting the contents</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat">
      <xs:annotation>
        <xs:documentation>OutputFormat of message for messageType=info Default: XML</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="DocumentFormatAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="FrankListenerType">
    <xs:attributeGroup ref="FrankListenerDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.receivers.FrankListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="FrankListenerDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the listener by which it can be found by the org.frankframework.senders.FrankSender. If this
 is not configured, the name will default to the name of the org.frankframework.core.Adapter.
 The name of the {@code FrankListener} must be unique across the configuration.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="FtpFileSystemListenerType">
    <xs:attributeGroup ref="FtpFileSystemListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.receivers.FtpFileSystemListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="FtpFileSystemListenerDeclaredAttributeGroup">
    <xs:attribute name="remoteDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>pathname of the file or directory to list. Default: Home folder of the ftp user</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="host" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name or ip address of remote host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="frankInt">
      <xs:annotation>
        <xs:documentation>Port number of remote host Default: 21</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the alias to obtain credentials to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the user to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy hostname</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="frankInt">
      <xs:annotation>
        <xs:documentation>Proxy port Default: 1080</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ftpType">
      <xs:annotation>
        <xs:documentation>FTP protocol to use Default: FTP</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="FtpTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="fileType">
      <xs:simpleType>
        <xs:union memberTypes="FileTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="passive" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, passive ftp is used: before data is sent, a pasv command is issued, and the connection is set up by the server Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyTransportType">
      <xs:annotation>
        <xs:documentation>(ftps) Transport type in case of sftp Default: SOCKS5</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="TransportTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="keystore" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Resource url to keystore or certificate to be used for authentication. If none specified, the JVMs default keystore will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType">
      <xs:annotation>
        <xs:documentation>(ftps) Type of keystore Default: pkcs12</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="keystoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Authentication alias used to obtain keystore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Default password to access keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Alias to obtain specific certificate or key in keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Authentication alias to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Default password to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Key manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Resource url to truststore to be used for authenticating peer. If none specified, the JVMs default truststore will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType">
      <xs:annotation>
        <xs:documentation>(ftps) Type of truststore Default: jks</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Authentication alias used to obtain truststore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Default password to access truststore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Trust manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(ftps) If &lt;code&gt;true&lt;/code&gt;, the hostname in the certificate will be checked against the actual hostname of the peer</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowSelfSignedCertificates" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(ftps) If &lt;code&gt;true&lt;/code&gt;, self signed certificates are accepted Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCertificateExpiredException" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(ftps) If &lt;code&gt;true&lt;/code&gt;, CertificateExpiredExceptions are ignored Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prot">
      <xs:annotation>
        <xs:documentation>Sets the &lt;code&gt;Data Channel Protection Level&lt;/code&gt;. Default: C</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="ProtAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FtpFileSystemListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="FtpFileSystemListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemListenerDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FxfListenerType">
    <xs:group ref="JmsListenerBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="FxfListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.fxf.FxfListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="FxfListenerDeclaredAttributeGroup">
    <xs:attribute name="fxfFileSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the session key to store the name of the received file in Default: fxfFile</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="moveProcessedFile" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the received file is moved after being processed Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="processedSiblingDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;moveProcessedFile=true&lt;/code&gt;) &lt;b&gt;sibling&lt;/b&gt; directory (related to the parent directory of the file to process) where files are stored after being processed Default: processed</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createProcessedDirectory" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;moveProcessedFile=true&lt;/code&gt;) when set to &lt;code&gt;true&lt;/code&gt;, the directory to move processed files in is created if it does not exist Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FxfListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="FxfListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="EsbJmsListenerCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ImapListenerType">
    <xs:attributeGroup ref="ImapListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.receivers.ImapListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ImapListenerDeclaredAttributeGroup">
    <xs:attribute name="host" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>The hostname of the IMAP server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="frankInt">
      <xs:annotation>
        <xs:documentation>The port of the IMAP server Default: 993</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain accessToken or username and password for authentication to Exchange mail server.
 If the alias refers to a combination of a username and a password, the deprecated Basic Authentication method is used.
 If the alias refers to a password without a username, the password is treated as the accessToken.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Username for authentication to mail server.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password for authentication to mail server.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="baseFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder (subfolder of root or of inbox) to look for mails. If empty, the inbox folder is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyAddressFields" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of fields to try as response address Default: replyTo,from,sender,Return-Path</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ImapListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="ImapListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="MailListenerCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JavaListenerType">
    <xs:attributeGroup ref="JavaListenerDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.receivers.JavaListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="JavaListenerDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Internal name of the listener, as known to the adapter. An IbisLocalSender refers to this name in its &lt;code&gt;javaListener&lt;/code&gt;-attribute.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>External Name of the listener. An IbisJavaSender refers to this name in its &lt;code&gt;serviceName&lt;/code&gt;-attribute.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="returnedSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of keys of session variables that should be returned to caller, for correct results as well as for erroneous results.
 If not set (not even to an empty value), all session keys can be returned. Default: all session keys can be returned</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Should the JavaListener throw a ListenerException when it occurs or return an error message Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="httpWsdl" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the WSDL of the service provided by this listener will available for download Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="JdbcListenerType">
    <xs:attributeGroup ref="JdbcListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jdbc.JdbcListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="JdbcListenerDeclaredAttributeGroup">
    <xs:attribute ref="peekUntransacted" />
    <xs:attribute ref="peekQuery" />
    <xs:attribute name="keyField" type="xs:string">
      <xs:annotation>
        <xs:documentation>Primary key field of the table, used to identify and differentiate messages.
 &lt;b&gt;NB: there should be an index on this field!&lt;/b&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageField" type="xs:string">
      <xs:annotation>
        <xs:documentation>Field containing the message data Default: &lt;i&gt;same as keyField&lt;/i&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageFieldType">
      <xs:annotation>
        <xs:documentation>Type of the field containing the message data Default: &lt;i&gt;String&lt;/i&gt;</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="MessageFieldTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="messageIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>Field containing the &lt;code&gt;messageId&lt;/code&gt;.
 &lt;b&gt;NB: If this column is not set the default (primary key) keyField will be used as messageId!&lt;/b&gt; Default: &lt;i&gt;same as keyField&lt;/i&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>Field containing the &lt;code&gt;correlationId&lt;/code&gt;.
 &lt;b&gt;NB: If this column is not set, the &lt;code&gt;messageId&lt;/code&gt; and &lt;code&gt;correlationId&lt;/code&gt; will be the same!&lt;/b&gt; Default: &lt;i&gt;same as messageIdField&lt;/i&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sqlDialect" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the SQL dialect in which the queries are written and should be translated from to the actual SQL dialect</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Controls whether BLOB is considered stored compressed in the database Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Controls automatically whether blobdata is stored compressed and/or serialized in the database. N.B. When set true, then the BLOB will be converted into a string Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="trace" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcFacadeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JdbcFacadeType">
    <xs:attributeGroup ref="JdbcFacadeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jdbc.JdbcFacade" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="JdbcFacadeDeclaredAttributeGroup">
    <xs:attribute ref="datasourceName" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used to authenticate when connecting to database</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>User name for authentication when connecting to database, when none found from &lt;code&gt;authAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password for authentication when connecting to database, when none found from &lt;code&gt;authAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>controls the use of transactions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="connectionsArePooled" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcFacadeCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcFacadeDeclaredAttributeGroup" />
    <xs:attribute ref="authentication" />
    <xs:attribute ref="credentials" />
    <xs:attribute ref="initialContextFactoryName" />
    <xs:attribute ref="providerURL" />
    <xs:attribute ref="securityProtocol" />
    <xs:attribute ref="urlPkgPrefixes" />
    <xs:attribute ref="principal" />
    <xs:attribute ref="jndiAuthAlias" />
    <xs:attribute ref="jndiContextPrefix" />
    <xs:attribute ref="jndiProperties" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the sender or the listener</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="JdbcTableListenerType">
    <xs:attributeGroup ref="JdbcTableListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jdbc.JdbcTableListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="JdbcTableListenerDeclaredAttributeGroup">
    <xs:attribute name="tableName" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Name of the table to be used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="tableAlias" />
    <xs:attribute name="statusField" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Field containing the status of the message. 
 &lt;b&gt;NB: For optimal performance, an index should exist that starts with this field, followed by all fields that are used with a fixed value in the select condition, and end with the &lt;code&gt;orderField&lt;/code&gt;.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="orderField" />
    <xs:attribute name="timestampField" type="xs:string">
      <xs:annotation>
        <xs:documentation>(optional) Field used to store the date and time of the last change of the &lt;code&gt;statusField&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commentField" type="xs:string">
      <xs:annotation>
        <xs:documentation>(optional) Field used to store the reason of the last change of the &lt;code&gt;statusField&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="maxCommentLength" />
    <xs:attribute name="statusValueAvailable" type="xs:string">
      <xs:annotation>
        <xs:documentation>(optional) Value of &lt;code&gt;statusField&lt;/code&gt; indicating row is available to be processed. If not specified, any row not having any of the other status values is considered available.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueError" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Value of &lt;code&gt;statusField&lt;/code&gt; indicating the processing of the row resulted in an error</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueProcessed" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Value of status field indicating row is processed OK</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueInProcess" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of &lt;code&gt;statusField&lt;/code&gt; indicating is being processed. Can be left emtpy if database has &lt;code&gt;SKIP LOCKED&lt;/code&gt; functionality and the &lt;code&gt;transactionAttribute&lt;/code&gt; of the &lt;code&gt;Receiver&lt;/code&gt; can be (and is) set to &lt;code&gt;Required&lt;/code&gt; or &lt;code&gt;RequiresNew&lt;/code&gt;.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueHold" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of &lt;code&gt;statusField&lt;/code&gt; indicating message is on Hold, temporarily</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="selectCondition" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcTableListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcTableListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcListenerCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JmsListenerType">
    <xs:group ref="JmsListenerBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="PushingJmsListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jms.JmsListener" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="MessageStoreListenerType">
    <xs:attributeGroup ref="MessageStoreListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jdbc.MessageStoreListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="MessageStoreListenerDeclaredAttributeGroup">
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>Identifier for this service</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of sessionKey's to be read together with the message. Please note: corresponding MessageStoreSender must have the same value for this attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tableName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the table to be used Default: IBISSTORE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyField" type="xs:string">
      <xs:annotation>
        <xs:documentation>Primary key field of the table, used to identify and differentiate messages.
 &lt;b&gt;NB: there should be an index on this field!&lt;/b&gt; Default: MESSAGEKEY</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageField" type="xs:string">
      <xs:annotation>
        <xs:documentation>Field containing the message data Default: MESSAGE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>Field containing the &lt;code&gt;messageId&lt;/code&gt;.
 &lt;b&gt;NB: If this column is not set the default (primary key) keyField will be used as messageId!&lt;/b&gt; Default: MESSAGEID</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>Field containing the &lt;code&gt;correlationId&lt;/code&gt;.
 &lt;b&gt;NB: If this column is not set, the &lt;code&gt;messageId&lt;/code&gt; and &lt;code&gt;correlationId&lt;/code&gt; will be the same!&lt;/b&gt; Default: CORRELATIONID</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageFieldType">
      <xs:annotation>
        <xs:documentation>Type of the field containing the message data Default: BLOB</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="MessageFieldTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Controls automatically whether blobdata is stored compressed and/or serialized in the database. N.B. When set true, then the BLOB will be converted into a string Default: &lt;code&gt;true&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusField" type="xs:string">
      <xs:annotation>
        <xs:documentation>Field containing the status of the message. 
 &lt;b&gt;NB: For optimal performance, an index should exist that starts with this field, followed by all fields that are used with a fixed value in the select condition, and end with the &lt;code&gt;orderField&lt;/code&gt;. Default: TYPE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timestampField" type="xs:string">
      <xs:annotation>
        <xs:documentation>(optional) Field used to store the date and time of the last change of the &lt;code&gt;statusField&lt;/code&gt; Default: MESSAGEDATE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commentField" type="xs:string">
      <xs:annotation>
        <xs:documentation>(optional) Field used to store the reason of the last change of the &lt;code&gt;statusField&lt;/code&gt; Default: COMMENTS</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueAvailable" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of statusField indicating row is available to be processed. If set empty, any row not having any of the other status values is considered available. Default: &lt;code&gt;M&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueInProcess" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of status field indicating is being processed. Set to &lt;code&gt;I&lt;/code&gt; if database has no SKIP LOCKED functionality, the Receiver cannot be set to &lt;code&gt;Required&lt;/code&gt; or &lt;code&gt;RequiresNew&lt;/code&gt;, or to support programmatic retry.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueError" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of &lt;code&gt;statusField&lt;/code&gt; indicating the processing of the row resulted in an error Default: &lt;code&gt;E&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueProcessed" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of status field indicating row is processed OK Default: &lt;code&gt;A&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueHold" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of status field indicating message is on Hold, temporarily. If required, suggested value is &lt;code&gt;H&lt;/code&gt;.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="moveToMessageLog" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Move to messageLog after processing, as the message is already stored in the ibisstore only some fields need to be updated. When set &lt;code&gt;false&lt;/code&gt;, messages are deleted after being processed Default: &lt;code&gt;true&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="MessageStoreListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="MessageStoreListenerDeclaredAttributeGroup" />
    <xs:attribute ref="tableAlias" />
    <xs:attribute ref="orderField" />
    <xs:attribute ref="maxCommentLength" />
    <xs:attribute ref="selectCondition" />
    <xs:attribute ref="peekUntransacted" />
    <xs:attribute ref="peekQuery" />
    <xs:attribute name="sqlDialect" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the SQL dialect in which the queries are written and should be translated from to the actual SQL dialect</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Controls whether BLOB is considered stored compressed in the database Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="trace" />
    <xs:attributeGroup ref="JdbcFacadeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="MqttListenerType">
    <xs:attributeGroup ref="MqttFacadeDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.mqtt.MqttListener" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="MqttFacadeType">
    <xs:attributeGroup ref="MqttFacadeDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.mqtt.MqttFacade" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="MqttFacadeDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of the object.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="frankInt" />
    <xs:attribute name="keepAliveInterval" type="frankInt" />
    <xs:attribute name="clientId" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;a href="https://www.eclipse.org/paho/files/javadoc/org/eclipse/paho/client/mqttv3/MqttClient.html#MqttClient-java.lang.String-java.lang.String-org.eclipse.paho.client.mqttv3.MqttClientPersistence-" target="_blank"&gt;MqttClient(java.lang.String serverURI, java.lang.String clientId, MqttClientPersistence persistence)&lt;/a&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="brokerUrl" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;a href="https://www.eclipse.org/paho/files/javadoc/org/eclipse/paho/client/mqttv3/MqttClient.html#MqttClient-java.lang.String-java.lang.String-org.eclipse.paho.client.mqttv3.MqttClientPersistence-" target="_blank"&gt;MqttClient(java.lang.String serverURI, java.lang.String clientId, MqttClientPersistence persistence)&lt;/a&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="topic" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;a href="https://www.eclipse.org/paho/files/javadoc/org/eclipse/paho/client/mqttv3/MqttClient.html#subscribe-java.lang.String-" target="_blank"&gt;MqttClient.subscribe(java.lang.String topicFilter)&lt;/a&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="qos" type="frankInt">
      <xs:annotation>
        <xs:documentation>see &lt;a href="https://www.eclipse.org/paho/files/javadoc/org/eclipse/paho/client/mqttv3/MqttClient.html#MqttClient-java.lang.String-java.lang.String-org.eclipse.paho.client.mqttv3.MqttClientPersistence-" target="_blank"&gt;MqttClient(java.lang.String serverURI, java.lang.String clientId, MqttClientPersistence persistence)&lt;/a&gt; Default: 2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cleanSession" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>see &lt;a href="https://www.eclipse.org/paho/files/javadoc/org/eclipse/paho/client/mqttv3/MqttConnectOptions.html#setCleanSession-boolean-" target="_blank"&gt;MqttConnectOptions.setCleanSession(boolean cleanSession)&lt;/a&gt; Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistenceDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;a href="https://www.eclipse.org/paho/files/javadoc/org/eclipse/paho/client/mqttv3/persist/MqttDefaultFilePersistence.html" target="_blank"&gt;MqttDefaultFilePersistence&lt;/a&gt; and &lt;a href="https://www.eclipse.org/paho/files/javadoc/org/eclipse/paho/client/mqttv3/MqttClient.html" target="_blank"&gt;MqttClient&lt;/a&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="automaticReconnect" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>see &lt;a href="https://www.eclipse.org/paho/files/javadoc/org/eclipse/paho/client/mqttv3/MqttConnectOptions.html#setAutomaticReconnect-boolean-" target="_blank"&gt;MqttConnectOptions.setAutomaticReconnect(boolean automaticReconnect)&lt;/a&gt; (apart from this recover job will also try to recover) Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>character encoding of received messages Default: UTF-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
    <xs:attribute name="password" type="xs:string" />
    <xs:attribute name="authAlias" type="xs:string" />
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="PullingJmsListenerType">
    <xs:group ref="JmsListenerBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="JmsListenerBaseCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jms.PullingJmsListener" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="RestListenerType">
    <xs:attributeGroup ref="RestListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.http.RestListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="RestListenerDeclaredAttributeGroup">
    <xs:attribute name="uriPattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>Uri pattern to match, the {uri} part in https://mydomain.com/ibis4something/rest/{uri}, where mydomain.com and ibis4something refer to 'your ibis'.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="method" type="xs:string">
      <xs:annotation>
        <xs:documentation>Method (e.g. GET or POST) to match</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="etagSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of session variable to store etag</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="contentTypeSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of Session variable that determines requested content type, overrides produces</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>Can be either &lt;code&gt;/rest&lt;/code&gt; or &lt;code&gt;/rest-public&lt;/code&gt; and must correspond with the available RestListenerServlet path(s).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authRoles" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of authorization roles which are granted for this rest service Default: IbisAdmin,IbisDataAdmin,IbisTester,IbisObserver,IbisWebService</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="frankBoolean" />
    <xs:attribute name="writeSecLogMessage" type="frankBoolean" />
    <xs:attribute name="retrieveMultipart" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Indicates whether the parts of a multipart entity should be retrieved and put in session keys. This can only be done once! Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="consumes">
      <xs:annotation>
        <xs:documentation>Mediatype (e.g. XML, JSON, TEXT) the RestServiceDispatcher receives as input Default: XML</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="MediaTypesAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="produces">
      <xs:annotation>
        <xs:documentation>Mediatype (e.g. XML, JSON, TEXT) the RestServiceDispatcher sends as output, if set to json the ibis will automatically try to convert the xml message Default: XML</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="MediaTypesAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="validateEtag" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to true the ibis will automatically validate and process etags Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="generateEtag" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to true the ibis will automatically create an etag Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="automaticallyTransformToAndFromJson" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Uses an JsonPipe to convert the json-input to xml, and xml-output to json.
 Use with caution, a properly configured Input/Output-wrapper can do much more and is more robust! Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="RestListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="RestListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="PushingListenerAdapterDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Samba2ListenerType">
    <xs:attributeGroup ref="Samba2ListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.receivers.Samba2Listener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="Samba2ListenerDeclaredAttributeGroup">
    <xs:attribute name="hostname" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Hostname of the SMB share.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="frankInt">
      <xs:annotation>
        <xs:documentation>Port to connect to. Default: 445</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authType">
      <xs:annotation>
        <xs:documentation>Type of the authentication either 'NTLM' or 'SPNEGO'.
 When setting SPNEGO, the host must use the FQDN, and must be registered on the KDC with a valid SPN. Default: SPNEGO</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="Samba2AuthTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for the smb share</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="domainName" type="xs:string">
      <xs:annotation>
        <xs:documentation>NTLM only: logon/authentication domain, in case the user account is bound to a domain such as Active Directory.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="share" type="xs:string">
      <xs:annotation>
        <xs:documentation>May not contain '\\' characters. The destination share, aka smb://xxx/yyy share.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="kdc" type="xs:string">
      <xs:annotation>
        <xs:documentation>SPNEGO only:
 Key Distribution Center, typically hosted on a domain controller.
 Stored in &lt;code&gt;java.security.krb5.kdc&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="realm" type="xs:string">
      <xs:annotation>
        <xs:documentation>SPNEGO only:
 Kerberos Realm, case sensitive. Typically upper case and the same as the domain name.
 An Active Directory domain acts as a Kerberos Realm.
 Stored in &lt;code&gt;java.security.krb5.realm&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Samba2ListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="Samba2ListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemListenerDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SambaListenerType">
    <xs:attributeGroup ref="Samba2ListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.receivers.SambaListener" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="SapListenerType">
    <xs:attributeGroup ref="SapListenerImplCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.sap.SapListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="SapListenerImplDeclaredAttributeGroup">
    <xs:attribute name="sapSystemName" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Name of the SapSystem used by this object</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="progid" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Name of the RFC-destination to be registered in the SAP system</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionCount" type="xs:string">
      <xs:annotation>
        <xs:documentation>The number of connections that should be registered at the gateway Default: 2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SapListenerImplCumulativeAttributeGroup">
    <xs:attributeGroup ref="SapListenerImplDeclaredAttributeGroup" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the Ibis-object</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="correlationIdFieldIndex" />
    <xs:attribute ref="correlationIdFieldName" />
    <xs:attribute ref="requestFieldIndex" />
    <xs:attribute ref="requestFieldName" />
    <xs:attribute ref="replyFieldIndex" />
    <xs:attribute ref="replyFieldName" />
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:attributeGroup name="SapFunctionFacadeDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the Ibis-object</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sapSystemName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the SapSystem used by this object</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="correlationIdFieldIndex" />
    <xs:attribute ref="correlationIdFieldName" />
    <xs:attribute ref="requestFieldIndex" />
    <xs:attribute ref="requestFieldName" />
    <xs:attribute ref="replyFieldIndex" />
    <xs:attribute ref="replyFieldName" />
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="SftpFileSystemListenerType">
    <xs:attributeGroup ref="SftpFileSystemListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.receivers.SftpFileSystemListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="SftpFileSystemListenerDeclaredAttributeGroup">
    <xs:attribute name="remoteDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>Path of the file or directory to start working. Default: Home folder of the sftp user</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="host" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name or ip address of remote host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="frankInt">
      <xs:annotation>
        <xs:documentation>Port number of remote host Default: 21</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the alias to obtain credentials to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the user to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy hostname</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="frankInt">
      <xs:annotation>
        <xs:documentation>Proxy port Default: 1080</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias to obtain credentials to authenticate on proxy</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default user name in case proxy requires authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password in case proxy requires authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyTransportType">
      <xs:annotation>
        <xs:documentation>Transport type in case of sftp Default: SOCKS5</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="TransportTypeAttributeValuesType_2 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="prefCSEncryption" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional preferred encryption from client to server for sftp protocol</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefSCEncryption" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional preferred encryption from server to client for sftp protocol</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyFilePath" type="xs:string">
      <xs:annotation>
        <xs:documentation>Path to private key file for sftp authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the alias to obtain credentials for passphrase of private key file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Passphrase of private key file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="knownHostsPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>Path to file with knownhosts</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictHostKeyChecking" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Verify the hosts againt the knownhosts file. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SftpFileSystemListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="SftpFileSystemListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemListenerDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SimpleJdbcListenerType">
    <xs:attributeGroup ref="SimpleJdbcListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jdbc.SimpleJdbcListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="SimpleJdbcListenerDeclaredAttributeGroup">
    <xs:attribute name="selectQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>count query that returns the number of available records. when there are available records the pipeline is activated</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trace" type="frankBoolean" />
  </xs:attributeGroup>
  <xs:attributeGroup name="SimpleJdbcListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="SimpleJdbcListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcFacadeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="TibcoLogJmsListenerType">
    <xs:group ref="JmsListenerBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="PushingJmsListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.tibco.TibcoLogJmsListener" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="WebServiceListenerType">
    <xs:attributeGroup ref="WebServiceListenerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.http.WebServiceListener" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="WebServiceListenerDeclaredAttributeGroup">
    <xs:attribute name="soap" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt; the SOAP envelope is removed from received messages and a SOAP envelope is added to returned messages (SOAP envelope will not be visible to the pipeline) Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespaceURI" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace of the service that is provided by the adapter of this listener.
 If specified, requests posted to https://mydomain.com/ibis4something/servlet/rpcrouter that have this namespace in their body  will be handled by this listener,
 where mydomain.com and ibis4something refer to 'your ibis'.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="applicationFaultsAsSoapFaults" type="frankBoolean" />
    <xs:attribute name="address" type="xs:string">
      <xs:annotation>
        <xs:documentation>The address to listen to, e.g the part &amp;lt;address&amp;gt; in https://mydomain.com/ibis4something/services/&amp;lt;address&amp;gt;,
 where mydomain.com and ibis4something refer to 'your ibis'.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mtomEnabled" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set, MTOM is enabled on the SOAP binding</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="attachmentSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of session keys to hold contents of attachments of the request</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartXmlSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of session variable that holds the description (name, sessionKey, mimeType) of the parts present in the request. Only used if attachmentSessionKeys are specified Default: multipartXml</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="WebServiceListenerCumulativeAttributeGroup">
    <xs:attributeGroup ref="WebServiceListenerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="PushingListenerAdapterDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="SenderElementGroup">
    <xs:choice>
      <xs:element name="Sender">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:group ref="CacheElementGroup" />
              <xs:group ref="ParamElementGroup" />
              <xs:group ref="SenderElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="SenderElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="CacheElementGroup">
    <xs:choice>
      <xs:element name="Cache">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="cache" use="prohibited" />
          <xs:attribute name="className" type="xs:string" default="org.frankframework.cache.EhCache" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="CacheElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="CacheElementGroupBase">
    <xs:choice>
      <xs:element name="EhCache">
        <xs:annotation>
          <xs:documentation>General Cache provider.

 N.B. the default values shown can be overridden using properties in appConstants. The property names are found by prefixing the attribute name with &lt;code&gt;cache.default.&lt;/code&gt;.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EhCacheType">
              <xs:attribute name="elementRole" type="xs:string" fixed="cache" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="EhCacheType">
    <xs:attributeGroup ref="EhCacheCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.cache.EhCache" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="EhCacheDeclaredAttributeGroup">
    <xs:attribute name="maxElementsInMemory" type="frankInt">
      <xs:annotation>
        <xs:documentation>The maximum number of elements in memory, before they are evicted Default: 100</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="memoryStoreEvictionPolicy" type="xs:string">
      <xs:annotation>
        <xs:documentation>Either &lt;code&gt;LRU&lt;/code&gt;=Least Recent Use,&lt;code&gt;LFU&lt;/code&gt;=Least Frequent Use or &lt;code&gt;FIFO&lt;/code&gt;=First In - First Out Default: LRU</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="eternal" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the elements in the cache are eternal, i.e. never expire Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeToLiveSeconds" type="frankInt">
      <xs:annotation>
        <xs:documentation>The amount of time &lt;i&gt;in seconds&lt;/i&gt; to live for an element from its creation date Default: 36000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeToIdleSeconds" type="frankInt">
      <xs:annotation>
        <xs:documentation>The amount of time &lt;i&gt;in seconds&lt;/i&gt; to live for an element from its last accessed or modified date Default: 36000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="overflowToDisk" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the elements that are evicted from memory are spooled to disk Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxElementsOnDisk" type="frankInt">
      <xs:annotation>
        <xs:documentation>The maximum number of elements on disk, before they are removed Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="diskPersistent" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the cache is stored on disk and survives configuration reloads &amp; JVM restarts. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="diskExpiryThreadIntervalSeconds" type="frankInt">
      <xs:annotation>
        <xs:documentation>How often to run the disk store expiry thread Default: 600</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="EhCacheCumulativeAttributeGroup">
    <xs:attributeGroup ref="EhCacheDeclaredAttributeGroup" />
    <xs:attributeGroup ref="CacheAdapterBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="CacheAdapterBaseDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the cache, will be lowercased Default: &lt;code&gt;&amp;lt;ownerName&amp;gt;&lt;/code&gt;_cache</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract cache key from request message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyXPathOutputType">
      <xs:annotation>
        <xs:documentation>output type of xpath expression to extract cache key from request message Default: text</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="OutputTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="keyNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for keyxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt; definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract cache key from request message. Use in combination with cacheEmptyKeys to inhibit caching for certain groups of request messages</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyInputSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to use as input for transformation of request message to key by keyxpath or keystylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cacheEmptyKeys" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>controls whether empty keys are used for caching. when set true, cache entries with empty keys can exist. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract value to be cached key from response message. Use in combination with cacheEmptyValues to inhibit caching for certain groups of response messages</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueXPathOutputType">
      <xs:simpleType>
        <xs:union memberTypes="OutputTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="valueNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for valuexpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt; definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract value to be cached from response message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueInputSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to use as input for transformation of response message to cached value by valuexpath or valuestylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cacheEmptyValues" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>controls whether empty values will be cached. when set true, empty cache entries can exist for any key. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:group name="SenderElementGroupBase">
    <xs:choice>
      <xs:element name="Afm2EdiFactSender">
        <xs:annotation>
          <xs:documentation>Domparser om AFM-XML berichten om te zetten in edifactberichten (voor de backoffice).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Afm2EdiFactSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="AmazonS3Sender">
        <xs:annotation>
          <xs:documentation>Sender to work with the Amazon S3 Filesystem.
 &lt;p&gt;
     In addition to regular parameters for filesystem senders, it is possible
     to set custom user-metadata on S3 files by prefixing parameter names with
     FileAttribute..
     This prefix will be not be part of the actual metadata property name.
 &lt;/p&gt;
 &lt;p&gt;
     The string value of these parameters will be used as value of the custom metadata attribute.
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="AmazonS3SenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CmisSender">
        <xs:annotation>
          <xs:documentation>Sender to obtain information from and write to a CMIS application.

 &lt;p&gt;
 When &lt;code&gt;action=get&lt;/code&gt; the input (xml string) indicates the id of the document to get. This input is mandatory.
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;Example:&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;cmis&gt;
     &lt;id&gt;documentId&lt;/id&gt;
 &lt;/cmis&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;
 &lt;p&gt;
 When &lt;code&gt;action=delete&lt;/code&gt; the input (xml string) indicates the id of the document to get. This input is mandatory.
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;Example:&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;cmis&gt;
     &lt;id&gt;documentId&lt;/id&gt;
 &lt;/cmis&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;
 &lt;p&gt;
 When &lt;code&gt;action=create&lt;/code&gt; the input (xml string) indicates document properties to set. This input is optional.
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;Example:&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;cmis&gt;
     &lt;name&gt;Offerte&lt;/name&gt;
     &lt;objectTypeId&gt;NNB_Geldlening&lt;/objectTypeId&gt;
     &lt;mediaType&gt;application/pdf&lt;/mediaType&gt;
     &lt;properties&gt;
         &lt;property name="ArrivedAt" type="datetime" formatString="yyyy-MM-dd'T'HH:mm:ss.SSSz"&gt;2014-11-27T16:43:01.268+0100&lt;/property&gt;
         &lt;property name="ArrivedBy"&gt;HDN&lt;/property&gt;
         &lt;property name="DocumentType"&gt;Geldlening&lt;/property&gt;
     &lt;/properties&gt;
 &lt;/cmis&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;

 &lt;p&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;mandatory property "cmis:name". If not set the sender attribute fileNameSessionKey is used&lt;/td&gt;&lt;td&gt;"[unknown]"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;objectTypeId&lt;/td&gt;&lt;td&gt;mandatory property "cmis:objectTypeId"&lt;/td&gt;&lt;td&gt;"cmis:document"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;mediaType&lt;/td&gt;&lt;td&gt;the MIME type of the document to store&lt;/td&gt;&lt;td&gt;"application/octet-stream"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;property&lt;/td&gt;&lt;td&gt;custom document property to set. Possible attributes:
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;type&lt;/td&gt;&lt;td&gt;
 &lt;ul&gt;
 &lt;li&gt;&lt;code&gt;string&lt;/code&gt;: renders the value&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;datetime&lt;/code&gt;: converts the value to a Date, by default using formatString &lt;code&gt;yyyy-MM-dd HH:mm:ss&lt;/code&gt;&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/td&gt;&lt;td&gt;string&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;formatString&lt;/td&gt;&lt;td&gt;used in combination with &lt;code&gt;datetime&lt;/code&gt;&lt;/td&gt;&lt;td&gt;yyyy-MM-dd HH:mm:ss&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;
 &lt;p&gt;
 When &lt;code&gt;action=find&lt;/code&gt; the input (xml string) indicates the query to perform.
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;Example:&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;query&gt;
    &lt;statement&gt;select * from cmis:document&lt;/statement&gt;
    &lt;maxItems&gt;10&lt;/maxItems&gt;
    &lt;skipCount&gt;0&lt;/skipCount&gt;
    &lt;searchAllVersions&gt;true&lt;/searchAllVersions&gt;
    &lt;includeAllowableActions&gt;true&lt;/includeAllowableActions&gt;
 &lt;/query
 }&lt;/pre&gt;
 &lt;/p&gt;
 &lt;p&gt;
 When &lt;code&gt;action=update&lt;/code&gt; the input (xml string) indicates document properties to update.
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;Example:&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;cmis&gt;
    &lt;id&gt;123456789&lt;/id&gt;
    &lt;properties&gt;
       &lt;property name="ArrivedAt" type="datetime" formatString="yyyy-MM-dd'T'HH:mm:ss.SSSz"&gt;2014-11-27T16:43:01.268+0100&lt;/property&gt;
       &lt;property name="ArrivedBy"&gt;HDN&lt;/property&gt;
       &lt;property name="DocumentType"&gt;Geldlening&lt;/property&gt;
    &lt;/properties&gt;
 &lt;/cmis&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;

 &lt;p&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;id&lt;/td&gt;&lt;td&gt;mandatory property "cmis:objectId" which indicates the document to update&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;property&lt;/td&gt;&lt;td&gt;custom document property to update. See &lt;code&gt;action=create&lt;/code&gt; for possible attributes&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CmisSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CommandSender">
        <xs:annotation>
          <xs:documentation>Sender that executes either its input or a fixed line, with all parametervalues appended, as a command.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CommandSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DelaySender">
        <xs:annotation>
          <xs:documentation>Sender that sleeps for a specified time, which defaults to 5000 msecs.
 Useful for testing purposes.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DelaySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DirectQuerySender">
        <xs:annotation>
          <xs:documentation>QuerySender that interprets the input message as a query, possibly with attributes.
 Messages are expected to contain sql-text.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DirectQuerySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EchoSender">
        <xs:annotation>
          <xs:documentation>Echos input to output.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EchoSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbJmsSender">
        <xs:annotation>
          <xs:documentation>ESB (Enterprise Service Bus) extension of JmsSender.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbJmsSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ExchangeFolderSender">
        <xs:annotation>
          <xs:documentation>Implementation of a FileSystemSender that enables to manipulate messages in an Exchange folder.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ExchangeFolderSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FileSystemSenderWithAttachmentsSender">
        <xs:annotation>
          <xs:documentation>FileSystem Sender extension to handle Attachments.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FileSystemSenderWithAttachmentsType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FixedQuerySender">
        <xs:annotation>
          <xs:documentation>QuerySender that assumes a fixed query, possibly with attributes.

 &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; See DB2XMLWriter for ResultSet!&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FixedQuerySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FixedResultSender">
        <xs:annotation>
          <xs:documentation>FixedResultSender, same behaviour as FixedResultPipe, but now as a ISender.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FixedResultSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FrankSender">
        <xs:annotation>
          <xs:documentation>Sender to send a message to another Frank! Adapter, or an external program running in the same JVM as the Frank!Framework.
 &lt;p&gt;
 Sends a message to another Frank!Framework-adapter in the same Frank!Framework instance, or an external program running in
 the same JVM as the Frank!Framework. If the callee exits with an {@code &lt;Exit/&gt;} that has state PipeLine.ExitState#ERROR,
 an error is considered to happen in the caller which means that the {@code exception} forward is followed if it is present.
 &lt;/p&gt;
 &lt;p&gt;
 Returns {@code exit.code} as forward name to the SenderPipe, provided that {@code exit.code} can be parsed as integer.
 For example, if the called adapter has an exit state with code
 {@code 2}, then the SenderPipe supports a forward with name {@code 2}
 that is followed when the called adapter exits with the mentioned exit. This does not work if the code is for example {@code c2}.
 &lt;/p&gt;
 &lt;p&gt;
 A FrankSender makes a call to either an Adapter or an external program by setting the #scope. By default the scope is {@code ADAPTER}.
 &lt;/p&gt;
 &lt;p/&gt;

 &lt;h3&gt;Configuration of the Adapter to be called&lt;/h3&gt;
 &lt;p&gt;
 A call to another Adapter in the same Frank!Framework instance is preferably made using the combination
 of a FrankSender configured with the name of the adapter.
 &lt;/p&gt;
 &lt;h4&gt;Configuring FrankSender and Adapter&lt;/h4&gt;
 &lt;ul&gt;
   &lt;li&gt;Define a SenderPipe with a FrankSender&lt;/li&gt;
   &lt;li&gt;Set the attribute {@code target} to &lt;i&gt;targetAdapterName&lt;/i&gt;&lt;/li&gt;
   &lt;li&gt;If the adapter is in another Configuration deployed in the same Frank!Framework instance, then set {@code target} to {@code targetConfigurationName/targetAdapterName} (note the slash-separator between Configuration name and Adapter name).&lt;/li&gt;
 &lt;/ul&gt;
 In the Adapter to be called:
 &lt;ul&gt;
   &lt;li&gt;The adapter does not need to have a receiver configured to be called from a FrankSender,&lt;/li&gt;
   &lt;li&gt;The adapter will run in the same transaction as the calling adapter,&lt;/li&gt;
   &lt;li&gt;If the called adapter does not to run in its own transaction, set the transaction attributes on the PipeLine attribute of this adapter
   or on the SenderPipe that contains this {@code FrankSender}.&lt;/li&gt;
 &lt;/ul&gt;

 &lt;h4&gt;Configuring FrankSender with FrankListener&lt;/h4&gt;
 &lt;ul&gt;
   &lt;li&gt;Define a SenderPipe with a FrankSender&lt;/li&gt;
   &lt;li&gt;In the target adapter, define a org.frankframework.receivers.Receiver with a FrankListener&lt;/li&gt;
   &lt;li&gt;Give a unique name to the listener: FrankListener#setName(String). If the name is not set, the name of the Adapter will be used.&lt;/li&gt;
   &lt;li&gt;Set the #setScope(Scope) to {@code LISTENER} and the #setTarget(String) to the listener name as per previous point&lt;/li&gt;
   &lt;li&gt;If the listener is in a different configuration, prefix the listener name with the name of the configuration and a slash ({@code /}) as separator between configuration and listener name&lt;/li&gt;
 &lt;/ul&gt;

 &lt;h4&gt;Configuring FrankSender and Remote Application&lt;/h4&gt;
 &lt;p&gt;
 &lt;em&gt;NB:&lt;/em&gt; Please make sure that the IbisServiceDispatcher-1.4.jar or newer is present on the class path of the server. For more information, see:
 &lt;/p&gt;
 &lt;ul&gt;
     &lt;li&gt;Define a SenderPipe with a FrankSender&lt;/li&gt;
     &lt;li&gt;Set the attribute {@code scope} to either {@code JVM} for a Java application, or to {@code DLL} for code loaded from a DLL&lt;/li&gt;
     &lt;li&gt;Set the attribute {@code target} to the service-name the other application used to register itself&lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
 In the other application:
 &lt;ul&gt;
     &lt;li&gt;Implement the interface {@code nl.nn.adapterframework.dispatcher.RequestProcessor} from the IbisServiceDispatcher library&lt;/li&gt;
     &lt;li&gt;Register the instance with the {@code nl.nn.adapterframework.dispatcher.DispatcherManager} obtained via the {@code nl.nn.adapterframework.dispatcher.DispatcherManagerFactory}&lt;/li&gt;
     &lt;li&gt;See the implementation code of the {@code JavaListener} in the Frank!Framework for an example&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/p&gt;
 &lt;p&gt;
 See also the repository of the IbisServiceDispatcher:
  &lt;a href="https://github.com/frankframework/servicedispatcher"&gt;https://github.com/frankframework/servicedispatcher&lt;/a&gt;
 &lt;/p&gt;
 
 &lt;h4&gt;Using FrankSender to call an adapter from Larva tests&lt;/h4&gt;
 &lt;p&gt;
 You can configure a FrankSender in Larva property files to use the FrankSender to invoke an adapter to test. When doing this, keep the following in mind:
 &lt;ul&gt;
     &lt;li&gt;If you leave the default scope as {@code ADAPTER}, then the {@code target} property needs to have both configuration name and adapter name, separated by a {@code /} character&lt;/li&gt;
     &lt;li&gt;When scope is left as default, the receiver and JavaListener are skipped and no transaction is started unless it is set on the adapter's {@code PipeLine}&lt;/li&gt;
     &lt;li&gt;If you do need a transaction and the adapter has a JavaListener that has org.frankframework.receivers.JavaListener#setServiceName(String) defined, you can use the FrankSender with scope {@code JVM}
     and set the {@code target} attribute to the {@code serviceName} attribute of the {@code JavaListener}.&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/p&gt;

 &lt;h3&gt;Migrating Existing Configurations&lt;/h3&gt;
 &lt;p&gt;
 When one adapter (named A) needs to call another adapter (named B) like a subroutine, you will usually have an IbisLocalSender or an IbisJavaSender
 in adapter A, and a org.frankframework.receivers.JavaListener in adapter B.
 &lt;/p&gt;
 &lt;p&gt;
     &lt;em&gt;NB:&lt;/em&gt; For the example it is assumed that all adapters are defined in the same configuration.
 &lt;/p&gt;

 &lt;h4&gt;Example of Existing Configuration&lt;/h4&gt;
 The existing configuration might look like this in the calling adapter:
 &lt;pre&gt;{@code
 &lt;module&gt;
     &lt;adapter name="Adapter A"&gt;
         &lt;receiver name="Adapter A Receiver"&gt;
             &lt;listener name="Adapter A Listener"
                 className="org.frankframework..." etc/&gt;
         &lt;/receiver&gt;
  	   &lt;pipeline firstPipe="..."&gt;
  	       &lt;pipe name="send" className="org.frankframework.pipes.SenderPipe"&gt;
  	           &lt;sender className="org.frankframework.senders.IbisJavaSender"
  	               serviceName="service-Adapter-B" /&gt;
                 &lt;forward name="success" path="..." /&gt;
  	       &lt;/pipe&gt;
         &lt;/pipeline&gt;
     &lt;/adapter&gt;
 &lt;/module&gt;
 }&lt;/pre&gt;

 Or like using the modern XML XSD and an IbisLocalSender instead:
 &lt;pre&gt;{@code
 &lt;Module&gt;
     &lt;Adapter name="Adapter A"&gt;
         &lt;Receiver name="Adapter A Receiver"&gt;
             ... Listener setup and other configuration
         &lt;/Receiver&gt;
         &lt;Pipeline&gt;
             &lt;SenderPipe name="send"&gt;
                 &lt;IbisLocalSender name="call Adapter B"
                     javaListener="Adapter B Listener"/&gt;
                 &lt;Forward name="success" path="EXIT" /&gt;
             &lt;/SenderPipe&gt;
         &lt;/Pipeline&gt;
     &lt;/Adapter&gt;
 &lt;/Module&gt;
 }&lt;/pre&gt;

 In the receiving adapter B the listener would have been configured like this:
 &lt;pre&gt;{@code
 &lt;Module&gt;
     &lt;Adapter name="adapter B"&gt;
         &lt;Receiver name="Receiver B"&gt;
             &lt;JavaListener name="Adapter B Listener" serviceName="service-Adapter-B"/&gt;
         &lt;/Receiver&gt;
         &lt;Pipeline&gt;
             ...
         &lt;/Pipeline&gt;
     &lt;/Adapter&gt;
 &lt;/Module&gt;
 }&lt;/pre&gt;
 &lt;p/&gt;

 &lt;h4&gt;Rewritten Example Configuration With FrankSender&lt;/h4&gt;
 This example shows the most simple way of using the FrankSender to call another adapter with least amount of overhead.

 &lt;pre&gt;{@code
 &lt;Module&gt;
     &lt;Adapter name="Adapter A"&gt;
         &lt;Receiver name="Adapter A Receiver"&gt;
             ... Listener setup and other configuration
         &lt;/Receiver&gt;
         &lt;Pipeline&gt;
             &lt;SenderPipe name="send"&gt;
                 &lt;!-- when scope="ADAPTER", then target is directly the name of the adapter you want to call --&gt;
                 &lt;FrankSender name="call Adapter C"
                     scope="ADAPTER"
                     target="adapter B"
                 /&gt;
                 &lt;Forward name="success" path="EXIT" /&gt;
             &lt;/SenderPipe&gt;
         &lt;/Pipeline&gt;
     &lt;/Adapter&gt;
     &lt;Adapter name="adapter B"&gt;
         &lt;!-- No receiver needed for FrankSender in this scenario --&gt;
         &lt;Pipeline&gt;
             ... Exits, Pipes etc
         &lt;/Pipeline&gt;
     &lt;/Adapter&gt;
 &lt;/Module&gt;
 }&lt;/pre&gt;

 &lt;h4&gt;Rewritten Example Configuration With FrankSender and FrankListener&lt;/h4&gt;
 This example shows why you might want to call the other adapter via the FrankListener. This adds a bit more overhead to the call
 of the sub-adapter for the extra error-handling done by the target receiver.

 &lt;pre&gt;{@code
 &lt;Module&gt;
    &lt;Adapter name="Adapter A"&gt;
        &lt;Receiver name="Adapter A Receiver"&gt;
         ... Listener setup and other configuration
 		  &lt;/Receiver&gt;
 		  &lt;Pipeline&gt;
            &lt;SenderPipe name="send"&gt;
                &lt;!-- when scope="LISTENER", then target is directly the name of the FrankListener in the adapter you want to call --&gt;
                &lt;FrankSender
                    scope="LISTENER"
                    target="Adapter B Listener"/&gt;
                &lt;Forward name="success" path="EXIT" /&gt;
            &lt;/SenderPipe&gt;
        &lt;/Pipeline&gt;
     &lt;/Adapter&gt;
     &lt;Adapter name="adapter B"&gt;
         &lt;!-- Messages will only be sent to the error storage if:
             - The target receiver is not transactional, and has maxTries="0", or
             - The target receiver is transaction, and the Sender is set up to retry sending on error
             For internal adapters, sending / receiving with retries might not make sense so the example does not show that.
         --&gt;
         &lt;Receiver name="Receiver B" maxRetries="0" transactionAttribute="NotSupported"&gt;
             &lt;!-- Listener name is optional, defaults to Adapter name --&gt;
             &lt;FrankListener name="Adapter B Listener"/&gt;
                 &lt;!-- This adapter now has an error storage -- without Receiver and FrankListener the sub-adapter couldn't have that --&gt;
             &lt;JdbcErrorStorage slotId="Adapter B - Errors" /&gt;
         &lt;/Receiver&gt;
         &lt;!-- If transactions are required, set transaction-attribute on the Pipeline --&gt;
         &lt;Pipeline transactionAttribute="RequiresNew"&gt;
             ... Exits, Pipes etc
         &lt;/Pipeline&gt;
    &lt;/Adapter&gt;
 &lt;/Module&gt;
 }&lt;/pre&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FrankSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FtpFileSystemSender">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FtpFileSystemSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="HttpSender">
        <xs:annotation>
          <xs:documentation>Sender for the HTTP protocol using HttpMethod. By default, any response code outside the 2xx or 3xx range
 is considered an error and the &lt;code&gt;exception&lt;/code&gt; forward of the SenderPipe is followed if present and if there
 is no forward for the specific HTTP status code. Forwards for specific HTTP codes (e.g. "200", "201", ...)
 are returned by this sender, so they are available to the SenderPipe.

 &lt;p&gt;&lt;b&gt;Expected message format:&lt;/b&gt;&lt;/p&gt;
 &lt;p&gt;GET methods expect a message looking like this:
 &lt;pre&gt;
    param_name=param_value&amp;another_param_name=another_param_value
 &lt;/pre&gt;
 &lt;p&gt;POST AND PUT methods expect a message similar as GET, or looking like this:
 &lt;pre&gt;
   param_name=param_value
   another_param_name=another_param_value
 &lt;/pre&gt;

 Note:
 When used as MTOM sender and MTOM receiver doesn't support Content-Transfer-Encoding "base64", messages without line feeds will give an error.
 This can be fixed by setting the Content-Transfer-Encoding in the MTOM sender.
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="HttpSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IMSSender">
        <xs:annotation>
          <xs:documentation>JMS sender which will add an IMS header to the message and call the MQ specific logic.

 &lt;p&gt;See JmsSender for configuration&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IMSSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IbisJavaSender">
        <xs:annotation>
          <xs:documentation>Posts a message to another Frank!Framework-adapter or an application in the same JVM using IbisServiceDispatcher.
 &lt;p&gt;
 An IbisJavaSender makes a call to a Receiver with a JavaListener
 or any other application in the same JVM that has registered a &lt;code&gt;RequestProcessor&lt;/code&gt; with the IbisServiceDispatcher.
 &lt;/p&gt;
 The IbisJavaSender is now considered to be legacy. The new way to call another adapter or java application from your own
 adapter is by using the FrankSender.
 &lt;/p&gt;
 &lt;h4&gt;configuring IbisJavaSender and JavaListener&lt;/h4&gt;
 &lt;ul&gt;
   &lt;li&gt;&lt;em&gt;NB:&lt;/em&gt; Using IbisJavaSender to call another adapter is inefficient and therefore not recommended. It is much more efficient to use for this a FrankSender or IbisLocalSender.&lt;/li&gt;
   &lt;li&gt;Define a org.frankframework.pipes.SenderPipe with an IbisJavaSender&lt;/li&gt;
   &lt;li&gt;Set the attribute &lt;code&gt;serviceName&lt;/code&gt; to &lt;i&gt;yourExternalServiceName&lt;/i&gt;&lt;/li&gt;
 &lt;/ul&gt;
 In the Adapter to be called:
 &lt;ul&gt;
   &lt;li&gt;Define a Receiver with a JavaListener&lt;/li&gt;
   &lt;li&gt;Set the attribute &lt;code&gt;serviceName&lt;/code&gt; to &lt;i&gt;yourExternalServiceName&lt;/i&gt;&lt;/li&gt;
 &lt;/ul&gt;
 N.B. Please make sure that the IbisServiceDispatcher-1.4.jar or newer is present on the class path of the server. For more information, see:
  &lt;a href="https://github.com/frankframework/servicedispatcher"&gt;https://github.com/frankframework/servicedispatcher&lt;/a&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IbisJavaSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IbisLocalSender">
        <xs:annotation>
          <xs:documentation>Posts a message to another Frank!Framework-adapter in the same Frank!Framework instance. If the callee exits with an &amp;lt;&lt;code&gt;exit&lt;/code&gt;&amp;gt;
 that has state PipeLine.ExitState#ERROR, an error is considered to happen
 in the caller which means that the &lt;code&gt;exception&lt;/code&gt; forward is followed if it is present.
 &lt;p&gt;
 The IbisLocalSender is now considered to be legacy. The new way to call another adapter from your own
 adapter is by using the FrankSender.
 &lt;/p&gt;
 &lt;p&gt;
 Returns exit.code as forward name to SenderPipe provided that exit.code can be parsed as integer.
 For example, if the called adapter has an exit state with code
 &lt;code&gt;2&lt;/code&gt;, then the SenderPipe supports a forward with name &lt;code&gt;2&lt;/code&gt;
 that is followed when the called adapter exits with the mentioned exit. This does not work if the code is for example &lt;code&gt;c2&lt;/code&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 An IbisLocalSender makes a call to a org.frankframework.receivers.Receiver with either a WebServiceListener
 or a JavaListener.
 &lt;/p&gt;


 &lt;h3&gt;Configuration of the Adapter to be called&lt;/h3&gt;
 A call to another Adapter in the same Frank!Framework instance is preferably made using the combination
 of an IbisLocalSender and a JavaListener. If,
 however, a Receiver with a WebServiceListener is already present, that can be used in some cases, too.

 &lt;h4&gt;configuring IbisLocalSender and JavaListener&lt;/h4&gt;
 &lt;ul&gt;
   &lt;li&gt;Define a SenderPipe with an IbisLocalSender&lt;/li&gt;
   &lt;li&gt;Set the attribute &lt;code&gt;javaListener&lt;/code&gt; to &lt;i&gt;yourServiceName&lt;/i&gt;&lt;/li&gt;
   &lt;li&gt;Do not set the attribute &lt;code&gt;serviceName&lt;/code&gt;&lt;/li&gt;
 &lt;/ul&gt;
 In the Adapter to be called:
 &lt;ul&gt;
   &lt;li&gt;Define a Receiver with a JavaListener&lt;/li&gt;
   &lt;li&gt;Set the attribute &lt;code&gt;name&lt;/code&gt; to &lt;i&gt;yourServiceName&lt;/i&gt;&lt;/li&gt;
   &lt;li&gt;Do not set the attribute &lt;code&gt;serviceName&lt;/code&gt;, except if the service is to be called also
       from applications other than this Frank!Framework-instance&lt;/li&gt;
 &lt;/ul&gt;

 &lt;h4&gt;configuring IbisLocalSender and WebServiceListener&lt;/h4&gt;

 &lt;ul&gt;
   &lt;li&gt;Define a SenderPipe with an IbisLocalSender&lt;/li&gt;
   &lt;li&gt;Set the attribute &lt;code&gt;serviceName&lt;/code&gt; to &lt;i&gt;yourIbisWebServiceName&lt;/i&gt;&lt;/li&gt;
   &lt;li&gt;Do not set the attribute &lt;code&gt;javaListener&lt;/code&gt;&lt;/li&gt;
 &lt;/ul&gt;
 In the Adapter to be called:
 &lt;ul&gt;
   &lt;li&gt;Define a Receiver with a WebServiceListener&lt;/li&gt;
   &lt;li&gt;Set the attribute &lt;code&gt;name&lt;/code&gt; to &lt;i&gt;yourIbisWebServiceName&lt;/i&gt;&lt;/li&gt;
 &lt;/ul&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IbisLocalSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IdinSender">
        <xs:annotation>
          <xs:documentation>Requires the net.bankid.merchant.library V1.2.9</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IdinSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IdocSender">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IdocSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ImapSender">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ImapSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JavascriptSender">
        <xs:annotation>
          <xs:documentation>Sender used to run JavaScript code using `JavascriptEngine` implementations.
 &lt;p&gt;
 This sender can execute a function of a given Javascript file, the result of the function will be the output of the sender.
 The parameters of the Javascript function to run are given as parameters by the adapter configuration
 The sender doesn't accept nor uses the given input, instead for each argument for the #jsFunctionName method,
 you will need to create a parameter on the sender.
 &lt;/p&gt;
 &lt;p&gt;
 The result of the Javascript function should be of type String, or directly convertible to String from a primitive type
 or an array of primitive types / strings, as the output of the sender will be of type String.
 &lt;/p&gt;
 &lt;p&gt;
 Failure to ensure the output is a string may mean the result will look like {@code [Object object]}.
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JavascriptSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JmsSender">
        <xs:annotation>
          <xs:documentation>This class sends messages with JMS.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JmsSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JsonXsltSender">
        <xs:annotation>
          <xs:documentation>Perform an XSLT transformation with a specified stylesheet on a JSON input, yielding JSON, yielding JSON, XML or text.
 JSON input is transformed into XML map, array, string, integer and boolean elements, in the namespace http://www.w3.org/2013/XSL/json.
 The XSLT stylesheet or XPathExpression operates on these element.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JsonXsltSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LdapSender">
        <xs:annotation>
          <xs:documentation>Sender to obtain information from and write to an LDAP Directory.
 Returns the set of attributes in an XML format. Examples are shown below.

 &lt;h2&gt;example&lt;/h2&gt;
 Consider the following configuration example:
 &lt;pre&gt;{@code
 &lt;sender
      className="org.frankframework.ldap.LdapSender"
      ldapProviderURL="ldap://servername:389/o=ing"
      operation="read"
      attributesToReturn="givenName,sn,telephoneNumber" &gt;
     &lt;param name="entryName" xpathExpression="entryName" /&gt;
 &lt;/sender&gt;
 }&lt;/pre&gt;
 &lt;br/&gt;

 This may result in the following output:
 &lt;pre&gt;{@code
 &lt;ldap&gt;
 	   &lt;entryName&gt;uid=srp,ou=people&lt;/entryName&gt;
 	   &lt;attributes&gt;
         &lt;attribute attrID="givenName"&gt;
             &lt;value&gt;Jan&lt;/value&gt;
         &lt;/attribute&gt;
         &lt;attribute attrID="telephoneNumber"&gt;
             &lt;value&gt;010 5131123&lt;/value&gt;
             &lt;value&gt;06 23456064&lt;/value&gt;
         &lt;/attribute&gt;
 	       &lt;attribute attrID="sn"&gt;
             &lt;value&gt;Jansen&lt;/value&gt;
 	       &lt;/attribute&gt;
 	   &lt;/attributes&gt;
 &lt;/ldap&gt;
 }&lt;/pre&gt;
 &lt;br/&gt;

 Search or Read?

 Read retrieves all the attributes of the specified entry.

 Search retrieves all the entries of the specified (by entryName) context that have the specified attributes,
 together with the attributes. If the specified attributes are null or empty all the attributes of all the entries within the
 specified context are returned.

 Sample result of a &lt;code&gt;read&lt;/code&gt; operation:&lt;br/&gt;
 &lt;pre&gt;{@code
 &lt;attributes&gt;
 	   &lt;attribute&gt;
 	   &lt;attribute name="employeeType" value="Extern"/&gt;
 	   &lt;attribute name="roomNumber" value="DP 2.13.025"/&gt;
 	   &lt;attribute name="departmentCode" value="358000"/&gt;
 	   &lt;attribute name="organizationalHierarchy"&gt;
 	       &lt;item value="ou=ING-EUR,ou=Group,ou=Organization,o=ing"/&gt;
 	       &lt;item value="ou=OPS&amp;IT,ou=NL,ou=ING-EUR,ou=Group,ou=Organization,o=ing"/&gt;
 	       &lt;item value="ou=000001,ou=OPS&amp;IT,ou=NL,ou=ING-EUR,ou=Group,ou=Organization,o=ing"/&gt;
 	   &lt;/attribute&gt;
 	   &lt;attribute name="givenName" value="Gerrit"/&gt;
 &lt;/attributes&gt;
 }&lt;/pre&gt;
 &lt;br/&gt;
 Sample result of a &lt;code&gt;search&lt;/code&gt; operation:&lt;br/&gt;
 &lt;pre&gt;{@code
 &lt;entries&gt;
 	   &lt;entry name="uid=srp"&gt;
 	       &lt;attributes&gt;
 	           &lt;attribute&gt;
 	           &lt;attribute name="employeeType" value="Extern"/&gt;
 	           &lt;attribute name="roomNumber" value="DP 2.13.025"/&gt;
 	           &lt;attribute name="departmentCode" value="358000"/&gt;
 	           &lt;attribute name="organizationalHierarchy"&gt;
 	               &lt;item value="ou=ING-EUR,ou=Group,ou=Organization,o=ing"/&gt;
 	               &lt;item value="ou=OPS&amp;IT,ou=NL,ou=ING-EUR,ou=Group,ou=Organization,o=ing"/&gt;
 	               &lt;item value="ou=000001,ou=OPS&amp;IT,ou=NL,ou=ING-EUR,ou=Group,ou=Organization,o=ing"/&gt;
 	           &lt;/attribute&gt;
 	           &lt;attribute name="givenName" value="Gerrit"/&gt;
 	       &lt;/attributes&gt;
 	   &lt;/entry&gt;
     &lt;entry&gt; .... &lt;/entry&gt;
    .....
 &lt;/entries&gt;
 }&lt;/pre&gt;
 &lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LdapSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LocalFileSystemSender">
        <xs:annotation>
          <xs:documentation>Sender to work with the server local filesystem.
 &lt;p&gt;
     In addition to regular parameters for filesystem senders, it is possible
     to set custom extended attributes on files by prefixing parameter names with
     FileAttribute..
     This prefix will be not be part of the actual metadata property name.
 &lt;/p&gt;
 &lt;p&gt;
     The string value of these parameters will be used as value of the custom metadata attribute.
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LocalFileSystemSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LogSender">
        <xs:annotation>
          <xs:documentation>Sender that just logs its message.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LogSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MQSender">
        <xs:annotation>
          <xs:documentation>JMS sender which will call IBM WebSphere MQ specific
 setTargetClient(JMSC.MQJMS_CLIENT_NONJMS_MQ) on the destination prior to
 sending a message. This is needed when the MQ destination is not a JMS
 receiver otherwise format errors occur (e.g. dots are added after every
 character in the message).

 &lt;p&gt;See JmsSender for configuration&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MQSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MailSender">
        <xs:annotation>
          <xs:documentation>sender that sends a mail specified by an XML message.
 &lt;p&gt;
 Sample email.xml:
 &lt;pre&gt;{@code
 &lt;email&gt;
     &lt;recipients&gt;
         &lt;recipient type="to"&gt;***@hotmail.com&lt;/recipient&gt;
         &lt;recipient type="cc"&gt;***@gmail.com&lt;/recipient&gt;
     &lt;/recipients&gt;
     &lt;from name="*** ***"&gt;***@yahoo.com&lt;/from&gt;
     &lt;subject&gt;This is the subject&lt;/subject&gt;
     &lt;threadTopic&gt;subject&lt;/threadTopic&gt;
     &lt;message&gt;This is the message&lt;/message&gt;
     &lt;messageType&gt;text/plain&lt;/messageType&gt;&lt;!-- Optional --&gt;
     &lt;messageBase64&gt;false&lt;/messageBase64&gt;&lt;!-- Optional --&gt;
     &lt;charset&gt;UTF-8&lt;/charset&gt;&lt;!-- Optional --&gt;
     &lt;attachments&gt;
         &lt;attachment name="filename1.txt"&gt;This is the first attachment&lt;/attachment&gt;
         &lt;attachment name="filename2.pdf" base64="true"&gt;JVBERi0xLjQKCjIgMCBvYmoKPDwvVHlwZS9YT2JqZWN0L1N1YnR5cGUvSW1...vSW5mbyA5IDAgUgo+PgpzdGFydHhyZWYKMzQxNDY2CiUlRU9GCg==&lt;/attachment&gt;
         &lt;attachment name="filename3.pdf" url="file:/c:/filename3.pdf"/&gt;
         &lt;attachment name="filename4.pdf" sessionKey="fileContent"/&gt;
     &lt;/attachments&gt;&lt;!-- Optional --&gt;
 &lt;/email&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;&lt;p&gt;
 Notice: the XML message must be valid XML. Therefore, especially the message element
 must be plain text or be wrapped as CDATA. Example:
 &lt;pre&gt;{@code
 &lt;message&gt;&lt;![CDATA[&lt;h1&gt;This is a HtmlMessage&lt;/h1&gt;]]&gt;&lt;/message&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;&lt;p&gt;
 The &lt;code&gt;sessionKey&lt;/code&gt; attribute for attachment can contain an inputstream or a string. Other types are not supported at this moment.
 &lt;/p&gt;&lt;p&gt;
 The attribute order for attachments is as follows:
 &lt;ol&gt;
    &lt;li&gt;sessionKey&lt;/li&gt;
    &lt;li&gt;url&lt;/li&gt;
    &lt;li&gt;&lt;i&gt;value of the attachment element&lt;/i&gt;&lt;/li&gt;
 &lt;/ol&gt;
 &lt;/p&gt;&lt;p&gt;
 The &lt;code&gt;base64&lt;/code&gt; attribute is only used when the value of the PipeLineSession variable &lt;code&gt;sessionKey&lt;/code&gt; is a String object
 or when the value of the attachment element is used. If &lt;code&gt;base64=true&lt;/code&gt; then the value will be decoded before it's used.
 &lt;/p&gt;&lt;p&gt;
 &lt;b&gt;Compilation and Deployment Note:&lt;/b&gt; mail.jar (v1.2) and activation.jar must appear BEFORE j2ee.jar.
 Otherwise errors like the following might occur: &lt;code&gt;NoClassDefFoundException: com/sun/mail/util/MailDateFormat&lt;/code&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MailSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MessageStoreSender">
        <xs:annotation>
          <xs:documentation>Send messages to the IBISSTORE database table to have them processed exactly-once by another
 adapter which will read the messages using a MessageStoreListener.
 This other adapter will process the messages asynchronously and (optionally)
 under transaction control. Duplicate messages are ignored based on the
 messageId (except when onlyStoreWhenMessageIdUnique is set to false), hence
 the sender of the message can retry sending the message until a valid reply
 is received in which case it can be certain that the message is stored in the
 database table IBISSTORE.
 &lt;br/&gt;&lt;br/&gt;
 If you have a &lt;code&gt;MessageStoreSender&lt;/code&gt; it does not make sense to add a &lt;code&gt;JdbcMessageLog&lt;/code&gt;
 or &lt;code&gt;JdbcErrorStorage&lt;/code&gt; in the same sender pipe. A &lt;code&gt;MessageStoreSender&lt;/code&gt;
 acts as a message log and an error store. It can be useful however to add a message log or error store
 to the adapter around the sender pipe, because errors may occur before the message reaches the sender pipe.
 &lt;br/&gt;&lt;br/&gt;
 Example configuration:
 &lt;pre&gt;{@code
 &lt;SenderPipe name="Send"&gt;
     &lt;MessageStoreSender
 	     slotId="${instance.name}/TestMessageStore"
 		 onlyStoreWhenMessageIdUnique="false" /&gt;
 &lt;/SenderPipe&gt;
 }&lt;/pre&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MessageStoreSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MongoDbSender">
        <xs:annotation>
          <xs:documentation>Sender to perform action on a MongoDB database.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MongoDbSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MqttSender">
        <xs:annotation>
          <xs:documentation>MQTT listener which will connect to a broker and subscribe to a topic.

 Links to &lt;a href="https://www.eclipse.org/paho/files/javadoc" target="_blank"&gt;https://www.eclipse.org/paho/files/javadoc&lt;/a&gt; are opened in a new window/tab because the response from eclipse.org contains header X-Frame-Options:SAMEORIGIN which will make the browser refuse to open the link inside this frame.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MqttSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="NetStorageSender">
        <xs:annotation>
          <xs:documentation>Sender for Akamai NetStorage (HTTP based).

 &lt;p&gt;See HttpSenderBase for more arguments and parameters!&lt;/p&gt;


 &lt;p&gt;&lt;b&gt;AuthAlias:&lt;/b&gt;&lt;/p&gt;
 &lt;p&gt;If you do not want to specify the nonce and the access token used to authenticate with Akamai, you can use the authalias property. The username
 represents the nonce and the password the access token.&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="NetStorageSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ParallelSendersSender">
        <xs:annotation>
          <xs:documentation>Collection of Senders, that are executed all at the same time.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ParallelSendersType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ReconnectSenderWrapperSender">
        <xs:annotation>
          <xs:documentation>Wrapper for senders, that opens the wrapped sender at runtime before each sender action, and closes it afterwards.
 This prevents (long) open connections inside Senders and possible connection failures.

 &lt;b&gt;Example:&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;SenderPipe&gt;
     &lt;ReconnectSenderWrapper&gt;
         &lt;EchoSender myAttribute="myValue" /&gt;
     &lt;/ReconnectSenderWrapper&gt;
 &lt;/SenderPipe&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ReconnectSenderWrapperType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ReloadSender">
        <xs:annotation>
          <xs:documentation>Performs a reload on database configuration.

 &lt;p&gt;It is possible to set the name of the configuration with the parameter 'name'.&lt;/p&gt;
 &lt;p&gt;You can dynamically set 'forceReload' attribute with the parameter 'forceReload'.&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ReloadSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ResultSet2FileSender">
        <xs:annotation>
          <xs:documentation>QuerySender that writes each row in a ResultSet to a file.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ResultSet2FileSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Samba1Sender">
        <xs:annotation>
          <xs:documentation>Uses the (old) SMB 1 protocol.
 &lt;br/&gt;
 Only supports NTLM authentication.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Samba1SenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Samba2Sender">
        <xs:annotation>
          <xs:documentation>Uses the (newer) SMB 2 and 3 protocol.

 Possible error codes:
 &lt;br/&gt;
 Pre-authentication information was invalid (24) or Identifier doesn't match expected value (906): login information is incorrect
 Server not found in Kerberos database (7): Verify that the hostname is the FQDN and the server is using a valid SPN.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Samba2SenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SapSender">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SapSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SchedulerSender">
        <xs:annotation>
          <xs:documentation>Registers a trigger in the scheduler so that the message is send to a javalistener
 at a scheduled time.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SchedulerSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SendGridSender">
        <xs:annotation>
          <xs:documentation>Sender that sends a mail via SendGrid v3 (cloud-based SMTP provider).

 Sample XML file can be found in the path: iaf-core/src/test/resources/emailSamplesXML/emailSample.xml</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SendGridSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SenderSeriesSender">
        <xs:annotation>
          <xs:documentation>Series of Senders, that are executed one after another.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SenderSeriesType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SenderWrapperSender">
        <xs:annotation>
          <xs:documentation>Wrapper for senders, that allows to get input from a session variable, and to store output in a session variable.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SenderWrapperType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SftpFileSystemSender">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SftpFileSystemSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ShadowSender">
        <xs:annotation>
          <xs:documentation>Collection of Senders, that are executed all at the same time. Once the results are processed, all results will be sent to the resultSender,
 while the original sender will return its result to the pipeline.

 &lt;p&gt;Multiple sub-senders can be configured within the ShadowSender, the minimum amount of senders is 2 (originalSender + resultSender)&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ShadowSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="StoredProcedureQuerySender">
        <xs:annotation>
          <xs:documentation>StoredProcedureQuerySender is used to send stored procedure queries and retrieve the result.

 &lt;p&gt;
     &lt;h3&gt;QueryType settings and OUTPUT parameters&lt;/h3&gt;
 The StoredProcedureQuerySender class has the following features:
 &lt;ul&gt;
     &lt;li&gt;It supports setting the output parameters of the stored procedure by setting 'mode' attribute of
     the corresponding 'Param' to 'OUTPUT' or 'INOUT'.&lt;/li&gt;
     &lt;li&gt;The queryType can only be 'SELECT' or 'OTHER'.&lt;/li&gt;
     &lt;li&gt;Use queryType 'SELECT' when the stored procedure only returns a set of rows, and you need
     the output to be the format as FixedQuerySender (see DB2XMLWriter).&lt;/li&gt;
     &lt;li&gt;Use queryType 'OTHER' if the stored procedure has one or more output parameters. With this query type,
     the stored procedure can return a result-set along with returning some values in output parameters.
     Depending on the database, the stored procedure can even returning multiple result sets or a combination
     of result sets as return values, and result sets as REF_CURSOR OUT parameters. &lt;/li&gt;
 &lt;/ul&gt;
 &lt;/p&gt;
 &lt;p&gt;
     All stored procedure parameters that are not fixed, so specified in the query with a {@code ?}, should
     have a corresponding IParameter entry. Output parameters should have {@code mode="OUTPUT"}, or
     {@code mode="INOUT"} depending on how the stored procedure is defined.
 &lt;/p&gt;
 &lt;p&gt;
	&lt;h3&gt;Sample Output for queryType=OTHER&lt;/h3&gt;
	&lt;h4&gt;Basic Example with Only Simple Output Parameters&lt;/h4&gt;
 &lt;pre&gt;{@code
 &lt;resultset&gt;
 	   &lt;result param="r1" type="STRING"&gt;MESSAGE-CONTENTS&lt;/result&gt;
     &lt;result param="r2" type="STRING"&gt;E&lt;/result&gt;
 &lt;/resultset&gt;
 }&lt;/pre&gt;

	&lt;h4&gt;Example with Resultset and Simple Output Parameters&lt;/h4&gt;
 &lt;pre&gt;{@code
 &lt;resultset&gt;
 		 &lt;result resultNr="1"&gt;
 			 &lt;fielddefinition&gt;
 				&lt;field name="FIELDNAME"
 						  type="columnType"
 						  columnDisplaySize=""
 						  precision=""
 						  scale=""
 						  isCurrency=""
 						  columnTypeName=""
 						  columnClassName=""/&gt;
 				 &lt;field ...../&gt;
  		     &lt;/fielddefinition&gt;
 			 &lt;rowset&gt;
 				 &lt;row number="0"&gt;
 					 &lt;field name="TKEY"&gt;MSG-ID&lt;/field&gt;
 					 &lt;field name="TCHAR"&gt;E&lt;/field&gt;
 					 &lt;field name="TMESSAGE"&gt;MESSAGE-CONTENTS&lt;/field&gt;
 					 &lt;field name="TCLOB" null="true"/&gt;
 					 &lt;field name="TBLOB" null="true"/&gt;
 				 &lt;/row&gt;
                  &lt;row number="1" ...../&gt;
 			 &lt;/rowset&gt;
 		 &lt;/result&gt;
 		 &lt;result param="count" type="INTEGER"&gt;5&lt;/result&gt;
 &lt;/resultset&gt;
 }&lt;/pre&gt;

	&lt;h4&gt;Example with Simple and Cursor Output Parameters&lt;/h4&gt;
 &lt;pre&gt;{@code
 &lt;resultset&gt;
 		&lt;result param="count" type="INTEGER"&gt;5&lt;/result&gt;
 		&lt;result param="cursor1" type="LIST"&gt;
 			 &lt;fielddefinition&gt;
 				&lt;field name="FIELDNAME"
 						  type="columnType"
 						  columnDisplaySize=""
 						  precision=""
 						  scale=""
 						  isCurrency=""
 						  columnTypeName=""
 						  columnClassName=""/&gt;
 				 &lt;field ...../&gt;
  		&lt;/fielddefinition&gt;
 			&lt;rowset&gt;
 				&lt;row number="0"&gt;
 					&lt;field name="TKEY"&gt;MSG-ID&lt;/field&gt;
 					&lt;field name="TCHAR"&gt;E&lt;/field&gt;
 					&lt;field name="TMESSAGE"&gt;MESSAGE-CONTENTS&lt;/field&gt;
 					&lt;field name="TCLOB" null="true"/&gt;
 					&lt;field name="TBLOB" null="true"/&gt;
 				&lt;/row&gt;
 				&lt;row number="1" ..... /&gt;
 			&lt;/rowset&gt;
 		&lt;/result&gt;
 	&lt;/resultset&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;
 &lt;p&gt;&lt;em&gt;NOTE:&lt;/em&gt; Support for stored procedures is currently experimental and changes in the currently produced output-format
 are expected.&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="StoredProcedureQuerySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="WebServiceSender">
        <xs:annotation>
          <xs:documentation>Sender that sends a message via a WebService.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="WebServiceSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XComSender">
        <xs:annotation>
          <xs:documentation>XCom client voor het versturen van files via XCom.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XComSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XfbSender">
        <xs:annotation>
          <xs:documentation>Sender for transferring files using the XFB protocol. Assumes sender input is local filename.
 &lt;br/&gt;
 Some comments from Richard Maddox (FTO) about UNIX File permissions:
 &lt;br/&gt;
 &lt;br/&gt;
 In case of AIX or SUN systems we advise the following user and directory permissions:
 &lt;br/&gt;
 &lt;br/&gt;
 SENDING CFT:
 &lt;br/&gt;
 - App_user must have secondary group: xfbgw
 &lt;br/&gt;
 - Folder should have ownership: app_user:xfbgw   (owner:group)
 &lt;br/&gt;
 - Folder should have access rights: 770  (rwx.rwx.---)  so nobody other then app_user and group xfbgw can do something in this folder
 &lt;br/&gt;
 - Folder should have SGID bit set so that all files what is copied to this folder get group ownership xfbgw
 &lt;br/&gt;
 - send file must have rights 660 after putting the file in the send directory.
 &lt;br/&gt;
 &lt;br/&gt;
 RECEIVING CFT:
 &lt;br/&gt;
 - App_user (the application user of customer) should have secondary group: xfbgw
 &lt;br/&gt;
 - Folder should have ownership:  app_user:xfbgw   (owner:group)
 &lt;br/&gt;
 - Folder should have access rights: 770  (rwx.rwx.---)  so nobody other then app_user and group xfbgw can do something in this folder
 &lt;br/&gt;
 - Folder should have SGID bit set, so that all files what is copied to this folder get group ownership xfbgw
 &lt;br/&gt;
 &lt;br/&gt;
 There are of course more solutions to get the job done, but this is the solution we can guarantee.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XfbSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlJmsBrowserSender">
        <xs:annotation>
          <xs:documentation>Sender for browsing and removing queue messages (with input and output in a XML message).

 &lt;p&gt;
 When input root element is &lt;code&gt;browse&lt;/code&gt; all queue messages are returned.
 &lt;/p&gt;
 &lt;p&gt;
 When input root element is &lt;code&gt;remove&lt;/code&gt; all queue messages are removed.
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;example (input):&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;browse&gt;
    &lt;jmsRealm&gt;qcf&lt;/jmsRealm&gt;
    &lt;destinationName&gt;jms/GetPolicyDetailsRequest&lt;/destinationName&gt;
    &lt;destinationType&gt;QUEUE&lt;/destinationType&gt;
 &lt;/browse&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;example (browse output):&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;result&gt;
   &lt;items count="2"&gt;
      &lt;item&gt;
         &lt;timestamp&gt;Thu Nov 20 13:36:31 CET 2014&lt;/timestamp&gt;
         &lt;messageId&gt;ID:LPAB00000003980-61959-1416486781822-3:5:33:1:1&lt;/messageId&gt;
         &lt;correlationId&gt;...&lt;/correlationId&gt;
         &lt;message&gt;&lt;![CDATA[...]]&gt;&lt;/message&gt;
      &lt;/item&gt;
      &lt;item&gt;
         &lt;timestamp&gt;Thu Dec 12 11:59:22 CET 2014&lt;/timestamp&gt;
         &lt;messageId&gt;ID:LPAB00000003980-58359-1721486799722-3:4:19:1:1&lt;/messageId&gt;
         &lt;correlationId&gt;...&lt;/correlationId&gt;
         &lt;message&gt;&lt;![CDATA[...]]&gt;&lt;/message&gt;
      &lt;/item&gt;
 	 &lt;/items&gt;
 &lt;/result&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;

 &lt;p&gt;
 &lt;b&gt;example (remove output):&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;result&gt;
     &lt;itemsRemoved&gt;2&lt;/itemsRemoved&gt;
 &lt;/result&gt;
 }&lt;/pre&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlJmsBrowserSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlQuerySender">
        <xs:annotation>
          <xs:documentation>QuerySender that transforms the input message to a query.
 &lt;br/&gt;
 &lt;pre&gt;{@code
  select
  delete
  insert
  update - tableName
         - columns [0..1] - column [1..n] - name
                                          - value [0..1]
                                          - type [0..1] one of {string;function;number;datetime;blob;clob;xmldatetime}, string by default
                                          - decimalSeparator [0..1] only applicable for type=number
                                          - groupingSeparator [0..1] only applicable for type=number
                                          - formatString [0..1] only applicable for type=datetime, yyyy-MM-dd HH:mm:ss.SSS by default
         - where [0..1]
         - order [0..1]

  alter - sequenceName
        - startWith

  sql   - type [0..1] one of {select;ddl;other}, other by default
        - query

 }&lt;/pre&gt;
 &lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlQuerySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlValidatorSender">
        <xs:annotation>
          <xs:documentation>Sender that validates the input message against a XML Schema.

 N.B. noNamespaceSchemaLocation may contain spaces, but not if the schema is stored in a .jar or .zip file on the class path.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlValidatorSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XsltSender">
        <xs:annotation>
          <xs:documentation>Perform an XSLT transformation with a specified stylesheet or XPath-expression.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XsltSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ZipWriterSender">
        <xs:annotation>
          <xs:documentation>Sender that writes an entry to a ZipStream, similar to ZipWriterPipe with action='write'.
 Filename and contents are taken from parameters. If one of the parameters is not present, the input message
 is used for either filename or contents.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ZipWriterSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="Afm2EdiFactSenderType">
    <xs:attributeGroup ref="Afm2EdiFactSenderDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.afm.Afm2EdiFactSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="Afm2EdiFactSenderDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of the object.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destination" type="xs:string" />
    <xs:attribute name="postbus" type="xs:string" />
    <xs:attribute name="tpnummer" type="xs:string" />
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="AmazonS3SenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="AmazonS3SenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.AmazonS3Sender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="AmazonS3SenderDeclaredAttributeGroup">
    <xs:attribute name="accessKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Access key to access to the AWS resources owned by the account</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secretKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Secret key to access to the AWS resources owned by the account</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain AWS credentials</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chunkedEncodingDisabled" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Setting this flag will result in disabling chunked encoding for all requests. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forceGlobalBucketAccessEnabled" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Option to enable or disable the usage of multi-region access point ARNs. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clientRegion" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Name of the AWS region that the client is using. Default: eu-west-1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="bucketName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the bucket to access. The bucketName can also be specified by prefixing it to the object name, separated from it by |</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="frankInt">
      <xs:annotation>
        <xs:documentation>Proxy port</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceEndpoint" type="xs:string">
      <xs:annotation>
        <xs:documentation>The S3 service endpoint, either with or without the protocol. (e.g. https://sns.us-west-1.amazonaws.com or sns.us-west-1.amazonaws.com)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConnections" type="frankInt">
      <xs:annotation>
        <xs:documentation>Maximum concurrent connections towards S3 Default: 50</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="AmazonS3SenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="AmazonS3SenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="SenderWithParametersBaseDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="ParamElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="SenderBaseDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the sender</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:attributeGroup name="FileSystemSenderDeclaredAttributeGroup">
    <xs:attribute name="action">
      <xs:annotation>
        <xs:documentation>If parameter [action] is set, then the attribute action value will be overridden with the value of the parameter.</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="FileSystemActionAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="filename" type="xs:string">
      <xs:annotation>
        <xs:documentation>Filename to operate on. If not set, the parameter filename is used. If that is not set either, the input is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destination" type="xs:string">
      <xs:annotation>
        <xs:documentation>Destination for move, copy or rename. If not set, the parameter destination is used. If that is not set either, the input is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder that is scanned for files when action=list. When not set, the root is scanned</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createFolder" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;: if a non-existing folder is part of the fileName, it will be created. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="overwrite" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, for actions create, write, move, copy or rename, the destination file is overwritten if it already exists Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rotateDays" type="frankInt">
      <xs:annotation>
        <xs:documentation>For action=append: If set to a positive number, the file is rotated each day, and this number of files is kept. The inputFolder must point to the directory where the file resides Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rotateSize" type="frankInt">
      <xs:annotation>
        <xs:documentation>For action=append: If set to a positive number, the file is rotated when it has reached the specified size, and the number of files specified in numberOfBackups is kept. Size is specified in plain bytes, suffixes like 'K', 'M' or 'G' are not recognized. The inputFolder must point to the directory where the file resides Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numberOfBackups" type="frankInt">
      <xs:annotation>
        <xs:documentation>For the actions write and append, with rotateSize&gt;0: the number of backup files that is kept. The inputFolder must point to the directory where the file resides Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wildcard" type="xs:string">
      <xs:annotation>
        <xs:documentation>Filter of files to look for in inputFolder e.g. '*.inp'. Works with actions move, copy, delete and list</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="excludeWildcard" type="xs:string">
      <xs:annotation>
        <xs:documentation>Filter of files to be excluded when looking in inputFolder. Works with actions move, copy, delete and list</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNonEmptyFolder" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt; then the folder and the content of the non empty folder will be deleted.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeLineSeparator" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt; then the system specific line separator will be appended to the file after executing the action. Works with actions write and append Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Charset to be used for read and write action</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deleteEmptyFolder" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to true then the folder will be deleted if it is empty after processing the action. Works with actions delete, readDelete and move</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat">
      <xs:annotation>
        <xs:documentation>OutputFormat Default: XML</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="DocumentFormatAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="typeFilter">
      <xs:annotation>
        <xs:documentation>Filter for action &lt;code&gt;list&lt;/code&gt;. Specify &lt;code&gt;FILES_ONLY&lt;/code&gt;, &lt;code&gt;FOLDERS_ONLY&lt;/code&gt; or &lt;code&gt;FILES_AND_FOLDERS&lt;/code&gt;. Default: FILES_ONLY</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="TypeFilterAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FileSystemSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="FileSystemSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="CmisSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="CmisSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.cmis.CmisSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="CmisSenderDeclaredAttributeGroup">
    <xs:attribute name="action" use="required">
      <xs:annotation>
        <xs:documentation>Specifies action to perform</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="CmisActionAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="maxConnections" type="frankInt">
      <xs:annotation>
        <xs:documentation>The maximum number of concurrent connections Default: 10</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>READ_TIMEOUT timeout in MS.
 Defaults to 10000, inherited from HttpSender#setTimeout. Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>URL to connect to</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="repository" type="xs:string">
      <xs:annotation>
        <xs:documentation>Repository ID</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain credentials for authentication to host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Username used in authentication to host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password used in authentication to host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="bindingType" use="required">
      <xs:annotation>
        <xs:documentation>BindingType CMIS protocol to use</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="BindingTypesAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="fileSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;action=create&lt;/code&gt; the sessionKey that contains the file to use. If &lt;code&gt;action=get&lt;/code&gt; and &lt;code&gt;getProperties=true&lt;/code&gt; the sessionKey to store the result in</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filenameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;action=create&lt;/code&gt; the session key that contains the name of the file to use. If not set, the value of the property &lt;code&gt;filename&lt;/code&gt; from the input message is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="defaultMediaType" type="xs:string">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;action=create&lt;/code&gt; the mime type used to store the document when it's not set in the input message by a property Default: 'application/octet-stream'</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getProperties" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(Only used when &lt;code&gt;action=get&lt;/code&gt;). If true, the content of the document is put to &lt;code&gt;FileSessionKey&lt;/code&gt; and all document properties are put in the result as a xml string Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getDocumentContent" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(Only used when &lt;code&gt;action=get&lt;/code&gt;). If true, the attachment for the document is the sender result or, if set, stored in &lt;code&gt;fileSessionKey&lt;/code&gt;. If false, only the properties are returned Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useRootFolder" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(Only used when &lt;code&gt;action=create&lt;/code&gt;). If true, the document is created in the root folder of the repository. Otherwise the document is created in the repository Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keepSession" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, the session is not closed at the end and it will be used in the next call Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="overrideEntryPointWSDL" type="xs:string">
      <xs:annotation>
        <xs:documentation>Override entrypoint WSDL by reading it from the classpath, overrides url attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystore" type="xs:string">
      <xs:annotation>
        <xs:documentation>Resource url to keystore or certificate. If none specified, the JVMs default keystore will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType">
      <xs:annotation>
        <xs:documentation>Type of keystore Default: pkcs12</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="keystoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used to obtain keystore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to access keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias to obtain specific certificate or key in keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>Resource url to truststore. If none specified, the JVMs default truststore will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType">
      <xs:annotation>
        <xs:documentation>Type of truststore Default: jks</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used to obtain truststore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to access truststore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Trust manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the hostname in the certificate will be checked against the actual hostname of the peer</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowSelfSignedCertificates" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, self signed certificates are accepted Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCertificateExpiredException" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, CertificateExpiredExceptions are ignored Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy host url</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="frankInt">
      <xs:annotation>
        <xs:documentation>Proxy host port Default: 80</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain credentials for authentication to proxy</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy Username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy Password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CmisSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="CmisSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="CommandSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="CommandSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.CommandSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="CommandSenderDeclaredAttributeGroup">
    <xs:attribute name="command" type="xs:string">
      <xs:annotation>
        <xs:documentation>The command to be executed. Note: Executing a command in WAS requires &amp;lt;&amp;lt;ALL FILES&amp;gt;&amp;gt; execute permission to avoid that provide the absolute path of the command. Absolute path can be found with the following command 'which -a {commandName}'</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of seconds to execute a command. If the limit is exceeded, a TimeoutException is thrown. A value of 0 means execution time is not limited Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commandWithArguments" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>In case the command that will be executed contains arguments then this flag should be set to true Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CommandSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="CommandSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="DelaySenderType">
    <xs:attributeGroup ref="DelaySenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.DelaySender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="DelaySenderDeclaredAttributeGroup">
    <xs:attribute name="delayTime" type="frankInt">
      <xs:annotation>
        <xs:documentation>The time &lt;i&gt;in milliseconds&lt;/i&gt; the thread will be put to sleep Default: 5000 [ms]</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="DelaySenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="DelaySenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="DirectQuerySenderType">
    <xs:group ref="JdbcSenderBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="JdbcQuerySenderBaseCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jdbc.DirectQuerySender" use="prohibited" />
  </xs:complexType>
  <xs:group name="JdbcSenderBaseDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="ParamElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="JdbcSenderBaseDeclaredAttributeGroup">
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of seconds the JDBC driver will wait for a statement object to execute. If the limit is exceeded, a TimeoutException is thrown. A value of 0 means execution time is not limited Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcSenderBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcSenderBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcFacadeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcQuerySenderBaseDeclaredAttributeGroup">
    <xs:attribute ref="packageContent" />
    <xs:attribute name="queryType">
      <xs:annotation>
        <xs:documentation>Type of query to be executed Default: OTHER</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="QueryTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute ref="scalar" />
    <xs:attribute ref="scalarExtended" />
    <xs:attribute name="maxRows" type="frankInt">
      <xs:annotation>
        <xs:documentation>The maximum number of rows to be returned from the output of &lt;code&gt;select&lt;/code&gt; queries, -1 means unlimited rows Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startRow" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of the first row to be returned from the output of &lt;code&gt;select&lt;/code&gt; queries. Rows before this are skipped from the output. Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="nullValue" />
    <xs:attribute ref="resultQuery" />
    <xs:attribute name="columnsReturned" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of columns whose values are to be returned. Works only if the driver implements jdbc 3.0 getGeneratedKeys().
 Note: not all drivers support multiple values and returned field names may vary between drivers.
 Works for H2 and Oracle. Could work for MS_SQL with a single identity column, with name GENERATED_KEYS, if a identity has been generated. Not supported for other DBMSes.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="useNamedParams" />
    <xs:attribute ref="includeFieldDefinition" />
    <xs:attribute ref="trimSpaces" />
    <xs:attribute name="rowIdSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If specified, the rowid of the processed row is put in the pipelinesession under the specified key (only applicable for &lt;code&gt;querytype=other&lt;/code&gt;). &lt;b&gt;Note:&lt;/b&gt; If multiple rows are processed a SqlException is thrown.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sqlDialect" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the SQL dialect in which the queries are written and should be translated from to the actual SQL dialect</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockRows" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>When set &lt;code&gt;true&lt;/code&gt;, exclusive row-level locks are obtained on all the rows identified by the select statement (e.g. by appending ' FOR UPDATE NOWAIT SKIP LOCKED' to the end of the query) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWait" type="frankInt">
      <xs:annotation>
        <xs:documentation>when set and &gt;=0, ' FOR UPDATE WAIT #' is used instead of ' FOR UPDATE NOWAIT SKIP LOCKED' Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="synchronous" />
    <xs:attribute name="blobColumn" type="frankInt">
      <xs:annotation>
        <xs:documentation>Only for querytype 'updateBlob': column that contains the BLOB to be updated Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>For querytype 'updateBlob': key of session variable that contains the data (String or InputStream) to be loaded to the BLOB. When empty, the input of the pipe, which then must be a String, is used.
 For querytype 'select': key of session variable that contains the OutputStream, Writer or Filename to write the BLOB to</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is stored compressed in the database Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobBase64Direction">
      <xs:annotation>
        <xs:documentation>controls whether the streamed blobdata will need to be base64 &lt;code&gt;encode&lt;/code&gt; or &lt;code&gt;decode&lt;/code&gt; or not.</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="DirectionAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="blobCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Charset that is used to read and write BLOBs. This assumes the blob contains character data.
 If blobCharset and blobSmartGet are not set, BLOBs are returned as bytes. Before version 7.6, blobs were base64 encoded after being read to accommodate for the fact that senders need to return a String. This is no longer the case</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Controls automatically whether blobdata is stored compressed and/or serialized in the database Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobColumn" type="frankInt">
      <xs:annotation>
        <xs:documentation>Only for querytype 'updateClob': column that contains the CLOB to be updated Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>For querytype 'updateClob': key of session variable that contains the CLOB (String or InputStream) to be loaded to the CLOB. When empty, the input of the pipe, which then must be a String, is used.
 For querytype 'select': key of session variable that contains the OutputStream, Writer or Filename to write the CLOB to</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="closeOutputstreamOnExit" />
    <xs:attribute ref="streamCharset" />
    <xs:attribute name="avoidLocking" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, then select queries are executed in a way that avoids taking locks, e.g. with isolation mode 'read committed' instead of 'repeatable read'. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="prettyPrint" />
    <xs:attribute name="outputFormat">
      <xs:annotation>
        <xs:documentation>The type of output. If not set then defaults to old-style XML. If set to XML, new-style XML is used. EXPERIMENTAL: datatypes like numbers are not yet rendered correctly Default: false</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="DocumentFormatAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcQuerySenderBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcQuerySenderBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcSenderBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="EchoSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="EchoSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.EchoSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="EchoSenderDeclaredAttributeGroup">
    <xs:attribute name="synchronous" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>hack to allow to introduce a correlationid Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="EchoSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="EchoSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="EsbJmsSenderType">
    <xs:group ref="JmsSenderDeclaredChildGroup" />
    <xs:attributeGroup ref="EsbJmsSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.esb.EsbJmsSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="EsbJmsSenderDeclaredAttributeGroup">
    <xs:attribute name="messageProtocol">
      <xs:annotation>
        <xs:documentation>protocol of ESB service to be called</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="MessageProtocolAttributeValuesType_2 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>receiver timeout, in milliseconds Default: 20000 (20s)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deliveryMode">
      <xs:annotation>
        <xs:documentation>if messageProtocol=&lt;code&gt;RR&lt;/code&gt; then &lt;code&gt;deliveryMode&lt;/code&gt; defaults to &lt;code&gt;NON_PERSISTENT&lt;/code&gt; Default: not set by application</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="DeliveryModeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="replyTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>if messageProtocol=&lt;code&gt;RR&lt;/code&gt; then &lt;code&gt;replyTimeout&lt;/code&gt; defaults to &lt;code&gt;timeout&lt;/code&gt; Default: 5000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>if messageProtocol=&lt;code&gt;RR&lt;/code&gt; then &lt;code&gt;synchronous&lt;/code&gt; defaults to &lt;code&gt;true&lt;/code&gt; Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapAction" type="xs:string">
      <xs:annotation>
        <xs:documentation>if messageProtocol=&lt;code&gt;RR&lt;/code&gt; then if &lt;code&gt;soapAction&lt;/code&gt; is empty then it is derived from the element MessageHeader/To/Location in the SOAP header of the input message (if $messagingLayer='P2P' then '$applicationFunction' else '$operationName_$operationVersion)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="EsbJmsSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="EsbJmsSenderDeclaredAttributeGroup" />
    <xs:attribute ref="destinationParam" />
    <xs:attribute ref="replyToName" />
    <xs:attribute ref="linkMethod" />
    <xs:attribute ref="messageType" />
    <xs:attribute ref="priority" />
    <xs:attribute name="soap" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, messages sent are put in a SOAP envelope Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="encodingStyleURI" />
    <xs:attribute ref="serviceNamespaceURI" />
    <xs:attribute ref="soapHeaderParam" />
    <xs:attribute ref="replySoapHeaderSessionKey" />
    <xs:attribute ref="responseHeadersToSessionKeys" />
    <xs:attributeGroup ref="JMSFacadeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JmsSenderType">
    <xs:group ref="JmsSenderDeclaredChildGroup" />
    <xs:attributeGroup ref="JmsSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jms.JmsSender" use="prohibited" />
  </xs:complexType>
  <xs:group name="JmsSenderDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="ParamElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="JmsSenderDeclaredAttributeGroup">
    <xs:attribute ref="destinationParam" />
    <xs:attribute name="synchronous" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the sender operates in RR mode: A reply is expected, either on the queue specified in &lt;code&gt;replyToName&lt;/code&gt;, or on a dynamically generated temporary queue Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="replyToName" />
    <xs:attribute ref="linkMethod" />
    <xs:attribute name="replyTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>(Only for &lt;code&gt;synchronous=true&lt;/code&gt;). Maximum time in ms to wait for a reply. 0 means no timeout. Default: 5000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="messageType" />
    <xs:attribute name="deliveryMode">
      <xs:annotation>
        <xs:documentation>Controls mode that messages are sent with Default: not set by application</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="DeliveryModeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute ref="priority" />
    <xs:attribute name="soap" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, messages sent are put in a SOAP envelope Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="encodingStyleURI" />
    <xs:attribute ref="serviceNamespaceURI" />
    <xs:attribute name="soapAction" type="xs:string">
      <xs:annotation>
        <xs:documentation>SOAPAction string sent as message property</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="soapHeaderParam" />
    <xs:attribute ref="replySoapHeaderSessionKey" />
    <xs:attribute ref="responseHeadersToSessionKeys" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JmsSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="JmsSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JMSFacadeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ExchangeFolderSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="ExchangeFolderSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.ExchangeFolderSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ExchangeFolderSenderDeclaredAttributeGroup">
    <xs:attribute name="mailAddress" type="xs:string">
      <xs:annotation>
        <xs:documentation>The mail address of the mailbox connected to (also used for auto discovery)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>Url of the Exchange server. Set to e.g. https://outlook.office365.com/EWS/Exchange.asmx to speed up startup, leave empty to use autodiscovery</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clientId" type="xs:string">
      <xs:annotation>
        <xs:documentation>Client ID that represents a registered application in Azure AD which could be found at Azure AD -&gt; App Registrations -&gt; MyApp -&gt; Overview.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clientSecret" type="xs:string">
      <xs:annotation>
        <xs:documentation>Client secret that belongs to registered application in Azure AD which could be found at Azure AD -&gt; App Registrations -&gt; MyApp -&gt; Certificates and Secrets</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tenantId" type="xs:string">
      <xs:annotation>
        <xs:documentation>Tenant ID that represents the tenant in which the registered application exists within Azure AD which could be found at Azure AD -&gt; App Registrations -&gt; MyApp -&gt; Overview.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain client ID and secret or username and password for authentication to Exchange mail server.
 If the attribute tenantId is empty, the deprecated Basic Authentication method is used.
 If the attribute tenantId is not empty, the username and password are treated as the client ID and secret.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="baseFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder (subfolder of root or of inbox) to look for mails. If empty, the inbox folder is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filter" type="xs:string">
      <xs:annotation>
        <xs:documentation>If empty, all mails are retrieved. If set to &lt;code&gt;NDR&lt;/code&gt; only Non-Delivery Report mails ('bounces') are retrieved</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyAddressFields" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of fields to try as response address Default: replyTo,from,sender,Return-Path</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="frankInt">
      <xs:annotation>
        <xs:documentation>proxy port Default: 8080</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy authAlias</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyDomain" type="xs:string">
      <xs:annotation>
        <xs:documentation>proxy domain</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mailboxObjectSeparator" type="xs:string">
      <xs:annotation>
        <xs:documentation>Separator character used when working with multiple mailboxes, specified before the separator in the object name &lt;code&gt;test@organisation.com|My sub folder&lt;/code&gt; or &lt;code&gt;test@organisation.com|AAMkADljZDMxYzIzLTFlMjYtNGY4Mi1hM2Y1LTc2MjE5ZjIyZmMyNABGAAAAAAAu/9EmV5M6QokBRZwID1Q6BwDXQXY+F44hRbDfTB9v8jRfAAAEUqUVAADXQXY+F44hRbDfTB9v8jRfAAKA4F+pAAA=&lt;/code&gt;.
 Please consider when moving emails across mailboxes that there will be a null value returned instead of the newly created identifier. Default: |</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystore" type="xs:string">
      <xs:annotation>
        <xs:documentation>Resource url to keystore or certificate. If none specified, the JVMs default keystore will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType">
      <xs:annotation>
        <xs:documentation>Type of keystore Default: pkcs12</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="keystoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used to obtain keystore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to access keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias to obtain specific certificate or key in keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>Resource url to truststore. If none specified, the JVMs default truststore will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType">
      <xs:annotation>
        <xs:documentation>Type of truststore Default: jks</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used to obtain truststore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to access truststore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Trust manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the hostname in the certificate will be checked against the actual hostname of the peer</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowSelfSignedCertificates" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, self signed certificates are accepted Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCertificateExpiredException" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, CertificateExpiredExceptions are ignored Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ExchangeFolderSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="ExchangeFolderSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FileSystemSenderWithAttachmentsType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.filesystem.FileSystemSenderWithAttachments" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="FixedQuerySenderType">
    <xs:group ref="JdbcSenderBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedQuerySenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jdbc.FixedQuerySender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="FixedQuerySenderDeclaredAttributeGroup">
    <xs:attribute name="query" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>The SQL query text to be executed each time sendMessage() is called</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="batchSize" />
  </xs:attributeGroup>
  <xs:attributeGroup name="FixedQuerySenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="FixedQuerySenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcQuerySenderBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FixedResultSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedResultSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.FixedResultSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="FixedResultSenderDeclaredAttributeGroup">
    <xs:attribute name="substituteVars" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>should values between ${ and } be resolved from the pipelinesession Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filename" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the file containing the result message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="returnString" type="xs:string">
      <xs:annotation>
        <xs:documentation>returned message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceFrom" type="xs:string" />
    <xs:attribute name="replaceTo" type="xs:string" />
    <xs:attribute name="styleSheetName" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="FixedResultSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="FixedResultSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FrankSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="FrankSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.FrankSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="FrankSenderDeclaredAttributeGroup">
    <xs:attribute name="synchronous" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Synchronous or Asynchronous execution of the call to other adapter or system.
 &lt;br/&gt;
 Set to &lt;code&gt;false&lt;/code&gt; to make the call asynchronously. This means that the current adapter
 continues with the next pipeline and the result of the sub-adapter that was called, or other system that was called,
 is ignored. Instead, the input message will be returned as the result message. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scope">
      <xs:annotation>
        <xs:documentation>Scope decides if the FrankSender calls another adapter, or another Java program running in the same JVM.
 &lt;br/&gt;
 It is possible to set this via a parameter. If the parameter is defined but the value at runtime
 is empty, then the value set via this attribute will be used as default. Default: ADAPTER</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="ScopeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="target" type="xs:string">
      <xs:annotation>
        <xs:documentation>Target: service-name of service in other application that should be called, or name of adapter to be called.
 If the adapter is in another configuration, prefix the adapter name with the name of that configuration and a slash ("{@code /}").
 &lt;br/&gt;
 It is possible to set a target at runtime via a parameter.
 &lt;br/&gt;
 If a parameter with name target exists but has no value, then the target configured
 via the attribute will be used as a default.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="returnedSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of keys of session variables that will be returned to caller, for correct results as well as for erroneous results.
 The set of available sessionKeys to be returned might be limited by the returnedSessionKeys attribute of the corresponding JavaListener.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FrankSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="FrankSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FtpFileSystemSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="FtpFileSystemSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.FtpFileSystemSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="FtpFileSystemSenderDeclaredAttributeGroup">
    <xs:attribute name="remoteDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>pathname of the file or directory to list. Default: Home folder of the ftp user</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="host" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name or ip address of remote host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="frankInt">
      <xs:annotation>
        <xs:documentation>Port number of remote host Default: 21</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the alias to obtain credentials to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the user to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy hostname</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="frankInt">
      <xs:annotation>
        <xs:documentation>Proxy port Default: 1080</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ftpType">
      <xs:annotation>
        <xs:documentation>FTP protocol to use Default: FTP</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="FtpTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="fileType">
      <xs:simpleType>
        <xs:union memberTypes="FileTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="passive" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, passive ftp is used: before data is sent, a pasv command is issued, and the connection is set up by the server Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyTransportType">
      <xs:annotation>
        <xs:documentation>(ftps) Transport type in case of sftp Default: SOCKS5</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="TransportTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="keystore" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Resource url to keystore or certificate to be used for authentication. If none specified, the JVMs default keystore will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType">
      <xs:annotation>
        <xs:documentation>(ftps) Type of keystore Default: pkcs12</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="keystoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Authentication alias used to obtain keystore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Default password to access keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Alias to obtain specific certificate or key in keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Authentication alias to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Default password to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Key manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Resource url to truststore to be used for authenticating peer. If none specified, the JVMs default truststore will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType">
      <xs:annotation>
        <xs:documentation>(ftps) Type of truststore Default: jks</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Authentication alias used to obtain truststore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Default password to access truststore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) Trust manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(ftps) If &lt;code&gt;true&lt;/code&gt;, the hostname in the certificate will be checked against the actual hostname of the peer</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowSelfSignedCertificates" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(ftps) If &lt;code&gt;true&lt;/code&gt;, self signed certificates are accepted Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCertificateExpiredException" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(ftps) If &lt;code&gt;true&lt;/code&gt;, CertificateExpiredExceptions are ignored Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prot">
      <xs:annotation>
        <xs:documentation>Sets the &lt;code&gt;Data Channel Protection Level&lt;/code&gt;. Default: C</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="ProtAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FtpFileSystemSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="FtpFileSystemSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="HttpSenderType">
    <xs:group ref="HttpSenderBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="HttpSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.http.HttpSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="HttpSenderDeclaredAttributeGroup">
    <xs:attribute name="postType">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;methodType&lt;/code&gt;=&lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt; or &lt;code&gt;PATCH&lt;/code&gt;, the type of post request Default: RAW</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="PostTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="firstBodyPartName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Only used when &lt;code&gt;methodType=POST&lt;/code&gt; and &lt;code&gt;postType=URLENCODED&lt;/code&gt;, &lt;code&gt;FORM-DATA&lt;/code&gt; or &lt;code&gt;MTOM&lt;/code&gt;) Prepends a new BodyPart using the specified name and uses the input of the Sender as content</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartXmlSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set and &lt;code&gt;methodType=POST&lt;/code&gt; and &lt;code&gt;paramsInUrl=false&lt;/code&gt;, a multipart/form-data entity is created instead of a request body.
 For each part element in the session key a part in the multipart entity is created. Part elements can contain the following attributes:
 &lt;ul&gt;
 &lt;li&gt;name: optional, used as 'filename' in Content-Disposition&lt;/li&gt;
 &lt;li&gt;sessionKey: mandatory, refers to contents of part&lt;/li&gt;
 &lt;li&gt;mimeType: optional MIME type&lt;/li&gt;
 &lt;/ul&gt;
 The name of the part is determined by the name attribute, unless that is empty, or the contents is binary. In those cases the sessionKey name is used as name of the part.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mtomContentTransferEncoding" type="xs:string" />
    <xs:attribute name="encodeMessages" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Specifies whether messages will encoded, e.g. spaces will be replaced by '+' etc. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="treatInputMessageAsParameters" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the input will be added to the URL for &lt;code&gt;methodType=GET&lt;/code&gt;, or for &lt;code&gt;methodType=POST&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt; or
 &lt;code&gt;PATCH&lt;/code&gt; if &lt;code&gt;postType=RAW&lt;/code&gt;. This used to be the default behaviour in framework version 7.7 and earlier Default: for methodType=&lt;code&gt;GET&lt;/code&gt;: &lt;code&gt;false&lt;/code&gt;,&lt;br/&gt;for methodTypes &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt;: &lt;code&gt;true&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="HttpSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="HttpSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="HttpSenderBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="HttpSenderBaseDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="ParamElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="HttpSenderBaseDeclaredAttributeGroup">
    <xs:attribute ref="url" />
    <xs:attribute ref="urlParam" />
    <xs:attribute ref="methodType" />
    <xs:attribute ref="contentType" />
    <xs:attribute ref="charSet" />
    <xs:attribute ref="headersParams" />
    <xs:attribute ref="parametersToSkipWhenEmpty" />
    <xs:attribute ref="xhtml" />
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Only used when xHtml=&lt;code&gt;true&lt;/code&gt;) stylesheet to apply to the HTML response</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="resultStatusCodeSessionKey" />
    <xs:attribute ref="sharedResourceRef" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of the object.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="HttpSenderBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="HttpSenderBaseDeclaredAttributeGroup" />
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Timeout in ms of obtaining a connection/result. Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="maxConnections" />
    <xs:attribute ref="maxExecuteRetries" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Username used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="tokenEndpoint" />
    <xs:attribute ref="tokenExpiry" />
    <xs:attribute ref="clientAlias" />
    <xs:attribute ref="clientId" />
    <xs:attribute ref="clientSecret" />
    <xs:attribute ref="scope" />
    <xs:attribute ref="authenticatedTokenRequest" />
    <xs:attribute ref="proxyHost" />
    <xs:attribute ref="proxyPort" />
    <xs:attribute ref="proxyAuthAlias" />
    <xs:attribute ref="proxyUsername" />
    <xs:attribute ref="proxyPassword" />
    <xs:attribute ref="proxyRealm" />
    <xs:attribute ref="prefillProxyAuthCache" />
    <xs:attribute ref="disableCookies" />
    <xs:attribute ref="keystore" />
    <xs:attribute ref="keystoreType" />
    <xs:attribute ref="keystoreAuthAlias" />
    <xs:attribute ref="keystorePassword" />
    <xs:attribute ref="keyManagerAlgorithm" />
    <xs:attribute ref="keystoreAlias" />
    <xs:attribute ref="keystoreAliasAuthAlias" />
    <xs:attribute ref="keystoreAliasPassword" />
    <xs:attribute ref="truststore" />
    <xs:attribute ref="truststoreAuthAlias" />
    <xs:attribute ref="truststorePassword" />
    <xs:attribute ref="truststoreType" />
    <xs:attribute ref="trustManagerAlgorithm" />
    <xs:attribute ref="verifyHostname" />
    <xs:attribute ref="allowSelfSignedCertificates" />
    <xs:attribute ref="ignoreCertificateExpiredException" />
    <xs:attribute ref="followRedirects" />
    <xs:attribute ref="ignoreRedirects" />
    <xs:attribute ref="staleChecking" />
    <xs:attribute ref="staleTimeout" />
    <xs:attribute ref="connectionTimeToLive" />
    <xs:attribute ref="connectionIdleTimeout" />
    <xs:attribute ref="protocol" />
    <xs:attribute ref="supportedCipherSuites" />
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:attributeGroup name="HttpSessionBaseDeclaredAttributeGroup">
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Timeout in ms of obtaining a connection/result. Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="maxConnections" />
    <xs:attribute ref="maxExecuteRetries" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Username used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="tokenEndpoint" />
    <xs:attribute ref="tokenExpiry" />
    <xs:attribute ref="clientAlias" />
    <xs:attribute ref="clientId" />
    <xs:attribute ref="clientSecret" />
    <xs:attribute ref="scope" />
    <xs:attribute ref="authenticatedTokenRequest" />
    <xs:attribute ref="proxyHost" />
    <xs:attribute ref="proxyPort" />
    <xs:attribute ref="proxyAuthAlias" />
    <xs:attribute ref="proxyUsername" />
    <xs:attribute ref="proxyPassword" />
    <xs:attribute ref="proxyRealm" />
    <xs:attribute ref="prefillProxyAuthCache" />
    <xs:attribute ref="disableCookies" />
    <xs:attribute ref="keystore" />
    <xs:attribute ref="keystoreType" />
    <xs:attribute ref="keystoreAuthAlias" />
    <xs:attribute ref="keystorePassword" />
    <xs:attribute ref="keyManagerAlgorithm" />
    <xs:attribute ref="keystoreAlias" />
    <xs:attribute ref="keystoreAliasAuthAlias" />
    <xs:attribute ref="keystoreAliasPassword" />
    <xs:attribute ref="truststore" />
    <xs:attribute ref="truststoreAuthAlias" />
    <xs:attribute ref="truststorePassword" />
    <xs:attribute ref="truststoreType" />
    <xs:attribute ref="trustManagerAlgorithm" />
    <xs:attribute ref="verifyHostname" />
    <xs:attribute ref="allowSelfSignedCertificates" />
    <xs:attribute ref="ignoreCertificateExpiredException" />
    <xs:attribute ref="followRedirects" />
    <xs:attribute ref="ignoreRedirects" />
    <xs:attribute ref="staleChecking" />
    <xs:attribute ref="staleTimeout" />
    <xs:attribute ref="connectionTimeToLive" />
    <xs:attribute ref="connectionIdleTimeout" />
    <xs:attribute ref="protocol" />
    <xs:attribute ref="supportedCipherSuites" />
    <xs:attribute name="name" type="xs:string" />
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="IMSSenderType">
    <xs:group ref="JmsSenderDeclaredChildGroup" />
    <xs:attributeGroup ref="IMSSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.ibm.IMSSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="IMSSenderDeclaredAttributeGroup">
    <xs:attribute name="transactionCode" type="xs:string">
      <xs:annotation>
        <xs:documentation>The transaction code that should be added in the header, must be 8 characters</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="IMSSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="IMSSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JmsSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="IbisJavaSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="IbisJavaSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.IbisJavaSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="IbisJavaSenderDeclaredAttributeGroup">
    <xs:attribute name="serviceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>ServiceName of the JavaListener that should be called.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of session variable to specify ServiceName of the JavaListener that should be called.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="returnedSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of keys of session variables that will be returned to caller, for correct results as well as for erroneous results.
 The set of available sessionKeys to be returned might be limited by the returnedSessionKeys attribute of the corresponding JavaListener.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dispatchType" type="xs:string">
      <xs:annotation>
        <xs:documentation>Set to 'DLL' to make the dispatcher communicate with a DLL set on the classpath</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="IbisJavaSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="IbisJavaSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="IbisLocalSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="IbisLocalSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.IbisLocalSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="IbisLocalSenderDeclaredAttributeGroup">
    <xs:attribute name="javaListener" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the JavaListener that should be called (will be ignored when javaListenerSessionKey is set)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="javaListenerSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the sessionKey which holds the name of the JavaListener that should be called</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="returnedSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of keys of session variables that will be returned to caller, for correct results as well as for erroneous results.
 The set of available sessionKeys to be returned might be limited by the returnedSessionKeys attribute of the corresponding JavaListener.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;false&lt;/code&gt;, the call is made asynchronously. This implies &lt;code&gt;isolated=true&lt;/code&gt; Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="isolated" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the call is made in a separate thread, possibly using separate transaction Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkDependency" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the sender waits upon open until the called JavaListener is opened Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dependencyTimeOut" type="frankInt">
      <xs:annotation>
        <xs:documentation>Maximum time (in seconds) the sender waits for the listener to start. A value of -1 indicates to wait indefinitely Default: 60</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwJavaListenerNotFoundException" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;false&lt;/code&gt;, the xml-string \"&amp;lt;error&amp;gt;could not find JavaListener [...]&amp;lt;/error&amp;gt;\" is returned instead of throwing a senderexception Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="IbisLocalSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="IbisLocalSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="IdinSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="IdinSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.idin.IdinSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="IdinSenderDeclaredAttributeGroup">
    <xs:attribute name="action">
      <xs:simpleType>
        <xs:union memberTypes="ActionAttributeValuesType_2 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="merchantID" type="xs:string">
      <xs:annotation>
        <xs:documentation>This is the contract number for iDIN the Merchant received from its Acquirer after registration,
 and is used to unambiguously identify the Merchant. This number is 10-digits long, where the
 first four digits are equal to the AcquirerID.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="merchantSubID" type="frankInt">
      <xs:annotation>
        <xs:documentation>The SubID that uniquely defines the name and address of the Merchant to be used for iDIN,
 if operating under different brands or trading entities. The Merchant obtains the SubID
 from its Acquirer after registration for iDIN. A Merchant can request permission from
 the Acquirer to use one or more SubIDs.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="merchantReturnUrl" type="xs:string">
      <xs:annotation>
        <xs:documentation>The web address provided by the Merchant in the transaction request that is used to redirect the
 Consumer back to the Merchant after completing the authentication in the Issuer domain. The URL
 does not necessarily begin with http:// or https://, it can also start with an app handler
 e.g. companyname-nlservice://.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="acquirerDirectoryUrl" type="xs:string" />
    <xs:attribute name="acquirerTransactionUrl" type="xs:string" />
    <xs:attribute name="acquirerStatusUrl" type="xs:string" />
    <xs:attribute name="keyStoreLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>The Java iDIN Software Library needs to access a keystore located in the Java classpath to
 store all the required certificates</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyStorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>The password used to access the keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyStoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>The AuthAlias used to access the keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="merchantCertificateAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>This is the certificate owned by the Merchant. It's the private certificate
 used to sign messages sent by the Merchant to the Acquirer's Routing Service platform. Its public
 key is also used by the Acquirer to authenticate incoming messages from the Merchant. The
 Merchant certificate must be in PKCS#12 format which has the extension .p12 or .pfx</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="merchantCertificatePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>In case the merchant certificate has been password protected</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="merchantCertificateAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>In case the merchant certificate has been password protected</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="acquirerCertificateAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>This is the public certificate used to authenticate incoming messages from the Acquirer. The library
 only needs its public key. The public certificate must be in PEM format (base64 ASCII) and typically
 has the file extension .cer,.crt or .pem.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="acquirerAlternativeCertificateAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>This is the public certificate used to authenticate incoming messages from the Acquirer. The library
 only needs its public key. The public certificate must be in PEM format (base64 ASCII) and typically
 has the file extension .cer,.crt or .pem.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="samlCertificateAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>This is the certificate owned by the Merchant. Its public key is used by the Issuer to encrypt information.
 The Merchant can then use the private key to decrypt that information. The SAML certificate must be in
 PKCS#12 format which has the extension .p12 or .pfx;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sAMLCertificatePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>In case the SAML certificate has been password protected</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sAMLCertificateAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>In case the SAML certificate has been password protected</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logsEnabled" type="frankBoolean" />
    <xs:attribute name="serviceLogsEnabled" type="frankBoolean" />
    <xs:attribute name="serviceLogsLocation" type="xs:string" />
    <xs:attribute name="serviceLogsPattern" type="xs:string" />
    <xs:attribute name="tls12Enabled" type="frankBoolean" />
    <xs:attribute name="merchantReturnUrlSessionKey" type="xs:string" />
    <xs:attribute name="configurationXML" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Load configuration from XML. Attributes may overwrite this 'default'.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="IdinSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="IdinSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="IdocSenderType">
    <xs:group ref="SapSenderBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="SapSenderBaseCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.sap.IdocSender" use="prohibited" />
  </xs:complexType>
  <xs:group name="SapSenderBaseDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="ParamElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="SapSenderBaseDeclaredAttributeGroup">
    <xs:attribute name="luwHandleSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key in which LUW information is stored. If set, actions that share a LUW-handle will be executed using the same destination. Can only be used for synchronous functions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sapSystemNameParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the parameter used to indicate the name of the SapSystem used by this object if the attribute &lt;code&gt;sapSystemName&lt;/code&gt; is empty Default: sapSystemName</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SapSenderBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="SapSenderBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SapFunctionFacadeDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ImapSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="ImapSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.ImapSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ImapSenderDeclaredAttributeGroup">
    <xs:attribute name="host" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>The hostname of the IMAP server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="frankInt">
      <xs:annotation>
        <xs:documentation>The port of the IMAP server Default: 993</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain accessToken or username and password for authentication to Exchange mail server.
 If the alias refers to a combination of a username and a password, the deprecated Basic Authentication method is used.
 If the alias refers to a password without a username, the password is treated as the accessToken.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Username for authentication to mail server.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password for authentication to mail server.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="baseFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder (subfolder of root or of inbox) to look for mails. If empty, the inbox folder is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyAddressFields" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of fields to try as response address Default: replyTo,from,sender,Return-Path</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ImapSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="ImapSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JavascriptSenderType">
    <xs:group ref="JavascriptSenderCumulativeChildGroup" />
    <xs:attributeGroup ref="JavascriptSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.JavascriptSender" use="prohibited" />
  </xs:complexType>
  <xs:group name="JavascriptSenderDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="SenderElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:group name="JavascriptSenderCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="JavascriptSenderDeclaredChildGroup" />
      <xs:group ref="SenderWrapperBaseCumulativeChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="JavascriptSenderDeclaredAttributeGroup">
    <xs:attribute name="jsFileName" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>the name of the javascript file containing the functions to run</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsFunctionName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the javascript function that will be called (first) Default: main</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="engineName">
      <xs:annotation>
        <xs:documentation>the name of the JavaScript engine to use. Default: J2V8</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="JavaScriptEnginesAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JavascriptSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="JavascriptSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderSeriesCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SenderSeriesType">
    <xs:group ref="SenderSeriesCumulativeChildGroup" />
    <xs:attributeGroup ref="SenderSeriesCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.SenderSeries" use="prohibited" />
  </xs:complexType>
  <xs:group name="SenderSeriesDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="SenderElementGroup" minOccurs="1" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:group name="SenderSeriesCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="SenderSeriesDeclaredChildGroup" />
      <xs:group ref="SenderWrapperBaseCumulativeChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="SenderSeriesDeclaredAttributeGroup">
    <xs:attribute name="synchronous" type="frankBoolean" />
  </xs:attributeGroup>
  <xs:attributeGroup name="SenderSeriesCumulativeAttributeGroup">
    <xs:attributeGroup ref="SenderSeriesDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderWrapperBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="SenderWrapperBaseDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="CacheElementGroup" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:group name="SenderWrapperBaseCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="SenderWrapperBaseDeclaredChildGroup" />
      <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="SenderWrapperBaseDeclaredAttributeGroup">
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, input is taken from this session key, instead of regular input</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, this fixed value is taken as input, instead of regular input</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the result is stored under this session key</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeInputInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the input is stored under this session key</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SenderWrapperBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="SenderWrapperBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JsonXsltSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="JsonXsltSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.JsonXsltSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="JsonXsltSenderDeclaredAttributeGroup">
    <xs:attribute name="jsonResult" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>When &lt;code&gt;true&lt;/code&gt;, the xml result of the transformation is converted back to json Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace definitions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt; definitions Default: j=http://www.w3.org/2013/XSL/json</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JsonXsltSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="JsonXsltSenderDeclaredAttributeGroup" />
    <xs:attribute name="streamingXslt" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, then this sender will process the XSLT while streaming in a different thread. Can be used to switch streaming off for debugging purposes Default: set by appconstant xslt.streaming.default</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Location of stylesheet to apply to the input message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key to retrieve stylesheet location. Overrides stylesheetName or xpathExpression attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetCacheSize" type="frankInt">
      <xs:annotation>
        <xs:documentation>Size of cache of stylesheets retrieved from styleSheetNameSessionKey Default: 100</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alternatively: XPath-expression to create stylesheet from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Omit the XML declaration on top of the output. If not set, the value specified in the stylesheet is followed Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="disableOutputEscaping" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, any output is reparsed before being handled as XML again. If not set, the stylesheet is searched for &lt;code&gt;@disable-output-escaping='yes'&lt;/code&gt; and the value is set accordingly Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType">
      <xs:annotation>
        <xs:documentation>For xpathExpression only Default: text</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="OutputTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="indentXml" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, result is pretty-printed. If not set, the value specified in the stylesheet is followed Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNamespaces" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed before transformation Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="handleLexicalEvents" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the transformer is enabled to handle lexical events, allowing it for example to process comments and to distinghuish CDATA from escaped text.
 Beware that this option can cause spurious NullPointerExceptions due to a race condition in streaming XSLT 1.0 processing in Xalan 2.7.2 Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipEmptyTags" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; empty tags in the output are removed after transformation Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xsltVersion" type="frankInt">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt; a Saxon (net.sf.saxon) xslt processor 2.0 or 3.0 respectively will be used, otherwise xslt processor 1.0 (org.apache.xalan). &lt;code&gt;0&lt;/code&gt; will auto-detect Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="debugInput" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XsltSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="XsltSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.XsltSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="XsltSenderDeclaredAttributeGroup">
    <xs:attribute name="streamingXslt" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, then this sender will process the XSLT while streaming in a different thread. Can be used to switch streaming off for debugging purposes Default: set by appconstant xslt.streaming.default</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Location of stylesheet to apply to the input message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key to retrieve stylesheet location. Overrides stylesheetName or xpathExpression attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetCacheSize" type="frankInt">
      <xs:annotation>
        <xs:documentation>Size of cache of stylesheets retrieved from styleSheetNameSessionKey Default: 100</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alternatively: XPath-expression to create stylesheet from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Omit the XML declaration on top of the output. If not set, the value specified in the stylesheet is followed Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="disableOutputEscaping" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, any output is reparsed before being handled as XML again. If not set, the stylesheet is searched for &lt;code&gt;@disable-output-escaping='yes'&lt;/code&gt; and the value is set accordingly Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions. For some other use cases (NOT xpathExpression), one entry can be without a prefix, that will define the default namespace.
 If left empty, an the xpathExpression will match any namespace</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType">
      <xs:annotation>
        <xs:documentation>For xpathExpression only Default: text</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="OutputTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="indentXml" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, result is pretty-printed. If not set, the value specified in the stylesheet is followed Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNamespaces" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed before transformation Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="handleLexicalEvents" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the transformer is enabled to handle lexical events, allowing it for example to process comments and to distinghuish CDATA from escaped text.
 Beware that this option can cause spurious NullPointerExceptions due to a race condition in streaming XSLT 1.0 processing in Xalan 2.7.2 Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipEmptyTags" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; empty tags in the output are removed after transformation Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xsltVersion" type="frankInt">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt; a Saxon (net.sf.saxon) xslt processor 2.0 or 3.0 respectively will be used, otherwise xslt processor 1.0 (org.apache.xalan). &lt;code&gt;0&lt;/code&gt; will auto-detect Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="debugInput" />
  </xs:attributeGroup>
  <xs:attributeGroup name="XsltSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="XsltSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LdapSenderType">
    <xs:group ref="LdapSenderDeclaredChildGroup" />
    <xs:attributeGroup ref="LdapSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.ldap.LdapSender" use="prohibited" />
  </xs:complexType>
  <xs:group name="LdapSenderDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="ParamElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="LdapSenderDeclaredAttributeGroup">
    <xs:attribute name="operation">
      <xs:annotation>
        <xs:documentation>Specifies LDAP operation to perform Default: read</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="OperationAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="ldapProviderURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>URL to context to search in, e.g. 'ldap://edsnlm01.group.intranet/ou=people, o=ing' to search in te people group of ing cds. Used to overwrite the providerURL specified in jmsRealm.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="manipulationSubject">
      <xs:annotation>
        <xs:documentation>Specifies subject to perform operation on. Default: attribute</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="ManipulationAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="attributesToReturn" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of attributes to return. When no are attributes specified, all the attributes from the object read are returned. Default: &lt;i&gt;all attributes&lt;/i&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="usePooling" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Specifies whether connection pooling is used or not Default: true when principal not set as parameter, false otherwise</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="searchTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Specifies the time (in ms) that is spent searching for results for operation search Default: 20000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="errorSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of session variable used to store cause of errors Default: errorReason</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxEntriesReturned" type="frankInt">
      <xs:annotation>
        <xs:documentation>The maximum number of entries to be returned by a search query, or &lt;code&gt;0&lt;/code&gt; for unlimited Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="unicodePwd" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>When &lt;code&gt;true&lt;/code&gt; the attributes passed by the input xml are scanned for an attribute with id unicodepwd, when found the value of this attribute will be encoded as required by active directory (a UTF-16 encoded unicode string containing the password surrounded by quotation marks) before sending it to the LDAP server Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyNotFound" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(Only used when &lt;code&gt;operation=search/deepsearch&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt; the xml '&amp;lt;ldapresult&amp;gt;object not found&amp;lt;/ldapresult&amp;gt;' is returned instead of the PartialResultException 'unprocessed continuation reference(s)' Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LdapSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="LdapSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JndiBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LocalFileSystemSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="LocalFileSystemSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.LocalFileSystemSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="LocalFileSystemSenderDeclaredAttributeGroup">
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>Path to the folder that serves as the root of this virtual filesystem. All specifications of folders or files are relative to this root.
 When the root is left unspecified, absolute paths to files and folders can be used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createRootFolder" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Whether the LocalFileSystem tries to create the root folder if it doesn't exist yet. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LocalFileSystemSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="LocalFileSystemSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LogSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="LogSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.LogSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="LogSenderDeclaredAttributeGroup">
    <xs:attribute name="logCategory" type="xs:string">
      <xs:annotation>
        <xs:documentation>category under which messages are logged Default: name of the sender</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logLevel" type="xs:string">
      <xs:annotation>
        <xs:documentation>level on which messages are logged Default: info</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LogSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="LogSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="MQSenderType">
    <xs:group ref="JmsSenderDeclaredChildGroup" />
    <xs:attributeGroup ref="JmsSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.ibm.MQSender" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="MailSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="MailSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.MailSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="MailSenderDeclaredAttributeGroup">
    <xs:attribute name="smtpHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the SMTP-host by which the messages are to be send</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="smtpPort" type="frankInt">
      <xs:annotation>
        <xs:documentation>Port of the SMTP-host by which the messages are to be send Default: 25</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useSsl" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>When set to true, we ensure TLS is being used Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="MailSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="MailSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="MailSenderBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="MailSenderBaseDeclaredAttributeGroup">
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authAlias used to obtain credentials for authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="userId" />
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>password of userid</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="defaultSubject" />
    <xs:attribute ref="defaultFrom" />
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Timeout &lt;i&gt;in milliseconds&lt;/i&gt; for socket connection timeout and socket i/o timeouts Default: 20000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="defaultAttachmentName" />
    <xs:attribute ref="defaultMessageType" />
    <xs:attribute ref="defaultMessageBase64" />
    <xs:attribute ref="bounceAddress" />
    <xs:attribute ref="domainWhitelist" />
  </xs:attributeGroup>
  <xs:attributeGroup name="MailSenderBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="MailSenderBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="MessageStoreSenderType">
    <xs:group ref="MessageStoreSenderDeclaredChildGroup" />
    <xs:attributeGroup ref="MessageStoreSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jdbc.MessageStoreSender" use="prohibited" />
  </xs:complexType>
  <xs:group name="MessageStoreSenderDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="ParamElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="MessageStoreSenderDeclaredAttributeGroup">
    <xs:attribute name="sessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of sessionKey's to be stored together with the message. Please note: corresponding MessageStoreListener must have the same value for this attribute.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onlyStoreWhenMessageIdUnique" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the message is stored only if the MessageId is not present in the store yet. Default: &lt;code&gt;true&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotId" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Set the slotId, an identifier to keep separate the messages inserted
 by different MessageStoreSenders.
 &lt;br/&gt;
 This field should be set.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="MessageStoreSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="MessageStoreSenderDeclaredAttributeGroup" />
    <xs:attribute ref="type" />
    <xs:attribute ref="slotIdField" />
    <xs:attribute ref="typeField" />
    <xs:attribute ref="hostField" />
    <xs:attribute ref="sequenceName" />
    <xs:attribute ref="checkTable" />
    <xs:attribute ref="messageFieldType" />
    <xs:attribute ref="keyFieldType" />
    <xs:attribute ref="dateFieldType" />
    <xs:attribute ref="textFieldType" />
    <xs:attribute name="blobsCompressed" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the messages are stored compressed Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="retention" />
    <xs:attribute ref="schemaOwner4Check" />
    <xs:attribute ref="storeFullMessage" />
    <xs:attributeGroup ref="JdbcTableMessageBrowserCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JdbcTransactionalStorageType">
    <xs:attributeGroup ref="JdbcTransactionalStorageCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jdbc.JdbcTransactionalStorage" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="JdbcTransactionalStorageDeclaredAttributeGroup">
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>Set the slotId, an identifier to keep separate the messages inserted
 by different JdbcTransactionalStorage instances.
 &lt;br/&gt;
 This field is optional, unless the attribute #onlyStoreWhenMessageIdUnique is
 set to {@code true}.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="type" />
    <xs:attribute ref="slotIdField" />
    <xs:attribute ref="typeField" />
    <xs:attribute ref="hostField" />
    <xs:attribute ref="sequenceName" />
    <xs:attribute ref="checkTable" />
    <xs:attribute ref="messageFieldType" />
    <xs:attribute ref="keyFieldType" />
    <xs:attribute ref="dateFieldType" />
    <xs:attribute ref="textFieldType" />
    <xs:attribute name="blobsCompressed" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the messages are stored compressed Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="retention" />
    <xs:attribute ref="schemaOwner4Check" />
    <xs:attribute ref="storeFullMessage" />
    <xs:attribute name="onlyStoreWhenMessageIdUnique" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the message is stored only if the MessageId is not present in the store yet. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcTransactionalStorageCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcTransactionalStorageDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcTableMessageBrowserCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JdbcTableMessageBrowserType">
    <xs:attributeGroup ref="JdbcTableMessageBrowserCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jdbc.JdbcTableMessageBrowser" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="JdbcTableMessageBrowserDeclaredAttributeGroup">
    <xs:attribute name="tableName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the table messages are stored in. Default: IBISSTORE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indexName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the index, to be used in hints for query optimizer too (only for Oracle). Default: IX_IBISSTORE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcTableMessageBrowserCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcTableMessageBrowserDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcMessageBrowserCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcMessageBrowserDeclaredAttributeGroup">
    <xs:attribute name="keyField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column that contains the primary key of the table Default: MESSAGEKEY</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="idField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column messageIds are stored in Default: MESSAGEID</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column correlation-ids are stored in Default: CORRELATIONID</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column message themselves are stored in Default: MESSAGE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column the timestamp is stored in Default: MESSAGEDATE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commentField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column comments are stored in Default: COMMENTS</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expiryDateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column the timestamp for expiry is stored in Default: EXPIRYDATE</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelField" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the column labels are stored in Default: LABEL</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>Prefix to be prefixed on all database objects (tables, indices, sequences), e.g. to access a different Oracle schema</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="order">
      <xs:simpleType>
        <xs:union memberTypes="SortOrderAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>Regular expression to mask strings in the errorStore/logStore.
 Every character between to the strings in this expression will be replaced by a '*'.
 &lt;br/&gt;
 For example, the regular expression (?&amp;lt;=&amp;lt;party&amp;gt;).*?(?=&amp;lt;/party&amp;gt;) will replace every
 character between keys &amp;lt;party&amp;gt; and &amp;lt;/party&amp;gt;
 &lt;br/&gt;
 When no hideRegex is configured on the errorStore / logStore but is configured on the org.frankframework.receivers.Receiver#setHideRegex(String),
 then the Receiver's hideRegex is used for the errorStore / logStore.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod">
      <xs:annotation>
        <xs:documentation>(Only used when hideRegex is not empty) Specifies the way to hide Default: ALL</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="HideMethodAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcMessageBrowserCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcMessageBrowserDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JdbcFacadeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="MongoDbSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="MongoDbSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.mongodb.MongoDbSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="MongoDbSenderDeclaredAttributeGroup">
    <xs:attribute name="datasourceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>The MongoDB datasource Default: mongodb.datasource.default</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="database" type="xs:string">
      <xs:annotation>
        <xs:documentation>Database to connect to. Can be overridden by parameter database</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collection" type="xs:string">
      <xs:annotation>
        <xs:documentation>Collection to act upon. Can be overridden by parameter collection</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="action">
      <xs:annotation>
        <xs:documentation>Action</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="MongoActionAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="filter" type="xs:string">
      <xs:annotation>
        <xs:documentation>Filter. Can contain references to parameters between ?{ and }. Can be overridden by parameter filter</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="limit" type="frankInt">
      <xs:annotation>
        <xs:documentation>Limit to number of results returned. A value of 0 means 'no limit'. Can be overridden by parameter limit. Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="countOnly" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Only for find operation: return only the count and not the full document(s) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat">
      <xs:annotation>
        <xs:documentation>OutputFormat Default: JSON</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="DocumentFormatAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="prettyPrint" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Format the output in easy legible way (currently only for XML)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="MongoDbSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="MongoDbSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="MqttSenderType">
    <xs:group ref="MqttSenderDeclaredChildGroup" />
    <xs:attributeGroup ref="MqttFacadeDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.mqtt.MqttSender" use="prohibited" />
  </xs:complexType>
  <xs:group name="MqttSenderDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="ParamElementGroup" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:complexType name="NetStorageSenderType">
    <xs:group ref="HttpSenderBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="NetStorageSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.akamai.NetStorageSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="NetStorageSenderDeclaredAttributeGroup">
    <xs:attribute name="hashAlgorithm">
      <xs:annotation>
        <xs:documentation>Only works in combination with the UPLOAD action. If set, and not specified as parameter, the sender will sign the file to be uploaded.</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="HashAlgorithmAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="action">
      <xs:annotation>
        <xs:documentation>NetStorage action to be used</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="ActionAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="actionVersion" type="frankInt">
      <xs:annotation>
        <xs:documentation>At the time of writing, NetStorage only supports version 1 Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cpCode" type="xs:string">
      <xs:annotation>
        <xs:documentation>NetStorage CP Code of the storage group</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>The destination URL for the Akamai NetStorage. (Only the hostname, without CpCode; eq. xyz-nsu.akamaihd.net)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="nonce" type="xs:string">
      <xs:annotation>
        <xs:documentation>Login is done via a Nonce and AccessToken</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="signVersion" type="frankInt">
      <xs:annotation>
        <xs:documentation>Version to validate queries made to NetStorage backend. Default: 5</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="accessToken" type="xs:string">
      <xs:annotation>
        <xs:documentation>Login is done via a Nonce and AccessToken</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rootDir" type="xs:string">
      <xs:annotation>
        <xs:documentation>Root directory (appended to the url + cpCode)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain credentials for nonce (username) and accesstoken (password)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="NetStorageSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="NetStorageSenderDeclaredAttributeGroup" />
    <xs:attribute ref="urlParam" />
    <xs:attribute ref="methodType" />
    <xs:attribute ref="contentType" />
    <xs:attribute ref="charSet" />
    <xs:attribute ref="headersParams" />
    <xs:attribute ref="parametersToSkipWhenEmpty" />
    <xs:attribute ref="xhtml" />
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Only used when xHtml=&lt;code&gt;true&lt;/code&gt;) stylesheet to apply to the HTML response</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="resultStatusCodeSessionKey" />
    <xs:attribute ref="sharedResourceRef" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of the object.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Timeout in ms of obtaining a connection/result. Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="maxConnections" />
    <xs:attribute ref="maxExecuteRetries" />
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Username used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="tokenEndpoint" />
    <xs:attribute ref="tokenExpiry" />
    <xs:attribute ref="clientAlias" />
    <xs:attribute ref="clientId" />
    <xs:attribute ref="clientSecret" />
    <xs:attribute ref="scope" />
    <xs:attribute ref="authenticatedTokenRequest" />
    <xs:attribute ref="proxyHost" />
    <xs:attribute ref="proxyPort" />
    <xs:attribute ref="proxyAuthAlias" />
    <xs:attribute ref="proxyUsername" />
    <xs:attribute ref="proxyPassword" />
    <xs:attribute ref="proxyRealm" />
    <xs:attribute ref="prefillProxyAuthCache" />
    <xs:attribute ref="disableCookies" />
    <xs:attribute ref="keystore" />
    <xs:attribute ref="keystoreType" />
    <xs:attribute ref="keystoreAuthAlias" />
    <xs:attribute ref="keystorePassword" />
    <xs:attribute ref="keyManagerAlgorithm" />
    <xs:attribute ref="keystoreAlias" />
    <xs:attribute ref="keystoreAliasAuthAlias" />
    <xs:attribute ref="keystoreAliasPassword" />
    <xs:attribute ref="truststore" />
    <xs:attribute ref="truststoreAuthAlias" />
    <xs:attribute ref="truststorePassword" />
    <xs:attribute ref="truststoreType" />
    <xs:attribute ref="trustManagerAlgorithm" />
    <xs:attribute ref="verifyHostname" />
    <xs:attribute ref="allowSelfSignedCertificates" />
    <xs:attribute ref="ignoreCertificateExpiredException" />
    <xs:attribute ref="followRedirects" />
    <xs:attribute ref="ignoreRedirects" />
    <xs:attribute ref="staleChecking" />
    <xs:attribute ref="staleTimeout" />
    <xs:attribute ref="connectionTimeToLive" />
    <xs:attribute ref="connectionIdleTimeout" />
    <xs:attribute ref="protocol" />
    <xs:attribute ref="supportedCipherSuites" />
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="ParallelSendersType">
    <xs:group ref="ParallelSendersCumulativeChildGroup" />
    <xs:attributeGroup ref="ParallelSendersCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.ParallelSenders" use="prohibited" />
  </xs:complexType>
  <xs:group name="ParallelSendersDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="SenderElementGroup" minOccurs="1" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>
  <xs:group name="ParallelSendersCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="ParallelSendersDeclaredChildGroup" />
      <xs:group ref="SenderWrapperBaseCumulativeChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="ParallelSendersDeclaredAttributeGroup">
    <xs:attribute name="maxConcurrentThreads" type="frankInt">
      <xs:annotation>
        <xs:documentation>Set the upper limit to the amount of concurrent threads that can be run simultaneously. Use 0 to disable. Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ParallelSendersCumulativeAttributeGroup">
    <xs:attributeGroup ref="ParallelSendersDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderSeriesCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ReconnectSenderWrapperType">
    <xs:group ref="ReconnectSenderWrapperCumulativeChildGroup" />
    <xs:attributeGroup ref="SenderWrapperBaseCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.ReconnectSenderWrapper" use="prohibited" />
  </xs:complexType>
  <xs:group name="ReconnectSenderWrapperDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="SenderElementGroup" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:group name="ReconnectSenderWrapperCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="ReconnectSenderWrapperDeclaredChildGroup" />
      <xs:group ref="SenderWrapperBaseCumulativeChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:complexType name="ReloadSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="ReloadSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.ReloadSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ReloadSenderDeclaredAttributeGroup">
    <xs:attribute name="forceReload" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>reload the configuration regardless of the version Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ReloadSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="ReloadSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ResultSet2FileSenderType">
    <xs:group ref="JdbcSenderBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="ResultSet2FileSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jdbc.ResultSet2FileSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ResultSet2FileSenderDeclaredAttributeGroup">
    <xs:attribute name="statusFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of the optional status field which is set after the row is written to the file: timestamp</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filenameSessionKey" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Key of session variable that contains the name of the file to use.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="append" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; and the file already exists, the resultset rows are written to the end of the file. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRecordsSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set (and &amp;gt;=0), this session key contains the maximum number of records which are processed.
 If &lt;code&gt;query&lt;/code&gt; contains a group field (3), then also following records with the same group field value as the last record are processed</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ResultSet2FileSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="ResultSet2FileSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedQuerySenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Samba1SenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="Samba1SenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.Samba1Sender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="Samba1SenderDeclaredAttributeGroup">
    <xs:attribute name="share" type="xs:string">
      <xs:annotation>
        <xs:documentation>The destination, aka smb://xxx/yyy share</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>The SMB share username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>The SMB share password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain credentials for the SMB share</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="domainName" type="xs:string">
      <xs:annotation>
        <xs:documentation>logon/authentication domain, in case the user account is bound to a domain such as Active Directory.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="force" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, intermediate directories are created also Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="listHiddenFiles" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>controls whether hidden files are seen or not Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Samba1SenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="Samba1SenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Samba2SenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="Samba2SenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.Samba2Sender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="Samba2SenderDeclaredAttributeGroup">
    <xs:attribute name="hostname" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Hostname of the SMB share.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="frankInt">
      <xs:annotation>
        <xs:documentation>Port to connect to. Default: 445</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authType">
      <xs:annotation>
        <xs:documentation>Type of the authentication either 'NTLM' or 'SPNEGO'.
 When setting SPNEGO, the host must use the FQDN, and must be registered on the KDC with a valid SPN. Default: SPNEGO</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="Samba2AuthTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for the smb share</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="domainName" type="xs:string">
      <xs:annotation>
        <xs:documentation>NTLM only: logon/authentication domain, in case the user account is bound to a domain such as Active Directory.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="share" type="xs:string">
      <xs:annotation>
        <xs:documentation>May not contain '\\' characters. The destination share, aka smb://xxx/yyy share.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="kdc" type="xs:string">
      <xs:annotation>
        <xs:documentation>SPNEGO only:
 Key Distribution Center, typically hosted on a domain controller.
 Stored in &lt;code&gt;java.security.krb5.kdc&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="realm" type="xs:string">
      <xs:annotation>
        <xs:documentation>SPNEGO only:
 Kerberos Realm, case sensitive. Typically upper case and the same as the domain name.
 An Active Directory domain acts as a Kerberos Realm.
 Stored in &lt;code&gt;java.security.krb5.realm&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Samba2SenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="Samba2SenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SapSenderType">
    <xs:group ref="SapSenderBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="SapSenderImplCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.sap.SapSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="SapSenderImplDeclaredAttributeGroup">
    <xs:attribute name="synchronous" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;false&lt;/code&gt;, the sender operates in RR mode: the a reply is expected from SAP, and the sender does not participate in a transaction. When &lt;code&gt;false&lt;/code&gt;, the sender operates in FF mode: no reply is expected from SAP, and the sender joins the transaction, that must be present. The SAP transaction is committed right after the XA transaction is completed. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="functionName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the RFC-function to be called in the SAP system</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="functionNameParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the parameter used to obtain the functionName from if the attribute &lt;code&gt;functionName&lt;/code&gt; is empty Default: functionName</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SapSenderImplCumulativeAttributeGroup">
    <xs:attributeGroup ref="SapSenderImplDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SapSenderBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SchedulerSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="SchedulerSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.scheduler.SchedulerSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="SchedulerSenderDeclaredAttributeGroup">
    <xs:attribute name="cronExpressionPattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>expression that generates the cron trigger</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jobGroup" type="xs:string">
      <xs:annotation>
        <xs:documentation>job group in which the new trigger is to be created (optional)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jobNamePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>pattern that leads to the name of the registered trigger(optional)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="javaListener" type="xs:string">
      <xs:annotation>
        <xs:documentation>java listener to be called when scheduler trigger fires</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SchedulerSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="SchedulerSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SendGridSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="SendGridSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.SendGridSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="SendGridSenderDeclaredAttributeGroup">
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Timeout in ms of obtaining a connection/result. Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConnections" type="frankInt">
      <xs:annotation>
        <xs:documentation>The maximum number of concurrent connections Default: 10</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxExecuteRetries" type="frankInt">
      <xs:annotation>
        <xs:documentation>The maximum number of times the execution is retried Default: 1 (for repeatable messages) else 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="frankInt">
      <xs:annotation>
        <xs:documentation>Proxy port Default: 80</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain credentials for authentication to proxy</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyRealm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy realm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystore" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource URL to keystore or certificate to be used for authentication. If none specified, the JVMs default keystore will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType">
      <xs:annotation>
        <xs:documentation>Type of keystore Default: pkcs12</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="keystoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used to obtain keystore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to access keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias to obtain specific certificate or key in keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>Resource URL to truststore to be used for authenticating peer. If none specified, the JVMs default truststore will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType">
      <xs:annotation>
        <xs:documentation>Type of truststore Default: jks</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used to obtain truststore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password to access truststore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Trust manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the hostname in the certificate will be checked against the actual hostname of the peer</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowSelfSignedCertificates" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, self signed certificates are accepted Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCertificateExpiredException" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, CertificateExpiredExceptions are ignored Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="followRedirects" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, a redirect request will be honoured, e.g. to switch to HTTPS Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleChecking" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Controls whether connections checked to be stale, i.e. appear open, but are not. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Used when &lt;code&gt;staleChecking&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Timeout after which an idle connection will be validated before being used. Default: 5000 ms</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="protocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>Secure socket protocol (such as 'TLSv1.2') to use when a SSLContext object is generated. Default: TLSv1.2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SendGridSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="SendGridSenderDeclaredAttributeGroup" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authAlias used to obtain credentials for authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="userId" />
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>password of userid</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="defaultSubject" />
    <xs:attribute ref="defaultFrom" />
    <xs:attribute ref="defaultAttachmentName" />
    <xs:attribute ref="defaultMessageType" />
    <xs:attribute ref="defaultMessageBase64" />
    <xs:attribute ref="bounceAddress" />
    <xs:attribute ref="domainWhitelist" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SenderWrapperType">
    <xs:group ref="SenderWrapperCumulativeChildGroup" />
    <xs:attributeGroup ref="SenderWrapperBaseCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.SenderWrapper" use="prohibited" />
  </xs:complexType>
  <xs:group name="SenderWrapperDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="SenderElementGroup" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:group name="SenderWrapperCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="SenderWrapperDeclaredChildGroup" />
      <xs:group ref="SenderWrapperBaseCumulativeChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:complexType name="SftpFileSystemSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="SftpFileSystemSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.SftpFileSystemSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="SftpFileSystemSenderDeclaredAttributeGroup">
    <xs:attribute name="remoteDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>Path of the file or directory to start working. Default: Home folder of the sftp user</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="host" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name or ip address of remote host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="frankInt">
      <xs:annotation>
        <xs:documentation>Port number of remote host Default: 21</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the alias to obtain credentials to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the user to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>Proxy hostname</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="frankInt">
      <xs:annotation>
        <xs:documentation>Proxy port Default: 1080</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias to obtain credentials to authenticate on proxy</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default user name in case proxy requires authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password in case proxy requires authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyTransportType">
      <xs:annotation>
        <xs:documentation>Transport type in case of sftp Default: SOCKS5</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="TransportTypeAttributeValuesType_2 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="prefCSEncryption" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional preferred encryption from client to server for sftp protocol</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefSCEncryption" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional preferred encryption from server to client for sftp protocol</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyFilePath" type="xs:string">
      <xs:annotation>
        <xs:documentation>Path to private key file for sftp authentication</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the alias to obtain credentials for passphrase of private key file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Passphrase of private key file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="knownHostsPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>Path to file with knownhosts</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictHostKeyChecking" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Verify the hosts againt the knownhosts file. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SftpFileSystemSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="SftpFileSystemSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemSenderCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ShadowSenderType">
    <xs:group ref="ParallelSendersCumulativeChildGroup" />
    <xs:attributeGroup ref="ShadowSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.ShadowSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ShadowSenderDeclaredAttributeGroup">
    <xs:attribute name="originalSender" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the sender that is considered that is considered to be the golden standard, i.e. the source of truth. Default: the first sender specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultSender" type="xs:string">
      <xs:annotation>
        <xs:documentation>The sender name which will process the results Default: the last sender specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="waitForShadowsToFinish" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; the sender will wait for all shadows to have finished. Otherwise the collection of results will happen in a background thread. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ShadowSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="ShadowSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="ParallelSendersCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="StoredProcedureQuerySenderType">
    <xs:group ref="JdbcSenderBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="StoredProcedureQuerySenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jdbc.StoredProcedureQuerySender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="StoredProcedureQuerySenderDeclaredAttributeGroup">
    <xs:attribute name="query" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>A SQL statement that calls a stored procedure. The statement should begin with the &lt;code&gt;CALL&lt;/code&gt; or &lt;code&gt;EXEC&lt;/code&gt;
 SQL keyword depending on SQL dialect. In case of doubt, the safe choice is to always start with &lt;code&gt;CALL&lt;/code&gt; and choose Oracle dialect.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queryType">
      <xs:annotation>
        <xs:documentation>The query type. For stored procedures, valid query types are JdbcQuerySenderBase.QueryType#SELECT and JdbcQuerySenderBase.QueryType#OTHER.
 Use JdbcQuerySenderBase.QueryType#SELECT when your stored procedure returns a row set (not supported by Oracle and PostgreSQL).
 Use JdbcQuerySenderBase.QueryType#OTHER when your stored procedure returns values via &lt;code&gt;OUT&lt;/code&gt; or &lt;code&gt;INOUT&lt;/code&gt; parameters, or does not return
 anything at all.
 &lt;p&gt;
 Using any other value will be rejected.
 &lt;/p&gt; Default: OTHER</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="QueryTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="StoredProcedureQuerySenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="StoredProcedureQuerySenderDeclaredAttributeGroup" />
    <xs:attribute ref="batchSize" />
    <xs:attribute ref="packageContent" />
    <xs:attribute ref="scalar" />
    <xs:attribute ref="scalarExtended" />
    <xs:attribute ref="nullValue" />
    <xs:attribute ref="resultQuery" />
    <xs:attribute ref="useNamedParams" />
    <xs:attribute ref="includeFieldDefinition" />
    <xs:attribute ref="trimSpaces" />
    <xs:attribute name="sqlDialect" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the SQL dialect in which the queries are written and should be translated from to the actual SQL dialect</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="synchronous" />
    <xs:attribute ref="closeOutputstreamOnExit" />
    <xs:attribute ref="streamCharset" />
    <xs:attribute ref="prettyPrint" />
    <xs:attribute name="outputFormat">
      <xs:annotation>
        <xs:documentation>The type of output. If not set then defaults to old-style XML. If set to XML, new-style XML is used. EXPERIMENTAL: datatypes like numbers are not yet rendered correctly Default: false</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="DocumentFormatAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attributeGroup ref="JdbcSenderBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="WebServiceSenderType">
    <xs:group ref="HttpSenderBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="WebServiceSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.http.WebServiceSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="WebServiceSenderDeclaredAttributeGroup">
    <xs:attribute name="soap" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope and the soap envelope is removed from received messages (soap envelope will not be visible to the pipeline) Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapAction" type="xs:string">
      <xs:annotation>
        <xs:documentation>the soapactionuri to be set in the requestheader</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapActionParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>parameter to obtain the soapactionuri</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the messageheader</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwApplicationFaults" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>controls whether soap faults generated by the application generate an exception, or are treated as 'normal' messages Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespaceParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>parameter to obtain the servicenamespace</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions to be added in the soap envelope tag. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>username used to obtain credentials for authentication to web services security</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>password used to obtain credentials for authentication to web services security</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="WebServiceSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="WebServiceSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="HttpSenderDeclaredAttributeGroup" />
    <xs:attribute ref="url" />
    <xs:attribute ref="urlParam" />
    <xs:attribute ref="contentType" />
    <xs:attribute ref="charSet" />
    <xs:attribute ref="headersParams" />
    <xs:attribute ref="parametersToSkipWhenEmpty" />
    <xs:attribute ref="xhtml" />
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Only used when xHtml=&lt;code&gt;true&lt;/code&gt;) stylesheet to apply to the HTML response</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="resultStatusCodeSessionKey" />
    <xs:attribute ref="sharedResourceRef" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of the object.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Timeout in ms of obtaining a connection/result. Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="maxConnections" />
    <xs:attribute ref="maxExecuteRetries" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Username used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="tokenEndpoint" />
    <xs:attribute ref="tokenExpiry" />
    <xs:attribute ref="clientAlias" />
    <xs:attribute ref="clientId" />
    <xs:attribute ref="clientSecret" />
    <xs:attribute ref="scope" />
    <xs:attribute ref="authenticatedTokenRequest" />
    <xs:attribute ref="proxyHost" />
    <xs:attribute ref="proxyPort" />
    <xs:attribute ref="proxyAuthAlias" />
    <xs:attribute ref="proxyUsername" />
    <xs:attribute ref="proxyPassword" />
    <xs:attribute ref="proxyRealm" />
    <xs:attribute ref="prefillProxyAuthCache" />
    <xs:attribute ref="disableCookies" />
    <xs:attribute ref="keystore" />
    <xs:attribute ref="keystoreType" />
    <xs:attribute ref="keystoreAuthAlias" />
    <xs:attribute ref="keystorePassword" />
    <xs:attribute ref="keyManagerAlgorithm" />
    <xs:attribute ref="keystoreAlias" />
    <xs:attribute ref="keystoreAliasAuthAlias" />
    <xs:attribute ref="keystoreAliasPassword" />
    <xs:attribute ref="truststore" />
    <xs:attribute ref="truststoreAuthAlias" />
    <xs:attribute ref="truststorePassword" />
    <xs:attribute ref="truststoreType" />
    <xs:attribute ref="trustManagerAlgorithm" />
    <xs:attribute ref="verifyHostname" />
    <xs:attribute ref="allowSelfSignedCertificates" />
    <xs:attribute ref="ignoreCertificateExpiredException" />
    <xs:attribute ref="followRedirects" />
    <xs:attribute ref="ignoreRedirects" />
    <xs:attribute ref="staleChecking" />
    <xs:attribute ref="staleTimeout" />
    <xs:attribute ref="connectionTimeToLive" />
    <xs:attribute ref="connectionIdleTimeout" />
    <xs:attribute ref="protocol" />
    <xs:attribute ref="supportedCipherSuites" />
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="XComSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="XComSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.xcom.XComSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="XComSenderDeclaredAttributeGroup">
    <xs:attribute name="fileOption">
      <xs:annotation>
        <xs:documentation>one of create, append or replace</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="FileOptionTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="remoteDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>remote directory is prefixed witht the remote file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="carriageflag">
      <xs:simpleType>
        <xs:union memberTypes="CarriageFlagTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="codeflag">
      <xs:annotation>
        <xs:documentation>characterset conversion</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="CodeTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="compress">
      <xs:simpleType>
        <xs:union memberTypes="CompressTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="logfile" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of logfile for xcomtcp to be used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>password of user on remote system</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="xs:string">
      <xs:annotation>
        <xs:documentation>port of remote host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queue" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>set queue off or on</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteSystem" type="xs:string">
      <xs:annotation>
        <xs:documentation>hostname or tcpip adres of remote host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tracelevel" type="frankInt">
      <xs:annotation>
        <xs:documentation>set between 0 (no trace) and 10</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truncation" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>set truncation off or on</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="userid" type="xs:string">
      <xs:annotation>
        <xs:documentation>loginname of user on remote system</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteFilePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>remote file to create. if empty, the name is equal to the local file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="workingDirName" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>directory in which to run the xcomtcp command</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xcomtcp" type="xs:string">
      <xs:annotation>
        <xs:documentation>path to xcomtcp command</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="configFile" type="xs:string" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the alias to obtain credentials to authenticatie on remote server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XComSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="XComSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XfbSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="XfbSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.xfb.XfbSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="XfbSenderDeclaredAttributeGroup">
    <xs:attribute name="script" type="xs:string">
      <xs:annotation>
        <xs:documentation>Full pathname to the XFB script to be executed to transfer the file</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ft" type="xs:string" />
    <xs:attribute name="flow" type="xs:string" />
    <xs:attribute name="appli" type="xs:string" />
    <xs:attribute name="noname" type="xs:string" />
    <xs:attribute name="copy" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>When set to &lt;code&gt;true&lt;/code&gt;, the file is copied before calling the XFB script.
 Reasons to copy the file:
 - XFB will rename the file (prefix it with FXB_) and delete it.
 - On Linux the sticky bit (drwxrws--- wasadmin xfbgw) isn't honoured with a move (only with a copy) (on AIX the sticky bit works for both move and copy).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="copyPrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>Prefix for the name of the copied or original filename. When the name of the original file starts with this prefix, it is removed. Otherwise this prefix is added to the filename of the copied file.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XfbSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="XfbSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XmlJmsBrowserSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jms.XmlJmsBrowserSender" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="XmlQuerySenderType">
    <xs:group ref="JdbcSenderBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="JdbcQuerySenderBaseCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jdbc.XmlQuerySender" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="XmlValidatorSenderType">
    <xs:attributeGroup ref="XmlValidatorSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.senders.XmlValidatorSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="XmlValidatorSenderDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of the object.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XmlValidatorSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="XmlValidatorSenderDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractXmlValidatorDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="AbstractXmlValidatorDeclaredAttributeGroup">
    <xs:attribute name="fullSchemaChecking" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Enable full schema grammar constraint checking, including checking which
 may be time-consuming or memory intensive. Currently, particle unique
 attribution constraint checking and particle derivation restriction
 checking are controlled by this option.
 &lt;p&gt;
 see property
 http://apache.org/xml/features/validation/schema-full-checking
 &lt;/p&gt; Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Should the XmlValidator throw a PipeRunexception on a validation error. If not, a forward with name 'failure' must be defined. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set: key of session variable to store reasons of mis-validation in Default: failureReason</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Like &lt;code&gt;reasonSessionKey&lt;/code&gt; but stores reasons in xml format and more extensive Default: xmlFailureReason</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. Otherwise the input itself is validated Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Characterset used for reading file, only used when &lt;code&gt;validateFile&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; Default: utf-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="warn" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, send warnings to logging and console about syntax problems in the configured schema('s).
 Alternatively, warnings can be switched off using suppression properties XSD_VALIDATION_WARNINGS_SUPPRESS_KEY, XSD_VALIDATION_ERROR_SUPPRESS_KEY and XSD_VALIDATION_FATAL_ERROR_SUPPRESS_KEY Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Ignore namespaces in the input message which are unknown Default: true when &lt;code&gt;schema&lt;/code&gt; or &lt;code&gt;noNamespaceSchemaLocation&lt;/code&gt; is used, false otherwise</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCaching" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the number for caching validators in appConstants is ignored and no caching is done (for this validator only) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlSchemaVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;1.0&lt;/code&gt;, Xerces's previous XML Schema factory will be used, which would make all XSD 1.1 features illegal. The default behaviour can also be set with &lt;code&gt;xsd.processor.version&lt;/code&gt; property. Default: &lt;code&gt;1.1&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="ZipWriterSenderType">
    <xs:group ref="SenderWithParametersBaseDeclaredChildGroup" />
    <xs:attributeGroup ref="ZipWriterSenderCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.compression.ZipWriterSender" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ZipWriterSenderDeclaredAttributeGroup" />
  <xs:attributeGroup name="ZipWriterSenderCumulativeAttributeGroup">
    <xs:attributeGroup ref="CollectorSenderBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="CollectorSenderBaseDeclaredAttributeGroup">
    <xs:attribute name="collectionName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key used to refer to collection. Must be specified with another value if multiple CollectorPipes are active at the same time in the same session Default: collection</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CollectorSenderBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="CollectorSenderBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SenderBaseDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="ErrorSenderElementGroup">
    <xs:choice>
      <xs:element name="ErrorSender">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:group ref="CacheElementGroup" />
              <xs:group ref="ParamElementGroup" />
              <xs:group ref="SenderElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ErrorSenderElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ErrorSenderElementGroupBase">
    <xs:choice>
      <xs:element name="Afm2EdiFactErrorSender">
        <xs:annotation>
          <xs:documentation>Domparser om AFM-XML berichten om te zetten in edifactberichten (voor de backoffice).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Afm2EdiFactSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="AmazonS3ErrorSender">
        <xs:annotation>
          <xs:documentation>Sender to work with the Amazon S3 Filesystem.
 &lt;p&gt;
     In addition to regular parameters for filesystem senders, it is possible
     to set custom user-metadata on S3 files by prefixing parameter names with
     FileAttribute..
     This prefix will be not be part of the actual metadata property name.
 &lt;/p&gt;
 &lt;p&gt;
     The string value of these parameters will be used as value of the custom metadata attribute.
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="AmazonS3SenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CmisErrorSender">
        <xs:annotation>
          <xs:documentation>Sender to obtain information from and write to a CMIS application.

 &lt;p&gt;
 When &lt;code&gt;action=get&lt;/code&gt; the input (xml string) indicates the id of the document to get. This input is mandatory.
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;Example:&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;cmis&gt;
     &lt;id&gt;documentId&lt;/id&gt;
 &lt;/cmis&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;
 &lt;p&gt;
 When &lt;code&gt;action=delete&lt;/code&gt; the input (xml string) indicates the id of the document to get. This input is mandatory.
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;Example:&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;cmis&gt;
     &lt;id&gt;documentId&lt;/id&gt;
 &lt;/cmis&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;
 &lt;p&gt;
 When &lt;code&gt;action=create&lt;/code&gt; the input (xml string) indicates document properties to set. This input is optional.
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;Example:&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;cmis&gt;
     &lt;name&gt;Offerte&lt;/name&gt;
     &lt;objectTypeId&gt;NNB_Geldlening&lt;/objectTypeId&gt;
     &lt;mediaType&gt;application/pdf&lt;/mediaType&gt;
     &lt;properties&gt;
         &lt;property name="ArrivedAt" type="datetime" formatString="yyyy-MM-dd'T'HH:mm:ss.SSSz"&gt;2014-11-27T16:43:01.268+0100&lt;/property&gt;
         &lt;property name="ArrivedBy"&gt;HDN&lt;/property&gt;
         &lt;property name="DocumentType"&gt;Geldlening&lt;/property&gt;
     &lt;/properties&gt;
 &lt;/cmis&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;

 &lt;p&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;mandatory property "cmis:name". If not set the sender attribute fileNameSessionKey is used&lt;/td&gt;&lt;td&gt;"[unknown]"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;objectTypeId&lt;/td&gt;&lt;td&gt;mandatory property "cmis:objectTypeId"&lt;/td&gt;&lt;td&gt;"cmis:document"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;mediaType&lt;/td&gt;&lt;td&gt;the MIME type of the document to store&lt;/td&gt;&lt;td&gt;"application/octet-stream"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;property&lt;/td&gt;&lt;td&gt;custom document property to set. Possible attributes:
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;type&lt;/td&gt;&lt;td&gt;
 &lt;ul&gt;
 &lt;li&gt;&lt;code&gt;string&lt;/code&gt;: renders the value&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;datetime&lt;/code&gt;: converts the value to a Date, by default using formatString &lt;code&gt;yyyy-MM-dd HH:mm:ss&lt;/code&gt;&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/td&gt;&lt;td&gt;string&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;formatString&lt;/td&gt;&lt;td&gt;used in combination with &lt;code&gt;datetime&lt;/code&gt;&lt;/td&gt;&lt;td&gt;yyyy-MM-dd HH:mm:ss&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;
 &lt;p&gt;
 When &lt;code&gt;action=find&lt;/code&gt; the input (xml string) indicates the query to perform.
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;Example:&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;query&gt;
    &lt;statement&gt;select * from cmis:document&lt;/statement&gt;
    &lt;maxItems&gt;10&lt;/maxItems&gt;
    &lt;skipCount&gt;0&lt;/skipCount&gt;
    &lt;searchAllVersions&gt;true&lt;/searchAllVersions&gt;
    &lt;includeAllowableActions&gt;true&lt;/includeAllowableActions&gt;
 &lt;/query
 }&lt;/pre&gt;
 &lt;/p&gt;
 &lt;p&gt;
 When &lt;code&gt;action=update&lt;/code&gt; the input (xml string) indicates document properties to update.
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;Example:&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;cmis&gt;
    &lt;id&gt;123456789&lt;/id&gt;
    &lt;properties&gt;
       &lt;property name="ArrivedAt" type="datetime" formatString="yyyy-MM-dd'T'HH:mm:ss.SSSz"&gt;2014-11-27T16:43:01.268+0100&lt;/property&gt;
       &lt;property name="ArrivedBy"&gt;HDN&lt;/property&gt;
       &lt;property name="DocumentType"&gt;Geldlening&lt;/property&gt;
    &lt;/properties&gt;
 &lt;/cmis&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;

 &lt;p&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;id&lt;/td&gt;&lt;td&gt;mandatory property "cmis:objectId" which indicates the document to update&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;property&lt;/td&gt;&lt;td&gt;custom document property to update. See &lt;code&gt;action=create&lt;/code&gt; for possible attributes&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CmisSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CommandErrorSender">
        <xs:annotation>
          <xs:documentation>Sender that executes either its input or a fixed line, with all parametervalues appended, as a command.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CommandSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DelayErrorSender">
        <xs:annotation>
          <xs:documentation>Sender that sleeps for a specified time, which defaults to 5000 msecs.
 Useful for testing purposes.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DelaySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DirectQueryErrorSender">
        <xs:annotation>
          <xs:documentation>QuerySender that interprets the input message as a query, possibly with attributes.
 Messages are expected to contain sql-text.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DirectQuerySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EchoErrorSender">
        <xs:annotation>
          <xs:documentation>Echos input to output.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EchoSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbJmsErrorSender">
        <xs:annotation>
          <xs:documentation>ESB (Enterprise Service Bus) extension of JmsSender.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbJmsSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ExchangeFolderErrorSender">
        <xs:annotation>
          <xs:documentation>Implementation of a FileSystemSender that enables to manipulate messages in an Exchange folder.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ExchangeFolderSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FileSystemSenderWithAttachmentsErrorSender">
        <xs:annotation>
          <xs:documentation>FileSystem Sender extension to handle Attachments.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FileSystemSenderWithAttachmentsType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FixedQueryErrorSender">
        <xs:annotation>
          <xs:documentation>QuerySender that assumes a fixed query, possibly with attributes.

 &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; See DB2XMLWriter for ResultSet!&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FixedQuerySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FixedResultErrorSender">
        <xs:annotation>
          <xs:documentation>FixedResultSender, same behaviour as FixedResultPipe, but now as a ISender.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FixedResultSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FrankErrorSender">
        <xs:annotation>
          <xs:documentation>Sender to send a message to another Frank! Adapter, or an external program running in the same JVM as the Frank!Framework.
 &lt;p&gt;
 Sends a message to another Frank!Framework-adapter in the same Frank!Framework instance, or an external program running in
 the same JVM as the Frank!Framework. If the callee exits with an {@code &lt;Exit/&gt;} that has state PipeLine.ExitState#ERROR,
 an error is considered to happen in the caller which means that the {@code exception} forward is followed if it is present.
 &lt;/p&gt;
 &lt;p&gt;
 Returns {@code exit.code} as forward name to the SenderPipe, provided that {@code exit.code} can be parsed as integer.
 For example, if the called adapter has an exit state with code
 {@code 2}, then the SenderPipe supports a forward with name {@code 2}
 that is followed when the called adapter exits with the mentioned exit. This does not work if the code is for example {@code c2}.
 &lt;/p&gt;
 &lt;p&gt;
 A FrankSender makes a call to either an Adapter or an external program by setting the #scope. By default the scope is {@code ADAPTER}.
 &lt;/p&gt;
 &lt;p/&gt;

 &lt;h3&gt;Configuration of the Adapter to be called&lt;/h3&gt;
 &lt;p&gt;
 A call to another Adapter in the same Frank!Framework instance is preferably made using the combination
 of a FrankSender configured with the name of the adapter.
 &lt;/p&gt;
 &lt;h4&gt;Configuring FrankSender and Adapter&lt;/h4&gt;
 &lt;ul&gt;
   &lt;li&gt;Define a SenderPipe with a FrankSender&lt;/li&gt;
   &lt;li&gt;Set the attribute {@code target} to &lt;i&gt;targetAdapterName&lt;/i&gt;&lt;/li&gt;
   &lt;li&gt;If the adapter is in another Configuration deployed in the same Frank!Framework instance, then set {@code target} to {@code targetConfigurationName/targetAdapterName} (note the slash-separator between Configuration name and Adapter name).&lt;/li&gt;
 &lt;/ul&gt;
 In the Adapter to be called:
 &lt;ul&gt;
   &lt;li&gt;The adapter does not need to have a receiver configured to be called from a FrankSender,&lt;/li&gt;
   &lt;li&gt;The adapter will run in the same transaction as the calling adapter,&lt;/li&gt;
   &lt;li&gt;If the called adapter does not to run in its own transaction, set the transaction attributes on the PipeLine attribute of this adapter
   or on the SenderPipe that contains this {@code FrankSender}.&lt;/li&gt;
 &lt;/ul&gt;

 &lt;h4&gt;Configuring FrankSender with FrankListener&lt;/h4&gt;
 &lt;ul&gt;
   &lt;li&gt;Define a SenderPipe with a FrankSender&lt;/li&gt;
   &lt;li&gt;In the target adapter, define a org.frankframework.receivers.Receiver with a FrankListener&lt;/li&gt;
   &lt;li&gt;Give a unique name to the listener: FrankListener#setName(String). If the name is not set, the name of the Adapter will be used.&lt;/li&gt;
   &lt;li&gt;Set the #setScope(Scope) to {@code LISTENER} and the #setTarget(String) to the listener name as per previous point&lt;/li&gt;
   &lt;li&gt;If the listener is in a different configuration, prefix the listener name with the name of the configuration and a slash ({@code /}) as separator between configuration and listener name&lt;/li&gt;
 &lt;/ul&gt;

 &lt;h4&gt;Configuring FrankSender and Remote Application&lt;/h4&gt;
 &lt;p&gt;
 &lt;em&gt;NB:&lt;/em&gt; Please make sure that the IbisServiceDispatcher-1.4.jar or newer is present on the class path of the server. For more information, see:
 &lt;/p&gt;
 &lt;ul&gt;
     &lt;li&gt;Define a SenderPipe with a FrankSender&lt;/li&gt;
     &lt;li&gt;Set the attribute {@code scope} to either {@code JVM} for a Java application, or to {@code DLL} for code loaded from a DLL&lt;/li&gt;
     &lt;li&gt;Set the attribute {@code target} to the service-name the other application used to register itself&lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
 In the other application:
 &lt;ul&gt;
     &lt;li&gt;Implement the interface {@code nl.nn.adapterframework.dispatcher.RequestProcessor} from the IbisServiceDispatcher library&lt;/li&gt;
     &lt;li&gt;Register the instance with the {@code nl.nn.adapterframework.dispatcher.DispatcherManager} obtained via the {@code nl.nn.adapterframework.dispatcher.DispatcherManagerFactory}&lt;/li&gt;
     &lt;li&gt;See the implementation code of the {@code JavaListener} in the Frank!Framework for an example&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/p&gt;
 &lt;p&gt;
 See also the repository of the IbisServiceDispatcher:
  &lt;a href="https://github.com/frankframework/servicedispatcher"&gt;https://github.com/frankframework/servicedispatcher&lt;/a&gt;
 &lt;/p&gt;
 
 &lt;h4&gt;Using FrankSender to call an adapter from Larva tests&lt;/h4&gt;
 &lt;p&gt;
 You can configure a FrankSender in Larva property files to use the FrankSender to invoke an adapter to test. When doing this, keep the following in mind:
 &lt;ul&gt;
     &lt;li&gt;If you leave the default scope as {@code ADAPTER}, then the {@code target} property needs to have both configuration name and adapter name, separated by a {@code /} character&lt;/li&gt;
     &lt;li&gt;When scope is left as default, the receiver and JavaListener are skipped and no transaction is started unless it is set on the adapter's {@code PipeLine}&lt;/li&gt;
     &lt;li&gt;If you do need a transaction and the adapter has a JavaListener that has org.frankframework.receivers.JavaListener#setServiceName(String) defined, you can use the FrankSender with scope {@code JVM}
     and set the {@code target} attribute to the {@code serviceName} attribute of the {@code JavaListener}.&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/p&gt;

 &lt;h3&gt;Migrating Existing Configurations&lt;/h3&gt;
 &lt;p&gt;
 When one adapter (named A) needs to call another adapter (named B) like a subroutine, you will usually have an IbisLocalSender or an IbisJavaSender
 in adapter A, and a org.frankframework.receivers.JavaListener in adapter B.
 &lt;/p&gt;
 &lt;p&gt;
     &lt;em&gt;NB:&lt;/em&gt; For the example it is assumed that all adapters are defined in the same configuration.
 &lt;/p&gt;

 &lt;h4&gt;Example of Existing Configuration&lt;/h4&gt;
 The existing configuration might look like this in the calling adapter:
 &lt;pre&gt;{@code
 &lt;module&gt;
     &lt;adapter name="Adapter A"&gt;
         &lt;receiver name="Adapter A Receiver"&gt;
             &lt;listener name="Adapter A Listener"
                 className="org.frankframework..." etc/&gt;
         &lt;/receiver&gt;
  	   &lt;pipeline firstPipe="..."&gt;
  	       &lt;pipe name="send" className="org.frankframework.pipes.SenderPipe"&gt;
  	           &lt;sender className="org.frankframework.senders.IbisJavaSender"
  	               serviceName="service-Adapter-B" /&gt;
                 &lt;forward name="success" path="..." /&gt;
  	       &lt;/pipe&gt;
         &lt;/pipeline&gt;
     &lt;/adapter&gt;
 &lt;/module&gt;
 }&lt;/pre&gt;

 Or like using the modern XML XSD and an IbisLocalSender instead:
 &lt;pre&gt;{@code
 &lt;Module&gt;
     &lt;Adapter name="Adapter A"&gt;
         &lt;Receiver name="Adapter A Receiver"&gt;
             ... Listener setup and other configuration
         &lt;/Receiver&gt;
         &lt;Pipeline&gt;
             &lt;SenderPipe name="send"&gt;
                 &lt;IbisLocalSender name="call Adapter B"
                     javaListener="Adapter B Listener"/&gt;
                 &lt;Forward name="success" path="EXIT" /&gt;
             &lt;/SenderPipe&gt;
         &lt;/Pipeline&gt;
     &lt;/Adapter&gt;
 &lt;/Module&gt;
 }&lt;/pre&gt;

 In the receiving adapter B the listener would have been configured like this:
 &lt;pre&gt;{@code
 &lt;Module&gt;
     &lt;Adapter name="adapter B"&gt;
         &lt;Receiver name="Receiver B"&gt;
             &lt;JavaListener name="Adapter B Listener" serviceName="service-Adapter-B"/&gt;
         &lt;/Receiver&gt;
         &lt;Pipeline&gt;
             ...
         &lt;/Pipeline&gt;
     &lt;/Adapter&gt;
 &lt;/Module&gt;
 }&lt;/pre&gt;
 &lt;p/&gt;

 &lt;h4&gt;Rewritten Example Configuration With FrankSender&lt;/h4&gt;
 This example shows the most simple way of using the FrankSender to call another adapter with least amount of overhead.

 &lt;pre&gt;{@code
 &lt;Module&gt;
     &lt;Adapter name="Adapter A"&gt;
         &lt;Receiver name="Adapter A Receiver"&gt;
             ... Listener setup and other configuration
         &lt;/Receiver&gt;
         &lt;Pipeline&gt;
             &lt;SenderPipe name="send"&gt;
                 &lt;!-- when scope="ADAPTER", then target is directly the name of the adapter you want to call --&gt;
                 &lt;FrankSender name="call Adapter C"
                     scope="ADAPTER"
                     target="adapter B"
                 /&gt;
                 &lt;Forward name="success" path="EXIT" /&gt;
             &lt;/SenderPipe&gt;
         &lt;/Pipeline&gt;
     &lt;/Adapter&gt;
     &lt;Adapter name="adapter B"&gt;
         &lt;!-- No receiver needed for FrankSender in this scenario --&gt;
         &lt;Pipeline&gt;
             ... Exits, Pipes etc
         &lt;/Pipeline&gt;
     &lt;/Adapter&gt;
 &lt;/Module&gt;
 }&lt;/pre&gt;

 &lt;h4&gt;Rewritten Example Configuration With FrankSender and FrankListener&lt;/h4&gt;
 This example shows why you might want to call the other adapter via the FrankListener. This adds a bit more overhead to the call
 of the sub-adapter for the extra error-handling done by the target receiver.

 &lt;pre&gt;{@code
 &lt;Module&gt;
    &lt;Adapter name="Adapter A"&gt;
        &lt;Receiver name="Adapter A Receiver"&gt;
         ... Listener setup and other configuration
 		  &lt;/Receiver&gt;
 		  &lt;Pipeline&gt;
            &lt;SenderPipe name="send"&gt;
                &lt;!-- when scope="LISTENER", then target is directly the name of the FrankListener in the adapter you want to call --&gt;
                &lt;FrankSender
                    scope="LISTENER"
                    target="Adapter B Listener"/&gt;
                &lt;Forward name="success" path="EXIT" /&gt;
            &lt;/SenderPipe&gt;
        &lt;/Pipeline&gt;
     &lt;/Adapter&gt;
     &lt;Adapter name="adapter B"&gt;
         &lt;!-- Messages will only be sent to the error storage if:
             - The target receiver is not transactional, and has maxTries="0", or
             - The target receiver is transaction, and the Sender is set up to retry sending on error
             For internal adapters, sending / receiving with retries might not make sense so the example does not show that.
         --&gt;
         &lt;Receiver name="Receiver B" maxRetries="0" transactionAttribute="NotSupported"&gt;
             &lt;!-- Listener name is optional, defaults to Adapter name --&gt;
             &lt;FrankListener name="Adapter B Listener"/&gt;
                 &lt;!-- This adapter now has an error storage -- without Receiver and FrankListener the sub-adapter couldn't have that --&gt;
             &lt;JdbcErrorStorage slotId="Adapter B - Errors" /&gt;
         &lt;/Receiver&gt;
         &lt;!-- If transactions are required, set transaction-attribute on the Pipeline --&gt;
         &lt;Pipeline transactionAttribute="RequiresNew"&gt;
             ... Exits, Pipes etc
         &lt;/Pipeline&gt;
    &lt;/Adapter&gt;
 &lt;/Module&gt;
 }&lt;/pre&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FrankSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FtpFileSystemErrorSender">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FtpFileSystemSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="HttpErrorSender">
        <xs:annotation>
          <xs:documentation>Sender for the HTTP protocol using HttpMethod. By default, any response code outside the 2xx or 3xx range
 is considered an error and the &lt;code&gt;exception&lt;/code&gt; forward of the SenderPipe is followed if present and if there
 is no forward for the specific HTTP status code. Forwards for specific HTTP codes (e.g. "200", "201", ...)
 are returned by this sender, so they are available to the SenderPipe.

 &lt;p&gt;&lt;b&gt;Expected message format:&lt;/b&gt;&lt;/p&gt;
 &lt;p&gt;GET methods expect a message looking like this:
 &lt;pre&gt;
    param_name=param_value&amp;another_param_name=another_param_value
 &lt;/pre&gt;
 &lt;p&gt;POST AND PUT methods expect a message similar as GET, or looking like this:
 &lt;pre&gt;
   param_name=param_value
   another_param_name=another_param_value
 &lt;/pre&gt;

 Note:
 When used as MTOM sender and MTOM receiver doesn't support Content-Transfer-Encoding "base64", messages without line feeds will give an error.
 This can be fixed by setting the Content-Transfer-Encoding in the MTOM sender.
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="HttpSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IMSErrorSender">
        <xs:annotation>
          <xs:documentation>JMS sender which will add an IMS header to the message and call the MQ specific logic.

 &lt;p&gt;See JmsSender for configuration&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IMSSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IbisJavaErrorSender">
        <xs:annotation>
          <xs:documentation>Posts a message to another Frank!Framework-adapter or an application in the same JVM using IbisServiceDispatcher.
 &lt;p&gt;
 An IbisJavaSender makes a call to a Receiver with a JavaListener
 or any other application in the same JVM that has registered a &lt;code&gt;RequestProcessor&lt;/code&gt; with the IbisServiceDispatcher.
 &lt;/p&gt;
 The IbisJavaSender is now considered to be legacy. The new way to call another adapter or java application from your own
 adapter is by using the FrankSender.
 &lt;/p&gt;
 &lt;h4&gt;configuring IbisJavaSender and JavaListener&lt;/h4&gt;
 &lt;ul&gt;
   &lt;li&gt;&lt;em&gt;NB:&lt;/em&gt; Using IbisJavaSender to call another adapter is inefficient and therefore not recommended. It is much more efficient to use for this a FrankSender or IbisLocalSender.&lt;/li&gt;
   &lt;li&gt;Define a org.frankframework.pipes.SenderPipe with an IbisJavaSender&lt;/li&gt;
   &lt;li&gt;Set the attribute &lt;code&gt;serviceName&lt;/code&gt; to &lt;i&gt;yourExternalServiceName&lt;/i&gt;&lt;/li&gt;
 &lt;/ul&gt;
 In the Adapter to be called:
 &lt;ul&gt;
   &lt;li&gt;Define a Receiver with a JavaListener&lt;/li&gt;
   &lt;li&gt;Set the attribute &lt;code&gt;serviceName&lt;/code&gt; to &lt;i&gt;yourExternalServiceName&lt;/i&gt;&lt;/li&gt;
 &lt;/ul&gt;
 N.B. Please make sure that the IbisServiceDispatcher-1.4.jar or newer is present on the class path of the server. For more information, see:
  &lt;a href="https://github.com/frankframework/servicedispatcher"&gt;https://github.com/frankframework/servicedispatcher&lt;/a&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IbisJavaSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IbisLocalErrorSender">
        <xs:annotation>
          <xs:documentation>Posts a message to another Frank!Framework-adapter in the same Frank!Framework instance. If the callee exits with an &amp;lt;&lt;code&gt;exit&lt;/code&gt;&amp;gt;
 that has state PipeLine.ExitState#ERROR, an error is considered to happen
 in the caller which means that the &lt;code&gt;exception&lt;/code&gt; forward is followed if it is present.
 &lt;p&gt;
 The IbisLocalSender is now considered to be legacy. The new way to call another adapter from your own
 adapter is by using the FrankSender.
 &lt;/p&gt;
 &lt;p&gt;
 Returns exit.code as forward name to SenderPipe provided that exit.code can be parsed as integer.
 For example, if the called adapter has an exit state with code
 &lt;code&gt;2&lt;/code&gt;, then the SenderPipe supports a forward with name &lt;code&gt;2&lt;/code&gt;
 that is followed when the called adapter exits with the mentioned exit. This does not work if the code is for example &lt;code&gt;c2&lt;/code&gt;.
 &lt;/p&gt;
 &lt;p&gt;
 An IbisLocalSender makes a call to a org.frankframework.receivers.Receiver with either a WebServiceListener
 or a JavaListener.
 &lt;/p&gt;


 &lt;h3&gt;Configuration of the Adapter to be called&lt;/h3&gt;
 A call to another Adapter in the same Frank!Framework instance is preferably made using the combination
 of an IbisLocalSender and a JavaListener. If,
 however, a Receiver with a WebServiceListener is already present, that can be used in some cases, too.

 &lt;h4&gt;configuring IbisLocalSender and JavaListener&lt;/h4&gt;
 &lt;ul&gt;
   &lt;li&gt;Define a SenderPipe with an IbisLocalSender&lt;/li&gt;
   &lt;li&gt;Set the attribute &lt;code&gt;javaListener&lt;/code&gt; to &lt;i&gt;yourServiceName&lt;/i&gt;&lt;/li&gt;
   &lt;li&gt;Do not set the attribute &lt;code&gt;serviceName&lt;/code&gt;&lt;/li&gt;
 &lt;/ul&gt;
 In the Adapter to be called:
 &lt;ul&gt;
   &lt;li&gt;Define a Receiver with a JavaListener&lt;/li&gt;
   &lt;li&gt;Set the attribute &lt;code&gt;name&lt;/code&gt; to &lt;i&gt;yourServiceName&lt;/i&gt;&lt;/li&gt;
   &lt;li&gt;Do not set the attribute &lt;code&gt;serviceName&lt;/code&gt;, except if the service is to be called also
       from applications other than this Frank!Framework-instance&lt;/li&gt;
 &lt;/ul&gt;

 &lt;h4&gt;configuring IbisLocalSender and WebServiceListener&lt;/h4&gt;

 &lt;ul&gt;
   &lt;li&gt;Define a SenderPipe with an IbisLocalSender&lt;/li&gt;
   &lt;li&gt;Set the attribute &lt;code&gt;serviceName&lt;/code&gt; to &lt;i&gt;yourIbisWebServiceName&lt;/i&gt;&lt;/li&gt;
   &lt;li&gt;Do not set the attribute &lt;code&gt;javaListener&lt;/code&gt;&lt;/li&gt;
 &lt;/ul&gt;
 In the Adapter to be called:
 &lt;ul&gt;
   &lt;li&gt;Define a Receiver with a WebServiceListener&lt;/li&gt;
   &lt;li&gt;Set the attribute &lt;code&gt;name&lt;/code&gt; to &lt;i&gt;yourIbisWebServiceName&lt;/i&gt;&lt;/li&gt;
 &lt;/ul&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IbisLocalSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IdinErrorSender">
        <xs:annotation>
          <xs:documentation>Requires the net.bankid.merchant.library V1.2.9</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IdinSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IdocErrorSender">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IdocSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ImapErrorSender">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ImapSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JavascriptErrorSender">
        <xs:annotation>
          <xs:documentation>Sender used to run JavaScript code using `JavascriptEngine` implementations.
 &lt;p&gt;
 This sender can execute a function of a given Javascript file, the result of the function will be the output of the sender.
 The parameters of the Javascript function to run are given as parameters by the adapter configuration
 The sender doesn't accept nor uses the given input, instead for each argument for the #jsFunctionName method,
 you will need to create a parameter on the sender.
 &lt;/p&gt;
 &lt;p&gt;
 The result of the Javascript function should be of type String, or directly convertible to String from a primitive type
 or an array of primitive types / strings, as the output of the sender will be of type String.
 &lt;/p&gt;
 &lt;p&gt;
 Failure to ensure the output is a string may mean the result will look like {@code [Object object]}.
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JavascriptSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JmsErrorSender">
        <xs:annotation>
          <xs:documentation>This class sends messages with JMS.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JmsSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JsonXsltErrorSender">
        <xs:annotation>
          <xs:documentation>Perform an XSLT transformation with a specified stylesheet on a JSON input, yielding JSON, yielding JSON, XML or text.
 JSON input is transformed into XML map, array, string, integer and boolean elements, in the namespace http://www.w3.org/2013/XSL/json.
 The XSLT stylesheet or XPathExpression operates on these element.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JsonXsltSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LdapErrorSender">
        <xs:annotation>
          <xs:documentation>Sender to obtain information from and write to an LDAP Directory.
 Returns the set of attributes in an XML format. Examples are shown below.

 &lt;h2&gt;example&lt;/h2&gt;
 Consider the following configuration example:
 &lt;pre&gt;{@code
 &lt;sender
      className="org.frankframework.ldap.LdapSender"
      ldapProviderURL="ldap://servername:389/o=ing"
      operation="read"
      attributesToReturn="givenName,sn,telephoneNumber" &gt;
     &lt;param name="entryName" xpathExpression="entryName" /&gt;
 &lt;/sender&gt;
 }&lt;/pre&gt;
 &lt;br/&gt;

 This may result in the following output:
 &lt;pre&gt;{@code
 &lt;ldap&gt;
 	   &lt;entryName&gt;uid=srp,ou=people&lt;/entryName&gt;
 	   &lt;attributes&gt;
         &lt;attribute attrID="givenName"&gt;
             &lt;value&gt;Jan&lt;/value&gt;
         &lt;/attribute&gt;
         &lt;attribute attrID="telephoneNumber"&gt;
             &lt;value&gt;010 5131123&lt;/value&gt;
             &lt;value&gt;06 23456064&lt;/value&gt;
         &lt;/attribute&gt;
 	       &lt;attribute attrID="sn"&gt;
             &lt;value&gt;Jansen&lt;/value&gt;
 	       &lt;/attribute&gt;
 	   &lt;/attributes&gt;
 &lt;/ldap&gt;
 }&lt;/pre&gt;
 &lt;br/&gt;

 Search or Read?

 Read retrieves all the attributes of the specified entry.

 Search retrieves all the entries of the specified (by entryName) context that have the specified attributes,
 together with the attributes. If the specified attributes are null or empty all the attributes of all the entries within the
 specified context are returned.

 Sample result of a &lt;code&gt;read&lt;/code&gt; operation:&lt;br/&gt;
 &lt;pre&gt;{@code
 &lt;attributes&gt;
 	   &lt;attribute&gt;
 	   &lt;attribute name="employeeType" value="Extern"/&gt;
 	   &lt;attribute name="roomNumber" value="DP 2.13.025"/&gt;
 	   &lt;attribute name="departmentCode" value="358000"/&gt;
 	   &lt;attribute name="organizationalHierarchy"&gt;
 	       &lt;item value="ou=ING-EUR,ou=Group,ou=Organization,o=ing"/&gt;
 	       &lt;item value="ou=OPS&amp;IT,ou=NL,ou=ING-EUR,ou=Group,ou=Organization,o=ing"/&gt;
 	       &lt;item value="ou=000001,ou=OPS&amp;IT,ou=NL,ou=ING-EUR,ou=Group,ou=Organization,o=ing"/&gt;
 	   &lt;/attribute&gt;
 	   &lt;attribute name="givenName" value="Gerrit"/&gt;
 &lt;/attributes&gt;
 }&lt;/pre&gt;
 &lt;br/&gt;
 Sample result of a &lt;code&gt;search&lt;/code&gt; operation:&lt;br/&gt;
 &lt;pre&gt;{@code
 &lt;entries&gt;
 	   &lt;entry name="uid=srp"&gt;
 	       &lt;attributes&gt;
 	           &lt;attribute&gt;
 	           &lt;attribute name="employeeType" value="Extern"/&gt;
 	           &lt;attribute name="roomNumber" value="DP 2.13.025"/&gt;
 	           &lt;attribute name="departmentCode" value="358000"/&gt;
 	           &lt;attribute name="organizationalHierarchy"&gt;
 	               &lt;item value="ou=ING-EUR,ou=Group,ou=Organization,o=ing"/&gt;
 	               &lt;item value="ou=OPS&amp;IT,ou=NL,ou=ING-EUR,ou=Group,ou=Organization,o=ing"/&gt;
 	               &lt;item value="ou=000001,ou=OPS&amp;IT,ou=NL,ou=ING-EUR,ou=Group,ou=Organization,o=ing"/&gt;
 	           &lt;/attribute&gt;
 	           &lt;attribute name="givenName" value="Gerrit"/&gt;
 	       &lt;/attributes&gt;
 	   &lt;/entry&gt;
     &lt;entry&gt; .... &lt;/entry&gt;
    .....
 &lt;/entries&gt;
 }&lt;/pre&gt;
 &lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LdapSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LocalFileSystemErrorSender">
        <xs:annotation>
          <xs:documentation>Sender to work with the server local filesystem.
 &lt;p&gt;
     In addition to regular parameters for filesystem senders, it is possible
     to set custom extended attributes on files by prefixing parameter names with
     FileAttribute..
     This prefix will be not be part of the actual metadata property name.
 &lt;/p&gt;
 &lt;p&gt;
     The string value of these parameters will be used as value of the custom metadata attribute.
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LocalFileSystemSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LogErrorSender">
        <xs:annotation>
          <xs:documentation>Sender that just logs its message.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LogSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MQErrorSender">
        <xs:annotation>
          <xs:documentation>JMS sender which will call IBM WebSphere MQ specific
 setTargetClient(JMSC.MQJMS_CLIENT_NONJMS_MQ) on the destination prior to
 sending a message. This is needed when the MQ destination is not a JMS
 receiver otherwise format errors occur (e.g. dots are added after every
 character in the message).

 &lt;p&gt;See JmsSender for configuration&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MQSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MailErrorSender">
        <xs:annotation>
          <xs:documentation>sender that sends a mail specified by an XML message.
 &lt;p&gt;
 Sample email.xml:
 &lt;pre&gt;{@code
 &lt;email&gt;
     &lt;recipients&gt;
         &lt;recipient type="to"&gt;***@hotmail.com&lt;/recipient&gt;
         &lt;recipient type="cc"&gt;***@gmail.com&lt;/recipient&gt;
     &lt;/recipients&gt;
     &lt;from name="*** ***"&gt;***@yahoo.com&lt;/from&gt;
     &lt;subject&gt;This is the subject&lt;/subject&gt;
     &lt;threadTopic&gt;subject&lt;/threadTopic&gt;
     &lt;message&gt;This is the message&lt;/message&gt;
     &lt;messageType&gt;text/plain&lt;/messageType&gt;&lt;!-- Optional --&gt;
     &lt;messageBase64&gt;false&lt;/messageBase64&gt;&lt;!-- Optional --&gt;
     &lt;charset&gt;UTF-8&lt;/charset&gt;&lt;!-- Optional --&gt;
     &lt;attachments&gt;
         &lt;attachment name="filename1.txt"&gt;This is the first attachment&lt;/attachment&gt;
         &lt;attachment name="filename2.pdf" base64="true"&gt;JVBERi0xLjQKCjIgMCBvYmoKPDwvVHlwZS9YT2JqZWN0L1N1YnR5cGUvSW1...vSW5mbyA5IDAgUgo+PgpzdGFydHhyZWYKMzQxNDY2CiUlRU9GCg==&lt;/attachment&gt;
         &lt;attachment name="filename3.pdf" url="file:/c:/filename3.pdf"/&gt;
         &lt;attachment name="filename4.pdf" sessionKey="fileContent"/&gt;
     &lt;/attachments&gt;&lt;!-- Optional --&gt;
 &lt;/email&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;&lt;p&gt;
 Notice: the XML message must be valid XML. Therefore, especially the message element
 must be plain text or be wrapped as CDATA. Example:
 &lt;pre&gt;{@code
 &lt;message&gt;&lt;![CDATA[&lt;h1&gt;This is a HtmlMessage&lt;/h1&gt;]]&gt;&lt;/message&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;&lt;p&gt;
 The &lt;code&gt;sessionKey&lt;/code&gt; attribute for attachment can contain an inputstream or a string. Other types are not supported at this moment.
 &lt;/p&gt;&lt;p&gt;
 The attribute order for attachments is as follows:
 &lt;ol&gt;
    &lt;li&gt;sessionKey&lt;/li&gt;
    &lt;li&gt;url&lt;/li&gt;
    &lt;li&gt;&lt;i&gt;value of the attachment element&lt;/i&gt;&lt;/li&gt;
 &lt;/ol&gt;
 &lt;/p&gt;&lt;p&gt;
 The &lt;code&gt;base64&lt;/code&gt; attribute is only used when the value of the PipeLineSession variable &lt;code&gt;sessionKey&lt;/code&gt; is a String object
 or when the value of the attachment element is used. If &lt;code&gt;base64=true&lt;/code&gt; then the value will be decoded before it's used.
 &lt;/p&gt;&lt;p&gt;
 &lt;b&gt;Compilation and Deployment Note:&lt;/b&gt; mail.jar (v1.2) and activation.jar must appear BEFORE j2ee.jar.
 Otherwise errors like the following might occur: &lt;code&gt;NoClassDefFoundException: com/sun/mail/util/MailDateFormat&lt;/code&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MailSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MessageStoreErrorSender">
        <xs:annotation>
          <xs:documentation>Send messages to the IBISSTORE database table to have them processed exactly-once by another
 adapter which will read the messages using a MessageStoreListener.
 This other adapter will process the messages asynchronously and (optionally)
 under transaction control. Duplicate messages are ignored based on the
 messageId (except when onlyStoreWhenMessageIdUnique is set to false), hence
 the sender of the message can retry sending the message until a valid reply
 is received in which case it can be certain that the message is stored in the
 database table IBISSTORE.
 &lt;br/&gt;&lt;br/&gt;
 If you have a &lt;code&gt;MessageStoreSender&lt;/code&gt; it does not make sense to add a &lt;code&gt;JdbcMessageLog&lt;/code&gt;
 or &lt;code&gt;JdbcErrorStorage&lt;/code&gt; in the same sender pipe. A &lt;code&gt;MessageStoreSender&lt;/code&gt;
 acts as a message log and an error store. It can be useful however to add a message log or error store
 to the adapter around the sender pipe, because errors may occur before the message reaches the sender pipe.
 &lt;br/&gt;&lt;br/&gt;
 Example configuration:
 &lt;pre&gt;{@code
 &lt;SenderPipe name="Send"&gt;
     &lt;MessageStoreSender
 	     slotId="${instance.name}/TestMessageStore"
 		 onlyStoreWhenMessageIdUnique="false" /&gt;
 &lt;/SenderPipe&gt;
 }&lt;/pre&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MessageStoreSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MongoDbErrorSender">
        <xs:annotation>
          <xs:documentation>Sender to perform action on a MongoDB database.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MongoDbSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MqttErrorSender">
        <xs:annotation>
          <xs:documentation>MQTT listener which will connect to a broker and subscribe to a topic.

 Links to &lt;a href="https://www.eclipse.org/paho/files/javadoc" target="_blank"&gt;https://www.eclipse.org/paho/files/javadoc&lt;/a&gt; are opened in a new window/tab because the response from eclipse.org contains header X-Frame-Options:SAMEORIGIN which will make the browser refuse to open the link inside this frame.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MqttSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="NetStorageErrorSender">
        <xs:annotation>
          <xs:documentation>Sender for Akamai NetStorage (HTTP based).

 &lt;p&gt;See HttpSenderBase for more arguments and parameters!&lt;/p&gt;


 &lt;p&gt;&lt;b&gt;AuthAlias:&lt;/b&gt;&lt;/p&gt;
 &lt;p&gt;If you do not want to specify the nonce and the access token used to authenticate with Akamai, you can use the authalias property. The username
 represents the nonce and the password the access token.&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="NetStorageSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ParallelSendersErrorSender">
        <xs:annotation>
          <xs:documentation>Collection of Senders, that are executed all at the same time.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ParallelSendersType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ReconnectSenderWrapperErrorSender">
        <xs:annotation>
          <xs:documentation>Wrapper for senders, that opens the wrapped sender at runtime before each sender action, and closes it afterwards.
 This prevents (long) open connections inside Senders and possible connection failures.

 &lt;b&gt;Example:&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;SenderPipe&gt;
     &lt;ReconnectSenderWrapper&gt;
         &lt;EchoSender myAttribute="myValue" /&gt;
     &lt;/ReconnectSenderWrapper&gt;
 &lt;/SenderPipe&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ReconnectSenderWrapperType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ReloadErrorSender">
        <xs:annotation>
          <xs:documentation>Performs a reload on database configuration.

 &lt;p&gt;It is possible to set the name of the configuration with the parameter 'name'.&lt;/p&gt;
 &lt;p&gt;You can dynamically set 'forceReload' attribute with the parameter 'forceReload'.&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ReloadSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ResultSet2FileErrorSender">
        <xs:annotation>
          <xs:documentation>QuerySender that writes each row in a ResultSet to a file.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ResultSet2FileSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Samba1ErrorSender">
        <xs:annotation>
          <xs:documentation>Uses the (old) SMB 1 protocol.
 &lt;br/&gt;
 Only supports NTLM authentication.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Samba1SenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Samba2ErrorSender">
        <xs:annotation>
          <xs:documentation>Uses the (newer) SMB 2 and 3 protocol.

 Possible error codes:
 &lt;br/&gt;
 Pre-authentication information was invalid (24) or Identifier doesn't match expected value (906): login information is incorrect
 Server not found in Kerberos database (7): Verify that the hostname is the FQDN and the server is using a valid SPN.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Samba2SenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SapErrorSender">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SapSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SchedulerErrorSender">
        <xs:annotation>
          <xs:documentation>Registers a trigger in the scheduler so that the message is send to a javalistener
 at a scheduled time.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SchedulerSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SendGridErrorSender">
        <xs:annotation>
          <xs:documentation>Sender that sends a mail via SendGrid v3 (cloud-based SMTP provider).

 Sample XML file can be found in the path: iaf-core/src/test/resources/emailSamplesXML/emailSample.xml</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SendGridSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SenderSeriesErrorSender">
        <xs:annotation>
          <xs:documentation>Series of Senders, that are executed one after another.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SenderSeriesType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SenderWrapperErrorSender">
        <xs:annotation>
          <xs:documentation>Wrapper for senders, that allows to get input from a session variable, and to store output in a session variable.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SenderWrapperType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SftpFileSystemErrorSender">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SftpFileSystemSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ShadowErrorSender">
        <xs:annotation>
          <xs:documentation>Collection of Senders, that are executed all at the same time. Once the results are processed, all results will be sent to the resultSender,
 while the original sender will return its result to the pipeline.

 &lt;p&gt;Multiple sub-senders can be configured within the ShadowSender, the minimum amount of senders is 2 (originalSender + resultSender)&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ShadowSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="StoredProcedureQueryErrorSender">
        <xs:annotation>
          <xs:documentation>StoredProcedureQuerySender is used to send stored procedure queries and retrieve the result.

 &lt;p&gt;
     &lt;h3&gt;QueryType settings and OUTPUT parameters&lt;/h3&gt;
 The StoredProcedureQuerySender class has the following features:
 &lt;ul&gt;
     &lt;li&gt;It supports setting the output parameters of the stored procedure by setting 'mode' attribute of
     the corresponding 'Param' to 'OUTPUT' or 'INOUT'.&lt;/li&gt;
     &lt;li&gt;The queryType can only be 'SELECT' or 'OTHER'.&lt;/li&gt;
     &lt;li&gt;Use queryType 'SELECT' when the stored procedure only returns a set of rows, and you need
     the output to be the format as FixedQuerySender (see DB2XMLWriter).&lt;/li&gt;
     &lt;li&gt;Use queryType 'OTHER' if the stored procedure has one or more output parameters. With this query type,
     the stored procedure can return a result-set along with returning some values in output parameters.
     Depending on the database, the stored procedure can even returning multiple result sets or a combination
     of result sets as return values, and result sets as REF_CURSOR OUT parameters. &lt;/li&gt;
 &lt;/ul&gt;
 &lt;/p&gt;
 &lt;p&gt;
     All stored procedure parameters that are not fixed, so specified in the query with a {@code ?}, should
     have a corresponding IParameter entry. Output parameters should have {@code mode="OUTPUT"}, or
     {@code mode="INOUT"} depending on how the stored procedure is defined.
 &lt;/p&gt;
 &lt;p&gt;
	&lt;h3&gt;Sample Output for queryType=OTHER&lt;/h3&gt;
	&lt;h4&gt;Basic Example with Only Simple Output Parameters&lt;/h4&gt;
 &lt;pre&gt;{@code
 &lt;resultset&gt;
 	   &lt;result param="r1" type="STRING"&gt;MESSAGE-CONTENTS&lt;/result&gt;
     &lt;result param="r2" type="STRING"&gt;E&lt;/result&gt;
 &lt;/resultset&gt;
 }&lt;/pre&gt;

	&lt;h4&gt;Example with Resultset and Simple Output Parameters&lt;/h4&gt;
 &lt;pre&gt;{@code
 &lt;resultset&gt;
 		 &lt;result resultNr="1"&gt;
 			 &lt;fielddefinition&gt;
 				&lt;field name="FIELDNAME"
 						  type="columnType"
 						  columnDisplaySize=""
 						  precision=""
 						  scale=""
 						  isCurrency=""
 						  columnTypeName=""
 						  columnClassName=""/&gt;
 				 &lt;field ...../&gt;
  		     &lt;/fielddefinition&gt;
 			 &lt;rowset&gt;
 				 &lt;row number="0"&gt;
 					 &lt;field name="TKEY"&gt;MSG-ID&lt;/field&gt;
 					 &lt;field name="TCHAR"&gt;E&lt;/field&gt;
 					 &lt;field name="TMESSAGE"&gt;MESSAGE-CONTENTS&lt;/field&gt;
 					 &lt;field name="TCLOB" null="true"/&gt;
 					 &lt;field name="TBLOB" null="true"/&gt;
 				 &lt;/row&gt;
                  &lt;row number="1" ...../&gt;
 			 &lt;/rowset&gt;
 		 &lt;/result&gt;
 		 &lt;result param="count" type="INTEGER"&gt;5&lt;/result&gt;
 &lt;/resultset&gt;
 }&lt;/pre&gt;

	&lt;h4&gt;Example with Simple and Cursor Output Parameters&lt;/h4&gt;
 &lt;pre&gt;{@code
 &lt;resultset&gt;
 		&lt;result param="count" type="INTEGER"&gt;5&lt;/result&gt;
 		&lt;result param="cursor1" type="LIST"&gt;
 			 &lt;fielddefinition&gt;
 				&lt;field name="FIELDNAME"
 						  type="columnType"
 						  columnDisplaySize=""
 						  precision=""
 						  scale=""
 						  isCurrency=""
 						  columnTypeName=""
 						  columnClassName=""/&gt;
 				 &lt;field ...../&gt;
  		&lt;/fielddefinition&gt;
 			&lt;rowset&gt;
 				&lt;row number="0"&gt;
 					&lt;field name="TKEY"&gt;MSG-ID&lt;/field&gt;
 					&lt;field name="TCHAR"&gt;E&lt;/field&gt;
 					&lt;field name="TMESSAGE"&gt;MESSAGE-CONTENTS&lt;/field&gt;
 					&lt;field name="TCLOB" null="true"/&gt;
 					&lt;field name="TBLOB" null="true"/&gt;
 				&lt;/row&gt;
 				&lt;row number="1" ..... /&gt;
 			&lt;/rowset&gt;
 		&lt;/result&gt;
 	&lt;/resultset&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;
 &lt;p&gt;&lt;em&gt;NOTE:&lt;/em&gt; Support for stored procedures is currently experimental and changes in the currently produced output-format
 are expected.&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="StoredProcedureQuerySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="WebServiceErrorSender">
        <xs:annotation>
          <xs:documentation>Sender that sends a message via a WebService.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="WebServiceSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XComErrorSender">
        <xs:annotation>
          <xs:documentation>XCom client voor het versturen van files via XCom.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XComSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XfbErrorSender">
        <xs:annotation>
          <xs:documentation>Sender for transferring files using the XFB protocol. Assumes sender input is local filename.
 &lt;br/&gt;
 Some comments from Richard Maddox (FTO) about UNIX File permissions:
 &lt;br/&gt;
 &lt;br/&gt;
 In case of AIX or SUN systems we advise the following user and directory permissions:
 &lt;br/&gt;
 &lt;br/&gt;
 SENDING CFT:
 &lt;br/&gt;
 - App_user must have secondary group: xfbgw
 &lt;br/&gt;
 - Folder should have ownership: app_user:xfbgw   (owner:group)
 &lt;br/&gt;
 - Folder should have access rights: 770  (rwx.rwx.---)  so nobody other then app_user and group xfbgw can do something in this folder
 &lt;br/&gt;
 - Folder should have SGID bit set so that all files what is copied to this folder get group ownership xfbgw
 &lt;br/&gt;
 - send file must have rights 660 after putting the file in the send directory.
 &lt;br/&gt;
 &lt;br/&gt;
 RECEIVING CFT:
 &lt;br/&gt;
 - App_user (the application user of customer) should have secondary group: xfbgw
 &lt;br/&gt;
 - Folder should have ownership:  app_user:xfbgw   (owner:group)
 &lt;br/&gt;
 - Folder should have access rights: 770  (rwx.rwx.---)  so nobody other then app_user and group xfbgw can do something in this folder
 &lt;br/&gt;
 - Folder should have SGID bit set, so that all files what is copied to this folder get group ownership xfbgw
 &lt;br/&gt;
 &lt;br/&gt;
 There are of course more solutions to get the job done, but this is the solution we can guarantee.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XfbSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlJmsBrowserErrorSender">
        <xs:annotation>
          <xs:documentation>Sender for browsing and removing queue messages (with input and output in a XML message).

 &lt;p&gt;
 When input root element is &lt;code&gt;browse&lt;/code&gt; all queue messages are returned.
 &lt;/p&gt;
 &lt;p&gt;
 When input root element is &lt;code&gt;remove&lt;/code&gt; all queue messages are removed.
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;example (input):&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;browse&gt;
    &lt;jmsRealm&gt;qcf&lt;/jmsRealm&gt;
    &lt;destinationName&gt;jms/GetPolicyDetailsRequest&lt;/destinationName&gt;
    &lt;destinationType&gt;QUEUE&lt;/destinationType&gt;
 &lt;/browse&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;example (browse output):&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;result&gt;
   &lt;items count="2"&gt;
      &lt;item&gt;
         &lt;timestamp&gt;Thu Nov 20 13:36:31 CET 2014&lt;/timestamp&gt;
         &lt;messageId&gt;ID:LPAB00000003980-61959-1416486781822-3:5:33:1:1&lt;/messageId&gt;
         &lt;correlationId&gt;...&lt;/correlationId&gt;
         &lt;message&gt;&lt;![CDATA[...]]&gt;&lt;/message&gt;
      &lt;/item&gt;
      &lt;item&gt;
         &lt;timestamp&gt;Thu Dec 12 11:59:22 CET 2014&lt;/timestamp&gt;
         &lt;messageId&gt;ID:LPAB00000003980-58359-1721486799722-3:4:19:1:1&lt;/messageId&gt;
         &lt;correlationId&gt;...&lt;/correlationId&gt;
         &lt;message&gt;&lt;![CDATA[...]]&gt;&lt;/message&gt;
      &lt;/item&gt;
 	 &lt;/items&gt;
 &lt;/result&gt;
 }&lt;/pre&gt;
 &lt;/p&gt;

 &lt;p&gt;
 &lt;b&gt;example (remove output):&lt;/b&gt;
 &lt;pre&gt;{@code
 &lt;result&gt;
     &lt;itemsRemoved&gt;2&lt;/itemsRemoved&gt;
 &lt;/result&gt;
 }&lt;/pre&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlJmsBrowserSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlQueryErrorSender">
        <xs:annotation>
          <xs:documentation>QuerySender that transforms the input message to a query.
 &lt;br/&gt;
 &lt;pre&gt;{@code
  select
  delete
  insert
  update - tableName
         - columns [0..1] - column [1..n] - name
                                          - value [0..1]
                                          - type [0..1] one of {string;function;number;datetime;blob;clob;xmldatetime}, string by default
                                          - decimalSeparator [0..1] only applicable for type=number
                                          - groupingSeparator [0..1] only applicable for type=number
                                          - formatString [0..1] only applicable for type=datetime, yyyy-MM-dd HH:mm:ss.SSS by default
         - where [0..1]
         - order [0..1]

  alter - sequenceName
        - startWith

  sql   - type [0..1] one of {select;ddl;other}, other by default
        - query

 }&lt;/pre&gt;
 &lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlQuerySenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlValidatorErrorSender">
        <xs:annotation>
          <xs:documentation>Sender that validates the input message against a XML Schema.

 N.B. noNamespaceSchemaLocation may contain spaces, but not if the schema is stored in a .jar or .zip file on the class path.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlValidatorSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XsltErrorSender">
        <xs:annotation>
          <xs:documentation>Perform an XSLT transformation with a specified stylesheet or XPath-expression.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XsltSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ZipWriterErrorSender">
        <xs:annotation>
          <xs:documentation>Sender that writes an entry to a ZipStream, similar to ZipWriterPipe with action='write'.
 Filename and contents are taken from parameters. If one of the parameters is not present, the input message
 is used for either filename or contents.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ZipWriterSenderType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorSender" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="ErrorStorageElementGroup">
    <xs:choice>
      <xs:element name="ErrorStorage">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="errorStorage" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ErrorStorageElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ErrorStorageElementGroupBase">
    <xs:choice>
      <xs:element name="EsbJmsErrorStorage">
        <xs:annotation>
          <xs:documentation>ESB (Enterprise Service Bus) extension of JmsTransactionalStorage.

 &lt;p&gt;
 Depending on the &lt;code&gt;type&lt;/code&gt; of the &lt;code&gt;TransactionalStorage&lt;/code&gt;
 one of the following messages is sent:
 &lt;ul&gt;
 &lt;li&gt;&lt;code&gt;errorStore&lt;/code&gt;:
 ESB.Infrastructure.US.Log.BusinessLog.2.ExceptionLog.1.Action&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;messageLog&lt;/code&gt;:
 ESB.Infrastructure.US.Log.BusinessLog.2.AuditLog.1.Action&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;Configuration &lt;/b&gt;&lt;i&gt;(where deviating from
 JmsTransactionalStorage)&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;
 &lt;th&gt;attributes&lt;/th&gt;
 &lt;th&gt;description&lt;/th&gt;
 &lt;th&gt;default&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbJmsTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorStorage" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JdbcErrorStorage">
        <xs:annotation>
          <xs:documentation>Implements a message log (&lt;code&gt;JdbcMessageLog&lt;/code&gt;) or error store (&lt;code&gt;JdbcErrorStorage&lt;/code&gt;) that uses database
 table IBISSTORE. A &lt;code&gt;MessageStoreSender&lt;/code&gt; and &lt;code&gt;MessageStoreListener&lt;/code&gt;
 pair implicitly includes a message log and an error store.
 If you have a &lt;code&gt;MessageStoreSender&lt;/code&gt; and &lt;code&gt;MessageStoreListener&lt;/code&gt;
 pair it is superfluous to add a &lt;code&gt;JdbcMessageLog&lt;/code&gt; or &lt;code&gt;JdbcErrorStorage&lt;/code&gt;
 within the same sender pipe or the same receiver.
 &lt;br/&gt;&lt;br/&gt;
 &lt;b&gt;Message log:&lt;/b&gt; A message log writes messages in persistent storage for logging purposes.
 When a message log appears in a receiver, it also ensures that the same message is only processed
 once, even if a related pushing listener receives the same message multiple times.
 &lt;br/&gt;&lt;br/&gt;
 &lt;b&gt;Error store:&lt;/b&gt; Appears in a receiver or sender pipe to store messages that could not be processed.
 Storing a message in the error store is the last resort of the Frank!Framework. Many types of listeners and senders
 offer a retry mechanism. Only if several tries have failed, then an optional transaction is not rolled
 back and the message is stored in the error store. Users can retry messages in an error store using the Frank!Console. When
 this is done, the message is processed in the same way as messages received from the original source.
 &lt;br/&gt;&lt;br/&gt;
 How does a message log or error store see duplicate messages? The message log or error store
 always appears in combination with a sender or listener. This sender or listener determines
 a key based on the sent or received message. Messages with the same key are considered to
 be the same.
 &lt;br/&gt;&lt;br/&gt;
 Storage structure is defined in /IAF_util/IAF_DatabaseChangelog.xml. If these database objects do not exist,
 the Frank!Framework will try to create them.
 &lt;br/&gt;&lt;br/&gt;
 N.B. Note on using XA transactions:
 If transactions are used on Oracle, make sure that the database user can access the table SYS.DBA_PENDING_TRANSACTIONS.
 If not, transactions present when the server goes down cannot be properly recovered, resulting in exceptions like:
 &lt;pre&gt;
   The error code was XAER_RMERR. The exception stack trace follows: javax.transaction.xa.XAException
	at oracle.jdbc.xa.OracleXAResource.recover(OracleXAResource.java:508)
   &lt;/pre&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JdbcTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorStorage" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JmsErrorStorage">
        <xs:annotation>
          <xs:documentation>Implements a message log (&lt;code&gt;JmsMessageLog&lt;/code&gt;) or error store (&lt;code&gt;JmsErrorStorage&lt;/code&gt;) that uses JMS technology.
 &lt;br/&gt;&lt;br/&gt;
 &lt;b&gt;Message log:&lt;/b&gt; A message log writes messages in persistent storage for logging purposes.
 When a message log appears in a receiver, it also ensures that the same message is only processed
 once, even if a related pushing listener receives the same message multiple times.
 &lt;br/&gt;&lt;br/&gt;
 &lt;b&gt;Error store:&lt;/b&gt; Appears in a receiver or sender pipe to store messages that could not be processed.
 Storing a message in the error store is the last resort of the Frank!Framework. Many types of listeners and senders
 offer a retry mechanism. Only if several tries have failed, then an optional transaction is not rolled
 back and the message is stored in the error store. Users can retry messages in an error store using the Frank!Console. When
 this is done, the message is processed in the same way as messages received from the original source.
 &lt;br/&gt;&lt;br/&gt;
 How does a message log or error store see duplicate messages? The message log or error store
 always appears in combination with a sender or listener. This sender or listener determines
 a key based on the sent or received message. Messages with the same key are considered to
 be the same.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JmsTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorStorage" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="EsbJmsTransactionalStorageType">
    <xs:attributeGroup ref="JmsTransactionalStorageCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.esb.EsbJmsTransactionalStorage" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="JmsTransactionalStorageType">
    <xs:attributeGroup ref="JmsTransactionalStorageCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jms.JmsTransactionalStorage" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="JmsTransactionalStorageDeclaredAttributeGroup">
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>Optional identifier for this storage, to be able to share the physical storage between a number of receivers and pipes.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>Possible values are &lt;code&gt;E&lt;/code&gt; (error store), &lt;code&gt;M&lt;/code&gt; (message store), &lt;code&gt;L&lt;/code&gt; (message log for Pipe) or &lt;code&gt;A&lt;/code&gt; (message log for Receiver).&lt;br/&gt;
 Receiver will always set type to &lt;code&gt;E&lt;/code&gt; for errorStorage and always set type to &lt;code&gt;A&lt;/code&gt; for messageLog. SenderPipe will set type to &lt;code&gt;L&lt;/code&gt; for messageLog (when type isn't specified).&lt;br/&gt;
 See MessageStoreSender for type &lt;code&gt;M&lt;/code&gt;. Default: &lt;code&gt;E&lt;/code&gt; for errorStorage on Receiver&lt;br/&gt;&lt;code&gt;A&lt;/code&gt; for messageLog on Receiver&lt;br/&gt;&lt;code&gt;L&lt;/code&gt; for messageLog on Pipe</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JmsTransactionalStorageCumulativeAttributeGroup">
    <xs:attributeGroup ref="JmsTransactionalStorageDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JmsMessageBrowserCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JmsMessageBrowserDeclaredAttributeGroup">
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Timeout &lt;i&gt;in milliseconds&lt;/i&gt; for receiving a message from the queue Default: 3000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>Regular expression to mask strings in the errorStore/logStore.
 Every character between to the strings in this expression will be replaced by a '*'.
 &lt;br/&gt;
 For example, the regular expression (?&amp;lt;=&amp;lt;party&amp;gt;).*?(?=&amp;lt;/party&amp;gt;) will replace every
 character between keys &amp;lt;party&amp;gt; and &amp;lt;/party&amp;gt;
 &lt;br/&gt;
 When no hideRegex is configured on the errorStore / logStore but is configured on the org.frankframework.receivers.Receiver#setHideRegex(String),
 then the Receiver's hideRegex is used for the errorStore / logStore.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod">
      <xs:annotation>
        <xs:documentation>(Only used when hideRegex is not empty) Specifies the way to hide Default: ALL</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="HideMethodAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JmsMessageBrowserCumulativeAttributeGroup">
    <xs:attributeGroup ref="JmsMessageBrowserDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JMSFacadeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="MessageLogElementGroup">
    <xs:choice>
      <xs:element name="MessageLog">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="messageLog" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="MessageLogElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="MessageLogElementGroupBase">
    <xs:choice>
      <xs:element name="EsbJmsMessageLog">
        <xs:annotation>
          <xs:documentation>ESB (Enterprise Service Bus) extension of JmsTransactionalStorage.

 &lt;p&gt;
 Depending on the &lt;code&gt;type&lt;/code&gt; of the &lt;code&gt;TransactionalStorage&lt;/code&gt;
 one of the following messages is sent:
 &lt;ul&gt;
 &lt;li&gt;&lt;code&gt;errorStore&lt;/code&gt;:
 ESB.Infrastructure.US.Log.BusinessLog.2.ExceptionLog.1.Action&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;messageLog&lt;/code&gt;:
 ESB.Infrastructure.US.Log.BusinessLog.2.AuditLog.1.Action&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;Configuration &lt;/b&gt;&lt;i&gt;(where deviating from
 JmsTransactionalStorage)&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;
 &lt;th&gt;attributes&lt;/th&gt;
 &lt;th&gt;description&lt;/th&gt;
 &lt;th&gt;default&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbJmsTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="messageLog" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JdbcMessageLog">
        <xs:annotation>
          <xs:documentation>Implements a message log (&lt;code&gt;JdbcMessageLog&lt;/code&gt;) or error store (&lt;code&gt;JdbcErrorStorage&lt;/code&gt;) that uses database
 table IBISSTORE. A &lt;code&gt;MessageStoreSender&lt;/code&gt; and &lt;code&gt;MessageStoreListener&lt;/code&gt;
 pair implicitly includes a message log and an error store.
 If you have a &lt;code&gt;MessageStoreSender&lt;/code&gt; and &lt;code&gt;MessageStoreListener&lt;/code&gt;
 pair it is superfluous to add a &lt;code&gt;JdbcMessageLog&lt;/code&gt; or &lt;code&gt;JdbcErrorStorage&lt;/code&gt;
 within the same sender pipe or the same receiver.
 &lt;br/&gt;&lt;br/&gt;
 &lt;b&gt;Message log:&lt;/b&gt; A message log writes messages in persistent storage for logging purposes.
 When a message log appears in a receiver, it also ensures that the same message is only processed
 once, even if a related pushing listener receives the same message multiple times.
 &lt;br/&gt;&lt;br/&gt;
 &lt;b&gt;Error store:&lt;/b&gt; Appears in a receiver or sender pipe to store messages that could not be processed.
 Storing a message in the error store is the last resort of the Frank!Framework. Many types of listeners and senders
 offer a retry mechanism. Only if several tries have failed, then an optional transaction is not rolled
 back and the message is stored in the error store. Users can retry messages in an error store using the Frank!Console. When
 this is done, the message is processed in the same way as messages received from the original source.
 &lt;br/&gt;&lt;br/&gt;
 How does a message log or error store see duplicate messages? The message log or error store
 always appears in combination with a sender or listener. This sender or listener determines
 a key based on the sent or received message. Messages with the same key are considered to
 be the same.
 &lt;br/&gt;&lt;br/&gt;
 Storage structure is defined in /IAF_util/IAF_DatabaseChangelog.xml. If these database objects do not exist,
 the Frank!Framework will try to create them.
 &lt;br/&gt;&lt;br/&gt;
 N.B. Note on using XA transactions:
 If transactions are used on Oracle, make sure that the database user can access the table SYS.DBA_PENDING_TRANSACTIONS.
 If not, transactions present when the server goes down cannot be properly recovered, resulting in exceptions like:
 &lt;pre&gt;
   The error code was XAER_RMERR. The exception stack trace follows: javax.transaction.xa.XAException
	at oracle.jdbc.xa.OracleXAResource.recover(OracleXAResource.java:508)
   &lt;/pre&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JdbcTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="messageLog" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JmsMessageLog">
        <xs:annotation>
          <xs:documentation>Implements a message log (&lt;code&gt;JmsMessageLog&lt;/code&gt;) or error store (&lt;code&gt;JmsErrorStorage&lt;/code&gt;) that uses JMS technology.
 &lt;br/&gt;&lt;br/&gt;
 &lt;b&gt;Message log:&lt;/b&gt; A message log writes messages in persistent storage for logging purposes.
 When a message log appears in a receiver, it also ensures that the same message is only processed
 once, even if a related pushing listener receives the same message multiple times.
 &lt;br/&gt;&lt;br/&gt;
 &lt;b&gt;Error store:&lt;/b&gt; Appears in a receiver or sender pipe to store messages that could not be processed.
 Storing a message in the error store is the last resort of the Frank!Framework. Many types of listeners and senders
 offer a retry mechanism. Only if several tries have failed, then an optional transaction is not rolled
 back and the message is stored in the error store. Users can retry messages in an error store using the Frank!Console. When
 this is done, the message is processed in the same way as messages received from the original source.
 &lt;br/&gt;&lt;br/&gt;
 How does a message log or error store see duplicate messages? The message log or error store
 always appears in combination with a sender or listener. This sender or listener determines
 a key based on the sent or received message. Messages with the same key are considered to
 be the same.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JmsTransactionalStorageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="messageLog" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="ErrorMessageFormatterElementGroup">
    <xs:choice>
      <xs:element name="ErrorMessageFormatter">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="Param" type="ParamType" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="errorMessageFormatter" use="prohibited" />
          <xs:attribute name="className" type="xs:string" default="org.frankframework.errormessageformatters.ErrorMessageFormatter" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ErrorMessageFormatterElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ErrorMessageFormatterElementGroupBase">
    <xs:choice>
      <xs:element name="FixedErrorMessageFormatter">
        <xs:annotation>
          <xs:documentation>ErrorMessageFormatter that returns a fixed message with replacements.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FixedErrorMessageFormatterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorMessageFormatter" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SoapErrorMessageFormatter">
        <xs:annotation>
          <xs:documentation>ErrorMessageFormatter that returns a soap fault message.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SoapErrorMessageFormatterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorMessageFormatter" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XslErrorMessageFormatter">
        <xs:annotation>
          <xs:documentation>Applies a XSLT-stylesheet to the standard error generated by an ErrorMessageFormatter.

 If the transformation does not succeed, this 'standard' error message is returned and an exception is logged.

 Hint: use &lt;code&gt;xpathExression="/errorMessage/@message"&lt;/code&gt; for a single compact string as errormessage.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XslErrorMessageFormatterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="errorMessageFormatter" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="FixedErrorMessageFormatterType">
    <xs:attributeGroup ref="FixedErrorMessageFormatterDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.errormessageformatters.FixedErrorMessageFormatter" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="FixedErrorMessageFormatterDeclaredAttributeGroup">
    <xs:attribute name="returnString" type="xs:string">
      <xs:annotation>
        <xs:documentation>returned message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filename" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the file containing the result message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceFrom" type="xs:string" />
    <xs:attribute name="replaceTo" type="xs:string" />
    <xs:attribute name="styleSheetName" type="xs:string" />
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="SoapErrorMessageFormatterType">
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.errormessageformatters.SoapErrorMessageFormatter" use="prohibited" />
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:complexType>
  <xs:complexType name="XslErrorMessageFormatterType">
    <xs:group ref="XslErrorMessageFormatterDeclaredChildGroup" />
    <xs:attributeGroup ref="XslErrorMessageFormatterDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.errormessageformatters.XslErrorMessageFormatter" use="prohibited" />
  </xs:complexType>
  <xs:group name="XslErrorMessageFormatterDeclaredChildGroup">
    <xs:sequence>
      <xs:element name="Param" minOccurs="0" maxOccurs="unbounded" type="ParamType" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="XslErrorMessageFormatterDeclaredAttributeGroup">
    <xs:attribute name="styleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>URL to the stylesheet used to transform the output of the standard ErrorMessageFormatter</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>xPathExpression to use for transformation</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:group name="InputValidatorElementGroup">
    <xs:choice>
      <xs:element name="InputValidator">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="Forward" type="ForwardType" />
              <xs:element name="Locker" type="LockerType" />
              <xs:group ref="ParamElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="InputValidatorElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="InputValidatorElementGroupBase">
    <xs:choice>
      <xs:element name="ApiWsdlXmlInputValidator">
        <xs:annotation>
          <xs:documentation>Extension to WsdlXmlValidator for API Management.

 The SOAP header can only contain the following schema (or it's empty):
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;mandatory&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;xmlns="http://api.nn.nl/MessageHeader"&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;no&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ApiWsdlXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbSoapInputValidator">
        <xs:annotation>
          <xs:documentation>XmlValidator that will automatically add the SOAP envelope XSD and the ESB XSD (e.g. a CommonMessageHeader.xsd)
 to the set of XSDs used for validation.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbSoapValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FxfXmlInputValidator">
        <xs:annotation>
          <xs:documentation>FxF XML validator to be used with FxF3. When receiving files
 (direction=receive) the message is validated against the
 OnCompletedTransferNotify WSDL (a P2P connection, hence same WSDL (provided
 by Tibco) for all queues (every Ibis receiving FxF files has it's own
 queue)). When sending files (direction=send) the message is validated against
 the StartTransfer WSDL (ESB service provided by Tibco).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FxfXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Json2XmlInputValidator">
        <xs:annotation>
          <xs:documentation>&lt;code&gt;Pipe&lt;/code&gt; that validates the XML or JSON input message against a XML Schema and returns either XML or JSON.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Json2XmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JsonInputValidator">
        <xs:annotation>
          <xs:documentation>Pipe that validates the input message against a JSON Schema.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JsonValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SoapInputValidator">
        <xs:annotation>
          <xs:documentation>XmlValidator that will automatically add the SOAP envelope XSD to the set of XSD's used for validation.

 Before the &lt;code&gt;outputSoapBody&lt;/code&gt; attribute was introduced, two validators were used for a request-reply pattern (an inputValidator for the request and an outputValidator for the reply).
 These inputValidator and outputValidator were identical except for the child element of the SOAP body. Because validators use relatively a lot of memory, the &lt;code&gt;outputSoapBody&lt;/code&gt; attribute was added which replaces the outputValidator.
 Both the request and the reply are then validated by the inputValidator.
 &lt;p&gt;To generate a wsdl with a soap action included one of the following properties must be set to the expected soapAction&lt;/p&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;td&gt;wsdl.${adapterName}.${listenerName}.soapAction&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;wsdl.${adapterName}.soapAction&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;wsdl.soapAction&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SoapValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="WsdlXmlInputValidator">
        <xs:annotation>
          <xs:documentation>XmlValidator that will read the XSD's to use from a WSDL. As it extends the
 SoapValidator is will also add the SOAP envelope XSD.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="WsdlXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlInputValidator">
        <xs:annotation>
          <xs:documentation>Pipe that validates the input message against an XML Schema.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlWellFormedCheckerInputValidator">
        <xs:annotation>
          <xs:documentation>&lt;code&gt;Pipe&lt;/code&gt; that checks the well-formedness of the input message.
 If &lt;code&gt;root&lt;/code&gt; is given then this is also checked.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlWellFormedCheckerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="ApiWsdlXmlValidatorType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="ApiWsdlXmlValidatorCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.api.ApiWsdlXmlValidator" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ApiWsdlXmlValidatorDeclaredAttributeGroup">
    <xs:attribute name="multipart" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>indicates whether the message is multipart/form-data. If so, the wsdl only represents the first part, other parts are attachments. This attribute is only used for generating the 'real' wsdl which is available in the ibis console (../rest/webservices) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ApiWsdlXmlValidatorCumulativeAttributeGroup">
    <xs:attributeGroup ref="ApiWsdlXmlValidatorDeclaredAttributeGroup" />
    <xs:attributeGroup ref="WsdlXmlValidatorCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="AbstractPipeDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="ParamElementGroup" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Locker" minOccurs="0" maxOccurs="1" type="LockerType" />
      <xs:element name="Forward" minOccurs="0" maxOccurs="unbounded" type="ForwardType" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="AbstractPipeDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>The functional name of this pipe. Can be referenced by the &lt;code&gt;path&lt;/code&gt; attribute of a PipeForward.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="getInputFromSessionKey" />
    <xs:attribute ref="getInputFromFixedValue" />
    <xs:attribute ref="emptyInputReplacement" />
    <xs:attribute ref="preserveInput" />
    <xs:attribute ref="storeResultInSessionKey" />
    <xs:attribute ref="maxThreads" />
    <xs:attribute ref="chompCharSize" />
    <xs:attribute ref="elementToMove" />
    <xs:attribute ref="elementToMoveSessionKey" />
    <xs:attribute ref="elementToMoveChain" />
    <xs:attribute ref="durationThreshold" />
    <xs:attribute ref="removeCompactMsgNamespaces" />
    <xs:attribute ref="restoreMovedElements" />
    <xs:attribute ref="sizeStatistics" />
    <xs:attribute ref="writeToSecLog" />
    <xs:attribute ref="secLogSessionKeys" />
    <xs:attribute ref="logIntermediaryResults" />
    <xs:attribute ref="hideRegex" />
  </xs:attributeGroup>
  <xs:attributeGroup name="AbstractPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="AbstractPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="TransactionAttributesDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="TransactionAttributesType">
    <xs:attributeGroup ref="TransactionAttributesDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.core.TransactionAttributes" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="TransactionAttributesDeclaredAttributeGroup">
    <xs:attribute ref="transactionTimeout" />
    <xs:attribute ref="transactionAttribute" />
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="WsdlXmlValidatorType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="WsdlXmlValidatorCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.WsdlXmlValidator" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="WsdlXmlValidatorDeclaredAttributeGroup">
    <xs:attribute name="wsdl" type="xs:string">
      <xs:annotation>
        <xs:documentation>The WSDL to read the XSDs from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the child element of the SOAP body, or a comma separated list of names to choose from (only one is allowed) (WSDL generator will use the first element) (use empty value to allow an empty SOAP body, for example to allow element x and an empty SOAP body use: x,). In case the request contains SOAPAction header and the WSDL contains an element specific to that SOAPAction, it will use that element as SOAP body.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocationToAdd" type="xs:string">
      <xs:annotation>
        <xs:documentation>Pairs of URI references which will be added to the WSDL</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>Creates &lt;code&gt;schemaLocation&lt;/code&gt; attribute based on the WSDL and replaces the namespace of the soap body element</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="WsdlXmlValidatorCumulativeAttributeGroup">
    <xs:attributeGroup ref="WsdlXmlValidatorDeclaredAttributeGroup" />
    <xs:attribute ref="outputSoapBody" />
    <xs:attribute ref="soapHeader" />
    <xs:attribute ref="soapHeaderNamespace" />
    <xs:attribute ref="soapVersion" />
    <xs:attribute ref="allowPlainXml" />
    <xs:attribute ref="ignoreUnknownNamespaces" />
    <xs:attributeGroup ref="Json2XmlValidatorDeclaredAttributeGroup" />
    <xs:attribute ref="schemaLocation" />
    <xs:attribute ref="noNamespaceSchemaLocation" />
    <xs:attribute ref="responseRoot" />
    <xs:attribute ref="fullSchemaChecking" />
    <xs:attribute ref="throwException" />
    <xs:attribute ref="reasonSessionKey" />
    <xs:attribute ref="xmlReasonSessionKey" />
    <xs:attribute ref="validateFile" />
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Characterset used for reading file, only used when &lt;code&gt;validateFile&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; Default: utf-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="addNamespaceToSchema" />
    <xs:attribute ref="importedSchemaLocationsToIgnore" />
    <xs:attribute ref="useBaseImportedSchemaLocationsToIgnore" />
    <xs:attribute ref="importedNamespacesToIgnore" />
    <xs:attribute ref="warn" />
    <xs:attribute ref="ignoreCaching" />
    <xs:attribute ref="xmlSchemaVersion" />
    <xs:attribute ref="rootElementSessionKey" />
    <xs:attribute ref="rootNamespaceSessionKey" />
    <xs:attribute ref="schemaSessionKey" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of this pipe. Can be referenced by the &lt;code&gt;path&lt;/code&gt; attribute of a PipeForward.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="FixedForwardPipeDeclaredAttributeGroup" />
    <xs:attribute ref="getInputFromSessionKey" />
    <xs:attribute ref="getInputFromFixedValue" />
    <xs:attribute ref="emptyInputReplacement" />
    <xs:attribute ref="preserveInput" />
    <xs:attribute ref="storeResultInSessionKey" />
    <xs:attribute ref="maxThreads" />
    <xs:attribute ref="chompCharSize" />
    <xs:attribute ref="elementToMove" />
    <xs:attribute ref="elementToMoveSessionKey" />
    <xs:attribute ref="elementToMoveChain" />
    <xs:attribute ref="durationThreshold" />
    <xs:attribute ref="removeCompactMsgNamespaces" />
    <xs:attribute ref="restoreMovedElements" />
    <xs:attribute ref="sizeStatistics" />
    <xs:attribute ref="writeToSecLog" />
    <xs:attribute ref="secLogSessionKeys" />
    <xs:attribute ref="logIntermediaryResults" />
    <xs:attribute ref="hideRegex" />
    <xs:attributeGroup ref="TransactionAttributesDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SoapValidatorType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="SoapValidatorCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.soap.SoapValidator" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="SoapValidatorDeclaredAttributeGroup">
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the child element of the SOAP body, or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap body, for example to allow element x and an empty soap body use: x,)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="outputSoapBody" />
    <xs:attribute ref="soapHeader" />
    <xs:attribute ref="soapHeaderNamespace" />
    <xs:attribute ref="soapVersion" />
    <xs:attribute ref="allowPlainXml" />
    <xs:attribute ref="ignoreUnknownNamespaces" />
  </xs:attributeGroup>
  <xs:attributeGroup name="SoapValidatorCumulativeAttributeGroup">
    <xs:attributeGroup ref="SoapValidatorDeclaredAttributeGroup" />
    <xs:attributeGroup ref="Json2XmlValidatorDeclaredAttributeGroup" />
    <xs:attribute ref="schemaLocation" />
    <xs:attribute ref="noNamespaceSchemaLocation" />
    <xs:attribute ref="responseRoot" />
    <xs:attribute ref="fullSchemaChecking" />
    <xs:attribute ref="throwException" />
    <xs:attribute ref="reasonSessionKey" />
    <xs:attribute ref="xmlReasonSessionKey" />
    <xs:attribute ref="validateFile" />
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Characterset used for reading file, only used when &lt;code&gt;validateFile&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; Default: utf-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="addNamespaceToSchema" />
    <xs:attribute ref="importedSchemaLocationsToIgnore" />
    <xs:attribute ref="useBaseImportedSchemaLocationsToIgnore" />
    <xs:attribute ref="importedNamespacesToIgnore" />
    <xs:attribute ref="warn" />
    <xs:attribute ref="ignoreCaching" />
    <xs:attribute ref="xmlSchemaVersion" />
    <xs:attribute ref="rootElementSessionKey" />
    <xs:attribute ref="rootNamespaceSessionKey" />
    <xs:attribute ref="schemaSessionKey" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of this pipe. Can be referenced by the &lt;code&gt;path&lt;/code&gt; attribute of a PipeForward.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="FixedForwardPipeDeclaredAttributeGroup" />
    <xs:attribute ref="getInputFromSessionKey" />
    <xs:attribute ref="getInputFromFixedValue" />
    <xs:attribute ref="emptyInputReplacement" />
    <xs:attribute ref="preserveInput" />
    <xs:attribute ref="storeResultInSessionKey" />
    <xs:attribute ref="maxThreads" />
    <xs:attribute ref="chompCharSize" />
    <xs:attribute ref="elementToMove" />
    <xs:attribute ref="elementToMoveSessionKey" />
    <xs:attribute ref="elementToMoveChain" />
    <xs:attribute ref="durationThreshold" />
    <xs:attribute ref="removeCompactMsgNamespaces" />
    <xs:attribute ref="restoreMovedElements" />
    <xs:attribute ref="sizeStatistics" />
    <xs:attribute ref="writeToSecLog" />
    <xs:attribute ref="secLogSessionKeys" />
    <xs:attribute ref="logIntermediaryResults" />
    <xs:attribute ref="hideRegex" />
    <xs:attributeGroup ref="TransactionAttributesDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Json2XmlValidatorType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="Json2XmlValidatorCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.Json2XmlValidator" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="Json2XmlValidatorDeclaredAttributeGroup">
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>Only for JSON input: namespace of the resulting XML. Need only be specified when the namespace of root name is ambiguous in the schema</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat">
      <xs:annotation>
        <xs:documentation>Default format of the result, that is used if the format cannot be found from outputFormatSessionKey or from inputFormatSessionKey (when validating responses and autoFormat=true) Default: XML</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="DocumentFormatAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key to retrieve outputFormat from Default: outputFormat</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key to store the inputFormat in, to be able to set the outputformat when autoFormat=true. Can also be used to pass the value of an HTTP Accept header, to obtain a properly formatted response Default: Json2XmlValidator.inputFormat &amp;lt;name of the pipe&amp;gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, the format on 'output' is set to the same as the format of the input message on 'input'. The format of the input message is stored in and retrieved from the session variable specified by outputFormatSessionKey Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compactJsonArrays" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true assume arrays in JSON do not have the element containers like in XML Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true check that incoming JSON adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from JSON to XML Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, assume that JSON contains/must contain a root element Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, and converting from JSON to XML, parameter substitutions are searched for optional sub elements too. By default, only mandatory elements are searched for parameter substitutions. N.B. Currently this option might cause problems. Please try using more qualified parameters names (using '/') first Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUndeclaredElements" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, and converting from JSON to XML, elements in JSON that are not found in the XML Schema are ignored Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, an exception is thrown when a wildcard is found in the XML Schema when parsing an object. This often indicates that an element is not properly typed in the XML Schema, and could lead to ambuigities. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="acceptNamespacelessXml" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, all XML is allowed to be without namespaces. If no namespaces are detected (by the presence of the string 'xmlns') in the XML, the root namespace is added to the XML Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespacelessXml" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, all XML that is generated is without a namespace set Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateJsonToRootElementOnly" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, and converting to or from JSON, then the message root is the only rootValidation, ignoring root validations like for SOAP envelope and header set by descender classes like SoapValidator Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowJson" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Allow JSON input Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Json2XmlValidatorCumulativeAttributeGroup">
    <xs:attributeGroup ref="Json2XmlValidatorDeclaredAttributeGroup" />
    <xs:attributeGroup ref="XmlValidatorCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XmlValidatorType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="XmlValidatorCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.XmlValidator" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="XmlValidatorDeclaredAttributeGroup">
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>The filename of the schema on the classpath. It is not possible to specify a namespace using this attribute. (effectively the same as noNamespaceSchemaLocation)
 An example value would be "xml/xsd/GetPartyDetail.xsd".
 The value of the schema attribute is only used if the schemaLocation attribute and the noNamespaceSchemaLocation are not set.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="schemaLocation" />
    <xs:attribute ref="noNamespaceSchemaLocation" />
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the root element, or a comma separated list of element names. The validation fails if the root element is not present in the list. N.B. for WSDL generation only the first element is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="responseRoot" />
    <xs:attribute ref="fullSchemaChecking" />
    <xs:attribute ref="throwException" />
    <xs:attribute ref="reasonSessionKey" />
    <xs:attribute ref="xmlReasonSessionKey" />
    <xs:attribute ref="validateFile" />
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Characterset used for reading file, only used when &lt;code&gt;validateFile&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; Default: utf-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="addNamespaceToSchema" />
    <xs:attribute ref="importedSchemaLocationsToIgnore" />
    <xs:attribute ref="useBaseImportedSchemaLocationsToIgnore" />
    <xs:attribute ref="importedNamespacesToIgnore" />
    <xs:attribute ref="warn" />
    <xs:attribute name="ignoreUnknownNamespaces" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Ignore namespaces in the input message which are unknown Default: true when &lt;code&gt;schema&lt;/code&gt; or &lt;code&gt;noNamespaceSchemaLocation&lt;/code&gt; is used, false otherwise</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="ignoreCaching" />
    <xs:attribute ref="xmlSchemaVersion" />
    <xs:attribute ref="rootElementSessionKey" />
    <xs:attribute ref="rootNamespaceSessionKey" />
  </xs:attributeGroup>
  <xs:attributeGroup name="XmlValidatorCumulativeAttributeGroup">
    <xs:attributeGroup ref="XmlValidatorDeclaredAttributeGroup" />
    <xs:attribute ref="schemaSessionKey" />
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of this pipe. Can be referenced by the &lt;code&gt;path&lt;/code&gt; attribute of a PipeForward.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="FixedForwardPipeDeclaredAttributeGroup" />
    <xs:attribute ref="getInputFromSessionKey" />
    <xs:attribute ref="getInputFromFixedValue" />
    <xs:attribute ref="emptyInputReplacement" />
    <xs:attribute ref="preserveInput" />
    <xs:attribute ref="storeResultInSessionKey" />
    <xs:attribute ref="maxThreads" />
    <xs:attribute ref="chompCharSize" />
    <xs:attribute ref="elementToMove" />
    <xs:attribute ref="elementToMoveSessionKey" />
    <xs:attribute ref="elementToMoveChain" />
    <xs:attribute ref="durationThreshold" />
    <xs:attribute ref="removeCompactMsgNamespaces" />
    <xs:attribute ref="restoreMovedElements" />
    <xs:attribute ref="sizeStatistics" />
    <xs:attribute ref="writeToSecLog" />
    <xs:attribute ref="secLogSessionKeys" />
    <xs:attribute ref="logIntermediaryResults" />
    <xs:attribute ref="hideRegex" />
    <xs:attributeGroup ref="TransactionAttributesDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="ValidatorBaseDeclaredAttributeGroup">
    <xs:attribute ref="schemaSessionKey" />
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the root element</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="responseRoot" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the response root element</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of this pipe. Can be referenced by the &lt;code&gt;path&lt;/code&gt; attribute of a PipeForward.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ValidatorBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="ValidatorBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeDeclaredAttributeGroup" />
    <xs:attribute ref="getInputFromSessionKey" />
    <xs:attribute ref="getInputFromFixedValue" />
    <xs:attribute ref="emptyInputReplacement" />
    <xs:attribute ref="preserveInput" />
    <xs:attribute ref="storeResultInSessionKey" />
    <xs:attribute ref="maxThreads" />
    <xs:attribute ref="chompCharSize" />
    <xs:attribute ref="elementToMove" />
    <xs:attribute ref="elementToMoveSessionKey" />
    <xs:attribute ref="elementToMoveChain" />
    <xs:attribute ref="durationThreshold" />
    <xs:attribute ref="removeCompactMsgNamespaces" />
    <xs:attribute ref="restoreMovedElements" />
    <xs:attribute ref="sizeStatistics" />
    <xs:attribute ref="writeToSecLog" />
    <xs:attribute ref="secLogSessionKeys" />
    <xs:attribute ref="logIntermediaryResults" />
    <xs:attribute ref="hideRegex" />
    <xs:attributeGroup ref="TransactionAttributesDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="FixedForwardPipeDeclaredAttributeGroup">
    <xs:attribute name="skipOnEmptyInput" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set, the processing continues directly at the forward of this pipe, without executing the pipe itself, if the input is empty Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifParam&lt;/code&gt; equals &lt;code&gt;ifValue&lt;/code&gt; (otherwise this pipe is skipped)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>See &lt;code&gt;ifParam&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onlyIfSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of session variable to check if action must be executed. The pipe is only executed if the session variable exists and is not null</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onlyIfValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of session variable 'onlyIfSessionKey' to check if action must be executed. The pipe is only executed if the session variable has the specified value</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="unlessSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of session variable to check if action must be executed. The pipe is not executed if the session variable exists and is not null</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="unlessValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value of session variable 'unlessSessionKey' to check if action must be executed. The pipe is not executed if the session variable has the specified value</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FixedForwardPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="FixedForwardPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="EsbSoapValidatorType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="EsbSoapValidatorCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.esb.EsbSoapValidator" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="EsbSoapValidatorDeclaredAttributeGroup">
    <xs:attribute name="direction">
      <xs:simpleType>
        <xs:union memberTypes="DirectionAttributeValuesType_2 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="mode">
      <xs:simpleType>
        <xs:union memberTypes="ModeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="cmhVersion" type="frankInt">
      <xs:annotation>
        <xs:documentation>Only used when &lt;code&gt;mode=reg&lt;/code&gt;!&lt;/b&gt; Sets the Common Message Header version. 1 or 2 Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="EsbSoapValidatorCumulativeAttributeGroup">
    <xs:attributeGroup ref="EsbSoapValidatorDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SoapValidatorCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FxfXmlValidatorType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FxfXmlValidatorCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.fxf.FxfXmlValidator" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="FxfXmlValidatorDeclaredAttributeGroup">
    <xs:attribute name="direction">
      <xs:simpleType>
        <xs:union memberTypes="DirectionAttributeValuesType_3 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="fxfVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>either 3.1 or 3.2 Default: 3.1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FxfXmlValidatorCumulativeAttributeGroup">
    <xs:attributeGroup ref="FxfXmlValidatorDeclaredAttributeGroup" />
    <xs:attributeGroup ref="WsdlXmlValidatorCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JsonValidatorType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="JsonValidatorCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.JsonValidator" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="JsonValidatorDeclaredAttributeGroup">
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>The JSON Schema to validate to</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="subSchemaPrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>Prefix to element name to find subschema in schema Default: /definitions/</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set: key of session variable to store reasons of mis-validation in Default: failureReason</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JsonValidatorCumulativeAttributeGroup">
    <xs:attributeGroup ref="JsonValidatorDeclaredAttributeGroup" />
    <xs:attributeGroup ref="ValidatorBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XmlWellFormedCheckerType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="XmlWellFormedCheckerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.XmlWellFormedChecker" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="XmlWellFormedCheckerDeclaredAttributeGroup">
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the root element</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of this pipe. Can be referenced by the &lt;code&gt;path&lt;/code&gt; attribute of a PipeForward.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XmlWellFormedCheckerCumulativeAttributeGroup">
    <xs:attributeGroup ref="XmlWellFormedCheckerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeDeclaredAttributeGroup" />
    <xs:attribute ref="getInputFromSessionKey" />
    <xs:attribute ref="getInputFromFixedValue" />
    <xs:attribute ref="emptyInputReplacement" />
    <xs:attribute ref="preserveInput" />
    <xs:attribute ref="storeResultInSessionKey" />
    <xs:attribute ref="maxThreads" />
    <xs:attribute ref="chompCharSize" />
    <xs:attribute ref="elementToMove" />
    <xs:attribute ref="elementToMoveSessionKey" />
    <xs:attribute ref="elementToMoveChain" />
    <xs:attribute ref="durationThreshold" />
    <xs:attribute ref="removeCompactMsgNamespaces" />
    <xs:attribute ref="restoreMovedElements" />
    <xs:attribute ref="sizeStatistics" />
    <xs:attribute ref="writeToSecLog" />
    <xs:attribute ref="secLogSessionKeys" />
    <xs:attribute ref="logIntermediaryResults" />
    <xs:attribute ref="hideRegex" />
    <xs:attributeGroup ref="TransactionAttributesDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="OutputValidatorElementGroup">
    <xs:choice>
      <xs:element name="OutputValidator">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="Forward" type="ForwardType" />
              <xs:element name="Locker" type="LockerType" />
              <xs:group ref="ParamElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="OutputValidatorElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="OutputValidatorElementGroupBase">
    <xs:choice>
      <xs:element name="ApiWsdlXmlOutputValidator">
        <xs:annotation>
          <xs:documentation>Extension to WsdlXmlValidator for API Management.

 The SOAP header can only contain the following schema (or it's empty):
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;mandatory&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;xmlns="http://api.nn.nl/MessageHeader"&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;no&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ApiWsdlXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbSoapOutputValidator">
        <xs:annotation>
          <xs:documentation>XmlValidator that will automatically add the SOAP envelope XSD and the ESB XSD (e.g. a CommonMessageHeader.xsd)
 to the set of XSDs used for validation.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbSoapValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FxfXmlOutputValidator">
        <xs:annotation>
          <xs:documentation>FxF XML validator to be used with FxF3. When receiving files
 (direction=receive) the message is validated against the
 OnCompletedTransferNotify WSDL (a P2P connection, hence same WSDL (provided
 by Tibco) for all queues (every Ibis receiving FxF files has it's own
 queue)). When sending files (direction=send) the message is validated against
 the StartTransfer WSDL (ESB service provided by Tibco).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FxfXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Json2XmlOutputValidator">
        <xs:annotation>
          <xs:documentation>&lt;code&gt;Pipe&lt;/code&gt; that validates the XML or JSON input message against a XML Schema and returns either XML or JSON.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Json2XmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JsonOutputValidator">
        <xs:annotation>
          <xs:documentation>Pipe that validates the input message against a JSON Schema.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JsonValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SoapOutputValidator">
        <xs:annotation>
          <xs:documentation>XmlValidator that will automatically add the SOAP envelope XSD to the set of XSD's used for validation.

 Before the &lt;code&gt;outputSoapBody&lt;/code&gt; attribute was introduced, two validators were used for a request-reply pattern (an inputValidator for the request and an outputValidator for the reply).
 These inputValidator and outputValidator were identical except for the child element of the SOAP body. Because validators use relatively a lot of memory, the &lt;code&gt;outputSoapBody&lt;/code&gt; attribute was added which replaces the outputValidator.
 Both the request and the reply are then validated by the inputValidator.
 &lt;p&gt;To generate a wsdl with a soap action included one of the following properties must be set to the expected soapAction&lt;/p&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;td&gt;wsdl.${adapterName}.${listenerName}.soapAction&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;wsdl.${adapterName}.soapAction&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;wsdl.soapAction&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SoapValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="WsdlXmlOutputValidator">
        <xs:annotation>
          <xs:documentation>XmlValidator that will read the XSD's to use from a WSDL. As it extends the
 SoapValidator is will also add the SOAP envelope XSD.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="WsdlXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlOutputValidator">
        <xs:annotation>
          <xs:documentation>Pipe that validates the input message against an XML Schema.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlWellFormedCheckerOutputValidator">
        <xs:annotation>
          <xs:documentation>&lt;code&gt;Pipe&lt;/code&gt; that checks the well-formedness of the input message.
 If &lt;code&gt;root&lt;/code&gt; is given then this is also checked.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlWellFormedCheckerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputValidator" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="InputWrapperElementGroup">
    <xs:choice>
      <xs:element name="InputWrapper">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="Forward" type="ForwardType" />
              <xs:element name="Locker" type="LockerType" />
              <xs:group ref="ParamElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="inputWrapper" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="InputWrapperElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="InputWrapperElementGroupBase">
    <xs:choice>
      <xs:element name="ApiSoapInputWrapper">
        <xs:annotation>
          <xs:documentation>Extension to SoapWrapperPipe for API Management.
 &lt;p&gt;
 &lt;b&gt;Configuration &lt;/b&gt;&lt;i&gt;(where deviating from SoapWrapperPipe)&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;soapHeaderSessionKey&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt;: &lt;/td&gt;&lt;td&gt;soapHeader&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;soapHeaderStyleSheet&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt;: &lt;/td&gt;&lt;td&gt;/xml/xsl/api/soapHeader.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;&lt;p&gt;
 &lt;b&gt;/xml/xsl/api/soapHeader.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;&lt;code&gt;MessageHeader&lt;/code&gt; is only created when $conversationId is filled (otherwise skipped)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&lt;code&gt;From&lt;/code&gt; is only created when $from_in is filled (otherwise skipped) and it's created with the value of $from_out&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$conversationId&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://api.nn.nl/MessageHeader"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;from_in&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;from_out&lt;/td&gt;&lt;td&gt;property 'instance.name'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;conversationId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ApiSoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputWrapper" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbSoapInputWrapper">
        <xs:annotation>
          <xs:documentation>Extension to SoapWrapperPipe for separate modes.

 &lt;p&gt;&lt;b&gt;Configuration &lt;/b&gt;&lt;i&gt;(where deviating from SoapWrapperPipe)&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;mode&lt;/td&gt;&lt;td&gt;either &lt;code&gt;i2t&lt;/code&gt; (ifsa2tibco), &lt;code&gt;reg&lt;/code&gt; (regular) or &lt;code&gt;bis&lt;/code&gt; (Business Integration Services)&lt;/td&gt;&lt;td&gt;reg&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;cmhVersion&lt;/td&gt;&lt;td&gt;(only used when &lt;code&gt;mode=reg&lt;/code&gt;) Common Message Header version (1 or 2)&lt;/td&gt;&lt;td&gt;1 when &lt;code&gt;mode=reg&lt;/code&gt;, 0 otherwise&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;soapHeaderSessionKey&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;unwrap&lt;/code&gt;: &lt;/td&gt;&lt;td&gt;soapHeader&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;soapHeaderStyleSheet&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt; and mode=&lt;code&gt;i2t&lt;/code&gt;:&lt;/td&gt;&lt;td&gt;/xml/xsl/esb/soapHeader.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt; and mode=&lt;code&gt;reg&lt;/code&gt;:&lt;/td&gt;&lt;td&gt;TODO (for now identical to the "&lt;code&gt;i2t&lt;/code&gt;" SOAP Header)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt; and mode=&lt;code&gt;bis&lt;/code&gt;:&lt;/td&gt;&lt;td&gt;/xml/xsl/esb/bisSoapHeader.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;soapBodyStyleSheet&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt; and mode=&lt;code&gt;reg&lt;/code&gt;:&lt;/td&gt;&lt;td&gt;/xml/xsl/esb/soapBody.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt; and mode=&lt;code&gt;bis&lt;/code&gt;:&lt;/td&gt;&lt;td&gt;/xml/xsl/esb/bisSoapBody.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;addOutputNamespace&lt;/td&gt;&lt;td&gt;(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;outputNamespace&lt;/code&gt; is automatically set using the parameters (if $messagingLayer='P2P' then 'http://nn.nl/XSD/$businessDomain/$applicationName/$applicationFunction' else is serviceContext is not empty 'http://nn.nl/XSD/$businessDomain/$serviceName/$serviceContext/$serviceContextVersion/$operationName/$operationVersion' else 'http://nn.nl/XSD/$businessDomain/$serviceName/$serviceVersion/$operationName/$operationVersion')&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;retrievePhysicalDestination&lt;/td&gt;&lt;td&gt;(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, the physical destination is retrieved from the queue instead of using the parameter &lt;code&gt;destination&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;useFixedValues&lt;/td&gt;&lt;td&gt;If &lt;code&gt;true&lt;/code&gt;, the fields CorrelationId, MessageId and Timestamp will have a fixed value (for testing purposes only)&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;fixResultNamespace&lt;/td&gt;&lt;td&gt;(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt; and the Result tag already exists, the namespace is changed&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;p2pAlias&lt;/td&gt;&lt;td&gt;When the messagingLayer part of the destination has this value interpret it as P2P&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;esbAlias&lt;/td&gt;&lt;td&gt;When the messagingLayer part of the destination has this value interpret it as ESB&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;/xml/xsl/esb/soapHeader.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Id&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$fromId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;To&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Location&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;if $messagingLayer='P2P' then&lt;br/&gt;&amp;nbsp;$messagingLayer.$businessDomain.$applicationName.$applicationFunction.$paradigm&lt;br/&gt;else if $serviceContext is not empty then&lt;br/&gt;&amp;nbsp;$messagingLayer.$businessDomain.$serviceLayer.$serviceName.$serviceContext.$serviceContextVersion.$operationName.$operationVersion.$paradigm&lt;br/&gt;else&lt;br/&gt;&amp;nbsp;$messagingLayer.$businessDomain.$serviceLayer.$serviceName.$serviceVersion.$operationName.$operationVersion.$paradigm&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;CPAId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$cpaId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$conversationId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;CorrelationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$correlationId (if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$messageId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ExternalRefToMessageId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$externalRefToMessageId (if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Timestamp&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$timestamp&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;TransactionId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$transactionId (only used when $mode=reg and $cmhVersion=2; if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Service&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$serviceName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Context&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$serviceContext&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Action&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Paradigm&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;$paradigm&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;$operationName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Version&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;$operationVersion&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;mode&lt;/td&gt;&lt;td&gt;copied from &lt;code&gt;mode&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;cmhVersion&lt;/td&gt;&lt;td&gt;copied from &lt;code&gt;cmhVersion&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://nn.nl/XSD/Generic/MessageHeader/2" (only when $mode=reg and $cmhVersion=2)&lt;br/&gt;"http://nn.nl/XSD/Generic/MessageHeader/1" (otherwise)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;businessDomain&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceContext&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;service(Context)Version&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationVersion&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;paradigm&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;applicationName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;applicationFunction&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;messagingLayer&lt;/td&gt;&lt;td&gt;ESB&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceLayer&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;destination&lt;/td&gt;&lt;td&gt;if not empty this parameter contains the preceding parameters as described in 'Location' in the table above&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;fromId&lt;/td&gt;&lt;td&gt;property 'instance.name'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;cpaId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header, else 'n/a'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;conversationId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header, else parameter pattern '{hostname}_{uid}'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;messageId&lt;/td&gt;&lt;td&gt;parameter pattern '{hostname}_{uid}'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;correlationId&lt;/td&gt;&lt;td&gt;if $paradigm equals 'Response' then copied from MessageId in the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;externalRefToMessageId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;timestamp&lt;/td&gt;&lt;td&gt;parameter pattern '{now,date,yyyy-MM-dd'T'HH:mm:ss}'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;transactionId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;/xml/xsl/esb/bisSoapHeader.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Id&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$fromId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$conversationId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$messageId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ExternalRefToMessageId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$externalRefToMessageId (if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Timestamp&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$timestamp&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://www.ing.com/CSP/XSD/General/Message_2"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;fromId&lt;/td&gt;&lt;td&gt;property 'instance.name'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;conversationId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header, else parameter pattern '{hostname}_{uid}'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;messageId&lt;/td&gt;&lt;td&gt;parameter pattern '{hostname}_{uid}'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;externalRefToMessageId&lt;/td&gt;&lt;td&gt;if applicable, copied from MessageId in the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;timestamp&lt;/td&gt;&lt;td&gt;parameter pattern '{now,date,yyyy-MM-dd'T'HH:mm:ss}'&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;/xml/xsl/esb/soapBody.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;[Payload]&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;if $errorCode is empty then the complete payload will be copied and if not already existing a Result tag will be added&lt;br/&gt;else only the root tag will be copied&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Result&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;this element will be the last child in the copied root tag (only applicable for $paradigm 'Response'); if $errorCode is empty and a Result tag already exists then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Status&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;if $errorCode is empty then 'OK'&lt;br/&gt;else 'ERROR'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ErrorList&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;if $errorCode is empty then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Error&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Code&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;$errorCode&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Reason&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;if $errorReason is not empty then $errorReason&lt;br/&gt;else it will be derived from $errorCode:
   &lt;table border="1"&gt;
   &lt;tr&gt;&lt;th&gt;errorCode&lt;/th&gt;&lt;th&gt;errorText&lt;/th&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6002&lt;/td&gt;&lt;td&gt;Service Interface Request Time Out&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6003&lt;/td&gt;&lt;td&gt;Invalid Request Message&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6004&lt;/td&gt;&lt;td&gt;Invalid Backend system response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6005&lt;/td&gt;&lt;td&gt;Backend system failure response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6999&lt;/td&gt;&lt;td&gt;Unspecified Errors&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Service&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;$serviceName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Context&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;$serviceContext&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Action&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Paradigm&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$paradigm&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$operationName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Version&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$operationVersion&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;DetailList&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;if $errorDetailCode is empty then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Detail&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Code&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$errorDetailCode&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Text&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$errorDetailText (if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;mode&lt;/td&gt;&lt;td&gt;copied from &lt;code&gt;mode&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;cmhVersion&lt;/td&gt;&lt;td&gt;copied from &lt;code&gt;cmhVersion&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://nn.nl/XSD/Generic/MessageHeader/2" (only when $mode=reg and $cmhVersion=2)&lt;br/&gt;"http://nn.nl/XSD/Generic/MessageHeader/1" (otherwise)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorCode&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorReason&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorDetailCode&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorDetailText&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceContext&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationVersion&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;paradigm&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;fixResultNamespace&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;/xml/xsl/esb/bisSoapBody.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;[Payload]&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;if $errorCode is empty then the complete payload will be copied and if not already existing a Result tag will be added&lt;br/&gt;else only the root tag will be copied&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Result&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;this element will be the last child in the copied root tag (only applicable for $paradigm 'Response' and 'Reply'); if $errorCode is empty and a Result tag already exists then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Status&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;if $errorCode is empty then 'OK'&lt;br/&gt;else 'ERROR'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ErrorList&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;if $errorCode is empty then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Error&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Code&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;$errorCode&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Reason&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;if $errorReason is not empty then $errorReason&lt;br/&gt;else it will be derived from $errorCode:
   &lt;table border="1"&gt;
   &lt;tr&gt;&lt;th&gt;errorCode&lt;/th&gt;&lt;th&gt;errorText&lt;/th&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6002&lt;/td&gt;&lt;td&gt;Service Interface Request Time Out&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6003&lt;/td&gt;&lt;td&gt;Invalid Request Message&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6004&lt;/td&gt;&lt;td&gt;Invalid Backend system response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6005&lt;/td&gt;&lt;td&gt;Backend system failure response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6999&lt;/td&gt;&lt;td&gt;Unspecified Errors&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Service&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;$serviceName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Context&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;$serviceContext&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Action&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$operationName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Version&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$operationVersion&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;DetailList&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;if $errorDetailCode is empty then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Detail&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Code&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$errorDetailCode&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Text&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$errorDetailText (if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://www.ing.com/CSP/XSD/General/Message_2"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorCode&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorReason&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorDetailCode&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorDetailText&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceContext&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationVersion&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;paradigm&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbSoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputWrapper" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FxfInputWrapper">
        <xs:annotation>
          <xs:documentation>FxF wrapper to be used with FxF3. When receiving files (direction=unwrap)
 the message handed to the pipeline is the local filename extracted from an
 ESB SOAP message. When sending files (direction=wrap) input should be a local
 filename which will be wrapped into an ESB SOAP message. Please note: When
 writing files which need to be send through FxF they should be written to
 ${fxf.dir}/NNX00000/out. The property ${fxf.dir} will automatically be
 available on the OTAP environment (define it in StageSpecifics_LOC.properties
 only). Replace NNX00000 with the specific flowId and generate a unique
 filename (files will automatically be cleaned after 30 days or any other
 value specified by ${fxf.retention}).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FxfWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputWrapper" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SoapInputWrapper">
        <xs:annotation>
          <xs:documentation>Pipe to wrap or unwrap a message from/into a SOAP Envelope.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="inputWrapper" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="ApiSoapWrapperPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="SoapWrapperPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.api.ApiSoapWrapperPipe" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="SoapWrapperPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="SoapWrapperPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.soap.SoapWrapperPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="SoapWrapperPipeDeclaredAttributeGroup">
    <xs:attribute name="direction">
      <xs:annotation>
        <xs:documentation>Default: wrap</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="DirectionAttributeValuesType_4 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="soapVersion">
      <xs:annotation>
        <xs:documentation>Soap version to use Default: auto</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="SoapVersionAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when direction=&lt;code&gt;wrap&lt;/code&gt;) Namespace of the soap envelope Default: auto determined from soapVersion</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespaceSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of session variable to store auto-detected soapNamespace Default: If configured as Pipeline Input Wrapper or PipeLine Output Wrapper: soapNamespace</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of session variable to store soap header Default: If configured as Pipeline Input Wrapper and direction=&lt;code&gt;unwrap&lt;/code&gt;: soapHeader</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>The encodingStyle to be set in the soap header</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>The default for the namespace of the message sent. Identifies the service to be called. May be overriden by an actual namespace setting in the message to be sent</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when direction=&lt;code&gt;wrap&lt;/code&gt;) Stylesheet to create the content of the soap header. As input for this stylesheet a dummy xml string is used. Note: outputType=&lt;code&gt;xml&lt;/code&gt; and xsltVersion=</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when direction=&lt;code&gt;wrap&lt;/code&gt;) Stylesheet to apply to the input message. Note: outputType=&lt;code&gt;xml&lt;/code&gt; and xsltVersion=2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeOutputNamespaces" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(only used when direction=&lt;code&gt;unwrap&lt;/code&gt;) If &lt;code&gt;true&lt;/code&gt;, namespaces (and prefixes) in the content of the soap body are removed Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeUnusedOutputNamespaces" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(only used when direction=&lt;code&gt;unwrap&lt;/code&gt; and &lt;code&gt;removeoutputnamespaces=false&lt;/code&gt;) If &lt;code&gt;true&lt;/code&gt;, unused namespaces in the content of the soap body are removed Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when direction=&lt;code&gt;wrap&lt;/code&gt;) If not empty, this namespace is added to the root element in the soap body</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>If not empty, the root element in the soap body is changed to this value</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreSoapFault" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(only used when direction=&lt;code&gt;unwrap&lt;/code&gt;) If &lt;code&gt;false&lt;/code&gt; and the soap body contains a soap fault, a PipeRunException is thrown Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowPlainXml" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>For direction=&lt;code&gt;unwrap&lt;/code&gt; only: if true, allow unwrapped xml too Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to WebServiceSecurity</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default username for WebServiceSecurity</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default password for WebServiceSecurity</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, the password is sent digested; Otherwise it is sent in clear text Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>For direction=&lt;code&gt;wrap&lt;/code&gt; only: When false, adds an XML declaration to the output message. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of this pipe. Can be referenced by the &lt;code&gt;path&lt;/code&gt; attribute of a PipeForward.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SoapWrapperPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="SoapWrapperPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeDeclaredAttributeGroup" />
    <xs:attribute ref="getInputFromSessionKey" />
    <xs:attribute ref="getInputFromFixedValue" />
    <xs:attribute ref="emptyInputReplacement" />
    <xs:attribute ref="preserveInput" />
    <xs:attribute ref="storeResultInSessionKey" />
    <xs:attribute ref="maxThreads" />
    <xs:attribute ref="chompCharSize" />
    <xs:attribute ref="elementToMove" />
    <xs:attribute ref="elementToMoveSessionKey" />
    <xs:attribute ref="elementToMoveChain" />
    <xs:attribute ref="durationThreshold" />
    <xs:attribute ref="removeCompactMsgNamespaces" />
    <xs:attribute ref="restoreMovedElements" />
    <xs:attribute ref="sizeStatistics" />
    <xs:attribute ref="writeToSecLog" />
    <xs:attribute ref="secLogSessionKeys" />
    <xs:attribute ref="logIntermediaryResults" />
    <xs:attribute ref="hideRegex" />
    <xs:attributeGroup ref="TransactionAttributesDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="EsbSoapWrapperPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="EsbSoapWrapperPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.esb.EsbSoapWrapperPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="EsbSoapWrapperPipeDeclaredAttributeGroup">
    <xs:attribute name="mode">
      <xs:annotation>
        <xs:documentation>Default: REG</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="ModeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="cmhVersion" type="frankInt">
      <xs:annotation>
        <xs:documentation>&lt;b&gt;Only used when &lt;code&gt;mode=reg&lt;/code&gt;!&lt;/b&gt; Sets the Common Message Header version. 1 or 2 Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addOutputNamespace" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;outputNamespace&lt;/code&gt; is automatically set using the parameters (if $messagingLayer='P2P' then 'http://nn.nl/XSD/$businessDomain/$applicationName/$applicationFunction' else is serviceContext is not empty 'http://nn.nl/XSD/$businessDomain/$serviceName/$serviceContext/$serviceContextVersion/$operationName/$operationVersion' else 'http://nn.nl/XSD/$businessDomain/$serviceName/$serviceVersion/$operationName/$operationVersion') Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retrievePhysicalDestination" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, the physical destination is retrieved from the queue instead of using the parameter &lt;code&gt;destination&lt;/code&gt; Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useFixedValues" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the fields CorrelationId, MessageId and Timestamp will have a fixed value (for testing purposes only) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fixResultNamespace" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt; and the Result tag already exists, the namespace is changed Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="p2pAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>When the messagingLayer part of the destination has this value interpret it as P2P</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="esbAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>When the messagingLayer part of the destination has this value interpret it as ESB</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="EsbSoapWrapperPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="EsbSoapWrapperPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="SoapWrapperPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FxfWrapperPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FxfWrapperPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.fxf.FxfWrapperPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="FxfWrapperPipeDeclaredAttributeGroup">
    <xs:attribute name="flowId" type="xs:string">
      <xs:annotation>
        <xs:documentation>The flowId of the file transfer when direction=wrap. When direction=unwrap the flowId will be extracted from the incoming message and added as a sessionKey to the pipeline.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="flowOutFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>specifies the output folder if transformFilename=&lt;code&gt;false&lt;/code&gt; and direction=wrap</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transformFilename" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; and direction=wrap, the input which is expected to be a local filename will be transformed to the filename as known on the IUF State machine. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodySessionKey" type="xs:string" />
    <xs:attribute name="transferFlowIdSessionKey" type="xs:string" />
    <xs:attribute name="clientFilenameSessionKey" type="xs:string" />
    <xs:attribute name="flowIdSessionKey" type="xs:string" />
    <xs:attribute name="fxfDirSessionKey" type="xs:string" />
    <xs:attribute name="fxfFileSessionKey" type="xs:string" />
    <xs:attribute name="fxfVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>either 3.1 or 3.2 Default: 3.1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createFolder" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the folder corresponding fxf.dir property will be created in case it does not exist Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useServerFilename" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, ServerFileName from the input will be used as the filename Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FxfWrapperPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="FxfWrapperPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="EsbSoapWrapperPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="OutputWrapperElementGroup">
    <xs:choice>
      <xs:element name="OutputWrapper">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="Forward" type="ForwardType" />
              <xs:element name="Locker" type="LockerType" />
              <xs:group ref="ParamElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="outputWrapper" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="OutputWrapperElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="OutputWrapperElementGroupBase">
    <xs:choice>
      <xs:element name="ApiSoapOutputWrapper">
        <xs:annotation>
          <xs:documentation>Extension to SoapWrapperPipe for API Management.
 &lt;p&gt;
 &lt;b&gt;Configuration &lt;/b&gt;&lt;i&gt;(where deviating from SoapWrapperPipe)&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;soapHeaderSessionKey&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt;: &lt;/td&gt;&lt;td&gt;soapHeader&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;soapHeaderStyleSheet&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt;: &lt;/td&gt;&lt;td&gt;/xml/xsl/api/soapHeader.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;&lt;p&gt;
 &lt;b&gt;/xml/xsl/api/soapHeader.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;&lt;code&gt;MessageHeader&lt;/code&gt; is only created when $conversationId is filled (otherwise skipped)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&lt;code&gt;From&lt;/code&gt; is only created when $from_in is filled (otherwise skipped) and it's created with the value of $from_out&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$conversationId&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://api.nn.nl/MessageHeader"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;from_in&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;from_out&lt;/td&gt;&lt;td&gt;property 'instance.name'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;conversationId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ApiSoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputWrapper" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbSoapOutputWrapper">
        <xs:annotation>
          <xs:documentation>Extension to SoapWrapperPipe for separate modes.

 &lt;p&gt;&lt;b&gt;Configuration &lt;/b&gt;&lt;i&gt;(where deviating from SoapWrapperPipe)&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;mode&lt;/td&gt;&lt;td&gt;either &lt;code&gt;i2t&lt;/code&gt; (ifsa2tibco), &lt;code&gt;reg&lt;/code&gt; (regular) or &lt;code&gt;bis&lt;/code&gt; (Business Integration Services)&lt;/td&gt;&lt;td&gt;reg&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;cmhVersion&lt;/td&gt;&lt;td&gt;(only used when &lt;code&gt;mode=reg&lt;/code&gt;) Common Message Header version (1 or 2)&lt;/td&gt;&lt;td&gt;1 when &lt;code&gt;mode=reg&lt;/code&gt;, 0 otherwise&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;soapHeaderSessionKey&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;unwrap&lt;/code&gt;: &lt;/td&gt;&lt;td&gt;soapHeader&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;soapHeaderStyleSheet&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt; and mode=&lt;code&gt;i2t&lt;/code&gt;:&lt;/td&gt;&lt;td&gt;/xml/xsl/esb/soapHeader.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt; and mode=&lt;code&gt;reg&lt;/code&gt;:&lt;/td&gt;&lt;td&gt;TODO (for now identical to the "&lt;code&gt;i2t&lt;/code&gt;" SOAP Header)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt; and mode=&lt;code&gt;bis&lt;/code&gt;:&lt;/td&gt;&lt;td&gt;/xml/xsl/esb/bisSoapHeader.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;soapBodyStyleSheet&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt; and mode=&lt;code&gt;reg&lt;/code&gt;:&lt;/td&gt;&lt;td&gt;/xml/xsl/esb/soapBody.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt; and mode=&lt;code&gt;bis&lt;/code&gt;:&lt;/td&gt;&lt;td&gt;/xml/xsl/esb/bisSoapBody.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;addOutputNamespace&lt;/td&gt;&lt;td&gt;(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;outputNamespace&lt;/code&gt; is automatically set using the parameters (if $messagingLayer='P2P' then 'http://nn.nl/XSD/$businessDomain/$applicationName/$applicationFunction' else is serviceContext is not empty 'http://nn.nl/XSD/$businessDomain/$serviceName/$serviceContext/$serviceContextVersion/$operationName/$operationVersion' else 'http://nn.nl/XSD/$businessDomain/$serviceName/$serviceVersion/$operationName/$operationVersion')&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;retrievePhysicalDestination&lt;/td&gt;&lt;td&gt;(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, the physical destination is retrieved from the queue instead of using the parameter &lt;code&gt;destination&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;useFixedValues&lt;/td&gt;&lt;td&gt;If &lt;code&gt;true&lt;/code&gt;, the fields CorrelationId, MessageId and Timestamp will have a fixed value (for testing purposes only)&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;fixResultNamespace&lt;/td&gt;&lt;td&gt;(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt; and the Result tag already exists, the namespace is changed&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;p2pAlias&lt;/td&gt;&lt;td&gt;When the messagingLayer part of the destination has this value interpret it as P2P&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;esbAlias&lt;/td&gt;&lt;td&gt;When the messagingLayer part of the destination has this value interpret it as ESB&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;/xml/xsl/esb/soapHeader.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Id&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$fromId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;To&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Location&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;if $messagingLayer='P2P' then&lt;br/&gt;&amp;nbsp;$messagingLayer.$businessDomain.$applicationName.$applicationFunction.$paradigm&lt;br/&gt;else if $serviceContext is not empty then&lt;br/&gt;&amp;nbsp;$messagingLayer.$businessDomain.$serviceLayer.$serviceName.$serviceContext.$serviceContextVersion.$operationName.$operationVersion.$paradigm&lt;br/&gt;else&lt;br/&gt;&amp;nbsp;$messagingLayer.$businessDomain.$serviceLayer.$serviceName.$serviceVersion.$operationName.$operationVersion.$paradigm&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;CPAId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$cpaId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$conversationId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;CorrelationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$correlationId (if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$messageId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ExternalRefToMessageId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$externalRefToMessageId (if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Timestamp&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$timestamp&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;TransactionId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$transactionId (only used when $mode=reg and $cmhVersion=2; if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Service&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$serviceName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Context&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$serviceContext&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Action&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Paradigm&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;$paradigm&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;$operationName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Version&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;$operationVersion&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;mode&lt;/td&gt;&lt;td&gt;copied from &lt;code&gt;mode&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;cmhVersion&lt;/td&gt;&lt;td&gt;copied from &lt;code&gt;cmhVersion&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://nn.nl/XSD/Generic/MessageHeader/2" (only when $mode=reg and $cmhVersion=2)&lt;br/&gt;"http://nn.nl/XSD/Generic/MessageHeader/1" (otherwise)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;businessDomain&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceContext&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;service(Context)Version&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationVersion&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;paradigm&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;applicationName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;applicationFunction&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;messagingLayer&lt;/td&gt;&lt;td&gt;ESB&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceLayer&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;destination&lt;/td&gt;&lt;td&gt;if not empty this parameter contains the preceding parameters as described in 'Location' in the table above&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;fromId&lt;/td&gt;&lt;td&gt;property 'instance.name'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;cpaId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header, else 'n/a'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;conversationId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header, else parameter pattern '{hostname}_{uid}'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;messageId&lt;/td&gt;&lt;td&gt;parameter pattern '{hostname}_{uid}'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;correlationId&lt;/td&gt;&lt;td&gt;if $paradigm equals 'Response' then copied from MessageId in the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;externalRefToMessageId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;timestamp&lt;/td&gt;&lt;td&gt;parameter pattern '{now,date,yyyy-MM-dd'T'HH:mm:ss}'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;transactionId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;/xml/xsl/esb/bisSoapHeader.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Id&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$fromId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$conversationId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$messageId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ExternalRefToMessageId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$externalRefToMessageId (if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Timestamp&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$timestamp&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://www.ing.com/CSP/XSD/General/Message_2"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;fromId&lt;/td&gt;&lt;td&gt;property 'instance.name'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;conversationId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header, else parameter pattern '{hostname}_{uid}'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;messageId&lt;/td&gt;&lt;td&gt;parameter pattern '{hostname}_{uid}'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;externalRefToMessageId&lt;/td&gt;&lt;td&gt;if applicable, copied from MessageId in the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;timestamp&lt;/td&gt;&lt;td&gt;parameter pattern '{now,date,yyyy-MM-dd'T'HH:mm:ss}'&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;/xml/xsl/esb/soapBody.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;[Payload]&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;if $errorCode is empty then the complete payload will be copied and if not already existing a Result tag will be added&lt;br/&gt;else only the root tag will be copied&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Result&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;this element will be the last child in the copied root tag (only applicable for $paradigm 'Response'); if $errorCode is empty and a Result tag already exists then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Status&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;if $errorCode is empty then 'OK'&lt;br/&gt;else 'ERROR'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ErrorList&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;if $errorCode is empty then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Error&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Code&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;$errorCode&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Reason&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;if $errorReason is not empty then $errorReason&lt;br/&gt;else it will be derived from $errorCode:
   &lt;table border="1"&gt;
   &lt;tr&gt;&lt;th&gt;errorCode&lt;/th&gt;&lt;th&gt;errorText&lt;/th&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6002&lt;/td&gt;&lt;td&gt;Service Interface Request Time Out&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6003&lt;/td&gt;&lt;td&gt;Invalid Request Message&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6004&lt;/td&gt;&lt;td&gt;Invalid Backend system response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6005&lt;/td&gt;&lt;td&gt;Backend system failure response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6999&lt;/td&gt;&lt;td&gt;Unspecified Errors&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Service&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;$serviceName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Context&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;$serviceContext&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Action&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Paradigm&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$paradigm&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$operationName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Version&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$operationVersion&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;DetailList&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;if $errorDetailCode is empty then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Detail&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Code&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$errorDetailCode&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Text&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$errorDetailText (if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;mode&lt;/td&gt;&lt;td&gt;copied from &lt;code&gt;mode&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;cmhVersion&lt;/td&gt;&lt;td&gt;copied from &lt;code&gt;cmhVersion&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://nn.nl/XSD/Generic/MessageHeader/2" (only when $mode=reg and $cmhVersion=2)&lt;br/&gt;"http://nn.nl/XSD/Generic/MessageHeader/1" (otherwise)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorCode&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorReason&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorDetailCode&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorDetailText&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceContext&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationVersion&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;paradigm&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;fixResultNamespace&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;/xml/xsl/esb/bisSoapBody.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;[Payload]&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;if $errorCode is empty then the complete payload will be copied and if not already existing a Result tag will be added&lt;br/&gt;else only the root tag will be copied&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Result&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;this element will be the last child in the copied root tag (only applicable for $paradigm 'Response' and 'Reply'); if $errorCode is empty and a Result tag already exists then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Status&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;if $errorCode is empty then 'OK'&lt;br/&gt;else 'ERROR'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ErrorList&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;if $errorCode is empty then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Error&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Code&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;$errorCode&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Reason&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;if $errorReason is not empty then $errorReason&lt;br/&gt;else it will be derived from $errorCode:
   &lt;table border="1"&gt;
   &lt;tr&gt;&lt;th&gt;errorCode&lt;/th&gt;&lt;th&gt;errorText&lt;/th&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6002&lt;/td&gt;&lt;td&gt;Service Interface Request Time Out&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6003&lt;/td&gt;&lt;td&gt;Invalid Request Message&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6004&lt;/td&gt;&lt;td&gt;Invalid Backend system response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6005&lt;/td&gt;&lt;td&gt;Backend system failure response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6999&lt;/td&gt;&lt;td&gt;Unspecified Errors&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Service&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;$serviceName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Context&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;$serviceContext&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Action&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$operationName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Version&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$operationVersion&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;DetailList&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;if $errorDetailCode is empty then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Detail&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Code&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$errorDetailCode&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Text&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$errorDetailText (if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://www.ing.com/CSP/XSD/General/Message_2"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorCode&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorReason&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorDetailCode&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorDetailText&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceContext&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationVersion&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;paradigm&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbSoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputWrapper" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FxfOutputWrapper">
        <xs:annotation>
          <xs:documentation>FxF wrapper to be used with FxF3. When receiving files (direction=unwrap)
 the message handed to the pipeline is the local filename extracted from an
 ESB SOAP message. When sending files (direction=wrap) input should be a local
 filename which will be wrapped into an ESB SOAP message. Please note: When
 writing files which need to be send through FxF they should be written to
 ${fxf.dir}/NNX00000/out. The property ${fxf.dir} will automatically be
 available on the OTAP environment (define it in StageSpecifics_LOC.properties
 only). Replace NNX00000 with the specific flowId and generate a unique
 filename (files will automatically be cleaned after 30 days or any other
 value specified by ${fxf.retention}).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FxfWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputWrapper" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SoapOutputWrapper">
        <xs:annotation>
          <xs:documentation>Pipe to wrap or unwrap a message from/into a SOAP Envelope.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="outputWrapper" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="PipeElementGroup">
    <xs:choice>
      <xs:element name="Pipe">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:group ref="CacheElementGroup" />
              <xs:element name="Forward" type="ForwardType" />
              <xs:group ref="InputValidatorElementGroup" />
              <xs:group ref="InputWrapperElementGroup" />
              <xs:group ref="ListenerElementGroup_2" />
              <xs:element name="Locker" type="LockerType" />
              <xs:group ref="MessageLogElementGroup" />
              <xs:group ref="OutputValidatorElementGroup" />
              <xs:group ref="OutputWrapperElementGroup" />
              <xs:group ref="ParamElementGroup" />
              <xs:group ref="SenderElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
          <xs:attribute name="className" type="xs:string" default="org.frankframework.pipes.SenderPipe" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="PipeElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="ListenerElementGroup_2">
    <xs:choice>
      <xs:element name="Listener">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:group ref="ParamElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="ListenerElementGroupBase_3" />
    </xs:choice>
  </xs:group>
  <xs:group name="ListenerElementGroupBase_3">
    <xs:choice>
      <xs:element name="PullingJmsListener">
        <xs:annotation>
          <xs:documentation>A true multi-threaded Listener-class.
 &lt;br/&gt;

 Since version 4.1, Ibis supports distributed transactions using the XA-protocol. This feature is controlled by the
 transacted attribute. If this is set to &lt;code&gt;true&lt;/code&gt;, received messages are
 committed or rolled back, possibly together with other actions, by the receiver or the pipeline.
 In case of a failure, all actions within the transaction are rolled back.

 &lt;p&gt;&lt;b&gt;Using jmsTransacted and acknowledgement&lt;/b&gt;&lt;br/&gt;
 If jmsTransacted is set &lt;code&gt;true&lt;/code&gt;: it should ensure that a message is received and processed on a both or nothing basis.
 IBIS will commit the the message, otherwise perform rollback. However using jmsTransacted, IBIS does not bring transactions within
 the adapters under transaction control, compromising the idea of atomic transactions. In the roll-back situation messages sent to
 other destinations within the Pipeline are NOT rolled back if jmsTransacted is set &lt;code&gt;true&lt;/code&gt;! In the failure situation the
 message is therefore completely processed, and the roll back does not mean that the processing is rolled back! To obtain the correct
 (transactional) behaviour, transacted should be used instead of listener.transacted.
&lt;p&gt;
 Setting listener.acknowledgeMode to "auto" means that messages are allways acknowledged (removed from
 the queue, regardless of what the status of the Adapter is. "client" means that the message will only be removed from the queue
 when the state of the Adapter equals the success state.
 The "dups" mode instructs the session to lazily acknowledge the delivery of the messages. This is likely to result in the
 delivery of duplicate messages if JMS fails. It should be used by consumers who are tolerant in processing duplicate messages.
 In cases where the client is tolerant of duplicate messages, some enhancement in performance can be achieved using this mode,
 since a session has lower overhead in trying to prevent duplicate messages.
 &lt;/p&gt;
 &lt;p&gt;The setting for listener.acknowledgeMode will only be processed if
 the setting for listener.transacted as well as for
 listener.jmsTransacted is false.&lt;/p&gt;

 &lt;p&gt;If useReplyTo is set and a replyTo-destination is
 specified in the message, the JmsListener sends the result of the processing
 in the pipeline to this destination. Otherwise the result is sent using the (optionally)
 specified Sender, that in turn sends the message to
 whatever it is configured to.&lt;/p&gt;
 &lt;/p&gt;
 &lt;p&gt;&lt;b&gt;Notice:&lt;/b&gt; the JmsListener is ONLY capable of processing
 &lt;code&gt;jakarta.jms.TextMessage&lt;/code&gt;s &lt;br/&gt;&lt;br/&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PullingJmsListenerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="listener" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="PipeElementGroupBase">
    <xs:choice>
      <xs:element name="Adios2XmlPipe">
        <xs:annotation>
          <xs:documentation>Transforms between ascii-ADIOS and an XML representation of ADIOS.

 &lt;p&gt;
 Sample xml:&lt;br/&gt;
 &lt;pre&gt;{@code
 &lt;adios rekenbox="L76HB150"&gt;
     &lt;rubriek naam="BER_VERZ_CD" waarde="COMBIFLEX_BELEGGING" /&gt;
     &lt;rubriek naam="INBR_CD" waarde="NIEUWE_VERZEKERING" /&gt;
     &lt;rubriek naam="PENS_DT_BEP_CD"  waarde="DT_UIT_PENS_LFT" /&gt;
     &lt;rubriek nummer="313" naam="AS_OPSL_PRD_TRM_PRM" index="3" recordnr="74" record="VUT_VERZEKERING" waarde="52.34" /&gt;
     ...
 &lt;/adios&gt;
 }&lt;/pre&gt;
 &lt;br/&gt;
 For input, a 'naam' or a 'nummer'-attribute must be specified. If both are specified, their match is checked.
 On output, 'nummer', 'naam' and 'waarde'-attributes are always present in each rubriek-element.
 Where applicable 'index', 'recordnr', 'record' and 'recordindex' are present, too.
 If sub-records exist, they are present with a 'sub' prefix to all attributes.
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Adios2XmlPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="AmountOfPagesPipe">
        <xs:annotation>
          <xs:documentation>Returns the amount of pages of a PDF file.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="AmountOfPagesPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ApiPrincipalPipe">
        <xs:annotation>
          <xs:documentation>Pipe to manage the ApiPrincipal handling</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ApiPrincipalPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ApiSoapWrapperPipe">
        <xs:annotation>
          <xs:documentation>Extension to SoapWrapperPipe for API Management.
 &lt;p&gt;
 &lt;b&gt;Configuration &lt;/b&gt;&lt;i&gt;(where deviating from SoapWrapperPipe)&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;soapHeaderSessionKey&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt;: &lt;/td&gt;&lt;td&gt;soapHeader&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;soapHeaderStyleSheet&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt;: &lt;/td&gt;&lt;td&gt;/xml/xsl/api/soapHeader.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;&lt;p&gt;
 &lt;b&gt;/xml/xsl/api/soapHeader.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;&lt;code&gt;MessageHeader&lt;/code&gt; is only created when $conversationId is filled (otherwise skipped)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&lt;code&gt;From&lt;/code&gt; is only created when $from_in is filled (otherwise skipped) and it's created with the value of $from_out&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$conversationId&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://api.nn.nl/MessageHeader"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;from_in&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;from_out&lt;/td&gt;&lt;td&gt;property 'instance.name'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;conversationId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ApiSoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ApiWsdlXmlValidatorPipe">
        <xs:annotation>
          <xs:documentation>Extension to WsdlXmlValidator for API Management.

 The SOAP header can only contain the following schema (or it's empty):
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;mandatory&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;xmlns="http://api.nn.nl/MessageHeader"&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;no&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ApiWsdlXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Base64Pipe">
        <xs:annotation>
          <xs:documentation>Pipe that performs base64 encoding and decoding.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Base64PipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="BlobLineIteratingPipe">
        <xs:annotation>
          <xs:documentation>Pipe that iterates over the lines in a BLOB.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="BlobLineIteratingPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="BytesOutputPipe">
        <xs:annotation>
          <xs:documentation>Output bytes as specified by the input XML.

 Actions are taken on every field
 tag found in the input XML. Every field tag should have a type attribute
 that specifies the type of conversion that needs to be done on the string
 specified by the value attribute. A value attribute also needs to be present
 for every field tag. Currently, two types of conversion are supported:

 &lt;ul&gt;
   &lt;li&gt;&lt;code&gt;GetBytesFromString&lt;/code&gt;, a conversion from string to bytes as specified by java.lang.String.getBytes(String charsetName)&lt;/li&gt;
   &lt;li&gt;&lt;code&gt;PackedDecimal&lt;/code&gt;, a conversion from string to Packed-decimal&lt;/li&gt;
 &lt;/ul&gt;

 An additional charset attribute is needed for a GetBytesFromString
 conversion. An input XML that would encode the string &amp;quot; TEST 1234 &amp;quot;
 into EBCDIC format would look like:

 &lt;pre&gt;
 &amp;lt;fields&amp;gt;
   &amp;lt;field type=&amp;quot;GetBytesFromString&amp;quot; value=&amp;quot; TEST 1234 &amp;quot; charset=&amp;quot;Cp037&amp;quot;/&amp;gt;
 &amp;lt;/fields&amp;gt;
 &lt;/pre&gt;

 The Packed-decimal conversion has been implemented according to information
 found in the following resources:

 &lt;ul&gt;
   &lt;li&gt;A description as found at &lt;a href="http://www.simotime.com/datapk01.htm"&gt;http://www.simotime.com/datapk01.htm&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;AS400PackedDecimal.java from jtopen_6_1_source.zip downloaded at &lt;a href="http://jt400.sourceforge.net/"&gt;http://jt400.sourceforge.net/&lt;/a&gt;&lt;/li&gt;
 &lt;/ul&gt;

 Some examples:

 &lt;ul&gt;
   &lt;li&gt;The string +12345 will be translated to three bytes with the following hexadecimal representation: 12 34 5C&lt;/li&gt;
   &lt;li&gt;The string -12345 will be translated to three bytes with the following hexadecimal representation: 12 34 5D&lt;/li&gt;
   &lt;li&gt;The string 12345 will be translated to three bytes with the following hexadecimal representation: 12 34 5F&lt;/li&gt;
   &lt;li&gt;The string 1234 will be translated to three bytes with the following hexadecimal representation: 01 23 4F&lt;/li&gt;
 &lt;/ul&gt;

 The Packed-decimal is prefixed with zeroes when the specified size is bigger
 than the number of decimals. An exception is thrown when the specified size
 is smaller than the number of decimals.

 An input XML that would generate a number of Packed-decimals could look like:

 &lt;pre&gt;
 &amp;lt;fields&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;+12345&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;+67890&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;+1234&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;-12345&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;-67890&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;-1234&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;12345&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;67890&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;1234&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;+1&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;-1&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;+12&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;-12&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;+123&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;-123&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;+1234&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;-1234&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;+12345&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;-12345&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;+123456&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;-123456&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;+1234567&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;-1234567&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;+12345678&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
   &amp;lt;field type=&amp;quot;PackedDecimal&amp;quot; value=&amp;quot;-12345678&amp;quot; size=&amp;quot;16&amp;quot;/&amp;gt;
 &amp;lt;/fields&amp;gt;
 &lt;/pre&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="BytesOutputPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ChecksumPipe">
        <xs:annotation>
          <xs:documentation>Pipe to calculate checksum on input.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ChecksumPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ClobLineIteratingPipe">
        <xs:annotation>
          <xs:documentation>Pipe that iterates over the lines in a CLOB.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ClobLineIteratingPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CompareIntegerPipe">
        <xs:annotation>
          <xs:documentation>Pipe that compares the two integer values.
 If one of the parameters is missing then the input message will be used as the missing operand.
 This pipe can be used in combination with IncreaseIntegerPipe to construct loops.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CompareIntegerPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CompareStringPipe">
        <xs:annotation>
          <xs:documentation>Pipe that lexicographically compares two strings, that must NOT be empty.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CompareStringPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CompressPipe">
        <xs:annotation>
          <xs:documentation>Pipe to zip or unzip a message or file.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CompressPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CounterSwitchPipe">
        <xs:annotation>
          <xs:documentation>Selects an exitState, based on the number of received messages by this pipe.

 The exitState is the difference (subtraction) between the &lt;code&gt;divisor&lt;/code&gt; and
 the remainder of [number of received messages] modulus &lt;code&gt;divisor&lt;/code&gt;.
 This will always be an integer between 1 and &lt;code&gt;divisor&lt;/code&gt;, inclusive.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CounterSwitchPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CredentialCheckingPipe">
        <xs:annotation>
          <xs:documentation>Pipe to check the the CredentialFactory (for testing only).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CredentialCheckingPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CrlPipe">
        <xs:annotation>
          <xs:documentation>Pipe that reads a CRL from an input stream and transforms it to an XML.
 The steam is closed after reading.

 Example configuration:
 &lt;pre&gt;{@code
 	&lt;pipe
 		name="Read issuer"
 		className="org.frankframework.pipes.FilePipe"
 		actions="read"
 		fileName="dir/issuer.cer"
 		preserveInput="true"
 		outputType="stream"
 		storeResultInSessionKey="issuer"&gt;
 		&lt;forward name="success" path="Read CRL" /&gt;
 	&lt;/pipe&gt;
 	&lt;pipe
 		name="Read CRL"
 		className="org.frankframework.pipes.FilePipe"
 		actions="read"
 		fileName="dir/CRL.crl"
 		outputType="stream"&gt;
 		&lt;forward name="success" path="Transform CRL" /&gt;
 	&lt;/pipe&gt;
 	&lt;pipe
 		name="Transform CRL"
 		className="org.frankframework.pipes.CrlPipe"
 		issuerSessionKey="issuer"&gt;
 		&lt;forward name="success" path="EXIT" /&gt;
 	&lt;/pipe&gt;
 }&lt;/pre&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CrlPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CsvParserPipe">
        <xs:annotation>
          <xs:documentation>Reads a message in CSV format, and turns it into XML.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CsvParserPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DelayPipe">
        <xs:annotation>
          <xs:documentation>Pipe that sleeps for a specified time, which defaults to 5000 msecs.
 Usefull for testing purposes.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DelayPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DirectWrapperPipe">
        <xs:annotation>
          <xs:documentation>Kind of extension to EsbSoapWrapperPipe for real time destinations.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DirectWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="DomainTransformerPipe">
        <xs:annotation>
          <xs:documentation>Pipe that performs domain transforming on the basis of a database table.

 Every string which equals "%![DT{&lt;code&gt;label&lt;/code&gt;,&lt;code&gt;valueIn&lt;/code&gt;,&lt;code&gt;type&lt;/code&gt;}]" will be replaced by &lt;code&gt;valueOut&lt;/code&gt;.

 The field &lt;code&gt;type&lt;/code&gt;, which is optional, indicates the format of &lt;code&gt;valueIn&lt;/code&gt;. Currently the following types are supported:

 &lt;ul&gt;
   &lt;li&gt;&lt;code&gt;string&lt;/code&gt; (default): the methode setString() is used&lt;/li&gt;
   &lt;li&gt;&lt;code&gt;number&lt;/code&gt;: the method setDouble() is used &lt;/li&gt;
 &lt;/ul&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="DomainTransformerPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EchoPipe">
        <xs:annotation>
          <xs:documentation>Returns simply the input message.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EchoPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbSoapValidatorPipe">
        <xs:annotation>
          <xs:documentation>XmlValidator that will automatically add the SOAP envelope XSD and the ESB XSD (e.g. a CommonMessageHeader.xsd)
 to the set of XSDs used for validation.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbSoapValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EsbSoapWrapperPipe">
        <xs:annotation>
          <xs:documentation>Extension to SoapWrapperPipe for separate modes.

 &lt;p&gt;&lt;b&gt;Configuration &lt;/b&gt;&lt;i&gt;(where deviating from SoapWrapperPipe)&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;mode&lt;/td&gt;&lt;td&gt;either &lt;code&gt;i2t&lt;/code&gt; (ifsa2tibco), &lt;code&gt;reg&lt;/code&gt; (regular) or &lt;code&gt;bis&lt;/code&gt; (Business Integration Services)&lt;/td&gt;&lt;td&gt;reg&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;cmhVersion&lt;/td&gt;&lt;td&gt;(only used when &lt;code&gt;mode=reg&lt;/code&gt;) Common Message Header version (1 or 2)&lt;/td&gt;&lt;td&gt;1 when &lt;code&gt;mode=reg&lt;/code&gt;, 0 otherwise&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;soapHeaderSessionKey&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;unwrap&lt;/code&gt;: &lt;/td&gt;&lt;td&gt;soapHeader&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;soapHeaderStyleSheet&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt; and mode=&lt;code&gt;i2t&lt;/code&gt;:&lt;/td&gt;&lt;td&gt;/xml/xsl/esb/soapHeader.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt; and mode=&lt;code&gt;reg&lt;/code&gt;:&lt;/td&gt;&lt;td&gt;TODO (for now identical to the "&lt;code&gt;i2t&lt;/code&gt;" SOAP Header)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt; and mode=&lt;code&gt;bis&lt;/code&gt;:&lt;/td&gt;&lt;td&gt;/xml/xsl/esb/bisSoapHeader.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;soapBodyStyleSheet&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt; and mode=&lt;code&gt;reg&lt;/code&gt;:&lt;/td&gt;&lt;td&gt;/xml/xsl/esb/soapBody.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;if direction=&lt;code&gt;wrap&lt;/code&gt; and mode=&lt;code&gt;bis&lt;/code&gt;:&lt;/td&gt;&lt;td&gt;/xml/xsl/esb/bisSoapBody.xsl&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;addOutputNamespace&lt;/td&gt;&lt;td&gt;(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;outputNamespace&lt;/code&gt; is automatically set using the parameters (if $messagingLayer='P2P' then 'http://nn.nl/XSD/$businessDomain/$applicationName/$applicationFunction' else is serviceContext is not empty 'http://nn.nl/XSD/$businessDomain/$serviceName/$serviceContext/$serviceContextVersion/$operationName/$operationVersion' else 'http://nn.nl/XSD/$businessDomain/$serviceName/$serviceVersion/$operationName/$operationVersion')&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;retrievePhysicalDestination&lt;/td&gt;&lt;td&gt;(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, the physical destination is retrieved from the queue instead of using the parameter &lt;code&gt;destination&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;useFixedValues&lt;/td&gt;&lt;td&gt;If &lt;code&gt;true&lt;/code&gt;, the fields CorrelationId, MessageId and Timestamp will have a fixed value (for testing purposes only)&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;fixResultNamespace&lt;/td&gt;&lt;td&gt;(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt; and the Result tag already exists, the namespace is changed&lt;/td&gt;&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;p2pAlias&lt;/td&gt;&lt;td&gt;When the messagingLayer part of the destination has this value interpret it as P2P&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;esbAlias&lt;/td&gt;&lt;td&gt;When the messagingLayer part of the destination has this value interpret it as ESB&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;/xml/xsl/esb/soapHeader.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Id&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$fromId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;To&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Location&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;if $messagingLayer='P2P' then&lt;br/&gt;&amp;nbsp;$messagingLayer.$businessDomain.$applicationName.$applicationFunction.$paradigm&lt;br/&gt;else if $serviceContext is not empty then&lt;br/&gt;&amp;nbsp;$messagingLayer.$businessDomain.$serviceLayer.$serviceName.$serviceContext.$serviceContextVersion.$operationName.$operationVersion.$paradigm&lt;br/&gt;else&lt;br/&gt;&amp;nbsp;$messagingLayer.$businessDomain.$serviceLayer.$serviceName.$serviceVersion.$operationName.$operationVersion.$paradigm&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;CPAId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$cpaId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$conversationId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;CorrelationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$correlationId (if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$messageId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ExternalRefToMessageId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$externalRefToMessageId (if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Timestamp&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$timestamp&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;TransactionId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$transactionId (only used when $mode=reg and $cmhVersion=2; if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Service&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$serviceName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Context&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$serviceContext&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Action&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Paradigm&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;$paradigm&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;$operationName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Version&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;$operationVersion&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;mode&lt;/td&gt;&lt;td&gt;copied from &lt;code&gt;mode&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;cmhVersion&lt;/td&gt;&lt;td&gt;copied from &lt;code&gt;cmhVersion&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://nn.nl/XSD/Generic/MessageHeader/2" (only when $mode=reg and $cmhVersion=2)&lt;br/&gt;"http://nn.nl/XSD/Generic/MessageHeader/1" (otherwise)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;businessDomain&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceContext&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;service(Context)Version&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationVersion&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;paradigm&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;applicationName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;applicationFunction&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;messagingLayer&lt;/td&gt;&lt;td&gt;ESB&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceLayer&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;destination&lt;/td&gt;&lt;td&gt;if not empty this parameter contains the preceding parameters as described in 'Location' in the table above&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;fromId&lt;/td&gt;&lt;td&gt;property 'instance.name'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;cpaId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header, else 'n/a'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;conversationId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header, else parameter pattern '{hostname}_{uid}'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;messageId&lt;/td&gt;&lt;td&gt;parameter pattern '{hostname}_{uid}'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;correlationId&lt;/td&gt;&lt;td&gt;if $paradigm equals 'Response' then copied from MessageId in the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;externalRefToMessageId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;timestamp&lt;/td&gt;&lt;td&gt;parameter pattern '{now,date,yyyy-MM-dd'T'HH:mm:ss}'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;transactionId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;/xml/xsl/esb/bisSoapHeader.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageHeader&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;From&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Id&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$fromId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;HeaderFields&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ConversationId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$conversationId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;MessageId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$messageId&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ExternalRefToMessageId&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$externalRefToMessageId (if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Timestamp&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;$timestamp&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://www.ing.com/CSP/XSD/General/Message_2"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;fromId&lt;/td&gt;&lt;td&gt;property 'instance.name'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;conversationId&lt;/td&gt;&lt;td&gt;if applicable, copied from the original (received) SOAP Header, else parameter pattern '{hostname}_{uid}'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;messageId&lt;/td&gt;&lt;td&gt;parameter pattern '{hostname}_{uid}'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;externalRefToMessageId&lt;/td&gt;&lt;td&gt;if applicable, copied from MessageId in the original (received) SOAP Header&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;timestamp&lt;/td&gt;&lt;td&gt;parameter pattern '{now,date,yyyy-MM-dd'T'HH:mm:ss}'&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;/xml/xsl/esb/soapBody.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;[Payload]&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;if $errorCode is empty then the complete payload will be copied and if not already existing a Result tag will be added&lt;br/&gt;else only the root tag will be copied&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Result&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;this element will be the last child in the copied root tag (only applicable for $paradigm 'Response'); if $errorCode is empty and a Result tag already exists then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Status&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;if $errorCode is empty then 'OK'&lt;br/&gt;else 'ERROR'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ErrorList&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;if $errorCode is empty then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Error&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Code&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;$errorCode&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Reason&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;if $errorReason is not empty then $errorReason&lt;br/&gt;else it will be derived from $errorCode:
   &lt;table border="1"&gt;
   &lt;tr&gt;&lt;th&gt;errorCode&lt;/th&gt;&lt;th&gt;errorText&lt;/th&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6002&lt;/td&gt;&lt;td&gt;Service Interface Request Time Out&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6003&lt;/td&gt;&lt;td&gt;Invalid Request Message&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6004&lt;/td&gt;&lt;td&gt;Invalid Backend system response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6005&lt;/td&gt;&lt;td&gt;Backend system failure response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6999&lt;/td&gt;&lt;td&gt;Unspecified Errors&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Service&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;$serviceName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Context&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;$serviceContext&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Action&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Paradigm&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$paradigm&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$operationName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Version&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$operationVersion&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;DetailList&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;if $errorDetailCode is empty then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Detail&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Code&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$errorDetailCode&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Text&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$errorDetailText (if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;mode&lt;/td&gt;&lt;td&gt;copied from &lt;code&gt;mode&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;cmhVersion&lt;/td&gt;&lt;td&gt;copied from &lt;code&gt;cmhVersion&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://nn.nl/XSD/Generic/MessageHeader/2" (only when $mode=reg and $cmhVersion=2)&lt;br/&gt;"http://nn.nl/XSD/Generic/MessageHeader/1" (otherwise)&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorCode&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorReason&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorDetailCode&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorDetailText&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceContext&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationVersion&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;paradigm&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;fixResultNamespace&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;
 &lt;p&gt;
 &lt;b&gt;/xml/xsl/esb/bisSoapBody.xsl:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;element&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;[Payload]&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;if $errorCode is empty then the complete payload will be copied and if not already existing a Result tag will be added&lt;br/&gt;else only the root tag will be copied&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Result&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;this element will be the last child in the copied root tag (only applicable for $paradigm 'Response' and 'Reply'); if $errorCode is empty and a Result tag already exists then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;xmlns=$namespace&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Status&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;if $errorCode is empty then 'OK'&lt;br/&gt;else 'ERROR'&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;ErrorList&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;if $errorCode is empty then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Error&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Code&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;$errorCode&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Reason&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;if $errorReason is not empty then $errorReason&lt;br/&gt;else it will be derived from $errorCode:
   &lt;table border="1"&gt;
   &lt;tr&gt;&lt;th&gt;errorCode&lt;/th&gt;&lt;th&gt;errorText&lt;/th&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6002&lt;/td&gt;&lt;td&gt;Service Interface Request Time Out&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6003&lt;/td&gt;&lt;td&gt;Invalid Request Message&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6004&lt;/td&gt;&lt;td&gt;Invalid Backend system response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6005&lt;/td&gt;&lt;td&gt;Backend system failure response&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;ERR6999&lt;/td&gt;&lt;td&gt;Unspecified Errors&lt;/td&gt;&lt;/tr&gt;
  &lt;/table&gt;
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Service&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;$serviceName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Context&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;$serviceContext&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Action&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$operationName&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Version&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$operationVersion&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;DetailList&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;if $errorDetailCode is empty then skip this element including its child elements&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Detail&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Code&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$errorDetailCode&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Text&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;$errorDetailText (if empty then skip this element)&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;b&gt;Parameters:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;"http://www.ing.com/CSP/XSD/General/Message_2"&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorCode&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorReason&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorDetailCode&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;errorDetailText&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;serviceContext&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationName&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;operationVersion&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;paradigm&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EsbSoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="EscapePipe">
        <xs:annotation>
          <xs:documentation>Pipe that performs translations between special characters and their xml equivalents.
 &lt;p&gt;When direction=cdata2text all cdata nodes are converted to text nodes without any other translations.&lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="EscapePipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ExceptionPipe">
        <xs:annotation>
          <xs:documentation>Pipe that throws an exception, based on the input message.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ExceptionPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FixedResultPipe">
        <xs:annotation>
          <xs:documentation>This Pipe opens and returns a file from the classpath. The filename is a mandatory parameter to use. You can
 provide this by using the &lt;code&gt;filename&lt;/code&gt; attribute or with a &lt;code&gt;param&lt;/code&gt; element to be able to
 use a sessionKey for instance.

 &lt;h2&gt;Migrating from deprecated features&lt;/h2&gt;
 The FixedResultPipe was a jack of all trades. You could use it to read a file (only text) and/or use
 a 'resultString' to find / replace values in. The following migrations are available:

 &lt;h3&gt;For using a 'resultString'&lt;/h3&gt;
 You can use the EchoPipe for a static value. This looked like this before:

 &lt;pre&gt;
 {@code
 &lt;pipe name="HelloWorld" className="org.frankframework.pipes.FixedResult" returnString="Hello World"&gt;
     &lt;forward name="success" path="EXIT"/&gt;
 &lt;/pipe&gt;
 }
 &lt;/pre&gt;
 Becomes:
 &lt;pre&gt;
 {@code
 &lt;pipe name="HelloWorld" className="org.frankframework.pipes.EchoPipe" getInputFromFixedValue="Hello World"&gt;
     &lt;forward name="success" path="EXIT"/&gt;
 &lt;/pipe&gt;
 }
 &lt;/pre&gt;

 &lt;h3&gt;For replacing a value&lt;/h3&gt;
 You can use the ReplacerPipe to replace a value in multiple ways. First, when you need to replace a placeholder with a parameter.
 This looked like:
 &lt;pre&gt;
 {@code
 &lt;pipe name="make unique message" className="org.frankframework.pipes.FixedResultPipe"
     returnString="&amp;lt;msg mid=&amp;quot;MID&amp;quot; action=&amp;quot;ACTION&amp;quot; /&amp;gt;" replaceFixedParams="true"&gt;
     &lt;param name="MID" sessionKey="mid" /&gt;
 	   &lt;param name="ACTION" xpathExpression="request/@action" /&gt;
 &lt;/pipe&gt;
 }
 &lt;/pre&gt;

 And can now be written like this (note the ?{..} syntax):
 &lt;pre&gt;
 {@code
 &lt;pipe name="make unique message" className="org.frankframework.pipes.ReplacerPipe"
     getInputFromFixedValue="&amp;lt;msg mid=&amp;quot;?{MID}&amp;quot; action=&amp;quot;?{ACTION}&amp;quot; /&amp;gt;"&gt;
 	   &lt;param name="MID" sessionKey="mid" /&gt;
 	   &lt;param name="ACTION" xpathExpression="request/@action" /&gt;
 &lt;/pipe&gt;
 }
 &lt;/pre&gt;

 When you need to replace a fixed value use the ReplacerPipe with find and replace. This looked like this:
 &lt;pre&gt;
 {@code
 &lt;FixedResultPipe name="InputValidateError"
     filename="ManageFileSystem/xml/ErrorMessage.xml"
     replaceFrom="%reasonCode" replaceTo="NOT_WELL_FORMED_XML"&gt;
     &lt;forward name="success" path="EXIT" /&gt;
 &lt;/FixedResultPipe&gt;
 }
 &lt;/pre&gt;

 And now should be solved like this:
 &lt;pre&gt;
 {@code
 &lt;FixedResultPipe name="InputValidateError"
     filename="ManageFileSystem/xml/ErrorMessage.xml"&gt;
     &lt;forward name="success" path="replaceReasonCode" /&gt;
 &lt;/FixedResultPipe&gt;
 &lt;ReplacerPipe name="replaceReasonCode"
     find="%reasonCode"
     replace="NOT_WELL_FORMED_XML"&gt;
     &lt;forward name="success" path="EXIT" /&gt;
 &lt;/ReplacerPipe&gt;
 }
 &lt;/pre&gt;
 This is also an example of now using two pipes to achieve the same result. Each pipe has its own responsibility.

 &lt;h2&gt;More complex configurations&lt;/h2&gt;
 In some cases, a combination of the above is needed to achieve what worked before. In some cases, FixedResultPipe
 was also used to store information in the session. For example, a port of configuration in the JMS listener sender configuration looked like this:
 &lt;pre&gt;
 {@code
 	&lt;CompareStringPipe name="compareIdAndCid" &gt;
 		&lt;param name="operand1" sessionKey="id"/&gt;
 		&lt;param name="operand2" sessionKey="cid"/&gt;
 		&lt;forward name="equals" path="IdAndCidSame" /&gt;
 		&lt;forward name="lessthan" path="IdAndCidDifferent" /&gt;
 		&lt;forward name="greaterthan" path="IdAndCidDifferent" /&gt;
 	&lt;/CompareStringPipe&gt;
 	&lt;FixedResultPipe name="IdAndCidSame" returnString="true" storeResultInSessionKey="IdAndCidSame"&gt;
 		&lt;forward name="success" path="displayKeys" /&gt;
 	&lt;/FixedResultPipe&gt;
 	&lt;FixedResultPipe name="IdAndCidDifferent" returnString="false" storeResultInSessionKey="IdAndCidSame"&gt;
 		&lt;forward name="success" path="displayKeys" /&gt;
 	&lt;/FixedResultPipe&gt;

  &lt;pipe name="displayKeys" className="org.frankframework.pipes.FixedResultPipe"
 		returnString="branch [BRANCH] Orignal Id [MID] cid [CID] id=cid [SAME]" replaceFixedParams="true"&gt;
 		&lt;param name="BRANCH" sessionKey="originalMessage" xpathExpression="*&amp;#47;@branch" /&gt;
 		&lt;param name="MID" sessionKey="id" /&gt;
 		&lt;param name="CID" sessionKey="cid" /&gt;
 		&lt;param name="SAME" sessionKey="IdAndCidSame" /&gt;
 		&lt;forward name="success" path="EXIT" /&gt;
 	&lt;/pipe&gt;
 }
 &lt;/pre&gt;

 Was rewritten to the following:
 &lt;pre&gt;
 {@code
 	&lt;CompareStringPipe name="compareIdAndCid" &gt;
 		&lt;param name="operand1" sessionKey="id"/&gt;
 		&lt;param name="operand2" sessionKey="cid"/&gt;
 		&lt;forward name="equals" path="IdAndCidSame" /&gt;
 		&lt;forward name="lessthan" path="IdAndCidDifferent" /&gt;
 		&lt;forward name="greaterthan" path="IdAndCidDifferent" /&gt;
 	&lt;/CompareStringPipe&gt;

 	&lt;PutInSessionPipe name="IdAndCidSame" value="true" sessionKey="IdAndCidSame"&gt;
 		&lt;forward name="success" path="putOriginalMessageInSession" /&gt;
 	&lt;/PutInSessionPipe&gt;
 	&lt;PutInSessionPipe name="IdAndCidDifferent" value="false" sessionKey="IdAndCidSame"&gt;
 		&lt;forward name="success" path="putOriginalMessageInSession" /&gt;
 	&lt;/PutInSessionPipe&gt;

 	&lt;PutInSessionPipe name="putOriginalMessageInSession" sessionKey="incomingMessage"/&gt;

 	&lt;pipe name="displayKeys" className="org.frankframework.pipes.ReplacerPipe"
 		getInputFromFixedValue="branch [?{BRANCH}] Original Id [?{MID}] cid [?{CID}] id=cid [?{SAME}]"&gt;
 		&lt;param name="BRANCH" sessionKey="originalMessage" xpathExpression="*&amp;#47;@branch" /&gt;
 		&lt;param name="MID" sessionKey="id" /&gt;
 		&lt;param name="CID" sessionKey="cid" /&gt;
 		&lt;param name="SAME" sessionKey="IdAndCidSame" /&gt;
 		&lt;forward name="success" path="EXIT" /&gt;
 	&lt;/pipe&gt;
 }
 &lt;/pre&gt;
 &lt;p&gt;

 &lt;h2&gt;The features/documentation of the deprecated features&lt;/h2&gt;
 Produces a fixed result that does not depend on the input message. It may return the contents of a file
 when &lt;code&gt;filename&lt;/code&gt; or &lt;code&gt;filenameSessionKey&lt;/code&gt; is specified. Otherwise, the
 value of attribute &lt;code&gt;returnString&lt;/code&gt; is returned.
 &lt;br/&gt;&lt;br/&gt;
 Using parameters and the attributes of this pipe, it is possible to substitute values. This pipe
 performs the following steps:
 &lt;ol&gt;
 &lt;li&gt;During execution, this pipe first obtains a string based on attributes &lt;code&gt;returnString&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt; or &lt;code&gt;filenameSessionKey&lt;/code&gt;.&lt;/li&gt;
 &lt;li&gt;The resulting string is transformed according to attributes &lt;code&gt;replaceFrom&lt;/code&gt; and &lt;code&gt;replaceTo&lt;/code&gt; if set.
 Please note that the plain value of attribute &lt;code&gt;replaceFrom&lt;/code&gt; is matched, no &lt;code&gt;?{...}&lt;/code&gt; here.&lt;/li&gt;

 &lt;li&gt;The resulting string is substituted based on the parameters of this pipe. This step depends on attribute &lt;code&gt;replaceFixedParams&lt;/code&gt;.
 Assume that there is a parameter with name &lt;code&gt;xyz&lt;/code&gt;. If &lt;code&gt;replaceFixedParams&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then
 each occurrence of &lt;code&gt;?{xyz}&lt;/code&gt; is replaced by the parameter's value. Otherwise, the text &lt;code&gt;xyz&lt;/code&gt;
 is substituted. See Parameter to see how parameter values are determined.&lt;/li&gt;

 &lt;li&gt;If attribute &lt;code&gt;substituteVars&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then expressions &lt;code&gt;${...}&lt;/code&gt; are substituted using
 system properties, pipelinesession variables and application properties. Please note that
 no &lt;code&gt;${...}&lt;/code&gt; patterns are left if the initial string came from attribute &lt;code&gt;returnString&lt;/code&gt;, because
 any &lt;code&gt;${...}&lt;/code&gt; pattern in attribute &lt;code&gt;returnString&lt;/code&gt; is substituted when the configuration is loaded.&lt;/li&gt;
 &lt;li&gt;If attribute &lt;code&gt;styleSheetName&lt;/code&gt; is set, then the referenced XSLT stylesheet is applied to the resulting string.&lt;/li&gt;
 &lt;/ol&gt;
 &lt;br/&gt;
 Many attributes of this pipe reference file names. If a file is referenced by a relative path, the path
 is relative to the configuration's root directory.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FixedResultPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ForEachAttachmentPipe">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ForEachAttachmentPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ForEachChildElementPipe">
        <xs:annotation>
          <xs:documentation>Sends a message to a Sender for each child element of the input XML.
 Input can be a String containing XML, a filename (set processFile true), an InputStream or a Reader.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ForEachChildElementPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FxfWrapperPipe">
        <xs:annotation>
          <xs:documentation>FxF wrapper to be used with FxF3. When receiving files (direction=unwrap)
 the message handed to the pipeline is the local filename extracted from an
 ESB SOAP message. When sending files (direction=wrap) input should be a local
 filename which will be wrapped into an ESB SOAP message. Please note: When
 writing files which need to be send through FxF they should be written to
 ${fxf.dir}/NNX00000/out. The property ${fxf.dir} will automatically be
 available on the OTAP environment (define it in StageSpecifics_LOC.properties
 only). Replace NNX00000 with the specific flowId and generate a unique
 filename (files will automatically be cleaned after 30 days or any other
 value specified by ${fxf.retention}).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FxfWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="FxfXmlValidatorPipe">
        <xs:annotation>
          <xs:documentation>FxF XML validator to be used with FxF3. When receiving files
 (direction=receive) the message is validated against the
 OnCompletedTransferNotify WSDL (a P2P connection, hence same WSDL (provided
 by Tibco) for all queues (every Ibis receiving FxF files has it's own
 queue)). When sending files (direction=send) the message is validated against
 the StartTransfer WSDL (ESB service provided by Tibco).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="FxfXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="GetFromSessionPipe">
        <xs:annotation>
          <xs:documentation>Gets the contents of the pipeLineSession by a key specified by
 &lt;code&gt;sessionKey&lt;/code&gt;.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="GetFromSessionType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="GetPrincipalPipe">
        <xs:annotation>
          <xs:documentation>Returns the name of the user executing the request.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="GetPrincipalPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="GetTibcoQueuesPipe">
        <xs:annotation>
          <xs:documentation>Returns information about Tibco queues in a XML string.
 &lt;p&gt;
 If the parameter &lt;code&gt;queueName&lt;/code&gt; is empty then
 &lt;ul&gt;&lt;li&gt;all Tibco queues including information about these queues are returned&lt;/li&gt;&lt;/ul&gt;
 else
 &lt;ul&gt;&lt;li&gt;one message on a specific Tibco queue including information about this message is returned (without removing it)&lt;/li&gt;&lt;/ul&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="GetTibcoQueuesType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="HashPipe">
        <xs:annotation>
          <xs:documentation>Pipe that hashes the input message.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="HashPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IncreaseIntegerPipe">
        <xs:annotation>
          <xs:documentation>Pipe that increases the integer value of a session variable.
 Can be used in combination with CompareIntegerPipe to construct loops.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IncreaseIntegerPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IsUserInRolePipe">
        <xs:annotation>
          <xs:documentation>Pipe that checks if the calling user has a specified role.
 Uses the PipeLineSessions methods.
 &lt;p&gt;
 If the role is not specified by the role attribute, the input of
 the pipe is used as role.

 N.B. The role itself must be specified by hand in the deployment descriptors web.xml and application.xml.
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IsUserInRolePipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="IsXmlPipe">
        <xs:annotation>
          <xs:documentation>Selects an exitState, based on if the input is a XML string.
 The input is an XML string if it, after removing leading white-space characters, starts with '&amp;lt;'.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="IsXmlPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Json2XmlValidatorPipe">
        <xs:annotation>
          <xs:documentation>&lt;code&gt;Pipe&lt;/code&gt; that validates the XML or JSON input message against a XML Schema and returns either XML or JSON.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Json2XmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JsonPipe">
        <xs:annotation>
          <xs:documentation>JSON is not aware of the element order. This pipe performs a &lt;strong&gt;best effort&lt;/strong&gt; JSON to XML transformation.
 If you wish to validate or add structure to the converted (xml) file, please use the Json2XmlValidator.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JsonPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JsonValidatorPipe">
        <xs:annotation>
          <xs:documentation>Pipe that validates the input message against a JSON Schema.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JsonValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JsonWellFormedCheckerPipe">
        <xs:annotation>
          <xs:documentation>&lt;code&gt;Pipe&lt;/code&gt; that checks the well-formedness of the input message.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JsonWellFormedCheckerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JsonXsltPipe">
        <xs:annotation>
          <xs:documentation>Perform an XSLT transformation with a specified stylesheet on a JSON input, yielding JSON, XML or text.
 JSON input is transformed into XML map, array, string, integer and boolean elements, in the namespace http://www.w3.org/2013/XSL/json.
 The XSLT stylesheet or XPathExpression operates on these element.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JsonXsltPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="JwtPipe">
        <xs:annotation>
          <xs:documentation>Creates a JWT with a shared secret using the HmacSHA256 algorithm.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="JwtPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LabelFormatPipe">
        <xs:annotation>
          <xs:documentation>Transforms between ascii and an XML representation.

 &lt;p&gt;
 Sample xml:&lt;br/&gt;
 &lt;pre&gt;{@code
 &lt;CALCBOXMESSAGE&gt;
 		&lt;OPDRACHT&gt;
 		    &lt;OPDRACHTSOORT&gt;ONTTREK_RISICO_EN_KOSTEN&lt;/OPDRACHTSOORT&gt;
 		    &lt;BASISRENDEMENTSOORT&gt;NVT&lt;/BASISRENDEMENTSOORT&gt;
 		    &lt;BEDRAG&gt;625&lt;/BEDRAG&gt;
 		    &lt;DATUM&gt;20071201&lt;/DATUM&gt;
     ...
 &lt;/CALCBOXMESSAGE&gt;
 }&lt;/pre&gt;
 &lt;br/&gt;

 Sample ascii:&lt;br/&gt;
 &lt;pre&gt;{@code
 	OPDRACHT : #SAMENGESTELD
 	OPDRACHT.OPDRACHTSOORT :ONTTREK_RISICO_EN_KOSTEN
 	OPDRACHT.BASISRENDEMENTSOORT :NVT
 	OPDRACHT.BEDRAG :625
 	OPDRACHT.DATUM :20071201

          ...
 	EINDEREKENVERZOEK :EINDE
 }&lt;/pre&gt;
 &lt;/p&gt;

 &lt;p&gt;&lt;b&gt;Configuration:&lt;/b&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;th&gt;attributes&lt;/th&gt;&lt;th&gt;description&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;direction&lt;/td&gt;&lt;td&gt;transformation direction. Possible values
 &lt;ul&gt;
   &lt;li&gt;"Xml2Label": transform an XML file to ascii&lt;/li&gt;
   &lt;li&gt;"Label2Xml": transform an ascii file to XML&lt;/li&gt;
 &lt;/ul&gt;&lt;/td&gt;&lt;td&gt;Xml2Label&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LabelFormatType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LadybugPipe">
        <xs:annotation>
          <xs:documentation>Call Ladybug Test Tool to rerun the reports present in test storage (see Test tab in Ladybug)</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LadybugPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LarvaPipe">
        <xs:annotation>
          <xs:documentation>Call Larva Test Tool</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LarvaPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LdapFindGroupMembershipsPipe">
        <xs:annotation>
          <xs:documentation>Pipe that returns the memberships of a userDN.
 The input is a fullDn, of a user or a group.
 &lt;br/&gt;
 Sample result:&lt;br/&gt;&lt;code&gt;&lt;pre&gt;
	&amp;lt;ldap&amp;gt;
	 &amp;lt;entry name="CN=xxyyzz,OU=Users,DC=domain,DC=ext"&amp;gt;
	   &amp;lt;attributes&amp;gt;
	    &amp;lt;attribute&amp;gt;
	    &amp;lt;attribute name="memberOf" value="Extern"/&amp;gt;
	    &amp;lt;attribute name="departmentCode" value="358000"/&amp;gt;
	    &amp;lt;attribute name="organizationalHierarchy"&amp;gt;
	        &amp;lt;item value="ou=zzyyxx"/&amp;gt;
	        &amp;lt;item value="ou=OPS&amp;amp;IT,ou=Group,ou=domain,o=ext"/&amp;gt;
	    &amp;lt;/attribute&gt;
	    &amp;lt;attribute name="givenName" value="Gerrit"/&gt;
	   &amp;lt;/attributes&amp;gt;
	  &amp;lt;/entry&amp;gt;
   &amp;lt;entry&amp;gt; .... &amp;lt;/entry&amp;gt;
   .....
	&amp;lt;/ldap&amp;gt;
 &lt;/pre&gt;&lt;/code&gt; &lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LdapFindGroupMembershipsPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LdapFindMemberPipe">
        <xs:annotation>
          <xs:documentation>Pipe that checks if a specified dn exists as 'member' in another specified dn
 in LDAP.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LdapFindMemberPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LocalFileSystemPipe">
        <xs:annotation>
          <xs:documentation>Pipe to work with the server local filesystem.
 &lt;p&gt;
     In addition to regular parameters for filesystem senders, it is possible
     to set custom extended attributes on files by prefixing parameter names with
     FileAttribute..
     This prefix will be not be part of the actual metadata property name.
 &lt;/p&gt;
 &lt;p&gt;
     The string value of these parameters will be used as value of the custom metadata attribute.
 &lt;/p&gt;
 &lt;p&gt;
     If extended attributes actually can be written depends on the underlying OS / filesystem.
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LocalFileSystemPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LogContextPipe">
        <xs:annotation>
          <xs:documentation>Pipe that stores all its parameter values in the ThreadContext, formerly known as Mapped Diagnostic Context (MDC), to be used in logging.
 The input is passed through to the output.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LogContextPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="MailSenderPipe">
        <xs:annotation>
          <xs:documentation>Pipe that sends a mail-message using a MailSender as its sender.
 &lt;br/&gt;
 Sample email.xml:&lt;br/&gt;
 &lt;pre&gt;{@code
 	&lt;email&gt;
 	    &lt;recipients&gt;
 	        &lt;recipient&gt;***@natned&lt;/recipient&gt;
 	        &lt;recipient&gt;***@nn.nl&lt;/recipient&gt;
 	    &lt;/recipients&gt;
 	    &lt;from&gt;***@nn.nl&lt;/from&gt;
 	    &lt;subject&gt;this is the subject&lt;/subject&gt;
 	    &lt;message&gt;dit is de message&lt;/message&gt;
 	&lt;/email&gt;
 }&lt;/pre&gt;
 &lt;br/&gt;
 Notice: it must be valid XML. Therefore, especially the message element
 must be plain text or be wrapped as CDATA.&lt;br/&gt;&lt;br/&gt;
 example:&lt;br/&gt;
 &lt;pre&gt;{@code
 &lt;message&gt;&lt;![CDATA[&lt;h1&gt;This is a HtmlMessage&lt;/h1&gt;]]&gt;&lt;/message&gt;
 }&lt;/pre&gt;
 &lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="MailSenderPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ObfuscatePipe">
        <xs:annotation>
          <xs:documentation>Pipe that performs obfuscation on a message, using the tibcrypt library.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ObfuscatePipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PGPPipe">
        <xs:annotation>
          <xs:documentation>&lt;p&gt;Performs various PGP (Pretty Good Privacy) actions such as Encrypt, Sign, Decrypt, Verify.&lt;/p&gt;
 &lt;p&gt;To use this pipe action parameter has to be set to one of the actions above.&lt;/p&gt;
 &lt;p&gt;
 &lt;strong&gt;Note:&lt;/strong&gt; When secret key is required in any of the actions,
 the related public key should also be included in public keys.
 &lt;/p&gt;

 &lt;p&gt;
 &lt;strong&gt;Note:&lt;/strong&gt; For fields that require multiple input
 (such as recipients, senders and publicKey -in certain actions-)
 you can seperate multiple values with ";" (semicolon).
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PGPPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PasswordGeneratorPipe">
        <xs:annotation>
          <xs:documentation>Generates a random password.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PasswordGeneratorPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PasswordHashPipe">
        <xs:annotation>
          <xs:documentation>Hash a password or validate a password against a hash using PasswordHash.java
 from &lt;a href="https://crackstation.net/hashing-security.htm"&gt;https://crackstation.net/hashing-security.htm&lt;/a&gt;.
 Input of the pipe is expected to be the password. In case hashSessionKey
 isn't used a hash of the password is returned. In case hashSessionKey is used
 it is validated against the hash in the session key which will determine
 the forward to be used (success or failure).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PasswordHashPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PdfPipe">
        <xs:annotation>
          <xs:documentation>Converts files to pdf type. This pipe has two actions convert and combine.
 With combine action you can attach files into main pdf file.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PdfPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PutInSessionPipe">
        <xs:annotation>
          <xs:documentation>Puts the input or the &lt;code&gt;value&lt;/code&gt; in the PipeLineSession, under the key specified by
 &lt;code&gt;sessionKey&lt;/code&gt;. Additionally, stores parameter values in the PipeLineSession.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PutInSessionType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="PutSystemDateInSessionPipe">
        <xs:annotation>
          <xs:documentation>Puts the system date/time under a key in the pipeLineSession.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="PutSystemDateInSessionType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="RekenBoxCallerPipe">
        <xs:annotation>
          <xs:documentation>Perform a call to a RekenBox.

 The inputmessage is written to a temporary file and passed as inputfile to the rekenbox. The contents of the outputfile of the
 rekenbox is returned as output message. The name of the rekenbox, as determined from the inputfile, is optionally written to
 the pipeLineSession.


 &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt;&lt;br/&gt;
 The rekenbox-name is currently determined from the first 8 characters of the file, or up
 to the first space (' ') or colon (':') character. Beware that if the first character of the
 file is a newline character or something similar, less characters are available to pass the
 rekenbox-name on. Especially if the inputmessages are constructed by means of an XSLT-stylesheet,
 messages often start with a newline character.
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RekenBoxCallerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="RemoveCacheKeyPipe">
        <xs:annotation>
          <xs:documentation>Remove specified cache key from cache with specified name.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RemoveCacheKeyPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="RemoveFromSessionPipe">
        <xs:annotation>
          <xs:documentation>Removes a key specified by &lt;code&gt;sessionKey&lt;/code&gt;
 from the pipeLineSession.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RemoveFromSessionType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ReplacerPipe">
        <xs:annotation>
          <xs:documentation>This Pipe is used to replace values in a few ways. The following steps are performed:
 &lt;ol&gt;
 &lt;li&gt;If &lt;code&gt;find&lt;/code&gt; is provided, it will be replaced by &lt;code&gt;replace&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;The resulting string is substituted based on the parameters of this pipe. It will replace values in the input enclosed
 with ?{}, for instance: ?{parameterOne}, with parameters of this pipe. If a parameter for the given value is not found, it
 will not be replaced and the '?{parameterOne}' value will remain in the output.
 &lt;p&gt;
 See Parameter to see how parameter values are determined.&lt;/li&gt;
 &lt;p&gt;
 &lt;li&gt;If attribute &lt;code&gt;substituteVars&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then expressions &lt;code&gt;${...}&lt;/code&gt; are substituted using
 system properties, session variables and application properties. Please note that no &lt;code&gt;${...}&lt;/code&gt; patterns are left in the input. &lt;/li&gt;
 &lt;/ol&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ReplacerPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ResultSetIteratingPipe">
        <xs:annotation>
          <xs:documentation>Pipe that iterates over rows in in ResultSet.

 Each row is send passed to the sender in the same format a row is usually returned from a query.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ResultSetIteratingPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Samba1Pipe">
        <xs:annotation>
          <xs:documentation>Uses the (old) SMB 1 protocol.
 &lt;br/&gt;
 Only supports NTLM authentication.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Samba1PipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Samba2Pipe">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Samba2PipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SambaPipe">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SambaPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SapLUWManagerPipe">
        <xs:annotation>
          <xs:documentation>Manager for SAP Logical Units of Work (LUWs).
 Used to begin, commit or rollback LUWs. A SapLUWManager can be placed before a number
 of SapSenders. The SapLUWManager and the SapSenders must each use the same value for
 luwHandleSessionKey. By doing so, they use the same connection to SAP. This allows to
 perform a commit on a number of actions.&lt;br/&gt;
 The placement of the the first SapLUWManager is optionan: By specifying a new
 luwHandleSessionKey a new handle is created implicitly.&lt;br/&gt;
 To explicityly commit or rollback a set of actions, a SapLUWManager-pipe can be used, with
 the action-attribute set apropriately.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SapLUWManagerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ScanTibcoSolutionPipe">
        <xs:annotation>
          <xs:documentation>Pipe which scans TIBCO sources in Subversion and creates a report in xml.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ScanTibcoSolutionPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SendTibcoMessagePipe">
        <xs:annotation>
          <xs:documentation>Sends a message to a Tibco queue.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SendTibcoMessageType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SenderPipe">
        <xs:annotation>
          <xs:documentation>Plain extension to MessageSendingPipe that can be used directly in configurations.
 Only extension is that the setters for listener and sender have been made public, and can therefore
 be set from the configuration file.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SenderPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SignaturePipe">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SignaturePipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SizePipe">
        <xs:annotation>
          <xs:documentation>Returns the number of bytes or characters in the input.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SizePipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SkipPipe">
        <xs:annotation>
          <xs:documentation>Skip a number of bytes or characters from the input message.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SkipPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SoapValidatorPipe">
        <xs:annotation>
          <xs:documentation>XmlValidator that will automatically add the SOAP envelope XSD to the set of XSD's used for validation.

 Before the &lt;code&gt;outputSoapBody&lt;/code&gt; attribute was introduced, two validators were used for a request-reply pattern (an inputValidator for the request and an outputValidator for the reply).
 These inputValidator and outputValidator were identical except for the child element of the SOAP body. Because validators use relatively a lot of memory, the &lt;code&gt;outputSoapBody&lt;/code&gt; attribute was added which replaces the outputValidator.
 Both the request and the reply are then validated by the inputValidator.
 &lt;p&gt;To generate a wsdl with a soap action included one of the following properties must be set to the expected soapAction&lt;/p&gt;
 &lt;table border="1"&gt;
 &lt;tr&gt;&lt;td&gt;wsdl.${adapterName}.${listenerName}.soapAction&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;wsdl.${adapterName}.soapAction&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;wsdl.soapAction&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SoapValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SoapWrapperPipe">
        <xs:annotation>
          <xs:documentation>Pipe to wrap or unwrap a message from/into a SOAP Envelope.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SoapWrapperPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="StreamLineIteratorPipe">
        <xs:annotation>
          <xs:documentation>Sends a message to a Sender for each line of its input, that must be an InputStream.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="StreamLineIteratorPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="StreamPipe">
        <xs:annotation>
          <xs:documentation>Stream an input stream to an output stream.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="StreamPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="Text2XmlPipe">
        <xs:annotation>
          <xs:documentation>Pipe for converting TEXT to XML.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="Text2XmlPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="TextSplitterPipe">
        <xs:annotation>
          <xs:documentation>Breaks up the text input in blocks of a maximum length.
 By default, the maximum block length is 160 characters, to enable them to be sent as SMS messages.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="TextSplitterPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="UUIDGeneratorPipe">
        <xs:annotation>
          <xs:documentation>Pipe that generates an UUID (Universally Unique Identifier).

 Only type &lt;code&gt;alphanumeric&lt;/code&gt; guarantees a 100% unique identifier, type &lt;code&gt;numeric&lt;/code&gt; has a 0.01% chance of exactly the same id in case of multiple calls on the same host within a few milliseconds.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="UUIDGeneratorPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="UnzipPipe">
        <xs:annotation>
          <xs:documentation>Assumes input to be the file name of a ZIP archive, and unzips it to a
 directory and/or an XML message.
 &lt;br/&gt;
 The output of each unzipped item is returned in XML as follows when
 collectFileContents is false:
 &lt;pre&gt;
  &amp;lt;results count="num_of_items"&amp;gt;
    &amp;lt;result item="1"&amp;gt;
      &amp;lt;zipEntry&amp;gt;name in ZIP archive of first item&amp;lt;/zipEntry&amp;gt;
      &amp;lt;fileName&amp;gt;filename of first item&amp;lt;/fileName&amp;gt;
    &amp;lt;/result&amp;gt;
    &amp;lt;result item="2"&amp;gt;
      &amp;lt;zipEntry&amp;gt;name in ZIP archive of second item&amp;lt;/zipEntry&amp;gt;
      &amp;lt;fileName&amp;gt;filename of second item&amp;lt;/fileName&amp;gt;
    &amp;lt;/result&amp;gt;
       ...
  &amp;lt;/results&amp;gt;
 &lt;/pre&gt;

 &lt;br/&gt;
 The output of each unzipped item is returned in XML as follows when
 collectFileContents is true:
 &lt;pre&gt;
  &amp;lt;results count="num_of_items"&amp;gt;
    &amp;lt;result item="1"&amp;gt;
      &amp;lt;zipEntry&amp;gt;name in ZIP archive of first item&amp;lt;/zipEntry&amp;gt;
      &amp;lt;fileContent&amp;gt;content of first item&amp;lt;/fileContent&amp;gt;
    &amp;lt;/result&amp;gt;
    &amp;lt;result item="2"&amp;gt;
      &amp;lt;zipEntry&amp;gt;name in ZIP archive of second item&amp;lt;/zipEntry&amp;gt;
      &amp;lt;fileContent&amp;gt;content of second item&amp;lt;/fileContent&amp;gt;
    &amp;lt;/result&amp;gt;
       ...
  &amp;lt;/results&amp;gt;
 &lt;/pre&gt;
 &lt;br/&gt;
 By default, this pipe takes care
 to produce unique file names, as follows. When the filename within
 the archive is:
 &lt;pre&gt;&amp;lt;basename&amp;gt; + "." + &amp;lt;extension&amp;gt;&lt;/pre&gt;
 then the extracted filename (path omitted) becomes
 &lt;pre&gt;&amp;lt;basename&amp;gt; + &amp;lt;unique number&amp;gt; + "." + &amp;lt;extension&amp;gt;&lt;/pre&gt;
 &lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="UnzipPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="WsdlGeneratorPipe">
        <xs:annotation>
          <xs:documentation>Generate WSDL of parent or specified adapter.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="WsdlGeneratorPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="WsdlXmlValidatorPipe">
        <xs:annotation>
          <xs:documentation>XmlValidator that will read the XSD's to use from a WSDL. As it extends the
 SoapValidator is will also add the SOAP envelope XSD.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="WsdlXmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XQueryPipe">
        <xs:annotation>
          <xs:documentation>Perform an XQuery.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XQueryPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlIfPipe">
        <xs:annotation>
          <xs:documentation>Selects a forward, based on XPath evaluation</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlIfType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlSwitchPipe">
        <xs:annotation>
          <xs:documentation>Selects an exitState, based on either the content of the input message, by means
 of a XSLT-stylesheet, the content of a session variable or, by default, by returning the name of the root-element.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlSwitchType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlValidatorPipe">
        <xs:annotation>
          <xs:documentation>Pipe that validates the input message against an XML Schema.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlValidatorType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XmlWellFormedCheckerPipe">
        <xs:annotation>
          <xs:documentation>&lt;code&gt;Pipe&lt;/code&gt; that checks the well-formedness of the input message.
 If &lt;code&gt;root&lt;/code&gt; is given then this is also checked.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XmlWellFormedCheckerType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="XsltPipe">
        <xs:annotation>
          <xs:documentation>Perform an XSLT transformation with a specified stylesheet.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="XsltPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ZipIteratorPipe">
        <xs:annotation>
          <xs:documentation>Sends a message to a Sender for each entry of its input, that must be an ZipInputStream. The input of the pipe must be one of:
 &lt;ul&gt;
 	&lt;li&gt;String refering to a filename&lt;/li&gt;
  &lt;li&gt;File&lt;/li&gt;
  &lt;li&gt;InputStream&lt;/li&gt;
 &lt;/ul&gt;
 The message sent each time to the sender is the filename of the entry found in the archive.
 The contents of the archive is available as a Stream or a String in a session variable.

 &lt;br/&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ZipIteratorPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ZipWriterPipe">
        <xs:annotation>
          <xs:documentation>Pipe that creates a ZIP archive (on action close).
 &lt;p&gt;
 A chain of zipWriterPipes can be used to create a ZIP archive. You can use the pipe with different actions (see specified below).
 Action &lt;code&gt;CLOSE&lt;/code&gt; will generate the ZIP archive which is returned as the pipe ouput.
 &lt;/p&gt;</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ZipWriterPipeType">
              <xs:attribute name="elementRole" type="xs:string" fixed="pipe" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="Adios2XmlPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="Adios2XmlPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.rekenbox.Adios2XmlPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="Adios2XmlPipeDeclaredAttributeGroup">
    <xs:attribute name="adiosDefinities" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets URL to the pascal file with label-constants generated by the ADIOS-utility. Default: nnrscons.pas</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction">
      <xs:annotation>
        <xs:documentation>Transformation direction. Default: Adios2Xml</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="DirectionAttributeValuesType_5 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="rekenbox" type="xs:string">
      <xs:annotation>
        <xs:documentation>Sets name of the rekenbox to be called</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rekenboxSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the SessionKey to retrieve the rekenbox name from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noConversionForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Sets the name of the forward used when no conversion to XML was performed, because the input was already XML. Default: noconversion</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Adios2XmlPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="Adios2XmlPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="AmountOfPagesPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="AmountOfPagesPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.aspose.pipe.AmountOfPagesPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="AmountOfPagesPipeDeclaredAttributeGroup">
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Charset to be used to read the input message.
 Defaults to the message's known charset or UTF-8 when unknown.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="AmountOfPagesPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="AmountOfPagesPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ApiPrincipalPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="ApiPrincipalPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.http.rest.ApiPrincipalPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ApiPrincipalPipeDeclaredAttributeGroup">
    <xs:attribute name="action" type="xs:string" />
    <xs:attribute name="authenticationMethod" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="ApiPrincipalPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ApiPrincipalPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Base64PipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="Base64PipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.Base64Pipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="Base64PipeDeclaredAttributeGroup">
    <xs:attribute name="direction">
      <xs:annotation>
        <xs:documentation>Default: ENCODE</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="DirectionAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Character encoding to be used to when reading input from strings for direction=encode or writing data for direction=decode.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineSeparator" type="xs:string">
      <xs:annotation>
        <xs:documentation>(Only used when direction=encode) Defines separator between lines. Special values: &lt;code&gt;auto&lt;/code&gt;: platform default, &lt;code&gt;dos&lt;/code&gt;: crlf, &lt;code&gt;unix&lt;/code&gt;: lf Default: auto</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineLength" type="frankInt">
      <xs:annotation>
        <xs:documentation>(Only used when direction=encode) Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4). If linelength &amp;lt;= 0, then the output will not be divided into lines Default: 76</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Base64PipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="Base64PipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="BlobLineIteratingPipeType">
    <xs:group ref="IteratingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="JdbcIteratingPipeBaseCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jdbc.BlobLineIteratingPipe" use="prohibited" />
  </xs:complexType>
  <xs:group name="IteratingPipeDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="SenderElementGroup" minOccurs="1" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:group name="IteratingPipeCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="IteratingPipeDeclaredChildGroup" />
      <xs:group ref="MessageSendingPipeCumulativeChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="IteratingPipeDeclaredAttributeGroup">
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Stylesheet to apply to each message, before sending it</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alternatively: xpath-expression to create stylesheet from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions. For some use other cases (NOT xpathExpression), one entry can be without a prefix, that will define the default namespace.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType">
      <xs:annotation>
        <xs:documentation>Only valid for xpathexpression Default: text</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="OutputTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Force the transformer generated from the xpath-expression to omit the xml declaration Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="itemNoSessionKey" />
    <xs:attribute ref="maxItems" />
    <xs:attribute ref="stopConditionXPathExpression" />
    <xs:attribute ref="ignoreExceptions" />
    <xs:attribute ref="collectResults" />
    <xs:attribute ref="removeXmlDeclarationInResults" />
    <xs:attribute ref="addInputToResult" />
    <xs:attribute ref="removeDuplicates" />
    <xs:attribute ref="parallel" />
    <xs:attribute ref="maxChildThreads" />
    <xs:attribute name="blockSize" type="frankInt">
      <xs:annotation>
        <xs:documentation>Controls multiline behaviour. When set to a value greater than 0, it specifies the number of rows send, in a one block, to the sender. Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="IteratingPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="IteratingPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="MessageSendingPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="MessageSendingPipeType">
    <xs:group ref="MessageSendingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="MessageSendingPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.MessageSendingPipe" use="prohibited" />
  </xs:complexType>
  <xs:group name="MessageSendingPipeDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="MessageLogElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="InputValidatorElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="OutputValidatorElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="InputWrapperElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="OutputWrapperElementGroup" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:group name="MessageSendingPipeCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="MessageSendingPipeDeclaredChildGroup" />
      <xs:group ref="AbstractPipeDeclaredChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="MessageSendingPipeDeclaredAttributeGroup">
    <xs:attribute name="linkMethod">
      <xs:annotation>
        <xs:documentation>For asynchronous communication, the server side may either use the messageID or the correlationID
 in the correlationID field of the reply message. Use this property to set the behaviour of the reply-listener. Default: CORRELATIONID</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="LinkMethodAttributeValuesType_2 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>Stylesheet to extract correlationid from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>XPath expression to extract correlationid from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for correlationIDXPath. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceUri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of a PipelineSession-variable. If specified, the value of the PipelineSession variable is used as input for the XPathExpression or stylesheet, instead of the current input message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>Stylesheet to extract label from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>XPath expression to extract label from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for labelXPath. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceUri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>XPath expression to extract audit trail from message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for auditTrailXPath. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceUri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of a PipelineSession-variable. If specified, the value of the PipelineSession variable is used as audit trail (instead of the default 'no audit trail)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useInputForExtract" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the input of the Pipe is used to extract audit trail, correlationid and label (instead of the wrapped input) Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>Next to common usage in AbstractPipe, also strings in the error/logstore are masked</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod">
      <xs:annotation>
        <xs:documentation>(Only used when hideRegex is not empty and only applies to error/logstore) Default: all</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="HideMethodAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="checkXmlWellFormed" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the XML Well-Formedness of the result is checked Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkRootTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, besides the XML Well-Formedness the root element of the result is checked to be equal to the value set</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultOnTimeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>The message (e.g. 'receiver timed out') that is returned when the time listening for a reply message
 exceeds the timeout, or in other situations no reply message is received.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRetries" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of times a processing attempt is retried after a timeout or an exception is caught or after an incorrect reply is received (see also &lt;code&gt;retryXPath&lt;/code&gt;) Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMinInterval" type="frankInt">
      <xs:annotation>
        <xs:documentation>The starting number of seconds waited after an unsuccessful processing attempt before another processing attempt is made. Each next retry this interval is doubled with a upper limit of &lt;code&gt;retryMaxInterval&lt;/code&gt; Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMaxInterval" type="frankInt">
      <xs:annotation>
        <xs:documentation>The maximum number of seconds waited after an unsuccessful processing attempt before another processing attempt is made Default: 600</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>XPath expression evaluated on each technical successful reply. Retry is done if condition returns true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for retryXPath. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceUri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="presumedTimeOutInterval" type="frankInt">
      <xs:annotation>
        <xs:documentation>If the previous call was a timeout, the maximum time &lt;i&gt;in seconds&lt;/i&gt; after this timeout to presume the current call is also a timeout. Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stubFilename" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the pipe returns a message from a file, instead of doing the regular process</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeoutOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>If not empty, a TimeoutException is thrown when the result equals this value (for testing purposes only)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exceptionOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>If not empty, a PipeRunException is thrown when the result equals this value (for testing purposes only)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="MessageSendingPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="MessageSendingPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeDeclaredAttributeGroup" />
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>The functional name of this pipe. Can be referenced by the &lt;code&gt;path&lt;/code&gt; attribute of a PipeForward.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="getInputFromSessionKey" />
    <xs:attribute ref="getInputFromFixedValue" />
    <xs:attribute ref="emptyInputReplacement" />
    <xs:attribute ref="preserveInput" />
    <xs:attribute ref="storeResultInSessionKey" />
    <xs:attribute ref="maxThreads" />
    <xs:attribute ref="chompCharSize" />
    <xs:attribute ref="elementToMove" />
    <xs:attribute ref="elementToMoveSessionKey" />
    <xs:attribute ref="elementToMoveChain" />
    <xs:attribute ref="durationThreshold" />
    <xs:attribute ref="removeCompactMsgNamespaces" />
    <xs:attribute ref="restoreMovedElements" />
    <xs:attribute ref="sizeStatistics" />
    <xs:attribute ref="writeToSecLog" />
    <xs:attribute ref="secLogSessionKeys" />
    <xs:attribute ref="logIntermediaryResults" />
    <xs:attributeGroup ref="TransactionAttributesDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcIteratingPipeBaseDeclaredAttributeGroup">
    <xs:attribute name="query" type="xs:string">
      <xs:annotation>
        <xs:documentation>The SQL query text to be excecuted each time sendMessage() is called. When not set, the input message is taken as the query</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>JNDI name of datasource to be used, can be configured via jmsRealm, too Default: jdbc.datasource.default</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useNamedParams" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Named parameters will be auto-detected by default. Every string in the query which equals &lt;code&gt;?{paramname}&lt;/code&gt; will be replaced by the value of the corresponding parameter. The parameters don't need to be in the correct order and unused parameters are skipped.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trimSpaces" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Remove trailing blanks from all result values. Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sqlDialect" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, the SQL dialect in which the queries are written and should be translated from to the actual SQL dialect</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockRows" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>When set &lt;code&gt;true&lt;/code&gt;, exclusive row-level locks are obtained on all the rows identified by the select statement (e.g. by appending ' FOR UPDATE NOWAIT SKIP LOCKED' to the end of the query) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWait" type="frankInt">
      <xs:annotation>
        <xs:documentation>when set and &gt;=0, ' FOR UPDATE WAIT #' is used instead of ' FOR UPDATE NOWAIT SKIP LOCKED' Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="avoidLocking" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, then select queries are executed in a way that avoids taking locks, e.g. with isolation mode 'read committed' instead of 'repeatable read'. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Controls automatically whether blobdata is stored compressed and/or serialized in the database Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is stored compressed in the database Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JdbcIteratingPipeBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="JdbcIteratingPipeBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="StringIteratorPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="StringIteratorPipeDeclaredAttributeGroup">
    <xs:attribute name="blockSize" type="frankInt">
      <xs:annotation>
        <xs:documentation>Controls multiline behaviour. If set to a value greater than 0, it specifies the number of rows send in a block to the sender. Default: 0 (one line at a time, no prefix of suffix)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startPosition" type="frankInt">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;startPosition &amp;gt;= 0&lt;/code&gt;, this field contains the start position of the key in the current record (first character is 0);
 A sequence of lines with the same key is put in one block and send to the sender. Cannot be used in combination with blockSize. Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="endPosition" type="frankInt">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;endPosition &amp;gt;= startPosition&lt;/code&gt;, this field contains the end position of the key in the current record Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="combineBlocks" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, all items in a block are sent at once. If set false, items are sent individually, potentially leveraging block enabled sending capabilities of the sender Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockPrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;combineBlocks = true&lt;/code&gt;, this string is inserted at the start of each block. Requires &lt;code&gt;blockSize&lt;/code&gt; or &lt;code&gt;startPosition&lt;/code&gt; and &lt;code&gt;endPosition&lt;/code&gt; to be set too. Default: &amp;lt;block&amp;gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;combineBlocks = true&lt;/code&gt;, this string is inserted at the end of the set of lines. Requires &lt;code&gt;blockSize&lt;/code&gt; or &lt;code&gt;startPosition&lt;/code&gt; and &lt;code&gt;endPosition&lt;/code&gt; to be set too. Default: &amp;lt;/block&amp;gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linePrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>This string is inserted at the start of each item</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>This string is appended at the end of each item</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="escapeXml" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Escape XML characters in each item Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="StringIteratorPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="StringIteratorPipeDeclaredAttributeGroup" />
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Stylesheet to apply to each message, before sending it</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alternatively: xpath-expression to create stylesheet from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions. For some use other cases (NOT xpathExpression), one entry can be without a prefix, that will define the default namespace.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType">
      <xs:annotation>
        <xs:documentation>Only valid for xpathexpression Default: text</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="OutputTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Force the transformer generated from the xpath-expression to omit the xml declaration Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="itemNoSessionKey" />
    <xs:attribute ref="maxItems" />
    <xs:attribute ref="stopConditionXPathExpression" />
    <xs:attribute ref="ignoreExceptions" />
    <xs:attribute ref="collectResults" />
    <xs:attribute ref="removeXmlDeclarationInResults" />
    <xs:attribute ref="addInputToResult" />
    <xs:attribute ref="removeDuplicates" />
    <xs:attribute ref="parallel" />
    <xs:attribute ref="maxChildThreads" />
    <xs:attributeGroup ref="MessageSendingPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="BytesOutputPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.BytesOutputPipe" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="ChecksumPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="ChecksumPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.ChecksumPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ChecksumPipeDeclaredAttributeGroup">
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Character encoding to be used to encode message before calculating checksum.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type">
      <xs:annotation>
        <xs:documentation>Type of checksum to be calculated Default: MD5</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="ChecksumTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ChecksumPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ChecksumPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ClobLineIteratingPipeType">
    <xs:group ref="IteratingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="JdbcIteratingPipeBaseCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jdbc.ClobLineIteratingPipe" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="CompareIntegerPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="AbstractPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.CompareIntegerPipe" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="CompareStringPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="CompareStringPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.CompareStringPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="CompareStringPipeDeclaredAttributeGroup">
    <xs:attribute name="xml" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; the string values to compare are considered to be xml strings and before the actual compare both xml strings are transformed to a canonical form Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CompareStringPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="CompareStringPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="CompressPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="CompressPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.CompressPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="CompressPipeDeclaredAttributeGroup">
    <xs:attribute name="compress" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>if &lt;code&gt;true&lt;/code&gt; the pipe compresses, otherwise it decompress Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageIsContent" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>flag indicates whether the message is the content or the path to a file with the contents. for multiple files use ';' as delimiter Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultIsContent" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>flag indicates whether the result must be written to the message or to a file (filename = message) Default: true when outputDirectory is not set.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileFormat">
      <xs:simpleType>
        <xs:union memberTypes="FileFormatAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CompressPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="CompressPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="CounterSwitchPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="CounterSwitchPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.CounterSwitchPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="CounterSwitchPipeDeclaredAttributeGroup">
    <xs:attribute name="divisor" type="frankInt">
      <xs:annotation>
        <xs:documentation>Default: 2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CounterSwitchPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="CounterSwitchPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="CredentialCheckingPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="CredentialCheckingPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.CredentialCheckingPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="CredentialCheckingPipeDeclaredAttributeGroup">
    <xs:attribute name="authAlias" type="xs:string" />
    <xs:attribute name="targetPassword" type="xs:string" />
    <xs:attribute name="targetUserid" type="xs:string" />
    <xs:attribute name="defaultPassword" type="xs:string" />
    <xs:attribute name="defaultUserid" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="CredentialCheckingPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="CredentialCheckingPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="CrlPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="CrlPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.CrlPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="CrlPipeDeclaredAttributeGroup">
    <xs:attribute name="issuerSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the sessionKey that holds the certificate of the issuer who signed the CRL.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CrlPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="CrlPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="CsvParserPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="CsvParserPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.CsvParserPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="CsvParserPipeDeclaredAttributeGroup">
    <xs:attribute name="fileContainsHeader" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Specifies if the first line should be treated as header or as data Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fieldNames" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of header names. If set, then &lt;code&gt;fileContainsHeader&lt;/code&gt; defaults to false. If not set, headers are taken from the first line</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fieldSeparator" type="xs:string">
      <xs:annotation>
        <xs:documentation>Character that separates fields Default: ,</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="headerCase">
      <xs:annotation>
        <xs:documentation>When set, character casing will be changed for the header</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="HeaderCaseAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="prettyPrint" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Format the XML output in easy legible way</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useControlCodes" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Enables the ASCII {@code (RS) Record Separator} and {@code (US) Unit Separator} Control Code field delimiters.
 May not be used in combination with attribute {@code fieldSeparator}.
 See &lt;a href="https://en.wikipedia.org/wiki/C0_and_C1_control_codes#Field_separators"&gt;WIKI Control Codes&lt;/a&gt;.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CsvParserPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="CsvParserPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="DelayPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="DelayPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.DelayPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="DelayPipeDeclaredAttributeGroup">
    <xs:attribute name="delayTime" type="frankInt">
      <xs:annotation>
        <xs:documentation>The time &lt;i&gt;in milliseconds&lt;/i&gt; the thread will be put to sleep Default: 5000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="DelayPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="DelayPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="DirectWrapperPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="TimeoutGuardPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.esb.DirectWrapperPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="TimeoutGuardPipeDeclaredAttributeGroup">
    <xs:attribute name="throwException" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a piperunexception is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>timeout in seconds of obtaining a result Default: 30</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="TimeoutGuardPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="TimeoutGuardPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="DomainTransformerPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="DomainTransformerPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.DomainTransformerPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="DomainTransformerPipeDeclaredAttributeGroup">
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="tableName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the table that contains the mapping Default: mapping</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column labels are stored in Default: label</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueInField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column source values are stored in Default: valuein</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueOutField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column destination values are stored in Default: valueout</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="DomainTransformerPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="DomainTransformerPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="EchoPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.EchoPipe" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="EscapePipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="EscapePipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.EscapePipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="EscapePipeDeclaredAttributeGroup">
    <xs:attribute name="substringStart" type="xs:string">
      <xs:annotation>
        <xs:documentation>substring to start translation</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="substringEnd" type="xs:string">
      <xs:annotation>
        <xs:documentation>substring to end translation</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction">
      <xs:simpleType>
        <xs:union memberTypes="DirectionAttributeValuesType_7 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="encodeSubstring" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; special characters in &lt;code&gt;substringstart&lt;/code&gt; and &lt;code&gt;substringend&lt;/code&gt; are first translated to their xml equivalents Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="EscapePipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="EscapePipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ExceptionPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="ExceptionPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.ExceptionPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ExceptionPipeDeclaredAttributeGroup">
    <xs:attribute name="throwException" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>When &lt;code&gt;true&lt;/code&gt;, a PipeRunException is thrown. Otherwise, the output is only logged as an error (and no rollback is performed). Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ExceptionPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ExceptionPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="FixedResultPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedResultPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.FixedResultPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="FixedResultPipeDeclaredAttributeGroup">
    <xs:attribute name="filename" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the file containing the result message.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FixedResultPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="FixedResultPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ForEachAttachmentPipeType">
    <xs:group ref="IteratingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="ForEachAttachmentPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.filesystem.ForEachAttachmentPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ForEachAttachmentPipeDeclaredAttributeGroup">
    <xs:attribute name="onlyProperties" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of attachment properties to list</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="excludeProperties" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of attachment properties not to list. When specified, 'onlyProperties' is ignored</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ForEachAttachmentPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ForEachAttachmentPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="IteratingPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ForEachChildElementPipeType">
    <xs:group ref="IteratingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="ForEachChildElementPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.ForEachChildElementPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ForEachChildElementPipeDeclaredAttributeGroup">
    <xs:attribute name="containerElement" type="xs:string">
      <xs:annotation>
        <xs:documentation>Element name (not an XPath-expression), qualified via attribute &lt;code&gt;namespaceDefs&lt;/code&gt;, used to determine the 'root' of elements to be iterated over, i.e. the root of the set of child elements.
 When empty, the pipe will iterate over each direct child element of the root</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetElement" type="xs:string">
      <xs:annotation>
        <xs:documentation>Element name (not an XPath-expression), qualified via attribute &lt;code&gt;namespaceDefs&lt;/code&gt;, used to determine the type of elements to be iterated over, i.e. the element name of each of the child elements.
 When empty, the pipe will iterate over any direct child element of the root or specified containerElement</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementXPathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>XPath-expression used to determine the set of elements to be iterated over, i.e. the set of child elements. When empty, the effective value is \/*\/*, i.e. the pipe will iterate over each direct child element of the root.
 Be aware that memory consumption appears to increase with file size when this attribute is used. When possible, use containerElement and/or targetElement instead.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xsltVersion" type="frankInt">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt; a Saxon (net.sf.saxon) XSLT processor 2.0 or 3.0 will be used, supporting XPath 2.0 or 3.0 respectively, otherwise an XSLT processor 1.0 (org.apache.xalan), supporting XPath 1.0. N.B. Be aware that setting this other than 1 might cause the input file being read as a whole in to memory, as XSLT Streaming is currently only supported by the XSLT Processor that is used for xsltVersion=1 Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNamespaces" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) are removed from the items just before forwarding them to the sender. N.B. This takes place &lt;strong&gt;after&lt;/strong&gt; the transformation for &lt;code&gt;elementXPathExpression&lt;/code&gt; if that is specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ForEachChildElementPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ForEachChildElementPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="StringIteratorPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="GetFromSessionType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="GetFromSessionCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.GetFromSession" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="GetFromSessionDeclaredAttributeGroup">
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of the session variable to retrieve the output message from. When left unspecified, the input message is used as the key of the session variable</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type">
      <xs:annotation>
        <xs:documentation>&lt;ul&gt;&lt;li&gt;&lt;code&gt;string&lt;/code&gt;: renders the contents&lt;/li&gt;&lt;li&gt;&lt;code&gt;map&lt;/code&gt;: converts a Map&amp;lt;String, String&amp;gt; object to a xml-string (&amp;lt;items&amp;gt;&amp;lt;item name='...'&amp;gt;...&amp;lt;/item&amp;gt;&amp;lt;item name='...'&amp;gt;...&amp;lt;/item&amp;gt;&amp;lt;/items&amp;gt;)&lt;/li&gt;&lt;/ul&gt; Default: string</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="ParameterTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="GetFromSessionCumulativeAttributeGroup">
    <xs:attributeGroup ref="GetFromSessionDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="GetPrincipalPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="GetPrincipalPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.GetPrincipalPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="GetPrincipalPipeDeclaredAttributeGroup">
    <xs:attribute name="notFoundForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of forward returned if principal has not been found</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="GetPrincipalPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="GetPrincipalPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="GetTibcoQueuesType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="GetTibcoQueuesCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.tibco.GetTibcoQueues" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="GetTibcoQueuesDeclaredAttributeGroup">
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>URL or base of URL to be used. When multiple URLs are defined (comma separated list), the first URL is used of which the server has an active state</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>username used in authentication to host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>password used in authentication to host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipTemporaryQueues" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, temporary queues are skipped Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMessage" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the length of the queue message is returned instead of the queue message self (when parameter &lt;code&gt;queueName&lt;/code&gt; is not empty) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueRegex" type="xs:string" />
    <xs:attribute name="emsPropertiesFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>Location to a &lt;code&gt;jndi.properties&lt;/code&gt; file for additional EMS (SSL) properties</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="GetTibcoQueuesCumulativeAttributeGroup">
    <xs:attributeGroup ref="GetTibcoQueuesDeclaredAttributeGroup" />
    <xs:attributeGroup ref="TimeoutGuardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="HashPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="HashPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.HashPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="HashPipeDeclaredAttributeGroup">
    <xs:attribute name="algorithm">
      <xs:annotation>
        <xs:documentation>Hash Algorithm to use Default: HmacSHA256</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="HashAlgorithmAttributeValuesType_2 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Character set to use for converting the secret from String to bytes Default: UTF-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hashEncoding">
      <xs:annotation>
        <xs:documentation>Method to use for converting the hash from bytes to String Default: Base64</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="HashEncodingAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="secret" type="xs:string">
      <xs:annotation>
        <xs:documentation>The secret to hash with. Only used if no parameter secret is configured. The secret is only used when there is no authAlias specified, by attribute or parameter</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authAlias to retrieve the secret from (password field). Only used if no parameter authAlias is configured</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="HashPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="HashPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="IncreaseIntegerPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="IncreaseIntegerPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.IncreaseIntegerPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="IncreaseIntegerPipeDeclaredAttributeGroup">
    <xs:attribute name="sessionKey" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Reference to the session variable whose value is to be increased</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="increment" type="frankInt">
      <xs:annotation>
        <xs:documentation>amount to increment the value. Can be set from the attribute or the parameter 'increment' Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="IncreaseIntegerPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="IncreaseIntegerPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="IsUserInRolePipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="IsUserInRolePipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.IsUserInRolePipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="IsUserInRolePipeDeclaredAttributeGroup">
    <xs:attribute name="role" type="xs:string">
      <xs:annotation>
        <xs:documentation>the j2ee role(s) to check, if the user in multiple roles, the first specified role will be matched.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="IsUserInRolePipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="IsUserInRolePipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="IsXmlPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="IsXmlPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.IsXmlPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="IsXmlPipeDeclaredAttributeGroup">
    <xs:attribute name="thenForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when &lt;code&gt;true&lt;/code&gt; Default: then</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elseForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when 'false' Default: else</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elseForwardOnEmptyInput" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>return elseforward when input is empty (or thenforward) Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="IsXmlPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="IsXmlPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JsonPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="JsonPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.JsonPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="JsonPipeDeclaredAttributeGroup">
    <xs:attribute name="direction">
      <xs:annotation>
        <xs:documentation>Direction of the transformation. Default: JSON2XML</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="DirectionAttributeValuesType_8 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="addXmlRootElement" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>When direction is JSON2XML, it wraps a root element around the converted message.
 When direction is XML2JSON, it includes the name of the root element as a key in the converted message. Default: TRUE when JSON2XML and FALSE when XML2JSON</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prettyPrint" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Format the output in easy legible way (currently only for XML)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JsonPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="JsonPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JsonWellFormedCheckerType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.JsonWellFormedChecker" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="JsonXsltPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="JsonXsltPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.JsonXsltPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="JsonXsltPipeDeclaredAttributeGroup">
    <xs:attribute name="jsonResult" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>When &lt;code&gt;true&lt;/code&gt;, the xml result of the transformation is converted back to json Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace definitions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt; definitions Default: j=http://www.w3.org/2013/XSL/json</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JsonXsltPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="JsonXsltPipeDeclaredAttributeGroup" />
    <xs:attribute name="streamingXslt" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, then this pipe will process the XSLT while streaming in a different thread. Can be used to switch streaming xslt off for debugging purposes Default: set by appconstant xslt.streaming.default</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Location of stylesheet to apply to the input message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key to retrieve stylesheet location. Overrides stylesheetName or xpathExpression attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetCacheSize" type="frankInt">
      <xs:annotation>
        <xs:documentation>Size of cache of stylesheets retrieved from styleSheetNameSessionKey Default: 100</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alternatively: XPath-expression to create stylesheet from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Omit the XML declaration on top of the output. If not set, the value specified in the stylesheet is followed Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="disableOutputEscaping" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, any output is reparsed before being handled as XML again. If not set, the stylesheet is searched for &lt;code&gt;@disable-output-escaping='yes'&lt;/code&gt; and the value is set accordingly Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType">
      <xs:annotation>
        <xs:documentation>For xpathExpression only Default: text</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="OutputTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="indentXml" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, result is pretty-printed. If not set, the value specified in the stylesheet is followed Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNamespaces" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed before transformation Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="handleLexicalEvents" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the transformer is enabled to handle lexical events, allowing it for example to process comments and to distinghuish CDATA from escaped text.
 Beware that this option can cause spurious NullPointerExceptions due to a race condition in streaming XSLT 1.0 processing in Xalan 2.7.2 Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipEmptyTags" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; empty tags in the output are removed after transformation Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xsltVersion" type="frankInt">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt; a Saxon (net.sf.saxon) xslt processor 2.0 or 3.0 respectively will be used, otherwise xslt processor 1.0 (org.apache.xalan). &lt;code&gt;0&lt;/code&gt; will auto-detect Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XsltPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="XsltPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.XsltPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="XsltPipeDeclaredAttributeGroup">
    <xs:attribute name="streamingXslt" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, then this pipe will process the XSLT while streaming in a different thread. Can be used to switch streaming xslt off for debugging purposes Default: set by appconstant xslt.streaming.default</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Location of stylesheet to apply to the input message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key to retrieve stylesheet location. Overrides stylesheetName or xpathExpression attribute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetCacheSize" type="frankInt">
      <xs:annotation>
        <xs:documentation>Size of cache of stylesheets retrieved from styleSheetNameSessionKey Default: 100</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alternatively: XPath-expression to create stylesheet from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Omit the XML declaration on top of the output. If not set, the value specified in the stylesheet is followed Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="disableOutputEscaping" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, any output is reparsed before being handled as XML again. If not set, the stylesheet is searched for &lt;code&gt;@disable-output-escaping='yes'&lt;/code&gt; and the value is set accordingly Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions. For some other use cases (NOT xpathExpression), one entry can be without a prefix, that will define the default namespace.
 If left empty, an the xpathExpression will match any namespace</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType">
      <xs:annotation>
        <xs:documentation>For xpathExpression only Default: text</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="OutputTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="indentXml" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, result is pretty-printed. If not set, the value specified in the stylesheet is followed Default: false, if not set in stylesheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNamespaces" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed before transformation Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="handleLexicalEvents" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the transformer is enabled to handle lexical events, allowing it for example to process comments and to distinghuish CDATA from escaped text.
 Beware that this option can cause spurious NullPointerExceptions due to a race condition in streaming XSLT 1.0 processing in Xalan 2.7.2 Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipEmptyTags" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; empty tags in the output are removed after transformation Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xsltVersion" type="frankInt">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt; a Saxon (net.sf.saxon) xslt processor 2.0 or 3.0 respectively will be used, otherwise xslt processor 1.0 (org.apache.xalan). &lt;code&gt;0&lt;/code&gt; will auto-detect Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XsltPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="XsltPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="JwtPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="JwtPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.JwtPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="JwtPipeDeclaredAttributeGroup">
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Auth Alias for the SharedSecret to be used when signing the JWT (using the HmacSHA256 algorithm)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sharedSecret" type="xs:string">
      <xs:annotation>
        <xs:documentation>Shared secret to be used when signing the JWT (using the HmacSHA256 algorithm)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expirationTime" type="frankInt">
      <xs:annotation>
        <xs:documentation>JWT expirationTime in seconds, 0 to disable Default: 600</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JwtPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="JwtPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LabelFormatType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="LabelFormatCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.rekenbox.LabelFormat" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="LabelFormatDeclaredAttributeGroup">
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets transformation direction. Possible values
 &lt;ul&gt;
   &lt;li&gt;"Xml2Label": transform an XML file to ascii&lt;/li&gt;
   &lt;li&gt;"Label2Xml": transform an ascii file to XML&lt;/li&gt;
 &lt;/ul&gt;
 default: None</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LabelFormatCumulativeAttributeGroup">
    <xs:attributeGroup ref="LabelFormatDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LadybugPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="LadybugPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.ibistesttool.LadybugPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="LadybugPipeDeclaredAttributeGroup">
    <xs:attribute name="writeToLog" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>whether or not to write results to the logfile (testtool4&amp;lt;instance.name&amp;gt;) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSystemOut" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>whether or not to write results to system out Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkRoles" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Set to &lt;code&gt;true&lt;/code&gt; when the pipeline is triggered by a user (e.g. using an http based listener
 that will add a securityHandler session key) and you don't want the listener to check whether the user
 is autorised and/or you want the enforce the roles as configured for the Ladybug Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="enableReportGenerator" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Set to &lt;code&gt;true&lt;/code&gt; to enable Ladybug's report generator for the duration of the scheduled report runs
 then revert it to its original setting Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exclude" type="xs:string">
      <xs:annotation>
        <xs:documentation>When set, reports with a full path (path + name) that matches with the specified regular expression are skipped. For example, \"/Unscheduled/.*\" or \".*SKIP\".</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LadybugPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="LadybugPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LarvaPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="LarvaPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.LarvaPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="LarvaPipeDeclaredAttributeGroup">
    <xs:attribute name="writeToLog" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSystemOut" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="execute" type="xs:string">
      <xs:annotation>
        <xs:documentation>The scenario sub directory to execute</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logLevel">
      <xs:annotation>
        <xs:documentation>the larva log level: one of [debug], [pipeline messages prepared for diff], [pipeline messages], [wrong pipeline messages prepared for diff], [wrong pipeline messages], [step passed/failed], [scenario passed/failed], [scenario failed], [totals], [error] Default: wrong pipeline messages</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="LarvaLogLevelAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="waitBeforeCleanup" type="xs:string">
      <xs:annotation>
        <xs:documentation>Default: 100ms</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>the larva timeout in milliseconds Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LarvaPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="LarvaPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LdapFindGroupMembershipsPipeType">
    <xs:group ref="LdapFindGroupMembershipsPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="LdapFindGroupMembershipsPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.ldap.LdapFindGroupMembershipsPipe" use="prohibited" />
  </xs:complexType>
  <xs:group name="LdapFindGroupMembershipsPipeDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="CacheElementGroup" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:group name="LdapFindGroupMembershipsPipeCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="LdapFindGroupMembershipsPipeDeclaredChildGroup" />
      <xs:group ref="AbstractPipeDeclaredChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="LdapFindGroupMembershipsPipeDeclaredAttributeGroup">
    <xs:attribute name="recursiveSearch" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the memberOf attribute is also searched in all the found members Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LdapFindGroupMembershipsPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="LdapFindGroupMembershipsPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="LdapQueryPipeBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="LdapQueryPipeBaseDeclaredAttributeGroup">
    <xs:attribute name="ldapProviderURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>Url to context to search in, e.g. 'ldaps://DOMAIN.EXT'.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="host" type="xs:string">
      <xs:annotation>
        <xs:documentation>Host part of ldapProviderUrl. Only used when ldapProviderUrl not specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="frankInt">
      <xs:annotation>
        <xs:documentation>Port of ldapProviderUrl. Only used when ldapProviderUrl not specified</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useSsl" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Indication to use ldap or ldaps in ldapProviderUrl. Only used when ldapProviderUrl not specified Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="baseDN" type="xs:string">
      <xs:annotation>
        <xs:documentation>BaseDN, e.g. CN=USERS,DC=DOMAIN,DC=EXT Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain credentials to connect to ldap server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Username used to obtain credentials to connect to ldap server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password used to obtain credentials to connect to ldap server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="notFoundForwardName" type="xs:string" />
    <xs:attribute name="exceptionForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>PipeForward used when an exception is caught</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LdapQueryPipeBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="LdapQueryPipeBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LdapFindMemberPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="LdapFindMemberPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.ldap.LdapFindMemberPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="LdapFindMemberPipeDeclaredAttributeGroup">
    <xs:attribute name="dnSearchIn" type="xs:string">
      <xs:annotation>
        <xs:documentation>The dn of the group to search in when the parameter dnSearchIn is not set</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dnFind" type="xs:string">
      <xs:annotation>
        <xs:documentation>The dn of the member to search for when the parameter dnFind is not set</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="recursiveSearch" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the member attribute is also searched in all the found members Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LdapFindMemberPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="LdapFindMemberPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="LdapQueryPipeBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LocalFileSystemPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="LocalFileSystemPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.LocalFileSystemPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="LocalFileSystemPipeDeclaredAttributeGroup">
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>Path to the folder that serves as the root of this virtual filesystem. All specifications of folders or files are relative to this root.
 When the root is left unspecified, absolute paths to files and folders can be used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createRootFolder" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Whether the LocalFileSystem tries to create the root folder if it doesn't exist yet. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LocalFileSystemPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="LocalFileSystemPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="FileSystemPipeDeclaredAttributeGroup">
    <xs:attribute name="action">
      <xs:annotation>
        <xs:documentation>If parameter [action] is set, then the attribute action value will be overridden with the value of the parameter.</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="FileSystemActionAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="filename" type="xs:string">
      <xs:annotation>
        <xs:documentation>Filename to operate on. If not set, the parameter filename is used. If that is not set either, the input is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destination" type="xs:string">
      <xs:annotation>
        <xs:documentation>Destination for move, copy or rename. If not set, the parameter destination is used. If that is not set either, the input is used</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputFolder" type="xs:string">
      <xs:annotation>
        <xs:documentation>Folder that is scanned for files when action=list. When not set, the root is scanned</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createFolder" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;: if a non-existing folder is part of the fileName, it will be created. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="overwrite" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, for actions create, write, move, copy or rename, the destination file is overwritten if it already exists Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rotateDays" type="frankInt">
      <xs:annotation>
        <xs:documentation>For action=append: If set to a positive number, the file is rotated each day, and this number of files is kept. The inputFolder must point to the directory where the file resides Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rotateSize" type="frankInt">
      <xs:annotation>
        <xs:documentation>For action=append: If set to a positive number, the file is rotated when it has reached the specified size, and the number of files specified in numberOfBackups is kept. Size is specified in plain bytes, suffixes like 'K', 'M' or 'G' are not recognized. The inputFolder must point to the directory where the file resides Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numberOfBackups" type="frankInt">
      <xs:annotation>
        <xs:documentation>For the actions write and append, with rotateSize&gt;0: the number of backup files that is kept. The inputFolder must point to the directory where the file resides Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wildcard" type="xs:string">
      <xs:annotation>
        <xs:documentation>Filter of files to look for in inputFolder e.g. '*.inp'. Works with actions move, copy, delete and list</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="excludeWildcard" type="xs:string">
      <xs:annotation>
        <xs:documentation>Filter of files to be excluded when looking in inputFolder. Works with actions move, copy, delete and list</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNonEmptyFolder" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt; then the folder and the content of the non empty folder will be deleted.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeLineSeparator" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt; then the system specific line separator will be appended to the file after executing the action. Works with actions write and append Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Charset to be used for read and write action</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deleteEmptyFolder" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to true then the folder will be deleted if it is empty after processing the action. Works with actions delete, readDelete and move</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat">
      <xs:annotation>
        <xs:documentation>OutputFormat Default: XML</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="DocumentFormatAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="typeFilter">
      <xs:annotation>
        <xs:documentation>Filter for action &lt;code&gt;list&lt;/code&gt;. Specify &lt;code&gt;FILES_ONLY&lt;/code&gt;, &lt;code&gt;FOLDERS_ONLY&lt;/code&gt; or &lt;code&gt;FILES_AND_FOLDERS&lt;/code&gt;. Default: FILES_ONLY</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="TypeFilterAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="FileSystemPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="FileSystemPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LogContextPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="LogContextPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.LogContextPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="LogContextPipeDeclaredAttributeGroup">
    <xs:attribute name="export" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt; the ThreadContext parameters will be exported from the current PipeLine up in the call tree. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="continueOnError" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set {@code true} the pipe will never forward to the {@code ExceptionForward} even if an error occurred during execution. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="LogContextPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="LogContextPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="MailSenderPipeType">
    <xs:group ref="MessageSendingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="MessageSendingPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.MailSenderPipe" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="ObfuscatePipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="ObfuscatePipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.tibco.pipes.ObfuscatePipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ObfuscatePipeDeclaredAttributeGroup">
    <xs:attribute name="direction">
      <xs:annotation>
        <xs:documentation>Default: OBFUSCATE</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="DirectionAttributeValuesType_6 variableRef" />
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ObfuscatePipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ObfuscatePipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="PGPPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="PGPPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.PGPPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="PGPPipeDeclaredAttributeGroup">
    <xs:attribute name="action">
      <xs:annotation>
        <xs:documentation>Action to be taken when pipe is executed.</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="ActionAttributeValuesType_4 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="recipients" type="xs:string">
      <xs:annotation>
        <xs:documentation>Recipients to be used during encryption stage. If multiple, separate with ';' (semicolon)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verificationAddresses" type="xs:string">
      <xs:annotation>
        <xs:documentation>Emails of the senders. This will be used to verify that all the senders have signed the given message.
 If not set, and the action is verify; this pipe will validate that at least one person has signed.
 For signing action, it needs to be set to the email that was used to generate the private key
 "that is being used for this process.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secretKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Path to the private key. It will be used when signing or decrypting.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secretPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password for the private key.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="publicKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>Path to the recipient's public key. It will be used for encryption and verification.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="PGPPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="PGPPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="PasswordGeneratorPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="PasswordGeneratorPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.PasswordGeneratorPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="PasswordGeneratorPipeDeclaredAttributeGroup">
    <xs:attribute name="lCharacters" type="xs:string">
      <xs:annotation>
        <xs:documentation>The lowercase characters to use. Default: ('a'..'z')</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="uCharacters" type="xs:string">
      <xs:annotation>
        <xs:documentation>The uppercase characters to use. Default: ('A'..'Z')</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numbers" type="xs:string">
      <xs:annotation>
        <xs:documentation>The numbers to use. Default: ('0'..'9')</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="signs" type="xs:string">
      <xs:annotation>
        <xs:documentation>The signs to use. Default: (;:_%$#@!&amp;gt;&amp;lt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numOfLCharacters" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of lowercase characters in the generated password. Default: 2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numOfDigits" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of digits in the generated password. Default: 2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numOfSigns" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of sign characters in the generated password. Default: 2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numOfUCharacters" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of uppercase characters in the generated password. Default: 2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="PasswordGeneratorPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="PasswordGeneratorPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="PasswordHashPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="PasswordHashPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.PasswordHashPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="PasswordHashPipeDeclaredAttributeGroup">
    <xs:attribute name="hashSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of sessionkey that holds the hash which will be used to validate the password (input of the pipe)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rounds" type="frankInt" />
    <xs:attribute name="roundsSessionKey" type="xs:string" />
  </xs:attributeGroup>
  <xs:attributeGroup name="PasswordHashPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="PasswordHashPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="PdfPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="PdfPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.aspose.pipe.PdfPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="PdfPipeDeclaredAttributeGroup">
    <xs:attribute name="action">
      <xs:simpleType>
        <xs:union memberTypes="DocumentActionAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="mainDocumentSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key that contains the document that the attachments will be attached to. Only used when action is set to 'combine' Default: defaultMainDocumentSessionKey</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="conversionResultDocumentSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>The session key used to store the main conversion result document. Only to be used when action is set to 'convert'. Default: documents</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="conversionResultFilesSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>The session-key in which result files are stored when documents are converted to PDF.

 &lt;p&gt;
 Conversion result files are stored as messages in the session, under keys numbered based
 on the value set here. If #isSaveSeparate() is {@code false} then only the main
 document is stored in the session, if it is {@code true} then each attachment is stored
 separately.
 &lt;/p&gt;
 &lt;p&gt;
     For example, if a file is converted that has 2 attachments and #setSaveSeparate(boolean)
     is set to {@code true} then there will be the following 3 session keys (assuming the default value
     is unchanged):
     &lt;ol&gt;
         &lt;li&gt;{@code pdfConversionResultFiles1}&lt;/li&gt;
         &lt;li&gt;{@code pdfConversionResultFiles2}&lt;/li&gt;
         &lt;li&gt;{@code pdfConversionResultFiles3}&lt;/li&gt;
     &lt;/ol&gt;
     Each session key will contain a FileMessage referencing the contents of that PDF.
 &lt;/p&gt; Default: pdfConversionResultFiles</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filenameToAttachSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key that contains the filename to be attached. Only used when the action is set to 'combine' Default: defaultFileNameToAttachSessionKey</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fontsDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>fonts folder to load the fonts. If not set then a temporary folder will be created to extract fonts from fonts.zip everytime. Having fontsDirectory to be set will improve startup time</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="unpackCommonFontsArchive" type="frankBoolean" />
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset to be used to decode the given input message in case the input is not binary but character stream Default: UTF-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="license" type="xs:string">
      <xs:annotation>
        <xs:documentation>aspose license location including the file name. It can also be used without license but there some restrictions on usage. If license is in resource, license attribute can be license file name. If the license is in somewhere in filesystem then it should be full path to file including filename and starting with file://// prefix. classloader.allowed.protocols property should contain 'file' protocol</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="saveSeparate" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when sets to false, converts the file including the attachments attached to the main file. when it is true, saves each attachment separately Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pdfOutputLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>directory to save resulting pdf files after conversion. If not set then a temporary directory will be created and the conversion results will be stored in that directory.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="loadExternalResources" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when set to true, external resources, such as stylesheets and images found in HTML pages, will be loaded from the internet Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="PdfPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="PdfPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="PutInSessionType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="PutInSessionCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.PutInSession" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="PutInSessionDeclaredAttributeGroup">
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of the session variable to store the input in</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation>Value to store in the &lt;code&gt;pipeLineSession&lt;/code&gt;. If not set, the input of the pipe is stored</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="PutInSessionCumulativeAttributeGroup">
    <xs:attributeGroup ref="PutInSessionDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="PutSystemDateInSessionType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="PutSystemDateInSessionCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.PutSystemDateInSession" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="PutSystemDateInSessionDeclaredAttributeGroup">
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key of session variable to store systemdate in Default: systemDate</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dateFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>Format to store date in Default: full ISO format: DateUtils.fullIsoFormat</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeZone" type="xs:string">
      <xs:annotation>
        <xs:documentation>Time zone to use for the formatter Default: the default time zone for the JVM</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sleepWhenEqualToPrevious" type="frankInt">
      <xs:annotation>
        <xs:documentation>Set to a time &lt;i&gt;in milliseconds&lt;/i&gt; to create a value that is different to the previous returned value by a PutSystemDateInSession pipe in
 this virtual machine or &lt;code&gt;-1&lt;/code&gt; to disable. The thread will sleep for the specified time before recalculating a new value. Set the
 timezone to a value without Daylight Saving Time (like GMT+1) to prevent this pipe to generate two equal value's when the clock is set back.
 &lt;b&gt;note:&lt;/b&gt; When you're looking for a GUID parameter for your XSLT it might be better to use
 &amp;lt;param name=&amp;quot;guid&amp;quot; pattern=&amp;quot;{hostname}_{uid}&amp;quot;/&amp;gt;, see Parameter. Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="returnFixedDate" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the date/time returned will always be 2001-12-17 09:30:47 (for testing purposes only). It is overridden by the value of the pipelinesession key &lt;code&gt;stub4testtool.fixeddate&lt;/code&gt; when it exists Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getCurrentTimeStampInMillis" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to 'true' then current time stamp in millisecond will be stored in the sessionKey Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="PutSystemDateInSessionCumulativeAttributeGroup">
    <xs:attributeGroup ref="PutSystemDateInSessionDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="RekenBoxCallerType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="RekenBoxCallerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.rekenbox.RekenBoxCaller" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="RekenBoxCallerDeclaredAttributeGroup">
    <xs:attribute name="rekenBoxName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Fixed name of the rekenbox (or wrapper) to be called. If empty, the name is determined from the request</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="runPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>Directory on server where rekenbox-executable can be found</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="templateDir" type="xs:string">
      <xs:annotation>
        <xs:documentation>Rekenbox template directory on server</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputOutputDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>Directory on server where input and output files are (temporarily) stored</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commandLineType" type="xs:string">
      <xs:annotation>
        <xs:documentation>Format of commandline of rekenbox. Possible values
 "straight": rekenbox is called like: rekenbox.exe inputFileName outputFileName templateDir
 "switches": rekenbox is called like: rekenbox.exe /IinputFileName /UoutputFileName /PtemplateDir
 "redirected": rekenbox is called like: rekenbox.exe inputFileName templateDir &gt; outputFileName; (This method has not been fully tested)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="executableExtension" type="xs:string">
      <xs:annotation>
        <xs:documentation>Extension of rekenbox-executable</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cleanup" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, input and output files are removed after the call to the rekenbox is finished</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rekenboxSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key in pipeLineSession to store rekenbox name in</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dataFilenamePrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>First part of filenames that communicate requests and replies to rekenbox</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRequestNumber" type="frankInt">
      <xs:annotation>
        <xs:documentation>Maximal number that will be concatenated to dataFilenamePrefix</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="RekenBoxCallerCumulativeAttributeGroup">
    <xs:attributeGroup ref="RekenBoxCallerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="RemoveCacheKeyPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="RemoveCacheKeyPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.cache.RemoveCacheKeyPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="RemoveCacheKeyPipeDeclaredAttributeGroup">
    <xs:attribute name="cacheName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the cache from which items are to be removed</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>XPath expression to extract cache key from request message</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyXPathOutputType">
      <xs:annotation>
        <xs:documentation>Output type of xpath expression to extract cache key from request message, must be 'xml' or 'text' Default: text</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="OutputTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="keyNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for keyXPath. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>Stylesheet to extract cache key from request message. Use in combination with cacheEmptyKeys to inhibit caching for certain groups of request messages</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyInputSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key to use as input for transformation of request message to key by keyXPath or keyStyleSheet</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="RemoveCacheKeyPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="RemoveCacheKeyPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="RemoveFromSessionType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="RemoveFromSessionCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.RemoveFromSession" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="RemoveFromSessionDeclaredAttributeGroup">
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the key of the entry in the &lt;code&gt;pipelinesession&lt;/code&gt; to remove. if this key is empty the input message is interpretted as key. for multiple keys use ',' as delimiter</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="RemoveFromSessionCumulativeAttributeGroup">
    <xs:attributeGroup ref="RemoveFromSessionDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ReplacerPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="ReplacerPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.ReplacerPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ReplacerPipeDeclaredAttributeGroup">
    <xs:attribute name="find" type="xs:string">
      <xs:annotation>
        <xs:documentation>Sets the string that is searched for. Newlines can be represented
 by the #setLineSeparatorSymbol(String).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replace" type="xs:string">
      <xs:annotation>
        <xs:documentation>Sets the string that will replace each of the occurrences of the find-string. Newlines can be represented
 * by the #setLineSeparatorSymbol(String).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineSeparatorSymbol" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets the string that will represent the line-separator in the #setFind(String) and #setReplace(String) strings.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceNonXmlChars" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Replace all characters that are non-printable according to the XML specification with
 the value specified in #setNonXmlReplacementCharacter(String).
 &lt;p&gt;
 &lt;b&gt;NB:&lt;/b&gt; This will only replace or remove characters considered non-printable. This
 will not check if a given character is valid in the particular way it is used. Thus it will
 not remove or replace, for instance, a single {@code '&amp;'} character.
 &lt;/p&gt;
 &lt;p&gt;
 See also:
 	&lt;ul&gt;
 	    &lt;li&gt;XmlEncodingUtils replaceNonValidXmlCharacters&lt;/li&gt;
 	    &lt;li&gt;&lt;a href="https://www.w3.org/TR/xml/#charsets"&gt;Character ranges specified in the XML Specification&lt;/a&gt;&lt;/li&gt;
 	&lt;/ul&gt;
 &lt;/p&gt; Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="nonXmlReplacementCharacter" type="xs:string">
      <xs:annotation>
        <xs:documentation>character that will replace each non-valid xml character (empty string is also possible) (use &amp;amp;#x00bf; for inverted question mark) Default: empty string</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowUnicodeSupplementaryCharacters" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Whether to allow Unicode supplementary characters (like a smiley) during replaceNonValidXmlCharacters Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="substituteVars" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Should properties (values between &lt;code&gt;${&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;) be resolved. Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ReplacerPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ReplacerPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ResultSetIteratingPipeType">
    <xs:group ref="IteratingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="JdbcIteratingPipeBaseCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.jdbc.ResultSetIteratingPipe" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="Samba1PipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="Samba1PipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.Samba1Pipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="Samba1PipeDeclaredAttributeGroup">
    <xs:attribute name="share" type="xs:string">
      <xs:annotation>
        <xs:documentation>The destination, aka smb://xxx/yyy share</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>The SMB share username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>The SMB share password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain credentials for the SMB share</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="domainName" type="xs:string">
      <xs:annotation>
        <xs:documentation>logon/authentication domain, in case the user account is bound to a domain such as Active Directory.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="force" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, intermediate directories are created also Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="listHiddenFiles" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>controls whether hidden files are seen or not Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Samba1PipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="Samba1PipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Samba2PipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="Samba2PipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.Samba2Pipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="Samba2PipeDeclaredAttributeGroup">
    <xs:attribute name="hostname" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Hostname of the SMB share.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="frankInt">
      <xs:annotation>
        <xs:documentation>Port to connect to. Default: 445</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authType">
      <xs:annotation>
        <xs:documentation>Type of the authentication either 'NTLM' or 'SPNEGO'.
 When setting SPNEGO, the host must use the FQDN, and must be registered on the KDC with a valid SPN. Default: SPNEGO</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="Samba2AuthTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for the smb share</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share username</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="domainName" type="xs:string">
      <xs:annotation>
        <xs:documentation>NTLM only: logon/authentication domain, in case the user account is bound to a domain such as Active Directory.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="share" type="xs:string">
      <xs:annotation>
        <xs:documentation>May not contain '\\' characters. The destination share, aka smb://xxx/yyy share.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="kdc" type="xs:string">
      <xs:annotation>
        <xs:documentation>SPNEGO only:
 Key Distribution Center, typically hosted on a domain controller.
 Stored in &lt;code&gt;java.security.krb5.kdc&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="realm" type="xs:string">
      <xs:annotation>
        <xs:documentation>SPNEGO only:
 Kerberos Realm, case sensitive. Typically upper case and the same as the domain name.
 An Active Directory domain acts as a Kerberos Realm.
 Stored in &lt;code&gt;java.security.krb5.realm&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Samba2PipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="Samba2PipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FileSystemPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SambaPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="Samba2PipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.SambaPipe" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="SapLUWManagerType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="SapLUWManagerCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.sap.jco3.SapLUWManager" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="SapLUWManagerDeclaredAttributeGroup">
    <xs:attribute name="sapSystemName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Name of the SapSystem used by this object</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="action" type="xs:string">
      <xs:annotation>
        <xs:documentation>One of: begin, commit, rollback, release</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="luwHandleSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key under which information is stored</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SapLUWManagerCumulativeAttributeGroup">
    <xs:attributeGroup ref="SapLUWManagerDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ScanTibcoSolutionPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="ScanTibcoSolutionPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.svn.ScanTibcoSolutionPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ScanTibcoSolutionPipeDeclaredAttributeGroup">
    <xs:attribute name="url" type="xs:string" />
    <xs:attribute name="level" type="frankInt" />
  </xs:attributeGroup>
  <xs:attributeGroup name="ScanTibcoSolutionPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ScanTibcoSolutionPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SendTibcoMessageType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="SendTibcoMessageCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.extensions.tibco.SendTibcoMessage" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="SendTibcoMessageDeclaredAttributeGroup">
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>URL or base of URL to be used. When multiple URLs are defined (comma separated list), the first URL is used of which the server has an active state</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>username used in authentication to host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>password used in authentication to host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueName" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the queue which is used for browsing one queue</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageProtocol">
      <xs:annotation>
        <xs:documentation>Protocol of Tibco service to be called</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="MessageProtocolAttributeValuesType_3 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="replyTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Maximum time in milliseconds to wait for a reply. 0 means no timeout. (Only for messageProtocol=RR) Default: 5000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapAction" type="xs:string">
      <xs:annotation>
        <xs:documentation>If empty then derived from queueName (if $messagingLayer='P2P' then '$applicationFunction' else '$operationName_$operationVersion)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emsPropertiesFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>Location to a &lt;code&gt;jndi.properties&lt;/code&gt; file for additional EMS (SSL) properties</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SendTibcoMessageCumulativeAttributeGroup">
    <xs:attributeGroup ref="SendTibcoMessageDeclaredAttributeGroup" />
    <xs:attributeGroup ref="TimeoutGuardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SenderPipeType">
    <xs:group ref="SenderPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="MessageSendingPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.SenderPipe" use="prohibited" />
  </xs:complexType>
  <xs:group name="SenderPipeDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="MessageLogElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="InputWrapperElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="InputValidatorElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="SenderElementGroup" minOccurs="1" maxOccurs="1" />
      <xs:group ref="ListenerElementGroup_2" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:group name="SenderPipeCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="SenderPipeDeclaredChildGroup" />
      <xs:group ref="OutputValidatorElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="OutputWrapperElementGroup" minOccurs="0" maxOccurs="1" />
      <xs:group ref="AbstractPipeDeclaredChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:complexType name="SignaturePipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="SignaturePipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.SignaturePipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="SignaturePipeDeclaredAttributeGroup">
    <xs:attribute name="action">
      <xs:annotation>
        <xs:documentation>Action to be taken when pipe is executed. Default: SIGN</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="ActionAttributeValuesType_5 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="algorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>The signing algorithm Default: ALGORITHM_DEFAULT</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="provider" type="xs:string">
      <xs:annotation>
        <xs:documentation>Cryptography provider</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="signatureBase64" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>if true, the signature is (expected to be) base64 encoded Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystore" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Keystore to obtain signing key</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType">
      <xs:annotation>
        <xs:documentation>Type of keystore, can be pkcs12 or pem Default: pkcs12</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="keystoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain keystore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>Keystore password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias in keystore</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Alias used to obtain keystoreAlias password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreAliasPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>KeystoreAlias password</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>Key manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SignaturePipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="SignaturePipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="SizePipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.SizePipe" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="SkipPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="SkipPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.SkipPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="SkipPipeDeclaredAttributeGroup">
    <xs:attribute name="skip" type="frankInt">
      <xs:annotation>
        <xs:documentation>Number of bytes (for binary input) or characters (for character input) to skip. An empty byte array or string is returned when skip is larger than the length of the input. Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="length" type="frankInt">
      <xs:annotation>
        <xs:documentation>If length&gt;=0 only these number of bytes (for binary input) or characters (for character input) is returned. Default: -1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SkipPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="SkipPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="StreamLineIteratorPipeType">
    <xs:group ref="IteratingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="StreamLineIteratorPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.StreamLineIteratorPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="StreamLineIteratorPipeDeclaredAttributeGroup">
    <xs:attribute name="endOfLineString" type="xs:string">
      <xs:annotation>
        <xs:documentation>If set, each record has to end with this string. If a line read doesn't end with this string more lines are added (including line separators) until the total record ends with the given string</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startOfLineString" type="xs:string">
      <xs:annotation>
        <xs:documentation>Marks the start of a new record. If set, a new record is started when this line is read.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="StreamLineIteratorPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="StreamLineIteratorPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="StringIteratorPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="StreamPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="StreamPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.StreamPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="StreamPipeDeclaredAttributeGroup">
    <xs:attribute name="extractFirstStringPart" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt;) when true the first part is not put in a session key but returned to the pipeline (as the result of this pipe) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartXmlSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;extractfirststringpart=true&lt;/code&gt;) the session key to put the xml in with info about the stored parts Default: &lt;code&gt;multipartxml&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkAntiVirus" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt;) when true parts are checked for antivirus scan returncode. these antivirus scan parts have been added by another application (so the antivirus scan is not performed in this pipe). for each file part an antivirus scan part have been added by this other application (directly after this file part) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusPartName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) name of antivirus scan status parts Default: &lt;code&gt;antivirus_rc&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusMessagePartName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) name of antivirus scan message parts Default: &lt;code&gt;antivirus_msg&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusPassedMessage" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) message of antivirus scan parts which indicates the antivirus scan passed Default: &lt;code&gt;pass&lt;/code&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusFailureAsSoapFault" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) when true and the antivirusfailed forward is specified and the antivirus scan did not pass, a soap fault is returned instead of only a plain error message Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusFailureReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) if not empty and the antivirusfailed forward is specified and the antivirus scan did not pass, the error message (or soap fault) is stored in this session key and the first string part is returned to the pipeline</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="StreamPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="StreamPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="Text2XmlPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="Text2XmlPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.Text2XmlPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="Text2XmlPipeDeclaredAttributeGroup">
    <xs:attribute name="xmlTag" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>The xml tag to encapsulate the text in</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="splitLines" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Controls whether the lines of the input are places in separated &amp;lt;line&amp;gt; tags Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceNonXmlChars" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Replace all non xml chars (not in the &lt;a href="http://www.w3.org/tr/2006/rec-xml-20060816/#nt-char"&gt;character range as specified by the xml specification&lt;/a&gt;)
 with the inverted question mark (0x00bf) Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useCdataSection" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Controls whether the text to encapsulate should be put in a cdata section Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="Text2XmlPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="Text2XmlPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="TextSplitterPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="TextSplitterPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.TextSplitterPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="TextSplitterPipeDeclaredAttributeGroup">
    <xs:attribute name="maxBlockLength" type="frankInt">
      <xs:annotation>
        <xs:documentation>Set the maximum number of characters of a block Default: 160</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="softSplit" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If true, try to break up the message at spaces, instead of in the middle of words Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="TextSplitterPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="TextSplitterPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="UUIDGeneratorPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="UUIDGeneratorPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.UUIDGeneratorPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="UUIDGeneratorPipeDeclaredAttributeGroup">
    <xs:attribute name="type">
      <xs:annotation>
        <xs:documentation>Format of generated string. Default: alphanumeric</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="TypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="UUIDGeneratorPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="UUIDGeneratorPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="UnzipPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="UnzipPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.UnzipPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="UnzipPipeDeclaredAttributeGroup">
    <xs:attribute name="directory" type="xs:string">
      <xs:annotation>
        <xs:documentation>Directory to extract the archive to</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directorySessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Sessionkey with a directory value to extract the archive to</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectResults" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;false&lt;/code&gt;, only a small summary (count of items in zip) is returned Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectFileContents" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the contents of the files in the zip are returned in the result xml message of this pipe. Please note this can consume a lot of memory for large files or a large number of files Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectFileContentsBase64Encoded" type="xs:string">
      <xs:annotation>
        <xs:documentation>Comma separated list of file extensions. Files with an extension which is part of this list will be base64 encoded. All other files are assumed to have UTF-8 when reading it from the zip and are added as escaped xml with non-unicode-characters being replaced by inverted question mark appended with #, the character number and ; Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keepOriginalFileName" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;false&lt;/code&gt;, a suffix is added to the original filename to be sure it is unique Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keepOriginalFilePath" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the path of the zip entry will be preserved. Otherwise, the zip entries will be extracted to the root folder Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="assumeDirectoryExists" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, validation of directory is ignored Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="UnzipPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="UnzipPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="WsdlGeneratorPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="WsdlGeneratorPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.WsdlGeneratorPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="WsdlGeneratorPipeDeclaredAttributeGroup">
    <xs:attribute name="from" type="xs:string">
      <xs:annotation>
        <xs:documentation>either parent (adapter of pipeline which contains this pipe) or input (name of adapter specified by input of pipe), adapter must be within the same Configuration Default: parent</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="WsdlGeneratorPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="WsdlGeneratorPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XQueryPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="XQueryPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.XQueryPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="XQueryPipeDeclaredAttributeGroup">
    <xs:attribute name="xqueryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the file (resource) on the classpath to read the xquery from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xqueryFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the file on the file system to read the xquery from</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XQueryPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="XQueryPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XmlIfType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="XmlIfCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.XmlIf" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="XmlIfDeclaredAttributeGroup">
    <xs:attribute name="expressionValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>a string to compare the result of the xpathExpression (or the input-message itself) to. If not specified, a non-empty result leads to the 'then'-forward, an empty result to 'else'-forward</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="thenForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when output is &lt;code&gt;true&lt;/code&gt; Default: then</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elseForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when output is &lt;code&gt;false&lt;/code&gt; Default: else</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to be applied to the input-message. if not set, no transformation is done</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="regex" type="xs:string">
      <xs:annotation>
        <xs:documentation>Regular expression to be applied to the input-message (ignored if &lt;code&gt;xpathExpression&lt;/code&gt; is specified).
 The input-message &lt;b&gt;fully&lt;/b&gt; matching the given regular expression leads to the 'then'-forward</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xsltVersion" type="frankInt">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt; a Saxon (net.sf.saxon) xslt processor 2.0 or 3.0 respectively will be used, otherwise xslt processor 1.0 (org.apache.xalan) Default: 2</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace definitions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt; definitions.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of XSLT transformation Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XmlIfCumulativeAttributeGroup">
    <xs:attributeGroup ref="XmlIfDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="XmlSwitchType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="XmlSwitchCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.pipes.XmlSwitch" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="XmlSwitchDeclaredAttributeGroup">
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet may return a string representing the forward to look up Default: &lt;i&gt;a stylesheet that returns the name of the root-element&lt;/i&gt;</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath-expression that returns a string representing the forward to look up. It's possible to refer to a parameter (which e.g. contains a value from a sessionkey) by using the parameter name prefixed with $</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>Namespace defintions for xpathExpression. Must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions. For some use other cases (NOT xpathExpression), one entry can be without a prefix, that will define the default namespace.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="notFoundForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Forward returned when the pipename derived from the stylesheet could not be found.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Forward returned when the content, on which the switch is performed, is empty. if &lt;code&gt;emptyforwardname&lt;/code&gt; is not specified, &lt;code&gt;notfoundforwardname&lt;/code&gt; is used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xsltVersion" type="frankInt">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt; a Saxon (net.sf.saxon) xslt processor 2.0 or 3.0 respectively will be used, otherwise xslt processor 1.0 (org.apache.xalan). &lt;code&gt;0&lt;/code&gt; will auto-detect Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeForwardInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Selected forward name will be stored in the specified session key.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key that will be used to get the forward name from.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of XSLT transformation Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="XmlSwitchCumulativeAttributeGroup">
    <xs:attributeGroup ref="XmlSwitchDeclaredAttributeGroup" />
    <xs:attributeGroup ref="AbstractPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ZipIteratorPipeType">
    <xs:group ref="IteratingPipeCumulativeChildGroup" />
    <xs:attributeGroup ref="ZipIteratorPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.compression.ZipIteratorPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ZipIteratorPipeDeclaredAttributeGroup">
    <xs:attribute name="contentsSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key used to store contents of each zip entry Default: zipdata</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamingContents" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;false&lt;/code&gt;, a string containing the contents of the entry is placed under the session key, instead of the inputstream to the contents Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used Default: true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>Charset used when reading the contents of the entry (only used if streamingContents=false) Default: utf-8</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ZipIteratorPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ZipIteratorPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="IteratingPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="ZipWriterPipeType">
    <xs:group ref="AbstractPipeDeclaredChildGroup" />
    <xs:attributeGroup ref="ZipWriterPipeCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.compression.ZipWriterPipe" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ZipWriterPipeDeclaredAttributeGroup">
    <xs:attribute name="completeFileHeader" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>Only for action='write': If set to &lt;code&gt;true&lt;/code&gt;, the fields 'crc-32', 'compressed size' and 'uncompressed size' in the zip entry file header are set explicitly (note: compression ratio is zero) Default: false</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ZipWriterPipeCumulativeAttributeGroup">
    <xs:attributeGroup ref="ZipWriterPipeDeclaredAttributeGroup" />
    <xs:attributeGroup ref="CollectorPipeBaseCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:attributeGroup name="CollectorPipeBaseDeclaredAttributeGroup">
    <xs:attribute name="action">
      <xs:annotation>
        <xs:documentation>Collectors must be opened before you can write content to them, after it's closed you can no longer write to it. Default: WRITE</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:union memberTypes="ActionAttributeValuesType_3 variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="collectionName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Session key used to refer to collection. Must be specified with another value if multiple CollectorPipes are active at the same time in the same session Default: collection</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CollectorPipeBaseCumulativeAttributeGroup">
    <xs:attributeGroup ref="CollectorPipeBaseDeclaredAttributeGroup" />
    <xs:attributeGroup ref="FixedForwardPipeCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="JobElementGroup">
    <xs:choice>
      <xs:element name="Job">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="DirectoryCleaner" type="DirectoryCleanerType" />
              <xs:element name="Locker" type="LockerType" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="job" use="prohibited" />
          <xs:attribute name="className" type="xs:string" default="org.frankframework.scheduler.job.Job" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="JobElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="JobElementGroupBase">
    <xs:choice>
      <xs:element name="ActionJob">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ActionJobType">
              <xs:attribute name="elementRole" type="xs:string" fixed="job" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CheckReloadJob">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CheckReloadJobType">
              <xs:attribute name="elementRole" type="xs:string" fixed="job" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CleanupDatabaseJob">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CleanupDatabaseJobType">
              <xs:attribute name="elementRole" type="xs:string" fixed="job" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="CleanupFileSystemJob">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="CleanupFileSystemJobType">
              <xs:attribute name="elementRole" type="xs:string" fixed="job" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ExecuteQueryJob">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ExecuteQueryJobType">
              <xs:attribute name="elementRole" type="xs:string" fixed="job" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="LoadDatabaseSchedulesJob">
        <xs:annotation>
          <xs:documentation>1. This method first stores all database jobs that can are found in the Quartz Scheduler in a Map.
 2. It then loops through all records found in the database.
 3. If the job is found, remove it from the Map and compares it with the already existing scheduled job.
    Only if they differ, it overwrites the current job.
    If it is not present it add the job to the scheduler.
 4. Once it's looped through all the database jobs, loop through the remaining jobs in the Map.
    Since they have been removed from the database, remove them from the Quartz Scheduler</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="LoadDatabaseSchedulesJobType">
              <xs:attribute name="elementRole" type="xs:string" fixed="job" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="RecoverAdaptersJob">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="RecoverAdaptersJobType">
              <xs:attribute name="elementRole" type="xs:string" fixed="job" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="SendMessageJob">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SendMessageJobType">
              <xs:attribute name="elementRole" type="xs:string" fixed="job" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="ActionJobType">
    <xs:group ref="JobDefDeclaredChildGroup" />
    <xs:attributeGroup ref="ActionJobCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.scheduler.job.ActionJob" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ActionJobDeclaredAttributeGroup">
    <xs:attribute name="action" use="required">
      <xs:simpleType>
        <xs:union memberTypes="AvailableActionAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="configurationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Configuration on which job operates</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="adapterName" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Adapter on which job operates</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="receiverName" type="xs:string">
      <xs:annotation>
        <xs:documentation>Receiver on which job operates</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ActionJobCumulativeAttributeGroup">
    <xs:attributeGroup ref="ActionJobDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JobDefCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="JobDefDeclaredChildGroup">
    <xs:sequence>
      <xs:element name="Locker" minOccurs="0" maxOccurs="1" type="LockerType" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="JobDefDeclaredAttributeGroup">
    <xs:attribute name="jobGroup" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Name of the job</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="description" type="xs:string">
      <xs:annotation>
        <xs:documentation>Description of the job</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cronExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>CRON expression that determines the frequency of execution.
 Can &lt;b&gt;not&lt;/b&gt; be used in combination with Interval.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="interval" type="frankInt">
      <xs:annotation>
        <xs:documentation>Triggers the Job at the specified number of milliseconds. Keep cronExpression empty in order to use interval.
 Value &lt;code&gt;0&lt;/code&gt; may be used to run once at startup of the application.
 A value of 0 in combination with function 'sendMessage' will set dependencyTimeout on the IbisLocalSender to -1 to keep waiting indefinitely instead of 60 seconds for the adapter to start.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numThreads" type="frankInt">
      <xs:annotation>
        <xs:documentation>Number of threads that may execute concurrently Default: 1</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageKeeperSize" type="frankInt">
      <xs:annotation>
        <xs:documentation>Number of messages displayed in ibisconsole Default: 10</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="JobDefCumulativeAttributeGroup">
    <xs:attributeGroup ref="JobDefDeclaredAttributeGroup" />
    <xs:attributeGroup ref="TransactionAttributesDeclaredAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="CheckReloadJobType">
    <xs:group ref="JobDefDeclaredChildGroup" />
    <xs:attributeGroup ref="JobDefCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.scheduler.job.CheckReloadJob" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="CleanupDatabaseJobType">
    <xs:group ref="JobDefDeclaredChildGroup" />
    <xs:attributeGroup ref="CleanupDatabaseJobCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.scheduler.job.CleanupDatabaseJob" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="CleanupDatabaseJobDeclaredAttributeGroup">
    <xs:attribute name="queryTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of seconds the database driver will wait for a statement to execute. If the limit is exceeded, a TimeoutException is thrown. 0 means no timeout Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="CleanupDatabaseJobCumulativeAttributeGroup">
    <xs:attributeGroup ref="CleanupDatabaseJobDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JobDefCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="CleanupFileSystemJobType">
    <xs:group ref="CleanupFileSystemJobCumulativeChildGroup" />
    <xs:attributeGroup ref="JobDefCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.scheduler.job.CleanupFileSystemJob" use="prohibited" />
  </xs:complexType>
  <xs:group name="CleanupFileSystemJobDeclaredChildGroup">
    <xs:sequence>
      <xs:element name="DirectoryCleaner" minOccurs="0" maxOccurs="unbounded" type="DirectoryCleanerType" />
    </xs:sequence>
  </xs:group>
  <xs:group name="CleanupFileSystemJobCumulativeChildGroup">
    <xs:sequence>
      <xs:group ref="CleanupFileSystemJobDeclaredChildGroup" />
      <xs:group ref="JobDefDeclaredChildGroup" />
    </xs:sequence>
  </xs:group>
  <xs:complexType name="ExecuteQueryJobType">
    <xs:group ref="JobDefDeclaredChildGroup" />
    <xs:attributeGroup ref="ExecuteQueryJobCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.scheduler.job.ExecuteQueryJob" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="ExecuteQueryJobDeclaredAttributeGroup">
    <xs:attribute name="query" type="xs:string">
      <xs:annotation>
        <xs:documentation>The SQL query text to be executed</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>JNDI name of datasource to be used Default: jdbc.datasource.default</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queryTimeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>The number of seconds the database driver will wait for a statement to execute. If the limit is exceeded, a TimeoutException is thrown. 0 means no timeout Default: 0</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="ExecuteQueryJobCumulativeAttributeGroup">
    <xs:attributeGroup ref="ExecuteQueryJobDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JobDefCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:complexType name="LoadDatabaseSchedulesJobType">
    <xs:group ref="JobDefDeclaredChildGroup" />
    <xs:attributeGroup ref="JobDefCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.scheduler.job.LoadDatabaseSchedulesJob" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="RecoverAdaptersJobType">
    <xs:group ref="JobDefDeclaredChildGroup" />
    <xs:attributeGroup ref="JobDefCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.scheduler.job.RecoverAdaptersJob" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="SendMessageJobType">
    <xs:group ref="JobDefDeclaredChildGroup" />
    <xs:attributeGroup ref="SendMessageJobCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.scheduler.job.SendMessageJob" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="SendMessageJobDeclaredAttributeGroup">
    <xs:attribute name="javaListener" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>JavaListener to send the message to</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="message" type="xs:string">
      <xs:annotation>
        <xs:documentation>message to be sent into the pipeline</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="SendMessageJobCumulativeAttributeGroup">
    <xs:attributeGroup ref="SendMessageJobDeclaredAttributeGroup" />
    <xs:attributeGroup ref="JobDefCumulativeAttributeGroup" />
  </xs:attributeGroup>
  <xs:group name="SapSystemElementGroup">
    <xs:choice>
      <xs:element name="SapSystem">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="sapSystem" use="prohibited" />
          <xs:attribute name="className" type="xs:string" default="org.frankframework.extensions.sap.SapSystem" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="SapSystemElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="SapSystemElementGroupBase">
    <xs:choice />
  </xs:group>
  <xs:group name="DestinationElementGroup">
    <xs:choice>
      <xs:element name="Destination">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:group ref="SenderElementGroup" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="destination" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="DestinationElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="DestinationElementGroupBase">
    <xs:choice>
      <xs:element name="SenderMonitorAdapterDestination">
        <xs:annotation>
          <xs:documentation>IMonitorAdapter that uses a sender to send its message.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="SenderMonitorAdapterType">
              <xs:attribute name="elementRole" type="xs:string" fixed="destination" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="SenderMonitorAdapterType">
    <xs:group ref="SenderMonitorAdapterDeclaredChildGroup" />
    <xs:attributeGroup ref="MonitorDestinationBaseDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.monitoring.SenderMonitorAdapter" use="prohibited" />
  </xs:complexType>
  <xs:group name="SenderMonitorAdapterDeclaredChildGroup">
    <xs:sequence>
      <xs:group ref="SenderElementGroup" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="MonitorDestinationBaseDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of the object.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:group name="TriggerElementGroup">
    <xs:choice>
      <xs:element name="Trigger">
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="Adapterfilter" type="AdapterfilterType" />
              <xs:element name="Event" minOccurs="0" maxOccurs="unbounded" type="xs:string" />
            </xs:choice>
          </xs:sequence>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="trigger" use="prohibited" />
          <xs:attribute name="className" type="xs:string" default="org.frankframework.monitoring.Trigger" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="TriggerElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="TriggerElementGroupBase">
    <xs:choice>
      <xs:element name="AlarmTrigger">
        <xs:annotation>
          <xs:documentation>A Trigger that starts its life with type = ALARM. The type of the trigger can be changed dynamically.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="AlarmType">
              <xs:attribute name="elementRole" type="xs:string" fixed="trigger" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="ClearingTrigger">
        <xs:annotation>
          <xs:documentation>A Trigger that starts its life with type = CLEARING. The type of the trigger can be changed dynamically.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="ClearingType">
              <xs:attribute name="elementRole" type="xs:string" fixed="trigger" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="AlarmType">
    <xs:group ref="TriggerDeclaredChildGroup" />
    <xs:attributeGroup ref="TriggerDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.monitoring.Alarm" use="prohibited" />
  </xs:complexType>
  <xs:complexType name="TriggerType">
    <xs:group ref="TriggerDeclaredChildGroup" />
    <xs:attributeGroup ref="TriggerDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.monitoring.Trigger" use="prohibited" />
  </xs:complexType>
  <xs:group name="TriggerDeclaredChildGroup">
    <xs:sequence>
      <xs:element name="Event" minOccurs="0" maxOccurs="unbounded" type="xs:string" />
      <xs:element name="Adapterfilter" minOccurs="0" maxOccurs="unbounded" type="AdapterfilterType" />
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="TriggerDeclaredAttributeGroup">
    <xs:attribute name="eventCode" type="xs:string" />
    <xs:attribute name="threshold" type="frankInt" />
    <xs:attribute name="period" type="frankInt" />
    <xs:attribute name="severity">
      <xs:simpleType>
        <xs:union memberTypes="SeverityAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="sourceFiltering">
      <xs:simpleType>
        <xs:union memberTypes="SourceFilteringAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="triggerType">
      <xs:simpleType>
        <xs:union memberTypes="TriggerTypeAttributeValuesType variableRef" />
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:complexType name="ClearingType">
    <xs:group ref="TriggerDeclaredChildGroup" />
    <xs:attributeGroup ref="TriggerDeclaredAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.monitoring.Clearing" use="prohibited" />
  </xs:complexType>
  <xs:group name="SharedResourceElementGroup">
    <xs:choice>
      <xs:element name="SharedResource">
        <xs:complexType>
          <xs:attribute ref="active" />
          <xs:attribute name="elementRole" type="xs:string" fixed="sharedResource" use="prohibited" />
          <xs:attribute name="className" type="xs:string" use="required" />
          <xs:anyAttribute processContents="skip" />
        </xs:complexType>
      </xs:element>
      <xs:group ref="SharedResourceElementGroupBase" />
    </xs:choice>
  </xs:group>
  <xs:group name="SharedResourceElementGroupBase">
    <xs:choice>
      <xs:element name="HttpSessionSharedResource">
        <xs:annotation>
          <xs:documentation>Shared HTTPSession, implements SharedResource so it can be set in the Configuration.xml</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="HttpSessionType">
              <xs:attribute name="elementRole" type="xs:string" fixed="sharedResource" use="prohibited" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="HttpSessionType">
    <xs:attributeGroup ref="HttpSessionCumulativeAttributeGroup" />
    <xs:attribute name="className" type="xs:string" fixed="org.frankframework.http.HttpSession" use="prohibited" />
  </xs:complexType>
  <xs:attributeGroup name="HttpSessionDeclaredAttributeGroup">
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>The functional name of the object.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="HttpSessionCumulativeAttributeGroup">
    <xs:attributeGroup ref="HttpSessionDeclaredAttributeGroup" />
    <xs:attribute name="timeout" type="frankInt">
      <xs:annotation>
        <xs:documentation>Timeout in ms of obtaining a connection/result. Default: 10000</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="maxConnections" />
    <xs:attribute ref="maxExecuteRetries" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>Authentication alias used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>Username used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>Password used for authentication to the host</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="tokenEndpoint" />
    <xs:attribute ref="tokenExpiry" />
    <xs:attribute ref="clientAlias" />
    <xs:attribute ref="clientId" />
    <xs:attribute ref="clientSecret" />
    <xs:attribute ref="scope" />
    <xs:attribute ref="authenticatedTokenRequest" />
    <xs:attribute ref="proxyHost" />
    <xs:attribute ref="proxyPort" />
    <xs:attribute ref="proxyAuthAlias" />
    <xs:attribute ref="proxyUsername" />
    <xs:attribute ref="proxyPassword" />
    <xs:attribute ref="proxyRealm" />
    <xs:attribute ref="prefillProxyAuthCache" />
    <xs:attribute ref="disableCookies" />
    <xs:attribute ref="keystore" />
    <xs:attribute ref="keystoreType" />
    <xs:attribute ref="keystoreAuthAlias" />
    <xs:attribute ref="keystorePassword" />
    <xs:attribute ref="keyManagerAlgorithm" />
    <xs:attribute ref="keystoreAlias" />
    <xs:attribute ref="keystoreAliasAuthAlias" />
    <xs:attribute ref="keystoreAliasPassword" />
    <xs:attribute ref="truststore" />
    <xs:attribute ref="truststoreAuthAlias" />
    <xs:attribute ref="truststorePassword" />
    <xs:attribute ref="truststoreType" />
    <xs:attribute ref="trustManagerAlgorithm" />
    <xs:attribute ref="verifyHostname" />
    <xs:attribute ref="allowSelfSignedCertificates" />
    <xs:attribute ref="ignoreCertificateExpiredException" />
    <xs:attribute ref="followRedirects" />
    <xs:attribute ref="ignoreRedirects" />
    <xs:attribute ref="staleChecking" />
    <xs:attribute ref="staleTimeout" />
    <xs:attribute ref="connectionTimeToLive" />
    <xs:attribute ref="connectionIdleTimeout" />
    <xs:attribute ref="protocol" />
    <xs:attribute ref="supportedCipherSuites" />
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:attributeGroup name="ConfigurationDeclaredAttributeGroup">
    <xs:attribute name="autoStart" type="frankBoolean">
      <xs:annotation>
        <xs:documentation>If the Configuration should automatically start all Adapters and Jobs.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Configurations should be wired through Spring, which in turn should call #setBeanName(String).
 Once the ConfigurationContext has a name it should not be changed anymore, hence
 super.setBeanName(String) only sets the name once.
 If not created by Spring, the setIdCalled flag in AbstractRefreshableConfigApplicationContext wont be set, allowing the name to be updated.

 The DisplayName will always be updated, which is purely used for logging purposes.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute ref="active" />
    <xs:anyAttribute namespace="##other" processContents="skip" />
  </xs:attributeGroup>
  <xs:simpleType name="ParameterModeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="INPUT" />
      <xs:enumeration value="OUTPUT" />
      <xs:enumeration value="INOUT" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DateFormatTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="DATE" />
      <xs:enumeration value="DATETIME" />
      <xs:enumeration value="TIMESTAMP" />
      <xs:enumeration value="TIME" />
      <xs:enumeration value="XMLDATETIME" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="HttpMethodAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="GET" />
      <xs:enumeration value="PUT" />
      <xs:enumeration value="POST" />
      <xs:enumeration value="PATCH" />
      <xs:enumeration value="DELETE" />
      <xs:enumeration value="HEAD" />
      <xs:enumeration value="OPTIONS" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="MediaTypesAttributeValuesType_2">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ANY" />
      <xs:enumeration value="DETECT" />
      <xs:enumeration value="TEXT" />
      <xs:enumeration value="XML" />
      <xs:enumeration value="JSON" />
      <xs:enumeration value="PDF" />
      <xs:enumeration value="OCTET" />
      <xs:enumeration value="MULTIPART_RELATED" />
      <xs:enumeration value="MULTIPART_FORMDATA" />
      <xs:enumeration value="MULTIPART" />
      <xs:enumeration value="TXT" />
      <xs:enumeration value="CSS" />
      <xs:enumeration value="CSV" />
      <xs:enumeration value="MJS" />
      <xs:enumeration value="HTML" />
      <xs:enumeration value="JAR" />
      <xs:enumeration value="DOC" />
      <xs:enumeration value="EPUB" />
      <xs:enumeration value="VSD" />
      <xs:enumeration value="AZW" />
      <xs:enumeration value="PPT" />
      <xs:enumeration value="XLS" />
      <xs:enumeration value="RAR" />
      <xs:enumeration value="RTF" />
      <xs:enumeration value="ICO" />
      <xs:enumeration value="ICS" />
      <xs:enumeration value="BMP" />
      <xs:enumeration value="GIF" />
      <xs:enumeration value="PNG" />
      <xs:enumeration value="SVG" />
      <xs:enumeration value="TIFF" />
      <xs:enumeration value="JPG" />
      <xs:enumeration value="OTF" />
      <xs:enumeration value="TTF" />
      <xs:enumeration value="WOFF" />
      <xs:enumeration value="WOFF2" />
      <xs:enumeration value="MPEG" />
      <xs:enumeration value="MP3" />
      <xs:enumeration value="MP4" />
      <xs:enumeration value="MIDI" />
      <xs:enumeration value="AAC" />
      <xs:enumeration value="AVI" />
      <xs:enumeration value="TS" />
      <xs:enumeration value="WAV" />
      <xs:enumeration value="WEBA" />
      <xs:enumeration value="WEBM" />
      <xs:enumeration value="WEBP" />
      <xs:enumeration value="GZ" />
      <xs:enumeration value="TAR" />
      <xs:enumeration value="BZ" />
      <xs:enumeration value="BZ2" />
      <xs:enumeration value="ZIP" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="AuthenticationMethodsAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="NONE" />
      <xs:enumeration value="COOKIE" />
      <xs:enumeration value="HEADER" />
      <xs:enumeration value="AUTHROLE" />
      <xs:enumeration value="JWT" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DocumentFormatAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="XML" />
      <xs:enumeration value="JSON" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="MessageProtocolAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="FF">
        <xs:annotation>
          <xs:documentation>Fire &amp; Forget protocol</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="RR">
        <xs:annotation>
          <xs:documentation>Request-Reply protocol</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DeliveryModeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="NOT_SET" />
      <xs:enumeration value="PERSISTENT" />
      <xs:enumeration value="NON_PERSISTENT" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="MessageClassAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="AUTO">
        <xs:annotation>
          <xs:documentation>Automatically determine the type of the outgoing jakarta.jms.Message based
 on the value of Message#isBinary().</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="TEXT">
        <xs:annotation>
          <xs:documentation>Create the outgoing message as TextMessage.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BYTES">
        <xs:annotation>
          <xs:documentation>Create the outgoing message as BytesMessage.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DestinationTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="QUEUE" />
      <xs:enumeration value="TOPIC" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="AcknowledgeModeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="none" />
      <xs:enumeration value="auto">
        <xs:annotation>
          <xs:documentation>auto or auto_acknowledge: Specifies that the session is to automatically acknowledge consumer receipt of
 messages when message processing is complete.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="client">
        <xs:annotation>
          <xs:documentation>client or client_acknowledge: Specifies that the consumer is to acknowledge all messages delivered in this session.
 The Frank application will acknowledge all messages processed correctly. The skipping of the acknowledgement of messages
 processed in error will cause them to be redelivered, thus providing an automatic retry.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="dups">
        <xs:annotation>
          <xs:documentation>dups or dups_ok_acknowledge: Specifies that the session is to "lazily" acknowledge the
 delivery of messages to the consumer. "Lazy" means that the consumer can delay the acknowledgment
 of messages to the server until a convenient time; meanwhile the server might redeliver messages.
 This mode reduces the session overhead. If JMS fails, the consumer may receive duplicate messages.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="SubscriberTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="DURABLE" />
      <xs:enumeration value="TRANSIENT" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="CacheModeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="CACHE_NONE" />
      <xs:enumeration value="CACHE_CONNECTION" />
      <xs:enumeration value="CACHE_SESSION" />
      <xs:enumeration value="CACHE_CONSUMER" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="KeystoreTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="PKCS12" />
      <xs:enumeration value="PEM" />
      <xs:enumeration value="JKS" />
      <xs:enumeration value="JCEKS" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="FtpTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="FTP" />
      <xs:enumeration value="FTPSI" />
      <xs:enumeration value="FTPSX(TLS)" />
      <xs:enumeration value="FTPSX(SSL)" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="FileTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ASCII" />
      <xs:enumeration value="BINARY" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TransportTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="DIRECT" />
      <xs:enumeration value="HTTP" />
      <xs:enumeration value="SOCKS" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ProtAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="C">
        <xs:annotation>
          <xs:documentation>Clear</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="S">
        <xs:annotation>
          <xs:documentation>Safe(SSL protocol only)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="E">
        <xs:annotation>
          <xs:documentation>Confidential(SSL protocol only)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="P">
        <xs:annotation>
          <xs:documentation>Private</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="MessageFieldTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="STRING" />
      <xs:enumeration value="CLOB" />
      <xs:enumeration value="BLOB" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="MediaTypesAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="XML" />
      <xs:enumeration value="JSON" />
      <xs:enumeration value="TEXT" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="Samba2AuthTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="NTLM" />
      <xs:enumeration value="SPNEGO" />
      <xs:enumeration value="ANONYMOUS" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TransportTypeAttributeValuesType_2">
    <xs:restriction base="xs:string">
      <xs:enumeration value="HTTP" />
      <xs:enumeration value="SOCKS4" />
      <xs:enumeration value="SOCKS5" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="OutputTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="TEXT" />
      <xs:enumeration value="XML" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="FileSystemActionAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="list">
        <xs:annotation>
          <xs:documentation>list files in a folder/directory, specified by attribute &lt;code&gt;inputFolder&lt;/code&gt;, parameter &lt;code&gt;inputFolder&lt;/code&gt; or input message</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="info">
        <xs:annotation>
          <xs:documentation>show info about a single file, specified by attribute &lt;code&gt;filename&lt;/code&gt;, parameter &lt;code&gt;filename&lt;/code&gt; or input message</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="read">
        <xs:annotation>
          <xs:documentation>read a file, specified by attribute &lt;code&gt;filename&lt;/code&gt;, parameter &lt;code&gt;filename&lt;/code&gt; or input message</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="readDelete">
        <xs:annotation>
          <xs:documentation>like &lt;code&gt;read&lt;/code&gt;, but deletes the file after it has been read</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="move">
        <xs:annotation>
          <xs:documentation>move a file, specified by attribute &lt;code&gt;filename&lt;/code&gt;, parameter &lt;code&gt;filename&lt;/code&gt; or input message, to a folder specified by attribute &lt;code&gt;destination&lt;/code&gt; or parameter &lt;code&gt;destination&lt;/code&gt;</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="copy">
        <xs:annotation>
          <xs:documentation>copy a file, specified by attribute &lt;code&gt;filename&lt;/code&gt;, parameter &lt;code&gt;filename&lt;/code&gt; or input message, to a folder specified by attribute &lt;code&gt;destination&lt;/code&gt; or parameter &lt;code&gt;destination&lt;/code&gt;</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="delete">
        <xs:annotation>
          <xs:documentation>delete a file, specified by attribute &lt;code&gt;filename&lt;/code&gt;, parameter &lt;code&gt;filename&lt;/code&gt; or input message</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="mkdir">
        <xs:annotation>
          <xs:documentation>create a folder/directory, specified by attribute &lt;code&gt;inputFolder&lt;/code&gt;, parameter &lt;code&gt;inputFolder&lt;/code&gt; or input message</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rmdir">
        <xs:annotation>
          <xs:documentation>remove a folder/directory, specified by attribute &lt;code&gt;inputFolder&lt;/code&gt;, parameter &lt;code&gt;inputFolder&lt;/code&gt; or input message</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="write">
        <xs:annotation>
          <xs:documentation>Creates file and writes contents, specified by parameter &lt;code&gt;contents&lt;/code&gt; or input message, to a file, specified by attribute &lt;code&gt;filename&lt;/code&gt;, parameter &lt;code&gt;filename&lt;/code&gt; or input message.
  At least one of the parameters must be specified. The missing parameter defaults to the input message. For streaming operation, the parameter &lt;code&gt;filename&lt;/code&gt; must be specified.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="append">
        <xs:annotation>
          <xs:documentation>(only for filesystems that support 'append') append contents, specified by parameter &lt;code&gt;contents&lt;/code&gt; or input message, to a file, specified by attribute &lt;code&gt;filename&lt;/code&gt;, parameter &lt;code&gt;filename&lt;/code&gt; or input message.
  At least one of the parameters must be specified. The missing parameter defaults to the input message. For streaming operation, the parameter &lt;code&gt;filename&lt;/code&gt; must be specified.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="create">
        <xs:annotation>
          <xs:documentation>create empty file, specified by attribute &lt;code&gt;filename&lt;/code&gt;, parameter &lt;code&gt;filename&lt;/code&gt; or input message</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rename">
        <xs:annotation>
          <xs:documentation>change the name of a file, specified by attribute &lt;code&gt;filename&lt;/code&gt;, parameter &lt;code&gt;filename&lt;/code&gt; or input message, to the value specified by attribute &lt;code&gt;destination&lt;/code&gt; or parameter &lt;code&gt;destination&lt;/code&gt;</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="forward">
        <xs:annotation>
          <xs:documentation>(for MailFileSystems only:) forward an existing file, specified by parameter &lt;code&gt;contents&lt;/code&gt; or input message, to a file, to an email address specified by attribute &lt;code&gt;destination&lt;/code&gt; or parameter &lt;code&gt;destination&lt;/code&gt;</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="listAttachments">
        <xs:annotation>
          <xs:documentation>Specific to FileSystemSenderWithAttachments</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TypeFilterAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="FILES_ONLY" />
      <xs:enumeration value="FOLDERS_ONLY" />
      <xs:enumeration value="FILES_AND_FOLDERS" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="CmisActionAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="CREATE">
        <xs:annotation>
          <xs:documentation>Create a document</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DELETE">
        <xs:annotation>
          <xs:documentation>Delete a document</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="GET">
        <xs:annotation>
          <xs:documentation>Get the content of a document (and optional the properties)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FIND">
        <xs:annotation>
          <xs:documentation>Perform a query that returns properties</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UPDATE">
        <xs:annotation>
          <xs:documentation>Update the properties of an existing document</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FETCH">
        <xs:annotation>
          <xs:documentation>Get the (meta)data of a folder or document</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DYNAMIC">
        <xs:annotation>
          <xs:documentation>Determine action based on the incoming CmisEvent</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="BindingTypesAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ATOMPUB" />
      <xs:enumeration value="WEBSERVICES" />
      <xs:enumeration value="BROWSER" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="QueryTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="SELECT">
        <xs:annotation>
          <xs:documentation>For queries that return data</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UPDATEBLOB">
        <xs:annotation>
          <xs:documentation>For queries that update a BLOB</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UPDATECLOB">
        <xs:annotation>
          <xs:documentation>For queries that update a CLOB</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PACKAGE">
        <xs:annotation>
          <xs:documentation>To execute Oracle PL/SQL package</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="OTHER">
        <xs:annotation>
          <xs:documentation>For queries that return no data</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DirectionAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ENCODE" />
      <xs:enumeration value="DECODE" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="MessageProtocolAttributeValuesType_2">
    <xs:restriction base="xs:string">
      <xs:enumeration value="FF">
        <xs:annotation>
          <xs:documentation>Fire &amp; Forget protocol</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="RR">
        <xs:annotation>
          <xs:documentation>Request-Reply protocol</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="LinkMethodAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="MESSAGEID">
        <xs:annotation>
          <xs:documentation>use the generated messageId as the correlationId in the selector for response messages</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="CORRELATIONID">
        <xs:annotation>
          <xs:documentation>set the correlationId of the pipeline as the correlationId of the message sent, and use that as the correlationId in the selector for response messages</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="CORRELATIONID_FROM_MESSAGE">
        <xs:annotation>
          <xs:documentation>do not automatically set the correlationId of the message sent, but use use the value found in that header after sending the message as the selector for response messages</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ScopeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="JVM" />
      <xs:enumeration value="DLL" />
      <xs:enumeration value="ADAPTER" />
      <xs:enumeration value="LISTENER" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="PostTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="RAW">
        <xs:annotation>
          <xs:documentation>The input message is sent unchanged as character data, like text, XML or JSON, with possibly parameter data appended</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BINARY">
        <xs:annotation>
          <xs:documentation>The input message is sent unchanged as binary data</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="URLENCODED">
        <xs:annotation>
          <xs:documentation>Yields a x-www-form-urlencoded form entity</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FORMDATA">
        <xs:annotation>
          <xs:documentation>Yields a multipart/form-data form entity</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="MTOM">
        <xs:annotation>
          <xs:documentation>Yields a MTOM multipart/related form entity</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="HttpMethodAttributeValuesType_2">
    <xs:restriction base="xs:string">
      <xs:enumeration value="GET" />
      <xs:enumeration value="POST" />
      <xs:enumeration value="PUT" />
      <xs:enumeration value="PATCH" />
      <xs:enumeration value="DELETE" />
      <xs:enumeration value="HEAD" />
      <xs:enumeration value="REPORT" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ActionAttributeValuesType_2">
    <xs:restriction base="xs:string">
      <xs:enumeration value="DIRECTORY" />
      <xs:enumeration value="RESPONSE" />
      <xs:enumeration value="AUTHENTICATE" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="JavaScriptEnginesAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="J2V8" />
      <xs:enumeration value="GRAALJS" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="OperationAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="read">
        <xs:annotation>
          <xs:documentation>Read the contents of an entry. Configuration requirements:
 &lt;ul&gt;
 	  &lt;li&gt;parameter 'entryName', resolving to RDN of entry to read&lt;/li&gt;
 	  &lt;li&gt;optional xml-inputmessage containing attributes to be returned&lt;/li&gt;
 &lt;/ul&gt;</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="create">
        <xs:annotation>
          <xs:documentation>Create an attribute or an entry. Configuration requirements:
 &lt;ul&gt;
 	  &lt;li&gt;parameter 'entryName', resolving to RDN of entry to create&lt;/li&gt;
 	  &lt;li&gt;xml-inputmessage containing attributes to create&lt;/li&gt;
 &lt;/ul&gt;</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="update">
        <xs:annotation>
          <xs:documentation>Update an attribute or an entry. Configuration requirements:
 &lt;ul&gt;
 	  &lt;li&gt;parameter 'entryName', resolving to RDN of entry to update&lt;/li&gt;
 	  &lt;li&gt;xml-inputmessage containing attributes to update&lt;/li&gt;
 	  &lt;li&gt;optional parameter 'newEntryName', new RDN of entry&lt;/li&gt;
 &lt;/ul&gt;</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="delete">
        <xs:annotation>
          <xs:documentation>Delete an attribute or an entry. Configuration requirements:
 &lt;ul&gt;
 	  &lt;li&gt;parameter 'entryName', resolving to RDN of entry to delete&lt;/li&gt;
 	  &lt;li&gt;when manipulationSubject is set to attribute: xml-inputmessage containing attributes to be deleted&lt;/li&gt;
 &lt;/ul&gt;</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="search">
        <xs:annotation>
          <xs:documentation>Search for an entry in the direct children of the specified root. Configuration requirements:
 &lt;ul&gt;
 	  &lt;li&gt;parameter 'entryName', resolving to RDN of entry to read&lt;/li&gt;
    &lt;li&gt;parameter 'filterExpression', specifying the entries searched for&lt;/li&gt;
 	  &lt;li&gt;optional attribute 'attributesReturned' containing attributes to be returned&lt;/li&gt;
 &lt;/ul&gt;</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="deepSearch">
        <xs:annotation>
          <xs:documentation>Search for an entry in the complete tree below the specified root. Configuration requirements:
 &lt;ul&gt;
 	  &lt;li&gt;parameter 'entryName', resolving to RDN of entry to read&lt;/li&gt;
    &lt;li&gt;parameter 'filterExpression', specifying the entries searched for&lt;/li&gt;
 	  &lt;li&gt;optional attribute 'attributesReturned' containing attributes to be returned&lt;/li&gt;
 &lt;/ul&gt;</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="getSubContexts">
        <xs:annotation>
          <xs:documentation>Get a list of the direct children of the specifed root. Configuration requirements:
 &lt;ul&gt;
 	  &lt;li&gt;parameter 'entryName', resolving to RDN of entry to read&lt;/li&gt;
 	  &lt;li&gt;optional attribute 'attributesReturned' containing attributes to be returned&lt;/li&gt;
 &lt;/ul&gt;</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="getTree">
        <xs:annotation>
          <xs:documentation>Get a copy of the complete tree below the specified root. Configuration requirements:
 &lt;ul&gt;
 	  &lt;li&gt;parameter 'entryName', resolving to RDN of entry to read&lt;/li&gt;
 	  &lt;li&gt;optional attribute 'attributesReturned' containing attributes to be returned&lt;/li&gt;
 &lt;/ul&gt;</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="challenge">
        <xs:annotation>
          <xs:documentation>Check username and password against LDAP specifying principal and credential using parameters. Configuration requirements:
 &lt;ul&gt;
 	  &lt;li&gt;parameter 'principal', resolving to RDN of user who's password should be verified&lt;/li&gt;
 	  &lt;li&gt;parameter 'credentials', password to verify&lt;/li&gt;
 &lt;/ul&gt;</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="changeUnicodePwd">
        <xs:annotation>
          <xs:documentation>Typical user change-password operation (one of the two methods to modify the unicodePwd attribute in AD (http://support.microsoft.com/kb/263991)). Configuration requirements:
 &lt;ul&gt;
 	  &lt;li&gt;parameter 'entryName', resolving to RDN of user who's password should be changed&lt;/li&gt;
 	  &lt;li&gt;parameter 'oldPassword', current password, will be encoded as required by Active Directory (a UTF-16 encoded Unicode string containing the password surrounded by quotation marks) before sending it to the LDAP server. It's advised to set attribute hidden to true for parameter.&lt;/li&gt;
 	  &lt;li&gt;parameter 'newPassword', new password, will be encoded as required by Active Directory (a UTF-16 encoded Unicode string containing the password surrounded by quotation marks) before sending it to the LDAP server. It's advised to set attribute hidden to true for parameter.&lt;/li&gt;
 &lt;/ul&gt;</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ManipulationAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ENTRY" />
      <xs:enumeration value="ATTRIBUTE" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="SortOrderAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="NONE" />
      <xs:enumeration value="ASC" />
      <xs:enumeration value="DESC" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="HideMethodAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ALL">
        <xs:annotation>
          <xs:documentation>to mask the entire string</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FIRSTHALF">
        <xs:annotation>
          <xs:documentation>to only mask the first half of the string</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="MongoActionAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="INSERTONE" />
      <xs:enumeration value="INSERTMANY" />
      <xs:enumeration value="FINDONE" />
      <xs:enumeration value="FINDMANY" />
      <xs:enumeration value="UPDATEONE" />
      <xs:enumeration value="UPDATEMANY" />
      <xs:enumeration value="DELETEONE" />
      <xs:enumeration value="DELETEMANY" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="HashAlgorithmAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="MD5" />
      <xs:enumeration value="SHA1" />
      <xs:enumeration value="SHA256" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ActionAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="DU" />
      <xs:enumeration value="DIR" />
      <xs:enumeration value="DELETE" />
      <xs:enumeration value="UPLOAD" />
      <xs:enumeration value="MKDIR" />
      <xs:enumeration value="RMDIR" />
      <xs:enumeration value="RENAME" />
      <xs:enumeration value="MTIME" />
      <xs:enumeration value="DOWNLOAD" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="FileOptionTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="CREATE" />
      <xs:enumeration value="APPEND" />
      <xs:enumeration value="REPLACE" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="CarriageFlagTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="YES" />
      <xs:enumeration value="VLR" />
      <xs:enumeration value="VLR2" />
      <xs:enumeration value="MPACK" />
      <xs:enumeration value="XPACK" />
      <xs:enumeration value="NO" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="CodeTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="EBCDIC" />
      <xs:enumeration value="ASCII" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="CompressTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="YES" />
      <xs:enumeration value="COMPACT" />
      <xs:enumeration value="LZLARGE" />
      <xs:enumeration value="LZMEDIUM" />
      <xs:enumeration value="LZSMALL" />
      <xs:enumeration value="RLE" />
      <xs:enumeration value="NO" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="OnErrorAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="CONTINUE">
        <xs:annotation>
          <xs:documentation>Don't stop the receiver when an error occurs.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="RECOVER">
        <xs:annotation>
          <xs:documentation>If an error occurs (e.g. connection is lost) the receiver will be stopped and marked as ERROR
 Once every &lt;code&gt;recover.adapters.interval&lt;/code&gt; it attempts to (re-) start the receiver.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="CLOSE">
        <xs:annotation>
          <xs:documentation>Stop the receiver when an error occurs.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="CheckForDuplicatesMethodAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="MESSAGEID" />
      <xs:enumeration value="CORRELATIONID" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TransactionAttributeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Required">
        <xs:annotation>
          <xs:documentation>Support a current transaction; create a new one if none exists.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Supports">
        <xs:annotation>
          <xs:documentation>Support a current transaction; execute non-transactionally if none exists.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Mandatory">
        <xs:annotation>
          <xs:documentation>Support a current transaction; throw an exception if no current transaction exists.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="RequiresNew">
        <xs:annotation>
          <xs:documentation>Create a new transaction, suspending the current transaction if one exists.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NotSupported">
        <xs:annotation>
          <xs:documentation>Do not support a current transaction; rather always execute non-transactionally.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Never">
        <xs:annotation>
          <xs:documentation>Do not support a current transaction; throw an exception if a current transaction exists.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ParameterTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="STRING">
        <xs:annotation>
          <xs:documentation>Renders the contents of the first node (in combination with xslt or xpath). Please note that
 if there are child nodes, only the contents are returned, use &lt;code&gt;XML&lt;/code&gt; if the xml tags are required</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="XML">
        <xs:annotation>
          <xs:documentation>Renders an xml-nodeset as an xml-string (in combination with xslt or xpath). This will include the xml tags</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NODE">
        <xs:annotation>
          <xs:documentation>Renders the CONTENTS of the first node as a nodeset
 that can be used as such when passed as xslt-parameter (only for XSLT 1.0).
 Please note that the nodeset may contain multiple nodes, without a common root node.
 N.B. The result is the set of children of what you might expect it to be...</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DOMDOC">
        <xs:annotation>
          <xs:documentation>Renders XML as a DOM document; similar to &lt;code&gt;node&lt;/code&gt;
		with the distinction that there is always a common root node (required for XSLT 2.0)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DATE">
        <xs:annotation>
          <xs:documentation>Converts the result to a Date, by default using formatString &lt;code&gt;yyyy-MM-dd&lt;/code&gt;.
 When applied as a JDBC parameter, the method setDate() is used</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="TIME">
        <xs:annotation>
          <xs:documentation>Converts the result to a Date, by default using formatString &lt;code&gt;HH:mm:ss&lt;/code&gt;.
 When applied as a JDBC parameter, the method setTime() is used</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DATETIME">
        <xs:annotation>
          <xs:documentation>Converts the result to a Date, by default using formatString &lt;code&gt;yyyy-MM-dd HH:mm:ss&lt;/code&gt;.
 When applied as a JDBC parameter, the method setTimestamp() is used</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="TIMESTAMP">
        <xs:annotation>
          <xs:documentation>Similar to &lt;code&gt;DATETIME&lt;/code&gt;, except for the formatString that is &lt;code&gt;yyyy-MM-dd HH:mm:ss.SSS&lt;/code&gt; by default</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="XMLDATETIME">
        <xs:annotation>
          <xs:documentation>Converts the result from a XML formatted dateTime to a Date.
 When applied as a JDBC parameter, the method setTimestamp() is used</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NUMBER">
        <xs:annotation>
          <xs:documentation>Converts the result to a Number, using decimalSeparator and groupingSeparator.
 When applied as a JDBC parameter, the method setDouble() is used</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="INTEGER">
        <xs:annotation>
          <xs:documentation>Converts the result to an Integer</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BOOLEAN">
        <xs:annotation>
          <xs:documentation>Converts the result to a Boolean</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BINARY">
        <xs:annotation>
          <xs:documentation>Forces the parameter value to be treated as binary data (e.g. when using a SQL BLOB field).
 When applied as a JDBC parameter, the method setBinaryStream() or setBytes() is used</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="CHARACTER">
        <xs:annotation>
          <xs:documentation>Forces the parameter value to be treated as character data (e.g. when using a SQL CLOB field).
 When applied as a JDBC parameter, the method setCharacterStream() or setString() is used</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LIST">
        <xs:annotation>
          <xs:documentation>Used for StoredProcedure OUT parameters when the database type is a {@code CURSOR} or java.sql.JDBCType#REF_CURSOR.
 See also org.frankframework.jdbc.StoredProcedureQuerySender.
 &lt;br/&gt;
 DEPRECATED: Type LIST can also be used in larva test to Convert a List to an xml-string (&amp;lt;items&amp;gt;&amp;lt;item&amp;gt;...&amp;lt;/item&amp;gt;&amp;lt;item&amp;gt;...&amp;lt;/item&amp;gt;&amp;lt;/items&amp;gt;)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="LockTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="T">
        <xs:annotation>
          <xs:documentation>Temporary</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="P">
        <xs:annotation>
          <xs:documentation>Permanent</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="SoapVersionAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="1.1" />
      <xs:enumeration value="1.2" />
      <xs:enumeration value="none">
        <xs:annotation>
          <xs:documentation>No wrapping or unwrapping will be done</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="auto">
        <xs:annotation>
          <xs:documentation>Try to auto-detect the value</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DirectionAttributeValuesType_2">
    <xs:restriction base="xs:string">
      <xs:enumeration value="INPUT" />
      <xs:enumeration value="OUTPUT" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ModeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="I2T">
        <xs:annotation>
          <xs:documentation>ifsa2tibco</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REG">
        <xs:annotation>
          <xs:documentation>Regular</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BIS">
        <xs:annotation>
          <xs:documentation>Business Integration Services</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DirectionAttributeValuesType_3">
    <xs:restriction base="xs:string">
      <xs:enumeration value="SEND" />
      <xs:enumeration value="RECEIVE" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DirectionAttributeValuesType_4">
    <xs:restriction base="xs:string">
      <xs:enumeration value="WRAP" />
      <xs:enumeration value="UNWRAP" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ExitStateAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="SUCCESS" />
      <xs:enumeration value="ERROR" />
      <xs:enumeration value="REJECTED" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DirectionAttributeValuesType_5">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Xml2Adios">
        <xs:annotation>
          <xs:documentation>Transform an Adios-XML file to ASCII-Adios</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Adios2Xml">
        <xs:annotation>
          <xs:documentation>Transform an ASCII-Adios file to Adios-XML</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="LinkMethodAttributeValuesType_2">
    <xs:restriction base="xs:string">
      <xs:enumeration value="MESSAGEID" />
      <xs:enumeration value="CORRELATIONID" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ChecksumTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="MD5" />
      <xs:enumeration value="SHA" />
      <xs:enumeration value="SHA256" />
      <xs:enumeration value="SHA512" />
      <xs:enumeration value="CRC32" />
      <xs:enumeration value="ADLER32" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="FileFormatAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="GZ">
        <xs:annotation>
          <xs:documentation>Gzip format; also used when direction is compress and resultIsContent=&lt;code&gt;true&lt;/code&gt;
 or when direction is decompress and messageIsContent=&lt;code&gt;true&lt;/code&gt;</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ZIP">
        <xs:annotation>
          <xs:documentation>Zip format; also used when direction is compress and resultIsContent=&lt;code&gt;false&lt;/code&gt;
 or when direction is decompress and messageIsContent=&lt;code&gt;false&lt;/code&gt;</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="HeaderCaseAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="LOWERCASE" />
      <xs:enumeration value="UPPERCASE" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DirectionAttributeValuesType_7">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ENCODE" />
      <xs:enumeration value="DECODE" />
      <xs:enumeration value="CDATA2TEXT" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="HashAlgorithmAttributeValuesType_2">
    <xs:restriction base="xs:string">
      <xs:enumeration value="HmacMD5" />
      <xs:enumeration value="HmacSHA1" />
      <xs:enumeration value="HmacSHA256" />
      <xs:enumeration value="HmacSHA384" />
      <xs:enumeration value="HmacSHA512" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="HashEncodingAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Base64" />
      <xs:enumeration value="Hex" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DirectionAttributeValuesType_8">
    <xs:restriction base="xs:string">
      <xs:enumeration value="JSON2XML" />
      <xs:enumeration value="XML2JSON" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="LarvaLogLevelAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="DEBUG" />
      <xs:enumeration value="PIPELINE_MESSAGES_PREPARED_FOR_DIFF" />
      <xs:enumeration value="PIPELINE_MESSAGES" />
      <xs:enumeration value="WRONG_PIPELINE_MESSAGES_PREPARED_FOR_DIFF" />
      <xs:enumeration value="WRONG_PIPELINE_MESSAGES" />
      <xs:enumeration value="STEP_PASSED_FAILED" />
      <xs:enumeration value="SCENARIO_PASSED_FAILED" />
      <xs:enumeration value="SCENARIO_FAILED" />
      <xs:enumeration value="TOTALS" />
      <xs:enumeration value="ERROR" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DirectionAttributeValuesType_6">
    <xs:restriction base="xs:string">
      <xs:enumeration value="OBFUSCATE" />
      <xs:enumeration value="DEOBFUSCATE" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ActionAttributeValuesType_4">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ENCRYPT">
        <xs:annotation>
          <xs:documentation>Encrypts the given input. Requires the publicKey to be set to recipients public key, and recipients to be set to recipients email addresses.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SIGN">
        <xs:annotation>
          <xs:documentation>Encrypts and then signs the given input. On top of the requirements for Encrypt action, signing requires senders to bet set for user's email; and secretKey &amp; secretPassword to be set to private key's path and it's password (password is optional, if private key does not have protection).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DECRYPT">
        <xs:annotation>
          <xs:documentation>Decrypts the given input. Requires secretKey and secretPassword to bet set to private key's path and it's password. Just like signing, password is not required, if private key does not have protection.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="VERIFY">
        <xs:annotation>
          <xs:documentation>Decrypts and verifies the given input. On top of the requirements for Decrypt action, verification expects list of senders' email's and corresponding public keys. However, sender emails does not have to be set, and in that case, this pipe will only validate that someone signed the input.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DocumentActionAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="CONVERT" />
      <xs:enumeration value="COMBINE" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="MessageProtocolAttributeValuesType_3">
    <xs:restriction base="xs:string">
      <xs:enumeration value="RR">
        <xs:annotation>
          <xs:documentation>Request-Reply</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FF">
        <xs:annotation>
          <xs:documentation>Fire &amp; Forget</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ActionAttributeValuesType_5">
    <xs:restriction base="xs:string">
      <xs:enumeration value="SIGN">
        <xs:annotation>
          <xs:documentation>signs the input</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="VERIFY">
        <xs:annotation>
          <xs:documentation>verifies a signature</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ALPHANUMERIC">
        <xs:annotation>
          <xs:documentation>the UUID will not have a fixed length which will be about 42</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NUMERIC">
        <xs:annotation>
          <xs:documentation>a UUID with fixed length 31 will be generated</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ActionAttributeValuesType_3">
    <xs:restriction base="xs:string">
      <xs:enumeration value="OPEN">
        <xs:annotation>
          <xs:documentation>To initiate a new collection</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="WRITE">
        <xs:annotation>
          <xs:documentation>Add an item to to an existing collection</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LAST">
        <xs:annotation>
          <xs:documentation>Combination of WRITE and CLOSE: Add an item to to an existing collection, then finalize the collection</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="CLOSE">
        <xs:annotation>
          <xs:documentation>Finalize the collection</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="MessageLogLevelAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="OFF">
        <xs:annotation>
          <xs:documentation>No logging</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="INFO">
        <xs:annotation>
          <xs:documentation>Logs information from adapter level messages</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DEBUG">
        <xs:annotation>
          <xs:documentation>Logs information from pipe messages</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="AvailableActionAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="STOPADAPTER" />
      <xs:enumeration value="STARTADAPTER" />
      <xs:enumeration value="STOPRECEIVER" />
      <xs:enumeration value="STARTRECEIVER" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="SeverityAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="HARMLESS" />
      <xs:enumeration value="WARNING" />
      <xs:enumeration value="CRITICAL" />
      <xs:enumeration value="FATAL" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="SourceFilteringAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="NONE" />
      <xs:enumeration value="ADAPTER" />
      <xs:enumeration value="SOURCE" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TriggerTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ALARM" />
      <xs:enumeration value="CLEARING" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="EventTypeAttributeValuesType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="TECHNICAL" />
      <xs:enumeration value="FUNCTIONAL" />
      <xs:enumeration value="HEARTBEAT" />
      <xs:enumeration value="CLEARING" />
    </xs:restriction>
  </xs:simpleType>
  <xs:attribute name="value" type="xs:string">
    <xs:annotation>
      <xs:documentation>The value of the parameter, or the base for transformation using xpathExpression or stylesheet, or formatting.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="sessionKey" type="xs:string">
    <xs:annotation>
      <xs:documentation>Key of a PipelineSession-variable. &lt;br/&gt;If specified, the value of the PipelineSession variable is used as input for
 the xpathExpression or stylesheet, instead of the current input message. &lt;br/&gt;If no xpathExpression or stylesheet are
 specified, the value itself is returned. &lt;br/&gt;If the value '*' is specified, all existing sessionkeys are added as
 parameter of which the name starts with the name of this parameter. &lt;br/&gt;If also the name of the parameter has the
 value '*' then all existing sessionkeys are added as parameter (except tsReceived)</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="contextKey" type="xs:string">
    <xs:annotation>
      <xs:documentation>key of message context variable to use as source, instead of the message found from input message or sessionKey itself</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="sessionKeyXPath" type="xs:string">
    <xs:annotation>
      <xs:documentation>Instead of a fixed &lt;code&gt;sessionKey&lt;/code&gt; it's also possible to use a XPath expression applied to the input message to extract the name of the session-variable.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="defaultValue" type="xs:string">
    <xs:annotation>
      <xs:documentation>If the result of sessionKey, xpathExpression and/or stylesheet returns null or an empty string, this value is returned</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="defaultValueMethods" type="xs:string">
    <xs:annotation>
      <xs:documentation>Comma separated list of methods (&lt;code&gt;defaultValue&lt;/code&gt;, &lt;code&gt;sessionKey&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; or &lt;code&gt;input&lt;/code&gt;) to use as default value. Used in the order they appear until a non-null value is found. Default: &lt;code&gt;defaultValue&lt;/code&gt;</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="pattern" type="xs:string">
    <xs:annotation>
      <xs:documentation>Value of parameter is determined using substitution and formatting, following MessageFormat syntax with named parameters. The expression can contain references
 to &lt;code&gt;session-variables&lt;/code&gt; or other &lt;code&gt;parameters&lt;/code&gt; using the {name-of-parameter} and is formatted using java.text.MessageFormat.
 &lt;br/&gt;&lt;b&gt;NB: When referencing other &lt;code&gt;parameters&lt;/code&gt; these MUST be defined before the parameter using pattern substitution.&lt;/b&gt;
 &lt;br/&gt;
 &lt;br/&gt;
 If for instance &lt;code&gt;fname&lt;/code&gt; is a parameter or session-variable that resolves to Eric, then the pattern
 'Hi {fname}, how do you do?' resolves to 'Hi Eric, do you do?'.&lt;br/&gt;
 The following predefined reference can be used in the expression too:&lt;ul&gt;
 &lt;li&gt;{now}: the current system time&lt;/li&gt;
 &lt;li&gt;{uid}: an unique identifier, based on the IP address and java.rmi.server.UID&lt;/li&gt;
 &lt;li&gt;{uuid}: an unique identifier, based on the IP address and java.util.UUID&lt;/li&gt;
 &lt;li&gt;{hostname}: the name of the machine the application runs on&lt;/li&gt;
 &lt;li&gt;{username}: username from the credentials found using authAlias, or the username attribute&lt;/li&gt;
 &lt;li&gt;{password}: password from the credentials found using authAlias, or the password attribute&lt;/li&gt;
 &lt;li&gt;{fixeddate}: fake date, for testing only&lt;/li&gt;
 &lt;li&gt;{fixeduid}: fake uid, for testing only&lt;/li&gt;
 &lt;li&gt;{fixedhostname}: fake hostname, for testing only&lt;/li&gt;
 &lt;/ul&gt;
 A guid can be generated using {hostname}_{uid}, see also
 &lt;a href="http://java.sun.com/j2se/1.4.2/docs/api/java/rmi/server/uid.html"&gt;http://java.sun.com/j2se/1.4.2/docs/api/java/rmi/server/uid.html&lt;/a&gt; for more information about (g)uid's or
 &lt;a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/uuid.html"&gt;http://docs.oracle.com/javase/1.5.0/docs/api/java/util/uuid.html&lt;/a&gt; for more information about uuid's.
 &lt;br/&gt;
 When combining a date or time &lt;code&gt;pattern&lt;/code&gt; like {now} or {fixeddate} with a DATE, TIME, DATETIME or TIMESTAMP &lt;code&gt;type&lt;/code&gt;, the effective value of the attribute
 &lt;code&gt;formatString&lt;/code&gt; must match the effective value of the formatString in the &lt;code&gt;pattern&lt;/code&gt;.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="ignoreUnresolvablePatternElements" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; pattern elements that cannot be resolved to a parameter or sessionKey are silently resolved to an empty string</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="minLength" type="frankInt">
    <xs:annotation>
      <xs:documentation>If set (&gt;=0) and the length of the value of the parameter falls short of this minimum length, the value is padded Default: -1</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="maxLength" type="frankInt">
    <xs:annotation>
      <xs:documentation>If set (&gt;=0) and the length of the value of the parameter exceeds this maximum length, the length is trimmed to this maximum length Default: -1</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="hidden" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the value of the parameter will not be shown in the log (replaced by asterisks) Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="mode">
    <xs:annotation>
      <xs:documentation>Set the mode of the parameter, which determines if the parameter is an INPUT, OUTPUT, or INOUT.
 This parameter only has effect for StoredProcedureQuerySender.
 An OUTPUT parameter does not need to have a value specified, but does need to have the type specified.
 Parameter values will not be updated, but output values will be put into the result of the
 StoredProcedureQuerySender.
 &lt;b/&gt;
 If not specified, the default is INPUT.</xs:documentation>
    </xs:annotation>
    <xs:simpleType>
      <xs:union memberTypes="ParameterModeAttributeValuesType variableRef" />
    </xs:simpleType>
  </xs:attribute>
  <xs:attribute name="inputFolder" type="xs:string">
    <xs:annotation>
      <xs:documentation>Folder that is scanned for files. If not set, the root is scanned</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="inProcessFolder" type="xs:string">
    <xs:annotation>
      <xs:documentation>Folder where files are stored &lt;i&gt;while&lt;/i&gt; being processed</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="processedFolder" type="xs:string">
    <xs:annotation>
      <xs:documentation>Folder where files are stored &lt;i&gt;after&lt;/i&gt; being processed</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="errorFolder" type="xs:string">
    <xs:annotation>
      <xs:documentation>Folder where files are stored &lt;i&gt;after&lt;/i&gt; being processed, in case the exit-state was not equal to &lt;code&gt;success&lt;/code&gt;</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="holdFolder" type="xs:string">
    <xs:annotation>
      <xs:documentation>Folder where messages from the error folder can be put on Hold, temporarily</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="logFolder" type="xs:string">
    <xs:annotation>
      <xs:documentation>Folder where a copy of every file that is received is stored</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="createFolders" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the folders to look for files and to move files to when being processed and after being processed are created if they are specified and do not exist Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="delete" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the file processed will be deleted after being processed, and not stored Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="numberOfBackups" type="frankInt">
    <xs:annotation>
      <xs:documentation>Number of copies held of a file with the same name. Backup files have a dot and a number suffixed to their name. If set to 0, no backups will be kept. Default: 0</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="overwrite" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the destination file will be deleted if it already exists Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="fileTimeSensitive" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the file modification time is used in addition to the filename to determine if a file has been seen before Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="minStableTime" type="frankInt">
    <xs:annotation>
      <xs:documentation>Minimal age of file &lt;i&gt;in milliseconds&lt;/i&gt;, to avoid receiving a file while it is still being written Default: 1000</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="messageIdPropertyKey" type="xs:string">
    <xs:annotation>
      <xs:documentation>Key of Property to use as messageId. If not set, the filename of the file as it was received in the inputFolder is used as the messageId Default: for MailFileSystems: Message-ID</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="disableMessageBrowsers" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, no browsers for process folders are generated Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="wildcard" type="xs:string">
    <xs:annotation>
      <xs:documentation>Filter of files to look for in inputFolder e.g. '*.inp'.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="excludeWildcard" type="xs:string">
    <xs:annotation>
      <xs:documentation>Filter of files to be excluded when looking in inputFolder.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="storeMetadataInSessionKey" type="xs:string">
    <xs:annotation>
      <xs:documentation>If set, an XML with all message properties is provided under this key</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="replyDestinationName" type="xs:string">
    <xs:annotation>
      <xs:documentation>Name of the JMS destination (queue or topic) to use for sending replies. If &lt;code&gt;useReplyTo=true&lt;/code&gt;,
 the sender specified reply destination takes precedence over this one.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="replyMessageType" type="xs:string">
    <xs:annotation>
      <xs:documentation>Value of the JMSType field of the reply message Default: not set by application</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="replyDeliveryMode">
    <xs:annotation>
      <xs:documentation>Controls mode that reply messages are sent with Default: NON_PERSISTENT</xs:documentation>
    </xs:annotation>
    <xs:simpleType>
      <xs:union memberTypes="DeliveryModeAttributeValuesType variableRef" />
    </xs:simpleType>
  </xs:attribute>
  <xs:attribute name="replyPriority" type="frankInt">
    <xs:annotation>
      <xs:documentation>Sets the priority that is used to deliver the reply message. Ranges from 0 to 9. Effectively the default priority is set by JMS to 4, &lt;code&gt;-1&lt;/code&gt; means not set and thus uses the JMS default Default: -1</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="replyMessageTimeToLive" type="frankInt">
    <xs:annotation>
      <xs:documentation>Time &lt;i&gt;in milliseconds&lt;/i&gt; after which the reply-message will expire Default: 0</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="replyEncodingStyleURI" type="xs:string" />
  <xs:attribute name="replyNamespaceURI" type="xs:string" />
  <xs:attribute name="replySoapAction" type="xs:string" />
  <xs:attribute name="soapHeaderSessionKey" type="xs:string">
    <xs:annotation>
      <xs:documentation>sessionKey to store the SOAP header of the incoming message Default: soapHeader</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="messageClass">
    <xs:annotation>
      <xs:documentation>The JMS jakarta.jms.Message class for the outgoing message.
 Currently supported are MessageClass#TEXT for JMS TextMessage,
 MessageClass#BYTES for JMS BytesMessage, or MessageClass#AUTO for auto-determination
 based on whether the input Message is binary or character.
 &lt;p&gt;
 Defaults to MessageClass#AUTO, unless the default is overridden in AppConstants with property {@code jms.messageClass.default}
 &lt;/p&gt;</xs:documentation>
    </xs:annotation>
    <xs:simpleType>
      <xs:union memberTypes="MessageClassAttributeValuesType variableRef" />
    </xs:simpleType>
  </xs:attribute>
  <xs:attribute name="destinationType">
    <xs:annotation>
      <xs:documentation>Type of the messageing destination.
 This function also sets the &lt;code&gt;useTopicFunctions&lt;/code&gt; field,
 that controls whether Topic functions are used or Queue functions. Default: QUEUE</xs:documentation>
    </xs:annotation>
    <xs:simpleType>
      <xs:union memberTypes="DestinationTypeAttributeValuesType variableRef" />
    </xs:simpleType>
  </xs:attribute>
  <xs:attribute name="acknowledgeMode">
    <xs:annotation>
      <xs:documentation>If not transacted, the way the application informs the JMS provider that it has successfully received a message. Default: auto</xs:documentation>
    </xs:annotation>
    <xs:simpleType>
      <xs:union memberTypes="AcknowledgeModeAttributeValuesType variableRef" />
    </xs:simpleType>
  </xs:attribute>
  <xs:attribute name="subscriberType">
    <xs:annotation>
      <xs:documentation>Only applicable for topics Default: DURABLE</xs:documentation>
    </xs:annotation>
    <xs:simpleType>
      <xs:union memberTypes="SubscriberTypeAttributeValuesType variableRef" />
    </xs:simpleType>
  </xs:attribute>
  <xs:attribute name="queueConnectionFactoryName" type="xs:string">
    <xs:annotation>
      <xs:documentation>Used when destinationType = QUEUE.
 The JNDI-name of the queueConnectionFactory to use to connect to a &lt;code&gt;queue&lt;/code&gt; if #isTransacted() returns &lt;code&gt;false&lt;/code&gt;.
 The corresponding connection factory should be configured not to support XA transactions.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="topicConnectionFactoryName" type="xs:string">
    <xs:annotation>
      <xs:documentation>Used when destinationType = TOPIC.
 The JNDI-name of the connection factory to use to connect to a &lt;i&gt;topic&lt;/i&gt; if #isTransacted() returns &lt;code&gt;false&lt;/code&gt;.
 The corresponding connection factory should be configured not to support XA transactions.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="correlationIdToHex" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>Transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part).
 Useful when sending messages to MQ which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: MQJMS1044: String is not a valid hexadecimal number Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="correlationIdToHexPrefix" type="xs:string">
    <xs:annotation>
      <xs:documentation>Prefix to check before executing correlationIdToHex. If empty (and correlationIdToHex equals true) all correlationid's are transformed, this is useful in case you want the entire correlationId to be transformed (for example when the receiving party doesn't allow characters like a colon to be present in the correlationId). Default: id:</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="messageTimeToLive" type="frankInt">
    <xs:annotation>
      <xs:documentation>The time &lt;i&gt;in milliseconds&lt;/i&gt; it takes for the message to expire. If the message is not consumed before, it will be lost. Must be a positive value for request/reply type of messages, 0 disables the expiry timeout Default: 0</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="correlationIdMaxLength" type="frankInt">
    <xs:annotation>
      <xs:documentation>If set (&gt;=0) and the length of the correlationId exceeds this maximum length, the correlationId is trimmed from the left side of a string to this maximum length Default: -1</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="messageSelector" type="xs:string">
    <xs:annotation>
      <xs:documentation>If set, the value of this attribute is used as a selector to filter messages. Default: 0 (unlimited)</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="lookupDestination" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If set &lt;code&gt;false&lt;/code&gt;, the destinationName is used directly instead of performing a JNDI lookup Default: true</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="authentication" type="xs:string">
    <xs:annotation>
      <xs:documentation>maps to the field context.security_authentication</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="credentials" type="xs:string">
    <xs:annotation>
      <xs:documentation>username to connect to context, maps to context.security_credentials</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="initialContextFactoryName" type="xs:string">
    <xs:annotation>
      <xs:documentation>class to use as initial context factory</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="providerURL" type="xs:string">
    <xs:annotation>
      <xs:documentation>Sets the value of providerURL</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="securityProtocol" type="xs:string">
    <xs:annotation>
      <xs:documentation>maps to the field context.security_protocol</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="urlPkgPrefixes" type="xs:string">
    <xs:annotation>
      <xs:documentation>maps to the field context.url_pkg_prefixes</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="principal" type="xs:string">
    <xs:annotation>
      <xs:documentation>username to connect to context, maps to context.security_principal</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="jndiAuthAlias" type="xs:string">
    <xs:annotation>
      <xs:documentation>authentication alias, may be used to override principal and credential-settings</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="jndiContextPrefix" type="xs:string" />
  <xs:attribute name="jndiProperties" type="xs:string" />
  <xs:attribute name="peekUntransacted" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>when true, then PollingListener container will execute getRawMessage() only when hasRawMessageAvailable() has returned true. This avoids rolling back a lot of XA transactions, that appears to be problematic on MS SQL Server Default: true</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="peekQuery" type="xs:string">
    <xs:annotation>
      <xs:documentation>(only used when &lt;code&gt;peekUntransacted&lt;/code&gt;=&lt;code&gt;true&lt;/code&gt;) peek query to determine if the select query should be executed. Peek queries are, unlike select queries, executed without a transaction and without a rowlock Default: selectQuery</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="trace" type="frankBoolean" />
  <xs:attribute name="datasourceName" type="xs:string">
    <xs:annotation>
      <xs:documentation>JNDI name of datasource to be used, can be configured via jmsRealm, too Default: jdbc.datasource.default</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="connectionsArePooled" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>informs the sender that the obtained connection is from a pool (and thus connections are reused and never closed) Default: true</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="tableAlias" type="xs:string">
    <xs:annotation>
      <xs:documentation>Alias of the table, that can be used in selectCondition Default: t</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="orderField" type="xs:string">
    <xs:annotation>
      <xs:documentation>(optional) Comma separated list of fields determining the order in which messages are processed</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="maxCommentLength" type="frankInt">
    <xs:annotation>
      <xs:documentation>(optional) Maximum length of strings to be stored in commentField, or -1 for unlimited Default: 1000</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="selectCondition" type="xs:string">
    <xs:annotation>
      <xs:documentation>Additional condition for a row to belong to this TableListener. Impacts all process states</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="correlationIdFieldIndex" type="frankInt">
    <xs:annotation>
      <xs:documentation>Index of the field in the ImportParameterList of the RFC function that contains the correlationId Default: 0</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="correlationIdFieldName" type="xs:string">
    <xs:annotation>
      <xs:documentation>Name of the field in the ImportParameterList of the RFC function that contains the correlationId</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="requestFieldIndex" type="frankInt">
    <xs:annotation>
      <xs:documentation>Index of the field in the ImportParameterList of the RFC function that contains the whole request message contents Default: 0</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="requestFieldName" type="xs:string">
    <xs:annotation>
      <xs:documentation>Name of the field in the ImportParameterList of the RFC function that contains the whole request message contents</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="replyFieldIndex" type="frankInt">
    <xs:annotation>
      <xs:documentation>Index of the field in the ExportParameterList of the RFC function that contains the whole reply message contents Default: 0</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="replyFieldName" type="xs:string">
    <xs:annotation>
      <xs:documentation>Name of the field in the ExportParameterList of the RFC function that contains the whole reply message contents</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="packageContent" type="xs:string">
    <xs:annotation>
      <xs:documentation>Controls if the returned package content is db2 format or xml format.
 Possible values:
 &lt;ul&gt;
 &lt;li&gt;select:&lt;/li&gt; xml content s expected
 &lt;li&gt;&lt;i&gt;anything else&lt;/i&gt;:&lt;/li&gt; db2 content is expected
 &lt;/ul&gt;</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="scalar" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>When &lt;code&gt;true&lt;/code&gt;, the value of the first column of the first row (or the startrow) is returned as the only result, as a simple non-xml value Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="scalarExtended" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>When &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;scalar&lt;/code&gt; is also &lt;code&gt;true&lt;/code&gt;, but returns no value, one of the following is returned:
 &lt;ul&gt;
 &lt;li&gt;'[absent]' no row is found&lt;/li&gt;
 &lt;li&gt;'[null]' a row is found, but the value is a SQL-NULL&lt;/li&gt;
 &lt;li&gt;'[empty]' a row is found, but the value is a empty string&lt;/li&gt;
 &lt;/ul&gt; Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="nullValue" type="xs:string">
    <xs:annotation>
      <xs:documentation>Value used in result as contents of fields that contain no value (sql-null) Default: &lt;i&gt;empty string&lt;/i&gt;</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="resultQuery" type="xs:string">
    <xs:annotation>
      <xs:documentation>Query that can be used to obtain result of side-effect of update-query, like generated value of sequence. Example: SELECT mysequence.currval FROM dual</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="useNamedParams" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>Named parameters will be auto-detected by default. Every string in the query which equals &lt;code&gt;?{paramname}&lt;/code&gt; will be replaced by the value of the corresponding parameter. The parameters don't need to be in the correct order and unused parameters are skipped.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="includeFieldDefinition" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the result contains besides the returned rows also includes a header with information about the fetched fields Default: application default (true)</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="trimSpaces" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>Remove trailing blanks from all result values. Default: true</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="synchronous" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>When &lt;code&gt;true&lt;/code&gt;, the result of sendMessage is the reply of the request. Default: true</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="closeOutputstreamOnExit" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>When set to &lt;code&gt;false&lt;/code&gt;, the Outputstream is not closed after BLOB or CLOB has been written to it Default: true</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="streamCharset" type="xs:string">
    <xs:annotation>
      <xs:documentation>Charset used when reading a stream (that is e.g. going to be written to a BLOB or CLOB). When empty, the stream is copied directly to the BLOB, without conversion</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="prettyPrint" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If true and scalar=false, multiline indented XML is produced Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="destinationParam" type="xs:string">
    <xs:annotation>
      <xs:documentation>Parameter that is used, if specified and not empty, to determine the destination. Overrides the &lt;code&gt;destination&lt;/code&gt; attribute</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="replyToName" type="xs:string">
    <xs:annotation>
      <xs:documentation>Name of the queue the reply is expected on. This value is sent in the JMSReplyTo-header with the message. Default: a dynamically generated temporary destination</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="linkMethod">
    <xs:annotation>
      <xs:documentation>(Only used when &lt;code&gt;synchronous=true&lt;/code&gt; and &lt;code&gt;replyToName&lt;/code&gt; is set). Indicates whether the server uses the correlationId from the pipeline,
 the correlationId from the message or the messageId in the correlationId field of the reply. This requires the sender to have set the correlationId at the time of sending. Default: MESSAGEID</xs:documentation>
    </xs:annotation>
    <xs:simpleType>
      <xs:union memberTypes="LinkMethodAttributeValuesType variableRef" />
    </xs:simpleType>
  </xs:attribute>
  <xs:attribute name="messageType" type="xs:string">
    <xs:annotation>
      <xs:documentation>Value of the JMSType field Default: not set by application</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="priority" type="frankInt">
    <xs:annotation>
      <xs:documentation>Sets the priority that is used to deliver the message. Ranges from 0 to 9. Defaults to -1, meaning not set. Effectively the default priority is set by JMS to 4 Default: -1</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="encodingStyleURI" type="xs:string">
    <xs:annotation>
      <xs:documentation>SOAP encoding style URI</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="serviceNamespaceURI" type="xs:string">
    <xs:annotation>
      <xs:documentation>SOAP service namespace URI</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="soapHeaderParam" type="xs:string">
    <xs:annotation>
      <xs:documentation>Name of parameter containing SOAP header Default: soapHeader</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="replySoapHeaderSessionKey" type="xs:string">
    <xs:annotation>
      <xs:documentation>session key to store SOAP header of reply Default: replySoapHeader</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="responseHeadersToSessionKeys" type="xs:string">
    <xs:annotation>
      <xs:documentation>A list of JMS headers of the response to add to the PipeLineSession</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="batchSize" type="frankInt">
    <xs:annotation>
      <xs:documentation>When set larger than 0 and used as a child of an IteratingPipe, then the database calls are made in batches of this size. Only for queryType=other. Default: 0</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="url" type="xs:string">
    <xs:annotation>
      <xs:documentation>URL or base of URL to be used</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="urlParam" type="xs:string">
    <xs:annotation>
      <xs:documentation>Parameter that is used to obtain URL; overrides url-attribute. Default: url</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="methodType">
    <xs:annotation>
      <xs:documentation>The HTTP Method used to execute the request Default: &lt;code&gt;GET&lt;/code&gt;</xs:documentation>
    </xs:annotation>
    <xs:simpleType>
      <xs:union memberTypes="HttpMethodAttributeValuesType_2 variableRef" />
    </xs:simpleType>
  </xs:attribute>
  <xs:attribute name="contentType" type="xs:string">
    <xs:annotation>
      <xs:documentation>Content-Type (superset of mimetype + charset) of the request, for &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt; and &lt;code&gt;PATCH&lt;/code&gt; methods Default: text/html, when postType=&lt;code&gt;RAW&lt;/code&gt;</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="charSet" type="xs:string">
    <xs:annotation>
      <xs:documentation>Charset of the request. Typically only used on &lt;code&gt;PUT&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; requests. Default: UTF-8</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="headersParams" type="xs:string">
    <xs:annotation>
      <xs:documentation>Comma separated list of parameter names which should be set as HTTP headers</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="parametersToSkipWhenEmpty" type="xs:string">
    <xs:annotation>
      <xs:documentation>Comma separated list of parameter names that should not be added as request or body parameter, or as HTTP header, if they are empty. Set to '*' for this behaviour for all parameters</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="xhtml" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the HTML response is transformed to XHTML Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="resultStatusCodeSessionKey" type="xs:string">
    <xs:annotation>
      <xs:documentation>If set, the status code of the HTTP response is put in the specified sessionKey and the (error or okay) response message is returned.
 Setting this property has a side effect. If a 4xx or 5xx result code is returned and if the configuration does not implement
 the specific forward for the returned HTTP result code, then the success forward is followed instead of the exception forward.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="sharedResourceRef" type="xs:string" />
  <xs:attribute name="maxConnections" type="frankInt">
    <xs:annotation>
      <xs:documentation>The maximum number of concurrent connections Default: 10</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="maxExecuteRetries" type="frankInt">
    <xs:annotation>
      <xs:documentation>The maximum number of times the execution is retried Default: 1 (for repeatable messages) else 0</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="tokenEndpoint" type="xs:string">
    <xs:annotation>
      <xs:documentation>Endpoint to obtain OAuth accessToken. If &lt;code&gt;authAlias&lt;/code&gt; or &lt;code&gt;username&lt;/code&gt;( and &lt;code&gt;password&lt;/code&gt;) are specified,
 then a PasswordGrant is used, otherwise a ClientCredentials grant. The obtained accessToken will be added to the regular requests
 in an HTTP Header 'Authorization' with a 'Bearer' prefix.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="tokenExpiry" type="frankInt">
    <xs:annotation>
      <xs:documentation>If set to a non-negative value, then determines the time (in seconds) after which the token will be refreshed. Otherwise the token
 will be refreshed when it is half way its lifetime as defined by the &lt;code&gt;expires_in&lt;/code&gt; clause of the token response,
 or when the regular server returns a 401 status with a challenge.
 If not specified, and the accessTokens lifetime is not found in the token response, the accessToken will not be refreshed preemptively. Default: -1</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="clientAlias" type="xs:string">
    <xs:annotation>
      <xs:documentation>Alias used to obtain client_id and client_secret for authentication to &lt;code&gt;tokenEndpoint&lt;/code&gt;</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="clientId" type="xs:string">
    <xs:annotation>
      <xs:documentation>Client_id used in authentication to &lt;code&gt;tokenEndpoint&lt;/code&gt;</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="clientSecret" type="xs:string">
    <xs:annotation>
      <xs:documentation>Client_secret used in authentication to &lt;code&gt;tokenEndpoint&lt;/code&gt;</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="scope" type="xs:string">
    <xs:annotation>
      <xs:documentation>Space or comma separated list of scope items requested for accessToken, e.g. &lt;code&gt;read write&lt;/code&gt;. Only used when &lt;code&gt;tokenEndpoint&lt;/code&gt; is specified</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="authenticatedTokenRequest" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>if set true, clientId and clientSecret will be added as Basic Authentication header to the tokenRequest, instead of as request parameters</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="proxyHost" type="xs:string">
    <xs:annotation>
      <xs:documentation>Proxy host</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="proxyPort" type="frankInt">
    <xs:annotation>
      <xs:documentation>Proxy port Default: 80</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="proxyAuthAlias" type="xs:string">
    <xs:annotation>
      <xs:documentation>Alias used to obtain credentials for authentication to proxy</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="proxyUsername" type="xs:string">
    <xs:annotation>
      <xs:documentation>Proxy username</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="proxyPassword" type="xs:string">
    <xs:annotation>
      <xs:documentation>Proxy password</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="proxyRealm" type="xs:string">
    <xs:annotation>
      <xs:documentation>Proxy realm</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="prefillProxyAuthCache" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>Create a pre-emptive login context for the proxy connection(s).</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="disableCookies" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>Disables the use of cookies, making the sender completely stateless Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="keystore" type="xs:string">
    <xs:annotation>
      <xs:documentation>resource URL to keystore or certificate to be used for authentication. If none specified, the JVMs default keystore will be used.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="keystoreType">
    <xs:annotation>
      <xs:documentation>Type of keystore Default: pkcs12</xs:documentation>
    </xs:annotation>
    <xs:simpleType>
      <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
    </xs:simpleType>
  </xs:attribute>
  <xs:attribute name="keystoreAuthAlias" type="xs:string">
    <xs:annotation>
      <xs:documentation>Authentication alias used to obtain keystore password</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="keystorePassword" type="xs:string">
    <xs:annotation>
      <xs:documentation>Default password to access keystore</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="keyManagerAlgorithm" type="xs:string">
    <xs:annotation>
      <xs:documentation>Key manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="keystoreAlias" type="xs:string">
    <xs:annotation>
      <xs:documentation>Alias to obtain specific certificate or key in keystore</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="keystoreAliasAuthAlias" type="xs:string">
    <xs:annotation>
      <xs:documentation>Authentication alias to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="keystoreAliasPassword" type="xs:string">
    <xs:annotation>
      <xs:documentation>Default password to authenticate access to certificate or key indicated by &lt;code&gt;keystoreAlias&lt;/code&gt;</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="truststore" type="xs:string">
    <xs:annotation>
      <xs:documentation>Resource URL to truststore to be used for authenticating peer. If none specified, the JVMs default truststore will be used.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="truststoreAuthAlias" type="xs:string">
    <xs:annotation>
      <xs:documentation>Authentication alias used to obtain truststore password</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="truststorePassword" type="xs:string">
    <xs:annotation>
      <xs:documentation>Default password to access truststore</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="truststoreType">
    <xs:annotation>
      <xs:documentation>Type of truststore Default: jks</xs:documentation>
    </xs:annotation>
    <xs:simpleType>
      <xs:union memberTypes="KeystoreTypeAttributeValuesType variableRef" />
    </xs:simpleType>
  </xs:attribute>
  <xs:attribute name="trustManagerAlgorithm" type="xs:string">
    <xs:annotation>
      <xs:documentation>Trust manager algorithm. Can be left empty to use the servers default algorithm</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="verifyHostname" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, the hostname in the certificate will be checked against the actual hostname of the peer</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="allowSelfSignedCertificates" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, self signed certificates are accepted Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="ignoreCertificateExpiredException" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, CertificateExpiredExceptions are ignored Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="followRedirects" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If &lt;code&gt;true&lt;/code&gt;, a redirect request will be honoured, e.g. to switch to HTTPS Default: true</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="ignoreRedirects" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If true, besides http status code 200 (OK) also the code 301 (MOVED_PERMANENTLY), 302 (MOVED_TEMPORARILY) and 307 (TEMPORARY_REDIRECT) are considered successful Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="staleChecking" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>Controls whether connections checked to be stale, i.e. appear open, but are not. Default: true</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="staleTimeout" type="frankInt">
    <xs:annotation>
      <xs:documentation>Used when &lt;code&gt;staleChecking&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Timeout after which an idle connection will be validated before being used. Default: 5000 ms</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="connectionTimeToLive" type="frankInt">
    <xs:annotation>
      <xs:documentation>Maximum Time to Live for connections in the pool. No connection will be re-used past its timeToLive value. Default: 900 s</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="connectionIdleTimeout" type="frankInt">
    <xs:annotation>
      <xs:documentation>Maximum Time for connection to stay idle in the pool. Connections that are idle longer will periodically be evicted from the pool Default: 10 s</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="protocol" type="xs:string">
    <xs:annotation>
      <xs:documentation>Secure socket protocol (such as 'TLSv1.2') to use when a SSLContext object is generated. Default: TLSv1.2</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="supportedCipherSuites" type="xs:string">
    <xs:annotation>
      <xs:documentation>Allows you to choose which CipherSuites are used when connecting to an endpoint. Works in tandem with {@code protocol} as the provided Suite may not be valid for the provided Protocol
 See the Java Security Standard Algorithm Names Specification for all available options. Note that these may differ depending on the JRE you're using.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="debugInput" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If set &lt;code&gt;true&lt;/code&gt; the input is written to the log file, at DEBUG level Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="userId" type="xs:string">
    <xs:annotation>
      <xs:documentation>userId on the smtphost</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="defaultSubject" type="xs:string">
    <xs:annotation>
      <xs:documentation>Set the default value of the subject: header, if not specified in message itself</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="defaultFrom" type="xs:string">
    <xs:annotation>
      <xs:documentation>Set the default from: header, if not specified in message itself</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="defaultAttachmentName" type="xs:string">
    <xs:annotation>
      <xs:documentation>When this name is used, it will be followed by a number which is equal to the node's position Default: attachment</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="defaultMessageType" type="xs:string">
    <xs:annotation>
      <xs:documentation>when messageType is not specified defaultMessageType will be used Default: text/plain</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="defaultMessageBase64" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>when messageBase64 is not specified defaultMessageBase64 will be used Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="bounceAddress" type="xs:string">
    <xs:annotation>
      <xs:documentation>NDR return address when mail cannot be delivered. This adds a Return-Path header Default: MAIL FROM attribute</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="domainWhitelist" type="xs:string">
    <xs:annotation>
      <xs:documentation>Comma separated list of domains to which mails can be send, domains not on the list are filtered out. Empty allows all domains</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="type" type="xs:string">
    <xs:annotation>
      <xs:documentation>Possible values are &lt;code&gt;E&lt;/code&gt; (error store), &lt;code&gt;M&lt;/code&gt; (message store), &lt;code&gt;L&lt;/code&gt; (message log for Pipe) or &lt;code&gt;A&lt;/code&gt; (message log for Receiver).&lt;br/&gt;
 Receiver will always set type to &lt;code&gt;E&lt;/code&gt; for errorStorage and always set type to &lt;code&gt;A&lt;/code&gt; for messageLog. SenderPipe will set type to &lt;code&gt;L&lt;/code&gt; for messageLog (when type isn't specified).&lt;br/&gt;
 See MessageStoreSender for type &lt;code&gt;M&lt;/code&gt;. Default: &lt;code&gt;E&lt;/code&gt; for errorStorage on Receiver&lt;br/&gt;&lt;code&gt;A&lt;/code&gt; for messageLog on Receiver&lt;br/&gt;&lt;code&gt;L&lt;/code&gt; for messageLog on Pipe</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="slotIdField" type="xs:string">
    <xs:annotation>
      <xs:documentation>The name of the column slotids are stored in Default: SLOTID</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="typeField" type="xs:string">
    <xs:annotation>
      <xs:documentation>The name of the column types are stored in Default: TYPE</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="hostField" type="xs:string">
    <xs:annotation>
      <xs:documentation>The name of the column that stores the hostname of the server Default: HOST</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="sequenceName" type="xs:string">
    <xs:annotation>
      <xs:documentation>The name of the sequence used to generate the primary key, for DBMSes that use sequences, like Oracle Default: seq_ibisstore</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="checkTable" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, checks are performed if the table exists and is properly created Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="messageFieldType" type="xs:string">
    <xs:annotation>
      <xs:documentation>The type of the column message themselves are stored in</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="keyFieldType" type="xs:string">
    <xs:annotation>
      <xs:documentation>The type of the column that contains the primary key of the table</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="dateFieldType" type="xs:string">
    <xs:annotation>
      <xs:documentation>The type of the column the timestamps are stored in</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="textFieldType" type="xs:string">
    <xs:annotation>
      <xs:documentation>The type of the columns messageId and correlationId, slotId and comments are stored in. N.B. &lt;code&gt;(100)&lt;/code&gt; is appended for id's, &lt;code&gt;(1000)&lt;/code&gt; is appended for comments.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="retention" type="frankInt">
    <xs:annotation>
      <xs:documentation>The time (in days) to keep the record in the database before making it eligible for deletion by a cleanup process. when set to -1, the record will live on forever Default: 30</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="schemaOwner4Check" type="xs:string">
    <xs:annotation>
      <xs:documentation>Schema owner to be used to check the database Default: &amp;lt;current_schema&amp;gt; (only for oracle)</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="storeFullMessage" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If set to &lt;code&gt;true&lt;/code&gt;, the full message is stored with the log. Can be set to &lt;code&gt;false&lt;/code&gt; to reduce table size, by avoiding to store the full message Default: true</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="transactionTimeout" type="frankInt">
    <xs:annotation>
      <xs:documentation>Timeout (in seconds) of transaction started to process a message. Default: &lt;code&gt;0&lt;/code&gt; (use system default)</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="transactionAttribute">
    <xs:annotation>
      <xs:documentation>The &lt;code&gt;transactionAttribute&lt;/code&gt; declares transactional behavior of execution. It applies both to database transactions and XA transactions.
 The pipeline uses this to start a new transaction or suspend the current one when required.
 For developers: it is equal to &lt;a href=\"https://docs.oracle.com/javaee/7/tutorial/transactions003.htm\"&gt;EJB transaction attribute&lt;/a&gt;.
 Possible values for transactionAttribute:
   &lt;table border=\"1\"&gt;
     &lt;tr&gt;&lt;th&gt;transactionAttribute&lt;/th&gt;&lt;th&gt;callers Transaction&lt;/th&gt;&lt;th&gt;Pipeline excecuted in Transaction&lt;/th&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Required&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;RequiresNew&lt;/td&gt; &lt;td&gt;none&lt;/td&gt;&lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T2&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Mandatory&lt;/td&gt;   &lt;td&gt;none&lt;/td&gt;&lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;NotSupported&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Supports&lt;/td&gt;    &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
  										      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;T1&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td colspan=\"1\" rowspan=\"2\"&gt;Never&lt;/td&gt;       &lt;td&gt;none&lt;/td&gt;&lt;td&gt;none&lt;/td&gt;&lt;/tr&gt;
 											      &lt;tr&gt;&lt;td&gt;T1&lt;/td&gt;  &lt;td&gt;error&lt;/td&gt;&lt;/tr&gt;
   &lt;/table&gt; Default: Supports</xs:documentation>
    </xs:annotation>
    <xs:simpleType>
      <xs:union memberTypes="TransactionAttributeAttributeValuesType variableRef" />
    </xs:simpleType>
  </xs:attribute>
  <xs:attribute name="getInputFromSessionKey" type="xs:string">
    <xs:annotation>
      <xs:documentation>If set, input is taken from this session key, instead of regular input</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="getInputFromFixedValue" type="xs:string">
    <xs:annotation>
      <xs:documentation>If set, this fixed value is taken as input, instead of regular input</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="emptyInputReplacement" type="xs:string">
    <xs:annotation>
      <xs:documentation>If set and the input is empty, this fixed value is taken as input</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="preserveInput" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the result of the pipe is replaced with the original input (i.e. the input before configured replacements of &lt;code&gt;getInputFromSessionKey&lt;/code&gt;, &lt;code&gt;getInputFromFixedValue&lt;/code&gt; or &lt;code&gt;emptyInputReplacement&lt;/code&gt;)</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="storeResultInSessionKey" type="xs:string">
    <xs:annotation>
      <xs:documentation>If set, the pipe result is copied to a session key that has the name defined by this attribute. The
 pipe result is still written as the output message as usual.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="maxThreads" type="frankInt">
    <xs:annotation>
      <xs:documentation>The maximum number of threads that may messages simultaneously.
 A value of 0 indicates an unlimited number of threads. Default: 0</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="chompCharSize" type="xs:string">
    <xs:annotation>
      <xs:documentation>If set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment)</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="elementToMove" type="xs:string">
    <xs:annotation>
      <xs:documentation>If set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionKey: + &lt;code&gt;elementToMoveSessionKey&lt;/code&gt; + }</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="elementToMoveSessionKey" type="xs:string">
    <xs:annotation>
      <xs:documentation>(Only used when &lt;code&gt;elementToMove&lt;/code&gt; is set) Name of the session key under which the character data is stored Default: ref_ + the name of the element</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="elementToMoveChain" type="xs:string">
    <xs:annotation>
      <xs:documentation>Like &lt;code&gt;elementToMove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe')</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="durationThreshold" type="frankInt">
    <xs:annotation>
      <xs:documentation>If durationThreshold &gt;=0 and the duration of the message processing exceeded the value specified (in milliseconds) the message is logged informatory to be analyzed Default: -1</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="removeCompactMsgNamespaces" type="frankBoolean" />
  <xs:attribute name="restoreMovedElements" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, compacted messages in the result are restored to their original format (see also  #setElementToMove(java.lang.String))</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="sizeStatistics" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>Collect and aggregate Message size statistics</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="writeToSecLog" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt; a record is written to the security log when the pipe has finished successfully</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="secLogSessionKeys" type="xs:string">
    <xs:annotation>
      <xs:documentation>(only used when &lt;code&gt;writeToSecLog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="logIntermediaryResults" type="xs:string">
    <xs:annotation>
      <xs:documentation>when set, the value in AppConstants is overwritten (for this pipe only)</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="hideRegex" type="xs:string">
    <xs:annotation>
      <xs:documentation>Regular expression to mask strings in the log. For example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt;
 will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level,
 so a {@code hideRegex} set on one pipe affects all pipes in the pipeline (and multiple values in different pipes are combined into a single regex).
 The regular expressions are matched against part of the log lines. See int)
 with {@code mode = 0} for how regular expressions are matched and replaced.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="outputSoapBody" type="xs:string">
    <xs:annotation>
      <xs:documentation>Identical to the &lt;code&gt;soapBody&lt;/code&gt; attribute except that it's used for the output message instead of the input message. For more information see &lt;a href=\"#note1\"&gt;note 1&lt;/a&gt;</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="soapHeader" type="xs:string">
    <xs:annotation>
      <xs:documentation>Name of the child element of the SOAP header, or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap header, for example to allow element x and an empty soap header use: x,)</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="soapHeaderNamespace" type="xs:string">
    <xs:annotation>
      <xs:documentation>Can be used when the SOAP header element exists multiple times</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="soapVersion">
    <xs:annotation>
      <xs:documentation>SOAP envelope XSD version to use Default: 1.1</xs:documentation>
    </xs:annotation>
    <xs:simpleType>
      <xs:union memberTypes="SoapVersionAttributeValuesType variableRef" />
    </xs:simpleType>
  </xs:attribute>
  <xs:attribute name="allowPlainXml" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>Allow plain XML, without a SOAP Envelope, too. Be aware that setting this true inhibits the capability to test for exit specific response roots in SOAP messages Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="ignoreUnknownNamespaces" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>Ignore namespaces in the input message which are unknown. If the XSD used has elementFormDefault=unqualified, it is necessary to set this to true. Be aware, however, that
 this will inhibit the validator to detect validation failures of namespaceless subelements of the SoapBody. Default: true when &lt;code&gt;schema&lt;/code&gt; or &lt;code&gt;noNamespaceSchemaLocation&lt;/code&gt; is used, false otherwise</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="schemaLocation" type="xs:string">
    <xs:annotation>
      <xs:documentation>Pairs of URI references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name).&lt;br/&gt;
 The syntax is the same as for schemaLocation attributes in instance documents: e.g, "http://www.example.com file%20name.xsd".&lt;br/&gt;
 The user can specify more than one XML Schema in the list.&lt;br/&gt;
 &lt;b&gt;Note&lt;/b&gt; that spaces are considered separators for this attributed. This means that, for example, spaces in filenames should be escaped to %20.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
    <xs:annotation>
      <xs:documentation>A uri reference as a hint as to the location of a schema document with no target namespace.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="responseRoot" type="xs:string">
    <xs:annotation>
      <xs:documentation>Name of the response root element, or a comma separated list of element names. The validation fails if the root element is not present in the list. N.B. for WSDL generation only the first element is used</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="fullSchemaChecking" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>Enable full schema grammar constraint checking, including checking which
 may be time-consuming or memory intensive. Currently, particle unique
 attribution constraint checking and particle derivation restriction
 checking are controlled by this option.
 &lt;p&gt;
 see property
 http://apache.org/xml/features/validation/schema-full-checking
 &lt;/p&gt; Default: &lt;code&gt;false&lt;/code&gt;</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="throwException" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>Should the XmlValidator throw a PipeRunexception on a validation error. If not, a forward with name 'failure' must be defined. Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="reasonSessionKey" type="xs:string">
    <xs:annotation>
      <xs:documentation>If set: key of session variable to store reasons of mis-validation in Default: failureReason</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="xmlReasonSessionKey" type="xs:string">
    <xs:annotation>
      <xs:documentation>Like &lt;code&gt;reasonSessionKey&lt;/code&gt; but stores reasons in xml format and more extensive Default: xmlFailureReason</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="validateFile" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. Otherwise the input itself is validated Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="addNamespaceToSchema" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
    <xs:annotation>
      <xs:documentation>Comma separated list of schemaLocations which are excluded from an import or include in the schema document</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the comparison for importedSchemaLocationsToIgnore is done on base filename without any path Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
    <xs:annotation>
      <xs:documentation>Comma separated list of namespaces which are excluded from an import or include in the schema document</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="warn" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, send warnings to logging and console about syntax problems in the configured schema('s).
 Alternatively, warnings can be switched off using suppression properties XSD_VALIDATION_WARNINGS_SUPPRESS_KEY, XSD_VALIDATION_ERROR_SUPPRESS_KEY and XSD_VALIDATION_FATAL_ERROR_SUPPRESS_KEY Default: true</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="ignoreCaching" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>If set &lt;code&gt;true&lt;/code&gt;, the number for caching validators in appConstants is ignored and no caching is done (for this validator only) Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="xmlSchemaVersion" type="xs:string">
    <xs:annotation>
      <xs:documentation>If set to &lt;code&gt;1.0&lt;/code&gt;, Xerces's previous XML Schema factory will be used, which would make all XSD 1.1 features illegal. The default behaviour can also be set with &lt;code&gt;xsd.processor.version&lt;/code&gt; property. Default: &lt;code&gt;1.1&lt;/code&gt;</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="rootElementSessionKey" type="xs:string">
    <xs:annotation>
      <xs:documentation>Key of session variable to store the name of the root element</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="rootNamespaceSessionKey" type="xs:string">
    <xs:annotation>
      <xs:documentation>Key of session variable to store the namespace of the root element</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="schemaSessionKey" type="xs:string">
    <xs:annotation>
      <xs:documentation>Session key for retrieving a schema</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="itemNoSessionKey" type="xs:string">
    <xs:annotation>
      <xs:documentation>Key of session variable to store number of items processed, i.e. the position or index in the set of items to be processed. When handling the first item, the value will be 1.</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="maxItems" type="frankInt">
    <xs:annotation>
      <xs:documentation>The maximum number of items returned. The (default) value of 0 means unlimited, all available items will be returned. Special forward maxItemsReached can be configured to follow Default: 0</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="stopConditionXPathExpression" type="xs:string">
    <xs:annotation>
      <xs:documentation>Expression evaluated on each result and forwards to [stopConditionMet] forward if configured.
 Iteration stops if condition returns anything other than an empty result. To test for the root element to have an attribute 'finished' with the value 'yes', the expression &lt;code&gt;*[@finished='yes']&lt;/code&gt; can be used.
 This can be used if the condition to stop can be derived from the item result. To stop after a maximum number of items has been processed, use &lt;code&gt;maxItems&lt;/code&gt;.
 Previous versions documented that &lt;code&gt;position()=2&lt;/code&gt; could be used. This is not working as expected; Use maxItems instead</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="ignoreExceptions" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>When &lt;code&gt;true&lt;/code&gt; ignore any exception thrown by executing sender Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="collectResults" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>Controls whether all the results of each iteration will be collected in one result message. If set &lt;code&gt;false&lt;/code&gt;, only a small summary is returned.
 Setting this attributes to &lt;code&gt;false&lt;/code&gt; is often required to enable processing of very large files. N.B. Remember in such a case that setting transactionAttribute to NotSupported might be necessary too Default: true</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="removeXmlDeclarationInResults" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>Postprocess each partial result, to remove the xml-declaration, as this is not allowed inside an xml-document Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="addInputToResult" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>When &lt;code&gt;true&lt;/code&gt; the input is added to the result in an input element Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="removeDuplicates" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>When &lt;code&gt;true&lt;/code&gt; duplicate input elements are removed, i.e. they are handled only once Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="parallel" type="frankBoolean">
    <xs:annotation>
      <xs:documentation>When set &lt;code&gt;true&lt;/code&gt;, the calls for all items are done in parallel (a new thread is started for each call). when collectresults set &lt;code&gt;true&lt;/code&gt;, this pipe will wait for all calls to finish before results are collected and pipe result is returned Default: false</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:attribute name="maxChildThreads" type="frankInt">
    <xs:annotation>
      <xs:documentation>Maximum number of child threads that may run in parallel simultaneously (combined total of all threads calling this pipe). Use &lt;code&gt;0&lt;/code&gt; for unlimited threads Default: 0</xs:documentation>
    </xs:annotation>
  </xs:attribute>
  <xs:simpleType name="frankBoolean">
    <xs:restriction base="xs:string">
      <xs:pattern value="(true|false)|($\{[^\}]+\})" />
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="frankInt">
    <xs:restriction base="xs:string">
      <xs:pattern value="((\+|-)?[0-9]+)|($\{[^\}]+\})" />
    </xs:restriction>
  </xs:simpleType>
  <xs:attribute name="active">
    <xs:annotation>
      <xs:documentation>If defined and empty or false, then this element and all its children are ignored</xs:documentation>
    </xs:annotation>
    <xs:simpleType>
      <xs:restriction base="xs:string">
        <xs:pattern value="!?(($\{[^\}]+\})|([tT][rR][uU][eE])|([fF][aA][lL][sS][eE]))" />
      </xs:restriction>
    </xs:simpleType>
  </xs:attribute>
  <xs:simpleType name="variableRef">
    <xs:restriction base="xs:string">
      <xs:pattern value="$\{[^\}]+\}" />
    </xs:restriction>
  </xs:simpleType>
</xs:schema>
