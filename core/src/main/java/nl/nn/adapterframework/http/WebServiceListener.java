/*
   Copyright 2013, 2018 Nationale-Nederlanden

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
package nl.nn.adapterframework.http;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;

import javax.xml.ws.Endpoint;
import javax.xml.ws.soap.SOAPBinding;

import nl.nn.adapterframework.configuration.ConfigurationException;
import nl.nn.adapterframework.configuration.ConfigurationWarnings;
import nl.nn.adapterframework.configuration.HasSpecialDefaultValues;
import nl.nn.adapterframework.core.HasPhysicalDestination;
import nl.nn.adapterframework.core.ListenerException;
import nl.nn.adapterframework.extensions.cxf.MessageProvider;
import nl.nn.adapterframework.receivers.ServiceDispatcher;
import nl.nn.adapterframework.soap.SoapWrapper;
import nl.nn.adapterframework.util.ClassUtils;
import nl.nn.adapterframework.util.XmlBuilder;

import org.apache.commons.lang.StringUtils;

/**
 * Implementation of a {@link nl.nn.adapterframework.core.IPushingListener IPushingListener} that enables a {@link nl.nn.adapterframework.receivers.GenericReceiver}
 * to receive messages as a web-service.
 * <p><b>Configuration:</b>
 * <table border="1">
 * <tr><th>attributes</th><th>description</th><th>default</th></tr>
 * <tr><td>className</td><td>nl.nn.adapterframework.http.WebServiceListener</td><td>&nbsp;</td></tr>
 * <tr><td>{@link #setName(String) name}</td><td>name of the listener as known to the adapter</td><td>&nbsp;</td></tr>
 * <tr><td>{@link #setSoap(boolean) soap}</td><td>when <code>true</code> the SOAP envelope is removed from received messages and a SOAP envelope is added to returned messages (SOAP envelope will not be visible to the pipeline)</td><td><code>true</code></td></tr>
 * <tr><td>{@link #setServiceNamespaceURI(String) serviceNamespaceURI}</td><td>namespace of the service that is provided by the adapter of this listener</td><td>&nbsp;</td></tr>
 * <tr><td>{@link #setApplicationFaultsAsSoapFaults(boolean) applicationFaultsAsSoapFaults}</td><td>Controls the behavior when an application-fault occurs: 
 *   <table>
 *     <tr><td><code>true</code></td><td>errors are returned as a SOAP-fault</td></tr>
 *     <tr><td><code>false</code></td><td>errors are returned in error message generated by the IBIS error message formatter</td></tr>
 *   </table>
 * </td><td>true</td></tr>
 * </table>
 * 
 * @author Gerrit van Brakel
 * @author Jaco de Groot
 * @author Niels Meijer
 */
public class WebServiceListener extends PushingListenerAdapter implements Serializable, HasPhysicalDestination, HasSpecialDefaultValues {

	private static final long serialVersionUID = 1L;

	private boolean soap = true;
	private String serviceNamespaceURI;
	private SoapWrapper soapWrapper = null;

	/* CXF Implementation */
	private String address;
	private boolean mtomEnabled = false;
	private String attachmentSessionKeys = "";
	private String multipartXmlSessionKey = "multipartXml";
	private List<String> attachmentSessionKeysList = new ArrayList<String>();
	private Endpoint endpoint = null;

	/**
	 * initialize listener and register <code>this</code> to the JNDI
	 */
	public void configure() throws ConfigurationException {
		super.configure();

		if(StringUtils.isEmpty(getAddress()) && isMtomEnabled())
			throw new ConfigurationException("can only use MTOM when address attribute has been set");

		if(StringUtils.isNotEmpty(getAddress()) && getAddress().contains(":"))
			throw new ConfigurationException("address cannot contain colon ( : ) character");

		if (StringUtils.isNotEmpty(getAttachmentSessionKeys())) {
			StringTokenizer stringTokenizer = new StringTokenizer(getAttachmentSessionKeys(), " ,;");
			while (stringTokenizer.hasMoreTokens()) {
				attachmentSessionKeysList.add(stringTokenizer.nextToken());
			}
		}

		if (isSoap()) {
//			String msg = ClassUtils.nameOf(this) +"["+getName()+"]: the use of attribute soap=true has been deprecated. Please use the SoapWrapperPipe instead";
//			ConfigurationWarnings.getInstance().add(log, msg, true);

			soapWrapper = SoapWrapper.getInstance();
		}

		if (StringUtils.isEmpty(getServiceNamespaceURI()) && StringUtils.isEmpty(getAddress())) {
			String msg = ClassUtils.nameOf(this) +"["+getName()+"]: calling webservices via de ServiceDispatcher_ServiceProxy is deprecated. Please specify an address or serviceNamespaceURI and modify the call accordingly";
			ConfigurationWarnings.getInstance().add(log, msg, true);
		}
	}

	@Override
	public void open() throws ListenerException {
		super.open();

		if (StringUtils.isNotEmpty(getAddress())) {
			log.debug("registering listener ["+getAddress()+"] with JAX-WS Endpoint");
			endpoint = Endpoint.publish(getAddress(), new MessageProvider(this, getMultipartXmlSessionKey()));
			SOAPBinding binding = (SOAPBinding)endpoint.getBinding();
			binding.setMTOMEnabled(isMtomEnabled());
		}

		//Can bind on multiple endpoints
		if (StringUtils.isNotEmpty(getServiceNamespaceURI())) {
			log.debug("registering listener ["+getName()+"] with ServiceDispatcher by serviceNamespaceURI ["+getServiceNamespaceURI()+"]");
			ServiceDispatcher.getInstance().registerServiceClient(getServiceNamespaceURI(), this);
		}
		else {
			log.debug("registering listener ["+getName()+"] with ServiceDispatcher");
			ServiceDispatcher.getInstance().registerServiceClient(getName(), this); //Backwards compatibility
		}
	}

	@Override
	public void close() {
		super.close();

		if(endpoint != null)
			endpoint.stop();

		//TODO maybe unregister oldschool rpc based serviceclients!?
		//How does this work when reloading a configuration??
	}

	@Override
	public String processRequest(String correlationId, String message, Map requestContext) throws ListenerException {
		if (attachmentSessionKeysList.size() > 0) {
			XmlBuilder xmlMultipart = new XmlBuilder("parts");
			for(String attachmentSessionKey: attachmentSessionKeysList) {
				//<parts><part type=\"file\" name=\"document.pdf\" sessionKey=\"part_file\" size=\"12345\" mimeType=\"application/octet-stream\"/></parts>
				XmlBuilder part = new XmlBuilder("part");
				part.addAttribute("name", attachmentSessionKey);
				part.addAttribute("sessionKey", attachmentSessionKey);
				part.addAttribute("mimeType", "application/octet-stream");
				xmlMultipart.addSubElement(part);
			}
			requestContext.put(getMultipartXmlSessionKey(), xmlMultipart.toXML());
		}

		if (isSoap()) {
			try {
				log.debug(getLogPrefix()+"received SOAPMSG [" + message + "]");
				String request = soapWrapper.getBody(message);
				String result = super.processRequest(correlationId, request, requestContext);
				String reply = soapWrapper.putInEnvelope(result,null);
				log.debug(getLogPrefix()+"replied SOAPMSG [" + reply + "]");
				return reply;
			} catch (Exception e) {
				throw new ListenerException(e);
			}
		}
		else
			return super.processRequest(correlationId, message, requestContext);
	}

	public String getLogPrefix() {
		return "WebServiceListener ["+getName()+"] listening on ["+getPhysicalDestinationName()+"] ";
	}

	public String getPhysicalDestinationName() {
		if(StringUtils.isNotEmpty(getAddress())) {
			return "address ["+getAddress()+"]";
		}
		else if (StringUtils.isNotEmpty(getServiceNamespaceURI())) {
			return "serviceNamespaceURI ["+getServiceNamespaceURI()+"]";
		}
		return "name ["+getName()+"]";
	}

	public void setSoap(boolean b) {
		soap = b;
	}
	public boolean isSoap() {
		return soap;
	}

	public String getServiceNamespaceURI() {
		return serviceNamespaceURI;
	}
	public void setServiceNamespaceURI(String string) {
		serviceNamespaceURI = string;
	}

	public boolean isApplicationFaultsAsSoapFaults() {
		return isApplicationFaultsAsExceptions();
	}
	public void setApplicationFaultsAsSoapFaults(boolean b) {
		setApplicationFaultsAsExceptions(b);
	}

	public void setAddress(String address) {
		this.address = address;
	}
	public String getAddress() {
		return address;
	}

	public void setMtomEnabled(boolean mtomEnabled) {
		this.mtomEnabled = mtomEnabled;
	}
	public boolean isMtomEnabled() {
		return mtomEnabled;
	}

	public void setAttachmentSessionKeys(String attachmentSessionKeys) {
		this.attachmentSessionKeys = attachmentSessionKeys;
	}
	public String getAttachmentSessionKeys() {
		return attachmentSessionKeys;
	}

	public void setMultipartXmlSessionKey(String multipartXmlSessionKey) {
		this.multipartXmlSessionKey = multipartXmlSessionKey;
	}
	public String getMultipartXmlSessionKey() {
		return multipartXmlSessionKey;
	}

	public Object getSpecialDefaultValue(String attributeName,
			Object defaultValue, Map<String, String> attributes) {
		if ("address".equals(attributeName)) {
			return getAddressDefaultValue(attributes.get("name"));
		}
		return defaultValue;
	}

	private static String getAddressDefaultValue(String name) {
		return "/" + name;
	}
}
