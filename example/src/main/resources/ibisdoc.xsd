<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
  <xs:element name="Configuration" type="ConfigurationType" />
  <xs:element name="Module" type="ModuleType" />
  <xs:element name="Adapter" type="AdapterType" />
  <xs:complexType name="ModuleType">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="Adapter" type="AdapterType" minOccurs="0" />
      <xs:element name="Job" type="JobType" minOccurs="0" />
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="AdapterType">
    <xs:sequence>
      <xs:element name="Receiver" type="ReceiverType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Pipeline" type="PipelineType" minOccurs="0" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether adapter is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the receiver is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoStart" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether adapters starts when configuration loads (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="description" type="xs:string">
      <xs:annotation>
        <xs:documentation>description of the adapter (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="errorState" type="xs:string" />
    <xs:attribute name="msgLogHidden" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set to &lt;code&gt;true&lt;/code&gt;, the length of the message is shown in the msg log instead of the content of the message (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="msgLogLevel" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the adapter (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="recover" type="xs:string" />
    <xs:attribute name="replaceNullMessage" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; a null message is replaced by an empty message (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetDesignDocument" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="Adios2XmlPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="adiosDefinities" type="xs:string" />
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noConversionForwardName" type="xs:string" />
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rekenbox" type="xs:string" />
    <xs:attribute name="rekenboxSessionKey" type="xs:string" />
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="Afm2EdiFactErrorSenderType">
    <xs:attribute name="destination" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="postbus" type="xs:string" />
    <xs:attribute name="tpnummer" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="Afm2EdiFactSenderType">
    <xs:attribute name="destination" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="postbus" type="xs:string" />
    <xs:attribute name="tpnummer" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ApiListenerType">
    <xs:attribute name="applicationFaultsAsExceptions" type="xs:string" />
    <xs:attribute name="authenticationMethod" type="xs:string" />
    <xs:attribute name="consumes" type="xs:string" />
    <xs:attribute name="method" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener as known to the adapter (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produces" type="xs:string" />
    <xs:attribute name="running" type="xs:string" />
    <xs:attribute name="updateEtag" type="xs:string" />
    <xs:attribute name="uriPattern" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ApiPrincipalPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="action" type="xs:string" />
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authenticationMethod" type="xs:string" />
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ApiSoapInputWrapperType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt; (default: wrap)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the soap header (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreSoapFault" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;false&lt;/code&gt; and the soap body contains a soap fault, a piperunexception is thrown (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when not empty, this namespace is added to the root element in the soap body (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, namespaces (and prefixes) in the content of the soap body are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeUnusedOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt; and &lt;code&gt;removeoutputnamespaces=false&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, unused namespaces in the content of the soap body are removed (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the root element in the soap body is changed to this value (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to apply to the input message. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="soapHeaderStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to create the content of the soap header. as input for this stylesheet a dummy xml string is used. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) namespace of the soap envelope (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ApiSoapOutputWrapperType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt; (default: wrap)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the soap header (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreSoapFault" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;false&lt;/code&gt; and the soap body contains a soap fault, a piperunexception is thrown (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when not empty, this namespace is added to the root element in the soap body (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, namespaces (and prefixes) in the content of the soap body are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeUnusedOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt; and &lt;code&gt;removeoutputnamespaces=false&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, unused namespaces in the content of the soap body are removed (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the root element in the soap body is changed to this value (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to apply to the input message. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="soapHeaderStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to create the content of the soap header. as input for this stylesheet a dummy xml string is used. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) namespace of the soap envelope (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ApiSoapWrapperPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt; (default: wrap)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the soap header (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreSoapFault" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;false&lt;/code&gt; and the soap body contains a soap fault, a piperunexception is thrown (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when not empty, this namespace is added to the root element in the soap body (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, namespaces (and prefixes) in the content of the soap body are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeUnusedOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt; and &lt;code&gt;removeoutputnamespaces=false&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, unused namespaces in the content of the soap body are removed (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the root element in the soap body is changed to this value (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to apply to the input message. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="soapHeaderStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to create the content of the soap header. as input for this stylesheet a dummy xml string is used. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) namespace of the soap envelope (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ApiStreamPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusFailureAsSoapFault" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) when true and the antivirusfailed forward is specified and the antivirus scan did not pass, a soap fault is returned instead of only a plain error message (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusFailureReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) if not empty and the antivirusfailed forward is specified and the antivirus scan did not pass, the error message (or soap fault) is stored in this session key and the first string part is returned to the pipeline (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusMessagePartName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) name of antivirus scan message parts (default: &lt;code&gt;antivirus_msg&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusPartName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) name of antivirus scan status parts (default: &lt;code&gt;antivirus_rc&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusPassedMessage" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) message of antivirus scan parts which indicates the antivirus scan passed (default: &lt;code&gt;pass&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkAntiVirus" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt;) when true parts are checked for antivirus scan returncode. these antivirus scan parts have been added by another application (so the antivirus scan is not performed in this pipe). for each file part an antivirus scan part have been added by this other application (directly after this file part) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="extractFirstStringPart" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt;) when true the first part is not put in a session key but returned to the pipeline (as the result of this pipe) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsRealm" type="xs:string" />
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartXmlSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;extractfirststringpart=true&lt;/code&gt;) the session key to put the xml in with info about the stored parts (default: &lt;code&gt;multipartxml&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ApiWsdlXmlInputValidatorType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputSoapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>identical to the &lt;code&gt;soapbody&lt;/code&gt; attribute except that it's used for the output message instead of the input message. for more information see &lt;a href="#note1"&gt;note 1&lt;/a&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="responseRoot" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>always envelope (not allowed to change) (default: envelope)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocationToAdd" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references which will be added to the wsdl (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap body. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap body, for example to allow element x and an empty soap body use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>creates &lt;code&gt;schemalocation&lt;/code&gt; attribute based on the wsdl and replaces the namespace of the soap body element (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap header. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap header, for example to allow element x and an empty soap header use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be used when the soap header element exists multiple times (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>soap envelope xsd version to use: 1.1, 1.2 or any (both 1.1 and 1.2) (default: 1.1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wsdl" type="xs:string">
      <xs:annotation>
        <xs:documentation>the wsdl to read the xsd's from (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ApiWsdlXmlOutputValidatorType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputSoapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>identical to the &lt;code&gt;soapbody&lt;/code&gt; attribute except that it's used for the output message instead of the input message. for more information see &lt;a href="#note1"&gt;note 1&lt;/a&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="responseRoot" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>always envelope (not allowed to change) (default: envelope)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocationToAdd" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references which will be added to the wsdl (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap body. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap body, for example to allow element x and an empty soap body use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>creates &lt;code&gt;schemalocation&lt;/code&gt; attribute based on the wsdl and replaces the namespace of the soap body element (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap header. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap header, for example to allow element x and an empty soap header use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be used when the soap header element exists multiple times (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>soap envelope xsd version to use: 1.1, 1.2 or any (both 1.1 and 1.2) (default: 1.1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wsdl" type="xs:string">
      <xs:annotation>
        <xs:documentation>the wsdl to read the xsd's from (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ApiWsdlXmlValidatorPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputSoapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>identical to the &lt;code&gt;soapbody&lt;/code&gt; attribute except that it's used for the output message instead of the input message. for more information see &lt;a href="#note1"&gt;note 1&lt;/a&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="responseRoot" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>always envelope (not allowed to change) (default: envelope)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocationToAdd" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references which will be added to the wsdl (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap body. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap body, for example to allow element x and an empty soap body use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>creates &lt;code&gt;schemalocation&lt;/code&gt; attribute based on the wsdl and replaces the namespace of the soap body element (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap header. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap header, for example to allow element x and an empty soap header use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be used when the soap header element exists multiple times (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>soap envelope xsd version to use: 1.1, 1.2 or any (both 1.1 and 1.2) (default: 1.1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wsdl" type="xs:string">
      <xs:annotation>
        <xs:documentation>the wsdl to read the xsd's from (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="Base64PipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:anyURI">
      <xs:annotation>
        <xs:documentation>character encoding to be used bla bla bla to  href="https://www.google.com" encode or decode message to or from string. (only used when convert2string=true) (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;encode&lt;/code&gt; or &lt;code&gt;decode&lt;/code&gt; (default: encode)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when direction=encode) each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4). if linelength &lt;= 0, then the output will not be divided into lines (default: auto)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineSeparator" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when direction=encode) defines separator between lines. special values: &lt;code&gt;auto&lt;/code&gt;: platform default, &lt;code&gt;dos&lt;/code&gt;: crlf, &lt;code&gt;unix&lt;/code&gt;: lf (default: auto)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;bytes&lt;/code&gt;, &lt;code&gt;stream&lt;/code&gt; or &lt;code&gt;base64&lt;/code&gt; (default: string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="BatchBlobTransformerPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>characterset used for reading file or inputstream (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="query" type="xs:string" />
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeOriginalBlock" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; the original block is stored under the session key originalblock (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="BatchClobTransformerPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>characterset used for reading file or inputstream (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="query" type="xs:string" />
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeOriginalBlock" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; the original block is stored under the session key originalblock (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="BatchFileTransformerPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>characterset used for reading file or inputstream (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="delete" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the file processed will deleted after being processed, and not stored (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="move2dirAfterError" type="xs:string">
      <xs:annotation>
        <xs:documentation>directory to which the inputfile is moved in case an error occurs (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="move2dirAfterTransform" type="xs:string">
      <xs:annotation>
        <xs:documentation>directory in which the transformed file(s) is stored (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numberOfBackups" type="xs:string">
      <xs:annotation>
        <xs:documentation>number of copies held of a file with the same name. backup files have a dot and a number suffixed to their name. if set to 0, no backups will be kept. (default: 5)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="overwrite" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the destination file will be deleted if it already exists (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeOriginalBlock" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; the original block is stored under the session key originalblock (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="BisInputWrapperType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addOutputNamespace" type="xs:string" />
    <xs:attribute name="bisActionName" type="xs:string" />
    <xs:attribute name="bisConversationIdSessionKey" type="xs:string" />
    <xs:attribute name="bisErrorCodeSessionKey" type="xs:string" />
    <xs:attribute name="bisErrorReasonSessionKey" type="xs:string" />
    <xs:attribute name="bisErrorTextSessionKey" type="xs:string" />
    <xs:attribute name="bisExternalRefToMessageIdSessionKey" type="xs:string" />
    <xs:attribute name="bisMessageHeaderInSoapBody" type="xs:string" />
    <xs:attribute name="bisMessageHeaderSessionKey" type="xs:string" />
    <xs:attribute name="bisResultInPayload" type="xs:string" />
    <xs:attribute name="bisServiceName" type="xs:string" />
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt; (default: wrap)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the soap header (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreSoapFault" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;false&lt;/code&gt; and the soap body contains a soap fault, a piperunexception is thrown (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputNamespaceDefs" type="xs:string" />
    <xs:attribute name="inputXPath" type="xs:string" />
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitResult" type="xs:string" />
    <xs:attribute name="outputNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when not empty, this namespace is added to the root element in the soap body (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputRoot" type="xs:string" />
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, namespaces (and prefixes) in the content of the soap body are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeUnusedOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt; and &lt;code&gt;removeoutputnamespaces=false&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, unused namespaces in the content of the soap body are removed (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the root element in the soap body is changed to this value (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to apply to the input message. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="soapHeaderStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to create the content of the soap header. as input for this stylesheet a dummy xml string is used. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) namespace of the soap envelope (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="BisJmsErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="ackMode" type="xs:string" />
    <xs:attribute name="acknowledgeMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: auto_acknowledge)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to jms server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="conversationIdSessionKey" type="xs:string" />
    <xs:attribute name="correlationIdMaxLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the correlationid exceeds this maximum length, the correlationid is trimmed from the left side of a string to this maximum length (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHex" type="xs:string">
      <xs:annotation>
        <xs:documentation>transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part). useful when sending messages to mq which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: mqjms1044: string is not a valid hexadecimal number (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deliveryMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls mode that messages are sent with: either 'persistent' or 'non_persistent' (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the jms destination (queue or topic) to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;topic&lt;/code&gt; (default: &lt;code&gt;queue&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyleURI" type="xs:string" />
    <xs:attribute name="errorListSessionKey" type="xs:string" />
    <xs:attribute name="externalRefToMessageIdSessionKey" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsTransacted" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when synchronous='true' and and replytoname is set) eithter 'correlationid', 'correlationid_from_message' or 'messageid'. indicates wether the server uses the correlationid from the pipeline, the correlationid from the message or the messageid in the correlationid field of the reply. this requires the sender to have set the correlationid at the time of sending. (default: messageid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lookupDestination" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the destinationname is used directly instead of performing a jndi lookup (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageHeaderInSoapBody" type="xs:string" />
    <xs:attribute name="messageSelector" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the value of this attribute is used as a selector to filter messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in milliseconds) it takes for the message to expire. if the message is not consumed before, it will be lost. make sure to set it to a positive value for request/repy type of messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of the jmstype field (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistent" type="xs:string">
      <xs:annotation>
        <xs:documentation>rather useless attribute, and not the same as &lt;code&gt;deliverymode&lt;/code&gt;. you probably want to use that. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="priority" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets the priority that is used to deliver the message. ranges from 0 to 9. defaults to -1, meaning not set. effectively the default priority is set by jms to 4 (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the queueconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;queue&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeResponseNamespaces" type="xs:string" />
    <xs:attribute name="replySoapHeaderSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to store soap header of reply (default: soapheader)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum time in ms to wait for a reply. 0 means no timeout. (only for synchronous=true) (default: 5000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="requestNamespace" type="xs:string" />
    <xs:attribute name="responseNamespaceDefs" type="xs:string" />
    <xs:attribute name="responseXPath" type="xs:string" />
    <xs:attribute name="resultInPayload" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespaceURI" type="xs:string" />
    <xs:attribute name="soap" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapAction" type="xs:string">
      <xs:annotation>
        <xs:documentation>soapaction string sent as messageproperty (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of parameter containing soap header (default: soapheader)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="subscriberType" type="xs:string" />
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the sender operates in rr mode: the a reply is expected, either on the queue specified in 'replytoname', or on a dynamically generated temporary queue (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the topicconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;topic&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="BisJmsListenerType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="ackMode" type="xs:string" />
    <xs:attribute name="acknowledgeMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: auto_acknowledge)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="actionName" type="xs:string" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to jms server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cacheMode" type="xs:string" />
    <xs:attribute name="commitOnState" type="xs:string">
      <xs:annotation>
        <xs:documentation>&lt;i&gt;deprecated&lt;/i&gt; exit state to control commit or rollback of jmssession. only used if &lt;code&gt;jmstransacted&lt;/code&gt; is set true. (default: success)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdMaxLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the correlationid exceeds this maximum length, the correlationid is trimmed from the left side of a string to this maximum length (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHex" type="xs:string">
      <xs:annotation>
        <xs:documentation>transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part). useful when sending messages to mq which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: mqjms1044: string is not a valid hexadecimal number (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the jms destination (queue or topic) to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;topic&lt;/code&gt; (default: &lt;code&gt;queue&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="errorCodeSessionKey" type="xs:string" />
    <xs:attribute name="errorReasonSessionKey" type="xs:string" />
    <xs:attribute name="errorTextSessionKey" type="xs:string" />
    <xs:attribute name="forceMessageIdAsCorrelationId" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsTransacted" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="layByNamespace" type="xs:string" />
    <xs:attribute name="listenerPort" type="xs:string" />
    <xs:attribute name="lookupDestination" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the destinationname is used directly instead of performing a jndi lookup (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageHeaderInSoapBody" type="xs:string" />
    <xs:attribute name="messageSelector" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the value of this attribute is used as a selector to filter messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in milliseconds) it takes for the message to expire. if the message is not consumed before, it will be lost. make sure to set it to a positive value for request/repy type of messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitResult" type="xs:string" />
    <xs:attribute name="persistent" type="xs:string">
      <xs:annotation>
        <xs:documentation>rather useless attribute, and not the same as &lt;code&gt;deliverymode&lt;/code&gt;. you probably want to use that. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pollGuardInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>interval in milliseconds for the poll guard to check whether a successful poll was done by the receive (https://docs.oracle.com/javaee/7/api/javax/jms/messageconsumer.html#receive-long-) since last check. when polling has stopped this will be logged and the listener will be stopped and started in an attempt to workaround problems with polling. polling might stop due to bugs in the jms driver/implementation which should be fixed by the supplier. as the poll time includes reading and processing of the message no successful poll might be registered since the last check when message processing takes a long time, hence while messages are being processed the check on last successful poll will be skipped. set to -1 to disable (default: ten times the specified timeout)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the queueconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;queue&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeRequestNamespaces" type="xs:string" />
    <xs:attribute name="replyDeliveryMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls mode that reply messages are sent with: either 'persistent' or 'non_persistent' (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyEncodingStyleURI" type="xs:string" />
    <xs:attribute name="replyMessageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>time that replymessage will live (default: 0 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyMessageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of the jmstype field of the reply message (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyNamespaceURI" type="xs:string" />
    <xs:attribute name="replyPriority" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets the priority that is used to deliver the reply message. ranges from 0 to 9. defaults to -1, meaning not set. effectively the default priority is set by jms to 4 (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replySoapAction" type="xs:string" />
    <xs:attribute name="requestNamespaceDefs" type="xs:string" />
    <xs:attribute name="requestXPath" type="xs:string" />
    <xs:attribute name="resultInPayload" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceName" type="xs:string" />
    <xs:attribute name="soap" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="subscriberType" type="xs:string" />
    <xs:attribute name="timeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>receiver timeout, in milliseconds (default: 3000 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the topicconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;topic&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useReplyTo" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xPathLoggingKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of all xpath keys that need to be logged. (overrides &lt;code&gt;msg.log.keys&lt;/code&gt; property) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="BisJmsSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="ackMode" type="xs:string" />
    <xs:attribute name="acknowledgeMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: auto_acknowledge)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to jms server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="conversationIdSessionKey" type="xs:string" />
    <xs:attribute name="correlationIdMaxLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the correlationid exceeds this maximum length, the correlationid is trimmed from the left side of a string to this maximum length (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHex" type="xs:string">
      <xs:annotation>
        <xs:documentation>transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part). useful when sending messages to mq which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: mqjms1044: string is not a valid hexadecimal number (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deliveryMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls mode that messages are sent with: either 'persistent' or 'non_persistent' (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the jms destination (queue or topic) to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;topic&lt;/code&gt; (default: &lt;code&gt;queue&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyleURI" type="xs:string" />
    <xs:attribute name="errorListSessionKey" type="xs:string" />
    <xs:attribute name="externalRefToMessageIdSessionKey" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsTransacted" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when synchronous='true' and and replytoname is set) eithter 'correlationid', 'correlationid_from_message' or 'messageid'. indicates wether the server uses the correlationid from the pipeline, the correlationid from the message or the messageid in the correlationid field of the reply. this requires the sender to have set the correlationid at the time of sending. (default: messageid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lookupDestination" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the destinationname is used directly instead of performing a jndi lookup (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageHeaderInSoapBody" type="xs:string" />
    <xs:attribute name="messageSelector" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the value of this attribute is used as a selector to filter messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in milliseconds) it takes for the message to expire. if the message is not consumed before, it will be lost. make sure to set it to a positive value for request/repy type of messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of the jmstype field (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistent" type="xs:string">
      <xs:annotation>
        <xs:documentation>rather useless attribute, and not the same as &lt;code&gt;deliverymode&lt;/code&gt;. you probably want to use that. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="priority" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets the priority that is used to deliver the message. ranges from 0 to 9. defaults to -1, meaning not set. effectively the default priority is set by jms to 4 (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the queueconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;queue&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeResponseNamespaces" type="xs:string" />
    <xs:attribute name="replySoapHeaderSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to store soap header of reply (default: soapheader)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum time in ms to wait for a reply. 0 means no timeout. (only for synchronous=true) (default: 5000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="requestNamespace" type="xs:string" />
    <xs:attribute name="responseNamespaceDefs" type="xs:string" />
    <xs:attribute name="responseXPath" type="xs:string" />
    <xs:attribute name="resultInPayload" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespaceURI" type="xs:string" />
    <xs:attribute name="soap" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapAction" type="xs:string">
      <xs:annotation>
        <xs:documentation>soapaction string sent as messageproperty (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of parameter containing soap header (default: soapheader)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="subscriberType" type="xs:string" />
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the sender operates in rr mode: the a reply is expected, either on the queue specified in 'replytoname', or on a dynamically generated temporary queue (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the topicconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;topic&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="BisOutputWrapperType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addOutputNamespace" type="xs:string" />
    <xs:attribute name="bisActionName" type="xs:string" />
    <xs:attribute name="bisConversationIdSessionKey" type="xs:string" />
    <xs:attribute name="bisErrorCodeSessionKey" type="xs:string" />
    <xs:attribute name="bisErrorReasonSessionKey" type="xs:string" />
    <xs:attribute name="bisErrorTextSessionKey" type="xs:string" />
    <xs:attribute name="bisExternalRefToMessageIdSessionKey" type="xs:string" />
    <xs:attribute name="bisMessageHeaderInSoapBody" type="xs:string" />
    <xs:attribute name="bisMessageHeaderSessionKey" type="xs:string" />
    <xs:attribute name="bisResultInPayload" type="xs:string" />
    <xs:attribute name="bisServiceName" type="xs:string" />
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt; (default: wrap)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the soap header (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreSoapFault" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;false&lt;/code&gt; and the soap body contains a soap fault, a piperunexception is thrown (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputNamespaceDefs" type="xs:string" />
    <xs:attribute name="inputXPath" type="xs:string" />
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitResult" type="xs:string" />
    <xs:attribute name="outputNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when not empty, this namespace is added to the root element in the soap body (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputRoot" type="xs:string" />
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, namespaces (and prefixes) in the content of the soap body are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeUnusedOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt; and &lt;code&gt;removeoutputnamespaces=false&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, unused namespaces in the content of the soap body are removed (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the root element in the soap body is changed to this value (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to apply to the input message. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="soapHeaderStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to create the content of the soap header. as input for this stylesheet a dummy xml string is used. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) namespace of the soap envelope (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="BisWrapperPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addOutputNamespace" type="xs:string" />
    <xs:attribute name="bisActionName" type="xs:string" />
    <xs:attribute name="bisConversationIdSessionKey" type="xs:string" />
    <xs:attribute name="bisErrorCodeSessionKey" type="xs:string" />
    <xs:attribute name="bisErrorReasonSessionKey" type="xs:string" />
    <xs:attribute name="bisErrorTextSessionKey" type="xs:string" />
    <xs:attribute name="bisExternalRefToMessageIdSessionKey" type="xs:string" />
    <xs:attribute name="bisMessageHeaderInSoapBody" type="xs:string" />
    <xs:attribute name="bisMessageHeaderSessionKey" type="xs:string" />
    <xs:attribute name="bisResultInPayload" type="xs:string" />
    <xs:attribute name="bisServiceName" type="xs:string" />
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt; (default: wrap)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the soap header (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreSoapFault" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;false&lt;/code&gt; and the soap body contains a soap fault, a piperunexception is thrown (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputNamespaceDefs" type="xs:string" />
    <xs:attribute name="inputXPath" type="xs:string" />
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitResult" type="xs:string" />
    <xs:attribute name="outputNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when not empty, this namespace is added to the root element in the soap body (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputRoot" type="xs:string" />
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, namespaces (and prefixes) in the content of the soap body are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeUnusedOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt; and &lt;code&gt;removeoutputnamespaces=false&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, unused namespaces in the content of the soap body are removed (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the root element in the soap body is changed to this value (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to apply to the input message. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="soapHeaderStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to create the content of the soap header. as input for this stylesheet a dummy xml string is used. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) namespace of the soap envelope (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="BlobLineIteratingPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapInputWrapper" type="ApiSoapInputWrapperType" minOccurs="0" />
        <xs:element name="BisInputWrapper" type="BisInputWrapperType" minOccurs="0" />
        <xs:element name="DirectInputWrapper" type="DirectInputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapInputWrapper" type="EsbSoapInputWrapperType" minOccurs="0" />
        <xs:element name="FxfInputWrapper" type="FxfInputWrapperType" minOccurs="0" />
        <xs:element name="SoapInputWrapper" type="SoapInputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlInputValidator" type="ApiWsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapInputValidator" type="EsbSoapInputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlInputValidator" type="FxfXmlInputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlInputValidator" type="Json2XmlInputValidatorType" minOccurs="0" />
        <xs:element name="SoapInputValidator" type="SoapInputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlInputValidator" type="WsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="XmlInputValidator" type="XmlInputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="Afm2EdiFactSender" type="Afm2EdiFactSenderType" minOccurs="0" />
        <xs:element name="BisJmsSender" type="BisJmsSenderType" minOccurs="0" />
        <xs:element name="CommandSender" type="CommandSenderType" minOccurs="0" />
        <xs:element name="DelaySender" type="DelaySenderType" minOccurs="0" />
        <xs:element name="DirectQuerySender" type="DirectQuerySenderType" minOccurs="0" />
        <xs:element name="EchoSender" type="EchoSenderType" minOccurs="0" />
        <xs:element name="EsbJmsSender" type="EsbJmsSenderType" minOccurs="0" />
        <xs:element name="FileSender" type="FileSenderType" minOccurs="0" />
        <xs:element name="FixedQuerySender" type="FixedQuerySenderType" minOccurs="0" />
        <xs:element name="FixedResultSender" type="FixedResultSenderType" minOccurs="0" />
        <xs:element name="FtpSender" type="FtpSenderType" minOccurs="0" />
        <xs:element name="HttpSender" type="HttpSenderType" minOccurs="0" />
        <xs:element name="IbisJavaSender" type="IbisJavaSenderType" minOccurs="0" />
        <xs:element name="IbisLocalSender" type="IbisLocalSenderType" minOccurs="0" />
        <xs:element name="IbisWebServiceSender" type="IbisWebServiceSenderType" minOccurs="0" />
        <xs:element name="JmsSender" type="JmsSenderType" minOccurs="0" />
        <xs:element name="LdapSender" type="LdapSenderType" minOccurs="0" />
        <xs:element name="LogSender" type="LogSenderType" minOccurs="0" />
        <xs:element name="MailSender" type="MailSenderType" minOccurs="0" />
        <xs:element name="MessageStoreSender" type="MessageStoreSenderType" minOccurs="0" />
        <xs:element name="MqttSender" type="MqttSenderType" minOccurs="0" />
        <xs:element name="ParallelSendersSender" type="ParallelSendersSenderType" minOccurs="0" />
        <xs:element name="ReloadSender" type="ReloadSenderType" minOccurs="0" />
        <xs:element name="RestSender" type="RestSenderType" minOccurs="0" />
        <xs:element name="ResultSet2FileSender" type="ResultSet2FileSenderType" minOccurs="0" />
        <xs:element name="SambaSender" type="SambaSenderType" minOccurs="0" />
        <xs:element name="SchedulerSender" type="SchedulerSenderType" minOccurs="0" />
        <xs:element name="SenderSeriesSender" type="SenderSeriesSenderType" minOccurs="0" />
        <xs:element name="SenderWrapperSender" type="SenderWrapperSenderType" minOccurs="0" />
        <xs:element name="ShadowSender" type="ShadowSenderType" minOccurs="0" />
        <xs:element name="TimeoutGuardSenderWithParametersBaseSender" type="TimeoutGuardSenderWithParametersBaseSenderType" minOccurs="0" />
        <xs:element name="WebServiceNtlmSender" type="WebServiceNtlmSenderType" minOccurs="0" />
        <xs:element name="WebServiceSender" type="WebServiceSenderType" minOccurs="0" />
        <xs:element name="XComSender" type="XComSenderType" minOccurs="0" />
        <xs:element name="XfbSender" type="XfbSenderType" minOccurs="0" />
        <xs:element name="XmlJmsBrowserSender" type="XmlJmsBrowserSenderType" minOccurs="0" />
        <xs:element name="XmlQuerySender" type="XmlQuerySenderType" minOccurs="0" />
        <xs:element name="XmlValidatorSender" type="XmlValidatorSenderType" minOccurs="0" />
        <xs:element name="XsltSender" type="XsltSenderType" minOccurs="0" />
        <xs:element name="ZipWriterSender" type="ZipWriterSenderType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="DummyMessageLog" type="DummyMessageLogType" minOccurs="0" />
        <xs:element name="EsbJmsMessageLog" type="EsbJmsMessageLogType" minOccurs="0" />
        <xs:element name="JdbcMessageLog" type="JdbcMessageLogType" minOccurs="0" />
        <xs:element name="JmsMessageLog" type="JmsMessageLogType" minOccurs="0" />
        <xs:element name="OracleMessageLog" type="OracleMessageLogType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlOutputValidator" type="ApiWsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapOutputValidator" type="EsbSoapOutputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlOutputValidator" type="FxfXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlOutputValidator" type="Json2XmlOutputValidatorType" minOccurs="0" />
        <xs:element name="SoapOutputValidator" type="SoapOutputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlOutputValidator" type="WsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="XmlOutputValidator" type="XmlOutputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapOutputWrapper" type="ApiSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="BisOutputWrapper" type="BisOutputWrapperType" minOccurs="0" />
        <xs:element name="DirectOutputWrapper" type="DirectOutputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapOutputWrapper" type="EsbSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="FxfOutputWrapper" type="FxfOutputWrapperType" minOccurs="0" />
        <xs:element name="SoapOutputWrapper" type="SoapOutputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addInputToResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; the input is added to the result in an input element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for audittrailxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. if specified, the value of the pipelinesession variable is used as audit trail (instead of the default 'no audit trail) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract audit trail from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockPrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;blocksize &amp;gt; 0&lt;/code&gt;, this string is inserted at the start of the set of lines. (default: &amp;lt;block&amp;gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls multiline behaviour. when set to a value greater than 0, it specifies the number of rows send in a block to the sender. (default: 0 (one line at a time, no prefix of suffix))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;blocksize &amp;gt; 0&lt;/code&gt;, this string is inserted at the end of the set of lines. (default: &amp;lt;/block&amp;gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkRootTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, besides the xml well-formedness the root element of the result is checked to be equal to the value set (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkXmlWellFormed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the xml well-formedness of the result is checked (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectResults" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether all the results of each iteration will be collected in one result message. if set &lt;code&gt;false&lt;/code&gt;, only a small summary is returned (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for correlationidxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. is specified, the value of the pipelinesession variable is used as input for the xpathexpression or stylesheet, instead of the current input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be configured from jmsrealm, too (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="endPosition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;endposition &amp;gt;= startposition&lt;/code&gt;, this field contains the end position of the key in the current record (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exceptionOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a piperunexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when hideregex is not empty and only applies to error/logstore) either &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;firsthalf&lt;/code&gt;. when &lt;code&gt;firsthalf&lt;/code&gt; only the first half of the string is masked, otherwise (&lt;code&gt;all&lt;/code&gt;) the entire string is masked (default: all)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>next to common usage in {@link abstractpipe}, also strings in the error/logstore are masked (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreExceptions" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; ignore any exception thrown by executing sender (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="itemNoSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable to store number of item processed. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for labelxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linePrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>this string is inserted at the start of each line (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>this string is inserted at the end of each line (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>indicates wether the server uses the correlationid or the messageid in the correlationid field of the reply. this requirers the sender to have set the correlationid at the time of sending. (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, exclusive row-level locks are obtained on all the rows identified by the select statement (by appending ' for update nowait skip locked' to the end of the query) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWait" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and &gt;=0, ' for update wait #' is used instead of ' for update nowait skip locked' (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of times a processing attempt is retried after a timeout or an exception is caught or after a incorrect reply is received (see also &lt;code&gt;retryxpath&lt;/code&gt;) (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:string">
      <xs:annotation>
        <xs:documentation>force the transformer generated from the xpath-expression to omit the xml declaration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either 'text' or 'xml'. only valid for xpathexpression (default: text)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="parallel" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the calls for all items are done in parallel (a new thread is started for each call). when collectresults set &lt;code&gt;true&lt;/code&gt;, this pipe will wait for all calls to finish before results are collected and pipe result is returned (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="presumedTimeOutInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>when the previous call was a timeout, the maximum time (in seconds) after this timeout to presume the current call is also a timeout. a value of -1 indicates to never presume timeouts (default: 10 s)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="query" type="xs:string">
      <xs:annotation>
        <xs:documentation>the sql query text to be excecuted each time sendmessage() is called. when not set, the input message is taken as the query (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeDuplicates" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; duplicate input elements are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeXmlDeclarationInResults" type="xs:string">
      <xs:annotation>
        <xs:documentation>postprocess each partial result, to remove the xml-declaration, as this is not allowed inside an xml-document (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultOnTimeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>result returned when no return-message was received within the timeout limit (e.g. 'receiver timed out'). (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMaxInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of seconds waited after an unsuccessful processing attempt before another processing attempt is made (default: 600)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMinInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the starting number of seconds waited after an unsuccessful processing attempt before another processing attempt is made. each next retry this interval is doubled with a upper limit of &lt;code&gt;retrymaxinterval&lt;/code&gt; (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for retryxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression evaluated on each technical successful reply. retry is done if condition returns true (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startPosition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;startposition &amp;gt;= 0&lt;/code&gt;, this field contains the start position of the key in the current record (first character is 0); all sequenced lines with the same key are put in one block and send to the sender (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stopConditionXPathExpression" type="xs:string" />
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is first base64 decoded and then streamed to the httpservletresponse object (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stubFileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the pipe returns a message from a file, instead of doing the regular process (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to apply to each message, before sending it (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOutOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a timeoutexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useInputForExtract" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is used to extract audit trail, correlationid and label (instead of the wrapped input) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>alternatively: xpath-expression to create stylesheet from (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="BytesOutputPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="CacheType">
    <xs:attribute name="cacheEmptyKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether empty keys are used for caching. when set true, cache entries with empty keys can exist. (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cacheEmptyValues" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether empty values will be cached. when set true, empty cache entries can exist for any key. (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="diskExpiryThreadIntervalSeconds" type="xs:string">
      <xs:annotation>
        <xs:documentation>how often to run the disk store expiry thread (default: 600)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="diskPersistent" type="xs:string">
      <xs:annotation>
        <xs:documentation>if &lt;code&gt;true&lt;/code&gt;, the the cache is reloaded after the jvm restarts (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="eternal" type="xs:string">
      <xs:annotation>
        <xs:documentation>if &lt;code&gt;true&lt;/code&gt;, the elements in the cache are eternal, i.e. never expire (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyInputSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to use as input for transformation of request message to key by keyxpath or keystylesheet (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for keyxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>setcacheemptykeys (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract cache key from request message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyXPathOutputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>output type of xpath expression to extract cache key from request message, must be 'xml' or 'text' (default: text)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxElementsInMemory" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of elements in memory, before they are evicted (default: 100)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxElementsOnDisk" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of elements on disk, before they are removed (default: 10000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="memoryStoreEvictionPolicy" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;lru&lt;/code&gt;=leastrecentuse,&lt;code&gt;lfu&lt;/code&gt;=leastfrequentuse or &lt;code&gt;fifo&lt;/code&gt;=firstinfirstout (default: lru)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the cache, will be set from owner (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="overflowToDisk" type="xs:string">
      <xs:annotation>
        <xs:documentation>if &lt;code&gt;true&lt;/code&gt;, the elements that are evicted from memory are spooled to disk (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeToIdleSeconds" type="xs:string">
      <xs:annotation>
        <xs:documentation>the amount of time to live for an element from its last accessed or modified date (default: 36000 (=10 hours))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeToLiveSeconds" type="xs:string">
      <xs:annotation>
        <xs:documentation>the amount of time to live for an element from its creation date (default: 36000 (=10 hours))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueInputSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to use as input for transformation of response message to cached value by valuexpath or valuestylesheet (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for valuexpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract value to be cached from response message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>setcacheemptyvalues (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueXPathOutputType" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ChecksumPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>character encoding to be used to encode message before calculating checksum (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputIsFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be a filename; otherwise the input itself is used in the calculations (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of checksum to be calculated. must be one of md5, sha, crc32, adler32 (default: md5)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="CleanupOldFilesPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deleteEmptySubdirectories" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, empty subdirectories will be deleted, too (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="excludeWildcard" type="xs:string">
      <xs:annotation>
        <xs:documentation>filter of files to be excluded for deletion (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>files that match this pattern will be deleted. parameters of the pipe are applied to this pattern. if this attribute is not set, the input of the pipe is interpreted as the file to be removed (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filePatternSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lastModifiedDelta" type="xs:string">
      <xs:annotation>
        <xs:documentation>time in milliseconds after last modification that must have passed at least before a file will be deleted (set to negative value to disable) (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="minStableTime" type="xs:string">
      <xs:annotation>
        <xs:documentation>minimal age of file in milliseconds, to avoid deleting a file while it is still being written (only used when wildcard is set) (set to 0 or negative value to disable) (default: 1000 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="subdirectories" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, files  in subdirectories will be deleted, too (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wildcard" type="xs:string">
      <xs:annotation>
        <xs:documentation>filter of files to delete. if not set and a directory is specified, all files in the directory are interpreted to be deleted (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ClobLineIteratingPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapInputWrapper" type="ApiSoapInputWrapperType" minOccurs="0" />
        <xs:element name="BisInputWrapper" type="BisInputWrapperType" minOccurs="0" />
        <xs:element name="DirectInputWrapper" type="DirectInputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapInputWrapper" type="EsbSoapInputWrapperType" minOccurs="0" />
        <xs:element name="FxfInputWrapper" type="FxfInputWrapperType" minOccurs="0" />
        <xs:element name="SoapInputWrapper" type="SoapInputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlInputValidator" type="ApiWsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapInputValidator" type="EsbSoapInputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlInputValidator" type="FxfXmlInputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlInputValidator" type="Json2XmlInputValidatorType" minOccurs="0" />
        <xs:element name="SoapInputValidator" type="SoapInputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlInputValidator" type="WsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="XmlInputValidator" type="XmlInputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="Afm2EdiFactSender" type="Afm2EdiFactSenderType" minOccurs="0" />
        <xs:element name="BisJmsSender" type="BisJmsSenderType" minOccurs="0" />
        <xs:element name="CommandSender" type="CommandSenderType" minOccurs="0" />
        <xs:element name="DelaySender" type="DelaySenderType" minOccurs="0" />
        <xs:element name="DirectQuerySender" type="DirectQuerySenderType" minOccurs="0" />
        <xs:element name="EchoSender" type="EchoSenderType" minOccurs="0" />
        <xs:element name="EsbJmsSender" type="EsbJmsSenderType" minOccurs="0" />
        <xs:element name="FileSender" type="FileSenderType" minOccurs="0" />
        <xs:element name="FixedQuerySender" type="FixedQuerySenderType" minOccurs="0" />
        <xs:element name="FixedResultSender" type="FixedResultSenderType" minOccurs="0" />
        <xs:element name="FtpSender" type="FtpSenderType" minOccurs="0" />
        <xs:element name="HttpSender" type="HttpSenderType" minOccurs="0" />
        <xs:element name="IbisJavaSender" type="IbisJavaSenderType" minOccurs="0" />
        <xs:element name="IbisLocalSender" type="IbisLocalSenderType" minOccurs="0" />
        <xs:element name="IbisWebServiceSender" type="IbisWebServiceSenderType" minOccurs="0" />
        <xs:element name="JmsSender" type="JmsSenderType" minOccurs="0" />
        <xs:element name="LdapSender" type="LdapSenderType" minOccurs="0" />
        <xs:element name="LogSender" type="LogSenderType" minOccurs="0" />
        <xs:element name="MailSender" type="MailSenderType" minOccurs="0" />
        <xs:element name="MessageStoreSender" type="MessageStoreSenderType" minOccurs="0" />
        <xs:element name="MqttSender" type="MqttSenderType" minOccurs="0" />
        <xs:element name="ParallelSendersSender" type="ParallelSendersSenderType" minOccurs="0" />
        <xs:element name="ReloadSender" type="ReloadSenderType" minOccurs="0" />
        <xs:element name="RestSender" type="RestSenderType" minOccurs="0" />
        <xs:element name="ResultSet2FileSender" type="ResultSet2FileSenderType" minOccurs="0" />
        <xs:element name="SambaSender" type="SambaSenderType" minOccurs="0" />
        <xs:element name="SchedulerSender" type="SchedulerSenderType" minOccurs="0" />
        <xs:element name="SenderSeriesSender" type="SenderSeriesSenderType" minOccurs="0" />
        <xs:element name="SenderWrapperSender" type="SenderWrapperSenderType" minOccurs="0" />
        <xs:element name="ShadowSender" type="ShadowSenderType" minOccurs="0" />
        <xs:element name="TimeoutGuardSenderWithParametersBaseSender" type="TimeoutGuardSenderWithParametersBaseSenderType" minOccurs="0" />
        <xs:element name="WebServiceNtlmSender" type="WebServiceNtlmSenderType" minOccurs="0" />
        <xs:element name="WebServiceSender" type="WebServiceSenderType" minOccurs="0" />
        <xs:element name="XComSender" type="XComSenderType" minOccurs="0" />
        <xs:element name="XfbSender" type="XfbSenderType" minOccurs="0" />
        <xs:element name="XmlJmsBrowserSender" type="XmlJmsBrowserSenderType" minOccurs="0" />
        <xs:element name="XmlQuerySender" type="XmlQuerySenderType" minOccurs="0" />
        <xs:element name="XmlValidatorSender" type="XmlValidatorSenderType" minOccurs="0" />
        <xs:element name="XsltSender" type="XsltSenderType" minOccurs="0" />
        <xs:element name="ZipWriterSender" type="ZipWriterSenderType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="DummyMessageLog" type="DummyMessageLogType" minOccurs="0" />
        <xs:element name="EsbJmsMessageLog" type="EsbJmsMessageLogType" minOccurs="0" />
        <xs:element name="JdbcMessageLog" type="JdbcMessageLogType" minOccurs="0" />
        <xs:element name="JmsMessageLog" type="JmsMessageLogType" minOccurs="0" />
        <xs:element name="OracleMessageLog" type="OracleMessageLogType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlOutputValidator" type="ApiWsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapOutputValidator" type="EsbSoapOutputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlOutputValidator" type="FxfXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlOutputValidator" type="Json2XmlOutputValidatorType" minOccurs="0" />
        <xs:element name="SoapOutputValidator" type="SoapOutputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlOutputValidator" type="WsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="XmlOutputValidator" type="XmlOutputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapOutputWrapper" type="ApiSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="BisOutputWrapper" type="BisOutputWrapperType" minOccurs="0" />
        <xs:element name="DirectOutputWrapper" type="DirectOutputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapOutputWrapper" type="EsbSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="FxfOutputWrapper" type="FxfOutputWrapperType" minOccurs="0" />
        <xs:element name="SoapOutputWrapper" type="SoapOutputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addInputToResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; the input is added to the result in an input element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for audittrailxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. if specified, the value of the pipelinesession variable is used as audit trail (instead of the default 'no audit trail) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract audit trail from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockPrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;blocksize &amp;gt; 0&lt;/code&gt;, this string is inserted at the start of the set of lines. (default: &amp;lt;block&amp;gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls multiline behaviour. when set to a value greater than 0, it specifies the number of rows send in a block to the sender. (default: 0 (one line at a time, no prefix of suffix))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;blocksize &amp;gt; 0&lt;/code&gt;, this string is inserted at the end of the set of lines. (default: &amp;lt;/block&amp;gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkRootTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, besides the xml well-formedness the root element of the result is checked to be equal to the value set (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkXmlWellFormed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the xml well-formedness of the result is checked (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectResults" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether all the results of each iteration will be collected in one result message. if set &lt;code&gt;false&lt;/code&gt;, only a small summary is returned (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for correlationidxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. is specified, the value of the pipelinesession variable is used as input for the xpathexpression or stylesheet, instead of the current input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be configured from jmsrealm, too (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="endPosition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;endposition &amp;gt;= startposition&lt;/code&gt;, this field contains the end position of the key in the current record (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exceptionOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a piperunexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when hideregex is not empty and only applies to error/logstore) either &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;firsthalf&lt;/code&gt;. when &lt;code&gt;firsthalf&lt;/code&gt; only the first half of the string is masked, otherwise (&lt;code&gt;all&lt;/code&gt;) the entire string is masked (default: all)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>next to common usage in {@link abstractpipe}, also strings in the error/logstore are masked (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreExceptions" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; ignore any exception thrown by executing sender (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="itemNoSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable to store number of item processed. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for labelxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linePrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>this string is inserted at the start of each line (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>this string is inserted at the end of each line (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>indicates wether the server uses the correlationid or the messageid in the correlationid field of the reply. this requirers the sender to have set the correlationid at the time of sending. (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, exclusive row-level locks are obtained on all the rows identified by the select statement (by appending ' for update nowait skip locked' to the end of the query) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWait" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and &gt;=0, ' for update wait #' is used instead of ' for update nowait skip locked' (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of times a processing attempt is retried after a timeout or an exception is caught or after a incorrect reply is received (see also &lt;code&gt;retryxpath&lt;/code&gt;) (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:string">
      <xs:annotation>
        <xs:documentation>force the transformer generated from the xpath-expression to omit the xml declaration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either 'text' or 'xml'. only valid for xpathexpression (default: text)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="parallel" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the calls for all items are done in parallel (a new thread is started for each call). when collectresults set &lt;code&gt;true&lt;/code&gt;, this pipe will wait for all calls to finish before results are collected and pipe result is returned (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="presumedTimeOutInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>when the previous call was a timeout, the maximum time (in seconds) after this timeout to presume the current call is also a timeout. a value of -1 indicates to never presume timeouts (default: 10 s)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="query" type="xs:string">
      <xs:annotation>
        <xs:documentation>the sql query text to be excecuted each time sendmessage() is called. when not set, the input message is taken as the query (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeDuplicates" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; duplicate input elements are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeXmlDeclarationInResults" type="xs:string">
      <xs:annotation>
        <xs:documentation>postprocess each partial result, to remove the xml-declaration, as this is not allowed inside an xml-document (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultOnTimeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>result returned when no return-message was received within the timeout limit (e.g. 'receiver timed out'). (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMaxInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of seconds waited after an unsuccessful processing attempt before another processing attempt is made (default: 600)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMinInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the starting number of seconds waited after an unsuccessful processing attempt before another processing attempt is made. each next retry this interval is doubled with a upper limit of &lt;code&gt;retrymaxinterval&lt;/code&gt; (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for retryxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression evaluated on each technical successful reply. retry is done if condition returns true (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startPosition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;startposition &amp;gt;= 0&lt;/code&gt;, this field contains the start position of the key in the current record (first character is 0); all sequenced lines with the same key are put in one block and send to the sender (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stopConditionXPathExpression" type="xs:string" />
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is first base64 decoded and then streamed to the httpservletresponse object (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stubFileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the pipe returns a message from a file, instead of doing the regular process (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to apply to each message, before sending it (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOutOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a timeoutexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useInputForExtract" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is used to extract audit trail, correlationid and label (instead of the wrapped input) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>alternatively: xpath-expression to create stylesheet from (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="CommandErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="command" type="xs:string" />
    <xs:attribute name="commandWithArguments" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOut" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="CommandSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="command" type="xs:string" />
    <xs:attribute name="commandWithArguments" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOut" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="CompareIntegerPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey1" type="xs:string">
      <xs:annotation>
        <xs:documentation>reference to one of the session variables to be compared (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey2" type="xs:string">
      <xs:annotation>
        <xs:documentation>reference to the other session variables to be compared (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="CompareStringPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey1" type="xs:string">
      <xs:annotation>
        <xs:documentation>reference to one of the session variables to be compared (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey2" type="xs:string">
      <xs:annotation>
        <xs:documentation>reference to the other session variables to be compared (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; the string values to compare are considered to be xml strings and before the actual compare both xml strings are transformed to a canonical form (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="CompressPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compress" type="xs:string">
      <xs:annotation>
        <xs:documentation>if &lt;code&gt;true&lt;/code&gt; the pipe compresses, otherwise it decompress (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="convert2String" type="xs:string">
      <xs:annotation>
        <xs:documentation>if &lt;code&gt;true&lt;/code&gt; result is returned as a string, otherwise as a byte array (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filenamePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>required if result is a file, the pattern for the result filename (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageIsContent" type="xs:string">
      <xs:annotation>
        <xs:documentation>flag indicates whether the message is the content or the path to a file with the contents. for multiple files use ';' as delimiter (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>required if result is a file, the directory in which to store the result file (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultIsContent" type="xs:string">
      <xs:annotation>
        <xs:documentation>flag indicates whether the result must be written to the message or to a file (filename = message) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="zipEntryPattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>the pattern for the zipentry name in case a zipfile is read or written (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ConfigurationType">
    <xs:sequence>
      <xs:element name="Adapter" type="AdapterType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Job" type="JobType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="autoStart" type="xs:string" />
    <xs:attribute name="configurationName" type="xs:string" />
    <xs:attribute name="loadedConfiguration" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="originalConfiguration" type="xs:string" />
    <xs:attribute name="unloadInProgressOrDone" type="xs:string" />
    <xs:attribute name="version" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="CounterSwitchPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="divisor" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: 2)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="CreateRestViewPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="contentType" type="xs:string">
      <xs:annotation>
        <xs:documentation>content type of the servlet response (default: text/html)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indentXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, result is pretty-printed. (only used when &lt;code&gt;skipemptytags=true&lt;/code&gt;) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of transformation (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:string">
      <xs:annotation>
        <xs:documentation>force the transformer generated from the xpath-expression to omit the xml declaration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either 'text' or 'xml'. only valid for xpathexpression (default: text)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string" />
    <xs:attribute name="skipEmptyTags" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; empty tags in the output are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to apply to the input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath-expression to apply to the input message. it's possible to refer to a parameter (which e.g. contains a value from a sessionkey) by using the parameter name prefixed with $ (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="CredentialCheckingPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string" />
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="defaultPassword" type="xs:string" />
    <xs:attribute name="defaultUserid" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetPassword" type="xs:string" />
    <xs:attribute name="targetUserid" type="xs:string" />
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="CrlPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="issuerSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the sessionkey that holds a stream to the certificate of the issuer who signed the crl. the steam is closed after reading (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="DelayErrorSenderType">
    <xs:attribute name="delayTime" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time the thread will be put to sleep (default: 5000 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="DelayPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="delayTime" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time the thread will be put to sleep (default: 5000 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="DelaySenderType">
    <xs:attribute name="delayTime" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time the thread will be put to sleep (default: 5000 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="DigesterPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="digesterRulesFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of file that containts the rules for xml parsing (default: (none))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="DirectInputWrapperType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a piperunexception is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in seconds of obtaining a result (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="DirectOutputWrapperType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a piperunexception is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in seconds of obtaining a result (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="DirectQueryErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobBase64Direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether the streamed blobdata will need to be base64 &lt;code&gt;encode&lt;/code&gt; or &lt;code&gt;decode&lt;/code&gt; or not. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used to read and write blobs (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobColumn" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for querytype 'updateblob': column that contains the blob to be updated (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>for querytype 'updateblob': key of session variable that contains the data (string or inputstream) to be loaded to the blob. when empty, the input of the pipe, which then must be a string, is used. for querytype 'select': key of session variable that contains the outputstream, writer or filename to write the blob to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls automatically whether blobdata is stored compressed and/or serialized in the database (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is stored compressed in the database (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobColumn" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for querytype 'updateclob': column that contains the clob to be updated (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>for querytype 'updateclob': key of session variable that contains the clob (string or inputstream) to be loaded to the clob. when empty, the input of the pipe, which then must be a string, is used. for querytype 'select': key of session variable that contains the outputstream, writer or filename to write the clob to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeOutputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the outputstream is not closed after blob or clob has been written to it (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="columnsReturned" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of columns whose values are to be returned. works only if the driver implements jdbc 3.0 getgeneratedkeys() (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="includeFieldDefinition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the result contains besides the returned rows also a header with information about the fetched fields (default: application default (true))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="lockRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, exclusive row-level locks are obtained on all the rows identified by the select statement (by appending ' for update nowait skip locked' to the end of the query) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWait" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and &gt;=0, ' for update wait #' is used instead of ' for update nowait skip locked' (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum number of rows returned (default: -1 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="nullValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>value used in result as contents of fields that contain no value (sql-null) (default: &lt;i&gt;empty string&lt;/&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="packageContent" type="xs:string" />
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queryType" type="xs:string" />
    <xs:attribute name="resultQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>query that can be used to obtain result of side-effecto of update-query, like generated value of sequence. example: select mysequence.currval from dual (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rowIdSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified, the rowid of the processed row is put in the pipelinesession under the specified key (only applicable for &lt;code&gt;querytype=other&lt;/code&gt;). &lt;b&gt;note:&lt;/b&gt; if multiple rows are processed a sqlexception is thrown. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalar" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the value of the first column of the first row (or the startrow) is returned as the only result, as a simple non-xml value (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalarExtended" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startRow" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of the first row returned from the output (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used when reading a stream (that is e.g. going to be written to a blob or clob). when empty, the stream is copied directly to the blob, without conversion (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to the httpservletresponse object of the restservicedispatcher (instead of passed as a string) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of seconds the driver will wait for a statement object to execute. if the limit is exceeded, a timeoutexception is thrown. 0 means no timeout (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="trimSpaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>remove trailing blanks from all values. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useNamedParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, every string in the message which equals &lt;code&gt;paramname&lt;/code&gt; will be replaced by the setter method for the corresponding parameter (the parameters don't need to be in the correct order and unused parameters are skipped) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="DirectQuerySenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobBase64Direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether the streamed blobdata will need to be base64 &lt;code&gt;encode&lt;/code&gt; or &lt;code&gt;decode&lt;/code&gt; or not. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used to read and write blobs (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobColumn" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for querytype 'updateblob': column that contains the blob to be updated (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>for querytype 'updateblob': key of session variable that contains the data (string or inputstream) to be loaded to the blob. when empty, the input of the pipe, which then must be a string, is used. for querytype 'select': key of session variable that contains the outputstream, writer or filename to write the blob to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls automatically whether blobdata is stored compressed and/or serialized in the database (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is stored compressed in the database (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobColumn" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for querytype 'updateclob': column that contains the clob to be updated (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>for querytype 'updateclob': key of session variable that contains the clob (string or inputstream) to be loaded to the clob. when empty, the input of the pipe, which then must be a string, is used. for querytype 'select': key of session variable that contains the outputstream, writer or filename to write the clob to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeOutputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the outputstream is not closed after blob or clob has been written to it (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="columnsReturned" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of columns whose values are to be returned. works only if the driver implements jdbc 3.0 getgeneratedkeys() (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="includeFieldDefinition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the result contains besides the returned rows also a header with information about the fetched fields (default: application default (true))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="lockRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, exclusive row-level locks are obtained on all the rows identified by the select statement (by appending ' for update nowait skip locked' to the end of the query) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWait" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and &gt;=0, ' for update wait #' is used instead of ' for update nowait skip locked' (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum number of rows returned (default: -1 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="nullValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>value used in result as contents of fields that contain no value (sql-null) (default: &lt;i&gt;empty string&lt;/&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="packageContent" type="xs:string" />
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queryType" type="xs:string" />
    <xs:attribute name="resultQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>query that can be used to obtain result of side-effecto of update-query, like generated value of sequence. example: select mysequence.currval from dual (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rowIdSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified, the rowid of the processed row is put in the pipelinesession under the specified key (only applicable for &lt;code&gt;querytype=other&lt;/code&gt;). &lt;b&gt;note:&lt;/b&gt; if multiple rows are processed a sqlexception is thrown. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalar" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the value of the first column of the first row (or the startrow) is returned as the only result, as a simple non-xml value (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalarExtended" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startRow" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of the first row returned from the output (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used when reading a stream (that is e.g. going to be written to a blob or clob). when empty, the stream is copied directly to the blob, without conversion (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to the httpservletresponse object of the restservicedispatcher (instead of passed as a string) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of seconds the driver will wait for a statement object to execute. if the limit is exceeded, a timeoutexception is thrown. 0 means no timeout (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="trimSpaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>remove trailing blanks from all values. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useNamedParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, every string in the message which equals &lt;code&gt;paramname&lt;/code&gt; will be replaced by the setter method for the corresponding parameter (the parameters don't need to be in the correct order and unused parameters are skipped) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="DirectWrapperPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a piperunexception is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in seconds of obtaining a result (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="DirectoryCleanerType">
    <xs:attribute name="deleteEmptySubdirectories" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, empty subdirectories will be deleted, too (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directory" type="xs:string">
      <xs:annotation>
        <xs:documentation>directory to be cleaned up (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="notExistWarn" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, send warnings to logging and console about not existing directories (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retention" type="xs:string">
      <xs:annotation>
        <xs:documentation>time (with suffix 'd', 'h', 'm' or 's' in milliseconds) that must have passed at least before a file will be deleted (default: 30d)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="subdirectories" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, files in subdirectories will be deleted, too (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="DirectoryListenerType">
    <xs:attribute name="createInputDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the directory to look for files is created if it does not exist (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="delete" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the file processed will deleted after being processed, and not stored (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="excludeWildcard" type="xs:string">
      <xs:annotation>
        <xs:documentation>filter of files to be excluded when looking in inputdirectory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileTimeSensitive" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the file modification time is used in addition to the filename to determine if a file has been seen before (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>directory to look for files (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="minStableTime" type="xs:string">
      <xs:annotation>
        <xs:documentation>minimal age of file in milliseconds, to avoid receiving a file while it is still being written (default: 1000 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numberOfAttempts" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum number of move attempts before throwing an exception. n.b. not used anymore. please use maxretries on the receiver instead (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numberOfBackups" type="xs:string">
      <xs:annotation>
        <xs:documentation>number of copies held of a file with the same name. backup files have a dot and a number suffixed to their name. if set to 0, no backups will be kept. (default: 5)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>directory where files are stored &lt;i&gt;while&lt;/i&gt; being processed (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFilenamePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>pattern for the name using the messageformat.format method. params: 0=inputfilename, 1=inputfile extension, 2=unique uuid, 3=current date (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="overwrite" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the destination file will be deleted if it already exists (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="passWithoutDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>pass the filename without the &lt;code&gt;outputdirectory&lt;/code&gt; to the pipeline (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="processedDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>directory where files are stored &lt;i&gt;after&lt;/i&gt; being processed (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="random" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, every file in the directory is passed in a random order (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="responseTime" type="xs:string">
      <xs:annotation>
        <xs:documentation>waittime to wait between polling. n.b. not used anymore. please use pollinterval on the receiver instead (default: 10000 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="waitBeforeRetry" type="xs:string">
      <xs:annotation>
        <xs:documentation>time waited after unsuccesful try. n.b. not used anymore. (default: 1000 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wildcard" type="xs:string">
      <xs:annotation>
        <xs:documentation>filter of files to look for in inputdirectory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="DomainTransformerPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column labels are stored in (default: label)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tableName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the table that contains the mapping (default: mapping)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueInField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column source values are stored in (default: valuein)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valueOutField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column destination values are stored in (default: valueout)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="DummyErrorStorageType">
    <xs:attribute name="active" type="xs:string" />
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the full message is stored with the log. can be set to &lt;code&gt;false&lt;/code&gt; to reduce table size, by avoiding to store the full message (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commentField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column comments are stored in (default: comments)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="correlationIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column correlation-ids are stored in (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createTable" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the table is created if it does not exist (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="dateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column the timestamp is stored in (default: messagedate)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dateFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column the timestamps are stored in (default: timestamp)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expiryDateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column the timestamp for expiry is stored in (default: expirydate)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hostField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column that stores the hostname of the server (default: host)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="idField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column messageids are stored in (default: messageid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indexName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the index, to be used in hints for query optimizer too (only for oracle) (default: ix_ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="keyField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column that contains the primary key of the table (default: messagekey)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column that contains the primary key of the table (default: int default autoincrement)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column labels are stored in (default: label)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column message themselves are stored in (default: message)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column message themselves are stored in (default: long binary)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="onlyStoreWhenMessageIdUnique" type="xs:string" />
    <xs:attribute name="order" type="xs:string" />
    <xs:attribute name="prefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>prefix to be prefixed on all database objects (tables, indices, sequences), e.q. to access a different oracle schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retention" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in days) to keep the record in the database before making it eligible for deletion by a cleanup process. when set to -1, the record will live on forever (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaOwner4Check" type="xs:string">
      <xs:annotation>
        <xs:documentation>schema owner to be used to check the database (default: &amp;lt;current_schema&amp;gt; (only for oracle))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sequenceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the sequence used to generate the primary key (only for oracle)&lt;br&gt;n.b. the default name has been changed in version 4.6 (default: seq_ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>optional identifier for this storage, to be able to share the physical table between a number of receivers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column slotids are stored in (default: slotid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeFullMessage" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the messages are stored compressed (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tableName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the table messages are stored in (default: ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="textFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the columns messageid and correlationid, slotid and comments are stored in. n.b. (100) is appended for id's, (1000) is appended for comments. (default: varchar)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>possible values are e (error store), m (message store), l (message log for pipe) or a (message log for receiver). receiverbase will always set type to e for errorstorage and always set type to a for messagelog. genericmessagesendingpipe will set type to l for messagelog (when type isn't specified). see {@link messagestoresender} for type m (default: e for errorstorage on receiver, a for messagelog on receiver and l for messagelog on pipe)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="typeField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column types are stored in (default: type)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="DummyMessageLogType">
    <xs:attribute name="active" type="xs:string" />
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the full message is stored with the log. can be set to &lt;code&gt;false&lt;/code&gt; to reduce table size, by avoiding to store the full message (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commentField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column comments are stored in (default: comments)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="correlationIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column correlation-ids are stored in (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createTable" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the table is created if it does not exist (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="dateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column the timestamp is stored in (default: messagedate)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dateFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column the timestamps are stored in (default: timestamp)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expiryDateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column the timestamp for expiry is stored in (default: expirydate)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hostField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column that stores the hostname of the server (default: host)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="idField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column messageids are stored in (default: messageid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indexName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the index, to be used in hints for query optimizer too (only for oracle) (default: ix_ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="keyField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column that contains the primary key of the table (default: messagekey)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column that contains the primary key of the table (default: int default autoincrement)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column labels are stored in (default: label)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column message themselves are stored in (default: message)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column message themselves are stored in (default: long binary)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="onlyStoreWhenMessageIdUnique" type="xs:string" />
    <xs:attribute name="order" type="xs:string" />
    <xs:attribute name="prefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>prefix to be prefixed on all database objects (tables, indices, sequences), e.q. to access a different oracle schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retention" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in days) to keep the record in the database before making it eligible for deletion by a cleanup process. when set to -1, the record will live on forever (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaOwner4Check" type="xs:string">
      <xs:annotation>
        <xs:documentation>schema owner to be used to check the database (default: &amp;lt;current_schema&amp;gt; (only for oracle))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sequenceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the sequence used to generate the primary key (only for oracle)&lt;br&gt;n.b. the default name has been changed in version 4.6 (default: seq_ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>optional identifier for this storage, to be able to share the physical table between a number of receivers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column slotids are stored in (default: slotid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeFullMessage" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the messages are stored compressed (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tableName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the table messages are stored in (default: ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="textFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the columns messageid and correlationid, slotid and comments are stored in. n.b. (100) is appended for id's, (1000) is appended for comments. (default: varchar)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>possible values are e (error store), m (message store), l (message log for pipe) or a (message log for receiver). receiverbase will always set type to e for errorstorage and always set type to a for messagelog. genericmessagesendingpipe will set type to l for messagelog (when type isn't specified). see {@link messagestoresender} for type m (default: e for errorstorage on receiver, a for messagelog on receiver and l for messagelog on pipe)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="typeField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column types are stored in (default: type)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="EchoErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>hack to allow to introduce a correlationid (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="EchoPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="EchoSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>hack to allow to introduce a correlationid (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="EsbJmsErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="ackMode" type="xs:string" />
    <xs:attribute name="acknowledgeMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: auto_acknowledge)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to jms server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdMaxLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the correlationid exceeds this maximum length, the correlationid is trimmed from the left side of a string to this maximum length (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHex" type="xs:string">
      <xs:annotation>
        <xs:documentation>transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part). useful when sending messages to mq which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: mqjms1044: string is not a valid hexadecimal number (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deliveryMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls mode that messages are sent with: either 'persistent' or 'non_persistent' (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the jms destination (queue or topic) to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;topic&lt;/code&gt; (default: &lt;code&gt;queue&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyleURI" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsTransacted" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when synchronous='true' and and replytoname is set) eithter 'correlationid', 'correlationid_from_message' or 'messageid'. indicates wether the server uses the correlationid from the pipeline, the correlationid from the message or the messageid in the correlationid field of the reply. this requires the sender to have set the correlationid at the time of sending. (default: messageid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lookupDestination" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the destinationname is used directly instead of performing a jndi lookup (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageProtocol" type="xs:string" />
    <xs:attribute name="messageSelector" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the value of this attribute is used as a selector to filter messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in milliseconds) it takes for the message to expire. if the message is not consumed before, it will be lost. make sure to set it to a positive value for request/repy type of messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of the jmstype field (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistent" type="xs:string">
      <xs:annotation>
        <xs:documentation>rather useless attribute, and not the same as &lt;code&gt;deliverymode&lt;/code&gt;. you probably want to use that. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="priority" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets the priority that is used to deliver the message. ranges from 0 to 9. defaults to -1, meaning not set. effectively the default priority is set by jms to 4 (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the queueconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;queue&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replySoapHeaderSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to store soap header of reply (default: soapheader)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum time in ms to wait for a reply. 0 means no timeout. (only for synchronous=true) (default: 5000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespaceURI" type="xs:string" />
    <xs:attribute name="soap" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapAction" type="xs:string">
      <xs:annotation>
        <xs:documentation>soapaction string sent as messageproperty (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of parameter containing soap header (default: soapheader)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="subscriberType" type="xs:string" />
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the sender operates in rr mode: the a reply is expected, either on the queue specified in 'replytoname', or on a dynamically generated temporary queue (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOut" type="xs:string" />
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the topicconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;topic&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="EsbJmsErrorStorageType">
    <xs:attribute name="ackMode" type="xs:string" />
    <xs:attribute name="acknowledgeMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: auto_acknowledge)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to jms server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdMaxLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the correlationid exceeds this maximum length, the correlationid is trimmed from the left side of a string to this maximum length (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHex" type="xs:string">
      <xs:annotation>
        <xs:documentation>transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part). useful when sending messages to mq which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: mqjms1044: string is not a valid hexadecimal number (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the jms destination (queue or topic) to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;topic&lt;/code&gt; (default: &lt;code&gt;queue&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsTransacted" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="lookupDestination" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the destinationname is used directly instead of performing a jndi lookup (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageSelector" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the value of this attribute is used as a selector to filter messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in milliseconds) it takes for the message to expire. if the message is not consumed before, it will be lost. make sure to set it to a positive value for request/repy type of messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistent" type="xs:string">
      <xs:annotation>
        <xs:documentation>rather useless attribute, and not the same as &lt;code&gt;deliverymode&lt;/code&gt;. you probably want to use that. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the queueconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;queue&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>optional identifier for this storage, to be able to share the physical storage between a number of receivers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="subscriberType" type="xs:string" />
    <xs:attribute name="timeOut" type="xs:string" />
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the topicconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;topic&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string" />
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="EsbJmsListenerType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="ackMode" type="xs:string" />
    <xs:attribute name="acknowledgeMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: auto_acknowledge)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to jms server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cacheMode" type="xs:string" />
    <xs:attribute name="commitOnState" type="xs:string">
      <xs:annotation>
        <xs:documentation>&lt;i&gt;deprecated&lt;/i&gt; exit state to control commit or rollback of jmssession. only used if &lt;code&gt;jmstransacted&lt;/code&gt; is set true. (default: success)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="copyAEProperties" type="xs:string" />
    <xs:attribute name="correlationIdMaxLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the correlationid exceeds this maximum length, the correlationid is trimmed from the left side of a string to this maximum length (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHex" type="xs:string">
      <xs:annotation>
        <xs:documentation>transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part). useful when sending messages to mq which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: mqjms1044: string is not a valid hexadecimal number (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the jms destination (queue or topic) to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;topic&lt;/code&gt; (default: &lt;code&gt;queue&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forceMessageIdAsCorrelationId" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsTransacted" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="listenerPort" type="xs:string" />
    <xs:attribute name="lookupDestination" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the destinationname is used directly instead of performing a jndi lookup (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageProtocol" type="xs:string" />
    <xs:attribute name="messageSelector" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the value of this attribute is used as a selector to filter messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in milliseconds) it takes for the message to expire. if the message is not consumed before, it will be lost. make sure to set it to a positive value for request/repy type of messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistent" type="xs:string">
      <xs:annotation>
        <xs:documentation>rather useless attribute, and not the same as &lt;code&gt;deliverymode&lt;/code&gt;. you probably want to use that. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pollGuardInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>interval in milliseconds for the poll guard to check whether a successful poll was done by the receive (https://docs.oracle.com/javaee/7/api/javax/jms/messageconsumer.html#receive-long-) since last check. when polling has stopped this will be logged and the listener will be stopped and started in an attempt to workaround problems with polling. polling might stop due to bugs in the jms driver/implementation which should be fixed by the supplier. as the poll time includes reading and processing of the message no successful poll might be registered since the last check when message processing takes a long time, hence while messages are being processed the check on last successful poll will be skipped. set to -1 to disable (default: ten times the specified timeout)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the queueconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;queue&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyDeliveryMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls mode that reply messages are sent with: either 'persistent' or 'non_persistent' (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyEncodingStyleURI" type="xs:string" />
    <xs:attribute name="replyMessageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>time that replymessage will live (default: 0 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyMessageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of the jmstype field of the reply message (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyNamespaceURI" type="xs:string" />
    <xs:attribute name="replyPriority" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets the priority that is used to deliver the reply message. ranges from 0 to 9. defaults to -1, meaning not set. effectively the default priority is set by jms to 4 (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replySoapAction" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soap" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="subscriberType" type="xs:string" />
    <xs:attribute name="timeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>receiver timeout, in milliseconds (default: 3000 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the topicconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;topic&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useReplyTo" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xPathLoggingKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of all xpath keys that need to be logged. (overrides &lt;code&gt;msg.log.keys&lt;/code&gt; property) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="EsbJmsMessageLogType">
    <xs:attribute name="ackMode" type="xs:string" />
    <xs:attribute name="acknowledgeMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: auto_acknowledge)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to jms server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdMaxLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the correlationid exceeds this maximum length, the correlationid is trimmed from the left side of a string to this maximum length (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHex" type="xs:string">
      <xs:annotation>
        <xs:documentation>transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part). useful when sending messages to mq which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: mqjms1044: string is not a valid hexadecimal number (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the jms destination (queue or topic) to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;topic&lt;/code&gt; (default: &lt;code&gt;queue&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsTransacted" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="lookupDestination" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the destinationname is used directly instead of performing a jndi lookup (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageSelector" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the value of this attribute is used as a selector to filter messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in milliseconds) it takes for the message to expire. if the message is not consumed before, it will be lost. make sure to set it to a positive value for request/repy type of messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistent" type="xs:string">
      <xs:annotation>
        <xs:documentation>rather useless attribute, and not the same as &lt;code&gt;deliverymode&lt;/code&gt;. you probably want to use that. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the queueconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;queue&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>optional identifier for this storage, to be able to share the physical storage between a number of receivers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="subscriberType" type="xs:string" />
    <xs:attribute name="timeOut" type="xs:string" />
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the topicconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;topic&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string" />
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="EsbJmsSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="ackMode" type="xs:string" />
    <xs:attribute name="acknowledgeMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: auto_acknowledge)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to jms server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdMaxLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the correlationid exceeds this maximum length, the correlationid is trimmed from the left side of a string to this maximum length (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHex" type="xs:string">
      <xs:annotation>
        <xs:documentation>transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part). useful when sending messages to mq which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: mqjms1044: string is not a valid hexadecimal number (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deliveryMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls mode that messages are sent with: either 'persistent' or 'non_persistent' (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the jms destination (queue or topic) to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;topic&lt;/code&gt; (default: &lt;code&gt;queue&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyleURI" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsTransacted" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when synchronous='true' and and replytoname is set) eithter 'correlationid', 'correlationid_from_message' or 'messageid'. indicates wether the server uses the correlationid from the pipeline, the correlationid from the message or the messageid in the correlationid field of the reply. this requires the sender to have set the correlationid at the time of sending. (default: messageid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lookupDestination" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the destinationname is used directly instead of performing a jndi lookup (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageProtocol" type="xs:string" />
    <xs:attribute name="messageSelector" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the value of this attribute is used as a selector to filter messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in milliseconds) it takes for the message to expire. if the message is not consumed before, it will be lost. make sure to set it to a positive value for request/repy type of messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of the jmstype field (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistent" type="xs:string">
      <xs:annotation>
        <xs:documentation>rather useless attribute, and not the same as &lt;code&gt;deliverymode&lt;/code&gt;. you probably want to use that. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="priority" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets the priority that is used to deliver the message. ranges from 0 to 9. defaults to -1, meaning not set. effectively the default priority is set by jms to 4 (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the queueconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;queue&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replySoapHeaderSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to store soap header of reply (default: soapheader)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum time in ms to wait for a reply. 0 means no timeout. (only for synchronous=true) (default: 5000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespaceURI" type="xs:string" />
    <xs:attribute name="soap" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapAction" type="xs:string">
      <xs:annotation>
        <xs:documentation>soapaction string sent as messageproperty (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of parameter containing soap header (default: soapheader)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="subscriberType" type="xs:string" />
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the sender operates in rr mode: the a reply is expected, either on the queue specified in 'replytoname', or on a dynamically generated temporary queue (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOut" type="xs:string" />
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the topicconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;topic&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="EsbSoapInputValidatorType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cmhVersion" type="xs:string" />
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="direction" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mode" type="xs:string" />
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputSoapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>identical to the &lt;code&gt;soapbody&lt;/code&gt; attribute except that it's used for the output message instead of the input message. for more information see &lt;a href="#note1"&gt;note 1&lt;/a&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="responseRoot" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>always envelope (not allowed to change) (default: envelope)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap body. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap body, for example to allow element x and an empty soap body use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap header. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap header, for example to allow element x and an empty soap header use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be used when the soap header element exists multiple times (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>soap envelope xsd version to use: 1.1, 1.2 or any (both 1.1 and 1.2) (default: 1.1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="EsbSoapInputWrapperType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addOutputNamespace" type="xs:string" />
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cmhVersion" type="xs:string" />
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt; (default: wrap)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the soap header (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fixResultNamespace" type="xs:string" />
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreSoapFault" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;false&lt;/code&gt; and the soap body contains a soap fault, a piperunexception is thrown (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mode" type="xs:string" />
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when not empty, this namespace is added to the root element in the soap body (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, namespaces (and prefixes) in the content of the soap body are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeUnusedOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt; and &lt;code&gt;removeoutputnamespaces=false&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, unused namespaces in the content of the soap body are removed (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retrievePhysicalDestination" type="xs:string" />
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the root element in the soap body is changed to this value (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to apply to the input message. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="soapHeaderStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to create the content of the soap header. as input for this stylesheet a dummy xml string is used. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) namespace of the soap envelope (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useFixedValues" type="xs:string" />
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="EsbSoapOutputValidatorType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cmhVersion" type="xs:string" />
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="direction" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mode" type="xs:string" />
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputSoapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>identical to the &lt;code&gt;soapbody&lt;/code&gt; attribute except that it's used for the output message instead of the input message. for more information see &lt;a href="#note1"&gt;note 1&lt;/a&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="responseRoot" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>always envelope (not allowed to change) (default: envelope)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap body. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap body, for example to allow element x and an empty soap body use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap header. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap header, for example to allow element x and an empty soap header use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be used when the soap header element exists multiple times (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>soap envelope xsd version to use: 1.1, 1.2 or any (both 1.1 and 1.2) (default: 1.1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="EsbSoapOutputWrapperType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addOutputNamespace" type="xs:string" />
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cmhVersion" type="xs:string" />
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt; (default: wrap)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the soap header (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fixResultNamespace" type="xs:string" />
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreSoapFault" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;false&lt;/code&gt; and the soap body contains a soap fault, a piperunexception is thrown (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mode" type="xs:string" />
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when not empty, this namespace is added to the root element in the soap body (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, namespaces (and prefixes) in the content of the soap body are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeUnusedOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt; and &lt;code&gt;removeoutputnamespaces=false&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, unused namespaces in the content of the soap body are removed (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retrievePhysicalDestination" type="xs:string" />
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the root element in the soap body is changed to this value (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to apply to the input message. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="soapHeaderStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to create the content of the soap header. as input for this stylesheet a dummy xml string is used. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) namespace of the soap envelope (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useFixedValues" type="xs:string" />
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="EsbSoapValidatorPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cmhVersion" type="xs:string" />
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="direction" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mode" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputSoapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>identical to the &lt;code&gt;soapbody&lt;/code&gt; attribute except that it's used for the output message instead of the input message. for more information see &lt;a href="#note1"&gt;note 1&lt;/a&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="responseRoot" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>always envelope (not allowed to change) (default: envelope)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap body. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap body, for example to allow element x and an empty soap body use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap header. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap header, for example to allow element x and an empty soap header use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be used when the soap header element exists multiple times (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>soap envelope xsd version to use: 1.1, 1.2 or any (both 1.1 and 1.2) (default: 1.1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="EsbSoapWrapperPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addOutputNamespace" type="xs:string" />
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cmhVersion" type="xs:string" />
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt; (default: wrap)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the soap header (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fixResultNamespace" type="xs:string" />
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreSoapFault" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;false&lt;/code&gt; and the soap body contains a soap fault, a piperunexception is thrown (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mode" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when not empty, this namespace is added to the root element in the soap body (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, namespaces (and prefixes) in the content of the soap body are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeUnusedOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt; and &lt;code&gt;removeoutputnamespaces=false&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, unused namespaces in the content of the soap body are removed (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retrievePhysicalDestination" type="xs:string" />
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the root element in the soap body is changed to this value (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to apply to the input message. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="soapHeaderStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to create the content of the soap header. as input for this stylesheet a dummy xml string is used. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) namespace of the soap envelope (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useFixedValues" type="xs:string" />
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="EscapePipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;encode&lt;/code&gt;, &lt;code&gt;decode&lt;/code&gt; or &lt;code&gt;cdata2text&lt;/code&gt; (default: encode)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodeSubstring" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; special characters in &lt;code&gt;substringstart&lt;/code&gt; and &lt;code&gt;substringend&lt;/code&gt; are first translated to their xml equivalents (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="substringEnd" type="xs:string">
      <xs:annotation>
        <xs:documentation>substring to end translation (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="substringStart" type="xs:string">
      <xs:annotation>
        <xs:documentation>substring to start translation (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="EtagHandlerPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="action" type="xs:string" />
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restPath" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="uriPattern" type="xs:string" />
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ExceptionPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a piperunexception is thrown. otherwise the output is only logged as an error (and no rollback is performed). (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ExchangeMailListenerType">
    <xs:attribute name="authAlias" type="xs:string" />
    <xs:attribute name="filter" type="xs:string" />
    <xs:attribute name="inputFolder" type="xs:string" />
    <xs:attribute name="mailAddress" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="outputFolder" type="xs:string" />
    <xs:attribute name="password" type="xs:string" />
    <xs:attribute name="simple" type="xs:string" />
    <xs:attribute name="storeEmailAsStreamInSessionKey" type="xs:string" />
    <xs:attribute name="url" type="xs:string" />
    <xs:attribute name="userName" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ExecuteJdbcPropertiesPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a piperunexception is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in seconds of obtaining a result (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ExecutePipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="command" type="xs:string">
      <xs:annotation>
        <xs:documentation>the command to execute (if command and commandsessionkey are empty, the command is taken from the input of the pipe) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commandSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>the session key that holds the command to execute (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ExitType">
    <xs:attribute name="path" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the pipeline exit (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="state" type="xs:string">
      <xs:annotation>
        <xs:documentation>the exit state defines possible exists to the pipeline. the state can be one of the following: &lt;code&gt;success, error&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="FileErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="actions" type="xs:string" />
    <xs:attribute name="createDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the directory to read from or write to is created if it does not exist (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deleteEmptyDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when actions=delete) when set to &lt;code&gt;true&lt;/code&gt;, the directory from which a file is deleted is also deleted when it contains no other files (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directory" type="xs:string">
      <xs:annotation>
        <xs:documentation>base directory where files are stored in or read from (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the file to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>the session key that contains the name of the file to use (only used if filename is not set) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="skipBOM" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, a possible bytes order mark (bom) at the start of the file is skipped (only used for the action read and encoding uft-8) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when outputtype=stream) if set, the result is streamed to the httpservletresponse object (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="testCanWrite" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, a test is performed to find out if a temporary file can be created and deleted in the specified directory (only used if directory is set and combined with the action write, write_append or create) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeLineSeparator" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, a line separator is written after the content is written (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>suffix of the file to be created (only used if filename and filenamesession are not set) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="FileLineIteratorPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapInputWrapper" type="ApiSoapInputWrapperType" minOccurs="0" />
        <xs:element name="BisInputWrapper" type="BisInputWrapperType" minOccurs="0" />
        <xs:element name="DirectInputWrapper" type="DirectInputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapInputWrapper" type="EsbSoapInputWrapperType" minOccurs="0" />
        <xs:element name="FxfInputWrapper" type="FxfInputWrapperType" minOccurs="0" />
        <xs:element name="SoapInputWrapper" type="SoapInputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlInputValidator" type="ApiWsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapInputValidator" type="EsbSoapInputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlInputValidator" type="FxfXmlInputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlInputValidator" type="Json2XmlInputValidatorType" minOccurs="0" />
        <xs:element name="SoapInputValidator" type="SoapInputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlInputValidator" type="WsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="XmlInputValidator" type="XmlInputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="Afm2EdiFactSender" type="Afm2EdiFactSenderType" minOccurs="0" />
        <xs:element name="BisJmsSender" type="BisJmsSenderType" minOccurs="0" />
        <xs:element name="CommandSender" type="CommandSenderType" minOccurs="0" />
        <xs:element name="DelaySender" type="DelaySenderType" minOccurs="0" />
        <xs:element name="DirectQuerySender" type="DirectQuerySenderType" minOccurs="0" />
        <xs:element name="EchoSender" type="EchoSenderType" minOccurs="0" />
        <xs:element name="EsbJmsSender" type="EsbJmsSenderType" minOccurs="0" />
        <xs:element name="FileSender" type="FileSenderType" minOccurs="0" />
        <xs:element name="FixedQuerySender" type="FixedQuerySenderType" minOccurs="0" />
        <xs:element name="FixedResultSender" type="FixedResultSenderType" minOccurs="0" />
        <xs:element name="FtpSender" type="FtpSenderType" minOccurs="0" />
        <xs:element name="HttpSender" type="HttpSenderType" minOccurs="0" />
        <xs:element name="IbisJavaSender" type="IbisJavaSenderType" minOccurs="0" />
        <xs:element name="IbisLocalSender" type="IbisLocalSenderType" minOccurs="0" />
        <xs:element name="IbisWebServiceSender" type="IbisWebServiceSenderType" minOccurs="0" />
        <xs:element name="JmsSender" type="JmsSenderType" minOccurs="0" />
        <xs:element name="LdapSender" type="LdapSenderType" minOccurs="0" />
        <xs:element name="LogSender" type="LogSenderType" minOccurs="0" />
        <xs:element name="MailSender" type="MailSenderType" minOccurs="0" />
        <xs:element name="MessageStoreSender" type="MessageStoreSenderType" minOccurs="0" />
        <xs:element name="MqttSender" type="MqttSenderType" minOccurs="0" />
        <xs:element name="ParallelSendersSender" type="ParallelSendersSenderType" minOccurs="0" />
        <xs:element name="ReloadSender" type="ReloadSenderType" minOccurs="0" />
        <xs:element name="RestSender" type="RestSenderType" minOccurs="0" />
        <xs:element name="ResultSet2FileSender" type="ResultSet2FileSenderType" minOccurs="0" />
        <xs:element name="SambaSender" type="SambaSenderType" minOccurs="0" />
        <xs:element name="SchedulerSender" type="SchedulerSenderType" minOccurs="0" />
        <xs:element name="SenderSeriesSender" type="SenderSeriesSenderType" minOccurs="0" />
        <xs:element name="SenderWrapperSender" type="SenderWrapperSenderType" minOccurs="0" />
        <xs:element name="ShadowSender" type="ShadowSenderType" minOccurs="0" />
        <xs:element name="TimeoutGuardSenderWithParametersBaseSender" type="TimeoutGuardSenderWithParametersBaseSenderType" minOccurs="0" />
        <xs:element name="WebServiceNtlmSender" type="WebServiceNtlmSenderType" minOccurs="0" />
        <xs:element name="WebServiceSender" type="WebServiceSenderType" minOccurs="0" />
        <xs:element name="XComSender" type="XComSenderType" minOccurs="0" />
        <xs:element name="XfbSender" type="XfbSenderType" minOccurs="0" />
        <xs:element name="XmlJmsBrowserSender" type="XmlJmsBrowserSenderType" minOccurs="0" />
        <xs:element name="XmlQuerySender" type="XmlQuerySenderType" minOccurs="0" />
        <xs:element name="XmlValidatorSender" type="XmlValidatorSenderType" minOccurs="0" />
        <xs:element name="XsltSender" type="XsltSenderType" minOccurs="0" />
        <xs:element name="ZipWriterSender" type="ZipWriterSenderType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="DummyMessageLog" type="DummyMessageLogType" minOccurs="0" />
        <xs:element name="EsbJmsMessageLog" type="EsbJmsMessageLogType" minOccurs="0" />
        <xs:element name="JdbcMessageLog" type="JdbcMessageLogType" minOccurs="0" />
        <xs:element name="JmsMessageLog" type="JmsMessageLogType" minOccurs="0" />
        <xs:element name="OracleMessageLog" type="OracleMessageLogType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlOutputValidator" type="ApiWsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapOutputValidator" type="EsbSoapOutputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlOutputValidator" type="FxfXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlOutputValidator" type="Json2XmlOutputValidatorType" minOccurs="0" />
        <xs:element name="SoapOutputValidator" type="SoapOutputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlOutputValidator" type="WsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="XmlOutputValidator" type="XmlOutputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapOutputWrapper" type="ApiSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="BisOutputWrapper" type="BisOutputWrapperType" minOccurs="0" />
        <xs:element name="DirectOutputWrapper" type="DirectOutputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapOutputWrapper" type="EsbSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="FxfOutputWrapper" type="FxfOutputWrapperType" minOccurs="0" />
        <xs:element name="SoapOutputWrapper" type="SoapOutputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addInputToResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; the input is added to the result in an input element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for audittrailxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. if specified, the value of the pipelinesession variable is used as audit trail (instead of the default 'no audit trail) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract audit trail from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockPrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;blocksize &amp;gt; 0&lt;/code&gt;, this string is inserted at the start of the set of lines. (default: &amp;lt;block&amp;gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls multiline behaviour. when set to a value greater than 0, it specifies the number of rows send in a block to the sender. (default: 0 (one line at a time, no prefix of suffix))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;blocksize &amp;gt; 0&lt;/code&gt;, this string is inserted at the end of the set of lines. (default: &amp;lt;/block&amp;gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkRootTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, besides the xml well-formedness the root element of the result is checked to be equal to the value set (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkXmlWellFormed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the xml well-formedness of the result is checked (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectResults" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether all the results of each iteration will be collected in one result message. if set &lt;code&gt;false&lt;/code&gt;, only a small summary is returned (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for correlationidxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. is specified, the value of the pipelinesession variable is used as input for the xpathexpression or stylesheet, instead of the current input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="endOfLineString" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, each line has to end with this string. if the line doesn't end with this string next lines are added (including line separators) until the total line ends with the given string (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="endPosition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;endposition &amp;gt;= startposition&lt;/code&gt;, this field contains the end position of the key in the current record (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exceptionOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a piperunexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when hideregex is not empty and only applies to error/logstore) either &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;firsthalf&lt;/code&gt;. when &lt;code&gt;firsthalf&lt;/code&gt; only the first half of the string is masked, otherwise (&lt;code&gt;all&lt;/code&gt;) the entire string is masked (default: all)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>next to common usage in {@link abstractpipe}, also strings in the error/logstore are masked (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreExceptions" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; ignore any exception thrown by executing sender (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="itemNoSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable to store number of item processed. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for labelxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linePrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>this string is inserted at the start of each line (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>this string is inserted at the end of each line (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>indicates wether the server uses the correlationid or the messageid in the correlationid field of the reply. this requirers the sender to have set the correlationid at the time of sending. (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of times a processing attempt is retried after a timeout or an exception is caught or after a incorrect reply is received (see also &lt;code&gt;retryxpath&lt;/code&gt;) (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="move2dirAfterError" type="xs:string">
      <xs:annotation>
        <xs:documentation>directory to which the inputfile is moved in case an error occurs (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="move2dirAfterTransform" type="xs:string">
      <xs:annotation>
        <xs:documentation>directory in which the transformed file(s) is stored (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:string">
      <xs:annotation>
        <xs:documentation>force the transformer generated from the xpath-expression to omit the xml declaration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either 'text' or 'xml'. only valid for xpathexpression (default: text)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="parallel" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the calls for all items are done in parallel (a new thread is started for each call). when collectresults set &lt;code&gt;true&lt;/code&gt;, this pipe will wait for all calls to finish before results are collected and pipe result is returned (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="presumedTimeOutInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>when the previous call was a timeout, the maximum time (in seconds) after this timeout to presume the current call is also a timeout. a value of -1 indicates to never presume timeouts (default: 10 s)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeDuplicates" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; duplicate input elements are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeXmlDeclarationInResults" type="xs:string">
      <xs:annotation>
        <xs:documentation>postprocess each partial result, to remove the xml-declaration, as this is not allowed inside an xml-document (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultOnTimeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>result returned when no return-message was received within the timeout limit (e.g. 'receiver timed out'). (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMaxInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of seconds waited after an unsuccessful processing attempt before another processing attempt is made (default: 600)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMinInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the starting number of seconds waited after an unsuccessful processing attempt before another processing attempt is made. each next retry this interval is doubled with a upper limit of &lt;code&gt;retrymaxinterval&lt;/code&gt; (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for retryxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression evaluated on each technical successful reply. retry is done if condition returns true (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startPosition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;startposition &amp;gt;= 0&lt;/code&gt;, this field contains the start position of the key in the current record (first character is 0); all sequenced lines with the same key are put in one block and send to the sender (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stopConditionXPathExpression" type="xs:string" />
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is first base64 decoded and then streamed to the httpservletresponse object (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stubFileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the pipe returns a message from a file, instead of doing the regular process (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to apply to each message, before sending it (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOutOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a timeoutexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useInputForExtract" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is used to extract audit trail, correlationid and label (instead of the wrapped input) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>alternatively: xpath-expression to create stylesheet from (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="FilePipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="FileRecordListenerType">
    <xs:attribute name="directoryProcessedFiles" type="xs:string">
      <xs:annotation>
        <xs:documentation>the directory to store processed files in (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>set the directory name to look in for files. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener as known to the adapter. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="responseTime" type="xs:string">
      <xs:annotation>
        <xs:documentation>set the time to delay when no records are to be processed and this class has to look for the arrival of a new file (default: 1000 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeFileNameInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the name of the read file is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wildcard" type="xs:string">
      <xs:annotation>
        <xs:documentation>the {@link nl.nn.adapterframework.util.wildcardfilter wildcard} to look for files in the specified directory, e.g. "*.inp" (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="FileSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="actions" type="xs:string" />
    <xs:attribute name="createDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the directory to read from or write to is created if it does not exist (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deleteEmptyDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when actions=delete) when set to &lt;code&gt;true&lt;/code&gt;, the directory from which a file is deleted is also deleted when it contains no other files (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directory" type="xs:string">
      <xs:annotation>
        <xs:documentation>base directory where files are stored in or read from (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the file to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>the session key that contains the name of the file to use (only used if filename is not set) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="skipBOM" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, a possible bytes order mark (bom) at the start of the file is skipped (only used for the action read and encoding uft-8) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when outputtype=stream) if set, the result is streamed to the httpservletresponse object (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="testCanWrite" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, a test is performed to find out if a temporary file can be created and deleted in the specified directory (only used if directory is set and combined with the action write, write_append or create) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeLineSeparator" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, a line separator is written after the content is written (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>suffix of the file to be created (only used if filename and filenamesession are not set) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="FilenameSwitchPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="notFoundForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when the forward or pipename derived from the filename that was the input could not be found.&lt;/i&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="toLowercase" type="xs:string">
      <xs:annotation>
        <xs:documentation>convert the result to lowercase, before searching for a corresponding forward (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="FixedForwardPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="FixedQueryErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobBase64Direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether the streamed blobdata will need to be base64 &lt;code&gt;encode&lt;/code&gt; or &lt;code&gt;decode&lt;/code&gt; or not. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used to read and write blobs (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobColumn" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for querytype 'updateblob': column that contains the blob to be updated (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>for querytype 'updateblob': key of session variable that contains the data (string or inputstream) to be loaded to the blob. when empty, the input of the pipe, which then must be a string, is used. for querytype 'select': key of session variable that contains the outputstream, writer or filename to write the blob to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls automatically whether blobdata is stored compressed and/or serialized in the database (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is stored compressed in the database (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobColumn" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for querytype 'updateclob': column that contains the clob to be updated (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>for querytype 'updateclob': key of session variable that contains the clob (string or inputstream) to be loaded to the clob. when empty, the input of the pipe, which then must be a string, is used. for querytype 'select': key of session variable that contains the outputstream, writer or filename to write the clob to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeOutputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the outputstream is not closed after blob or clob has been written to it (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="columnsReturned" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of columns whose values are to be returned. works only if the driver implements jdbc 3.0 getgeneratedkeys() (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="includeFieldDefinition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the result contains besides the returned rows also a header with information about the fetched fields (default: application default (true))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="lockRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, exclusive row-level locks are obtained on all the rows identified by the select statement (by appending ' for update nowait skip locked' to the end of the query) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWait" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and &gt;=0, ' for update wait #' is used instead of ' for update nowait skip locked' (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum number of rows returned (default: -1 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="nullValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>value used in result as contents of fields that contain no value (sql-null) (default: &lt;i&gt;empty string&lt;/&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="packageContent" type="xs:string" />
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="query" type="xs:string">
      <xs:annotation>
        <xs:documentation>the sql query text to be excecuted each time sendmessage() is called (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queryType" type="xs:string" />
    <xs:attribute name="resultQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>query that can be used to obtain result of side-effecto of update-query, like generated value of sequence. example: select mysequence.currval from dual (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rowIdSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified, the rowid of the processed row is put in the pipelinesession under the specified key (only applicable for &lt;code&gt;querytype=other&lt;/code&gt;). &lt;b&gt;note:&lt;/b&gt; if multiple rows are processed a sqlexception is thrown. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalar" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the value of the first column of the first row (or the startrow) is returned as the only result, as a simple non-xml value (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalarExtended" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startRow" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of the first row returned from the output (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used when reading a stream (that is e.g. going to be written to a blob or clob). when empty, the stream is copied directly to the blob, without conversion (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to the httpservletresponse object of the restservicedispatcher (instead of passed as a string) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of seconds the driver will wait for a statement object to execute. if the limit is exceeded, a timeoutexception is thrown. 0 means no timeout (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="trimSpaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>remove trailing blanks from all values. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useNamedParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, every string in the message which equals &lt;code&gt;paramname&lt;/code&gt; will be replaced by the setter method for the corresponding parameter (the parameters don't need to be in the correct order and unused parameters are skipped) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="FixedQuerySenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobBase64Direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether the streamed blobdata will need to be base64 &lt;code&gt;encode&lt;/code&gt; or &lt;code&gt;decode&lt;/code&gt; or not. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used to read and write blobs (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobColumn" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for querytype 'updateblob': column that contains the blob to be updated (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>for querytype 'updateblob': key of session variable that contains the data (string or inputstream) to be loaded to the blob. when empty, the input of the pipe, which then must be a string, is used. for querytype 'select': key of session variable that contains the outputstream, writer or filename to write the blob to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls automatically whether blobdata is stored compressed and/or serialized in the database (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is stored compressed in the database (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobColumn" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for querytype 'updateclob': column that contains the clob to be updated (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>for querytype 'updateclob': key of session variable that contains the clob (string or inputstream) to be loaded to the clob. when empty, the input of the pipe, which then must be a string, is used. for querytype 'select': key of session variable that contains the outputstream, writer or filename to write the clob to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeOutputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the outputstream is not closed after blob or clob has been written to it (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="columnsReturned" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of columns whose values are to be returned. works only if the driver implements jdbc 3.0 getgeneratedkeys() (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="includeFieldDefinition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the result contains besides the returned rows also a header with information about the fetched fields (default: application default (true))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="lockRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, exclusive row-level locks are obtained on all the rows identified by the select statement (by appending ' for update nowait skip locked' to the end of the query) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWait" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and &gt;=0, ' for update wait #' is used instead of ' for update nowait skip locked' (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum number of rows returned (default: -1 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="nullValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>value used in result as contents of fields that contain no value (sql-null) (default: &lt;i&gt;empty string&lt;/&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="packageContent" type="xs:string" />
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="query" type="xs:string">
      <xs:annotation>
        <xs:documentation>the sql query text to be excecuted each time sendmessage() is called (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queryType" type="xs:string" />
    <xs:attribute name="resultQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>query that can be used to obtain result of side-effecto of update-query, like generated value of sequence. example: select mysequence.currval from dual (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rowIdSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified, the rowid of the processed row is put in the pipelinesession under the specified key (only applicable for &lt;code&gt;querytype=other&lt;/code&gt;). &lt;b&gt;note:&lt;/b&gt; if multiple rows are processed a sqlexception is thrown. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalar" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the value of the first column of the first row (or the startrow) is returned as the only result, as a simple non-xml value (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalarExtended" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startRow" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of the first row returned from the output (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used when reading a stream (that is e.g. going to be written to a blob or clob). when empty, the stream is copied directly to the blob, without conversion (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to the httpservletresponse object of the restservicedispatcher (instead of passed as a string) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of seconds the driver will wait for a statement object to execute. if the limit is exceeded, a timeoutexception is thrown. 0 means no timeout (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="trimSpaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>remove trailing blanks from all values. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useNamedParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, every string in the message which equals &lt;code&gt;paramname&lt;/code&gt; will be replaced by the setter method for the corresponding parameter (the parameters don't need to be in the correct order and unused parameters are skipped) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="FixedResultErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="fileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the file containing the resultmessage (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceFrom" type="xs:string" />
    <xs:attribute name="replaceTo" type="xs:string" />
    <xs:attribute name="returnString" type="xs:string">
      <xs:annotation>
        <xs:documentation>returned message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string" />
    <xs:attribute name="substituteVars" type="xs:string">
      <xs:annotation>
        <xs:documentation>should values between ${ and } be resolved from the pipelinesession (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="FixedResultPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the file containing the resultmessage (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the session key containing the file name of the file containing the result message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="lookupAtRuntime" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the lookup of the file will be done at runtime instead of at configuration time (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="replaceFixedParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, any parameter is used for replacements but with &lt;code&gt;name-of-parameter&lt;/code&gt; and not &lt;code&gt;${name-of-parameter}&lt;/code&gt; (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceFrom" type="xs:string" />
    <xs:attribute name="replaceTo" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="returnString" type="xs:string">
      <xs:annotation>
        <xs:documentation>returned message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string" />
    <xs:attribute name="substituteVars" type="xs:string">
      <xs:annotation>
        <xs:documentation>should values between ${ and } be resolved from the pipelinesession (search order: 1) system properties 2) pipelinesession variables 3) application properties) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="FixedResultSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="fileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the file containing the resultmessage (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceFrom" type="xs:string" />
    <xs:attribute name="replaceTo" type="xs:string" />
    <xs:attribute name="returnString" type="xs:string">
      <xs:annotation>
        <xs:documentation>returned message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string" />
    <xs:attribute name="substituteVars" type="xs:string">
      <xs:annotation>
        <xs:documentation>should values between ${ and } be resolved from the pipelinesession (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ForEachChildElementPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapInputWrapper" type="ApiSoapInputWrapperType" minOccurs="0" />
        <xs:element name="BisInputWrapper" type="BisInputWrapperType" minOccurs="0" />
        <xs:element name="DirectInputWrapper" type="DirectInputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapInputWrapper" type="EsbSoapInputWrapperType" minOccurs="0" />
        <xs:element name="FxfInputWrapper" type="FxfInputWrapperType" minOccurs="0" />
        <xs:element name="SoapInputWrapper" type="SoapInputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlInputValidator" type="ApiWsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapInputValidator" type="EsbSoapInputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlInputValidator" type="FxfXmlInputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlInputValidator" type="Json2XmlInputValidatorType" minOccurs="0" />
        <xs:element name="SoapInputValidator" type="SoapInputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlInputValidator" type="WsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="XmlInputValidator" type="XmlInputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="Afm2EdiFactSender" type="Afm2EdiFactSenderType" minOccurs="0" />
        <xs:element name="BisJmsSender" type="BisJmsSenderType" minOccurs="0" />
        <xs:element name="CommandSender" type="CommandSenderType" minOccurs="0" />
        <xs:element name="DelaySender" type="DelaySenderType" minOccurs="0" />
        <xs:element name="DirectQuerySender" type="DirectQuerySenderType" minOccurs="0" />
        <xs:element name="EchoSender" type="EchoSenderType" minOccurs="0" />
        <xs:element name="EsbJmsSender" type="EsbJmsSenderType" minOccurs="0" />
        <xs:element name="FileSender" type="FileSenderType" minOccurs="0" />
        <xs:element name="FixedQuerySender" type="FixedQuerySenderType" minOccurs="0" />
        <xs:element name="FixedResultSender" type="FixedResultSenderType" minOccurs="0" />
        <xs:element name="FtpSender" type="FtpSenderType" minOccurs="0" />
        <xs:element name="HttpSender" type="HttpSenderType" minOccurs="0" />
        <xs:element name="IbisJavaSender" type="IbisJavaSenderType" minOccurs="0" />
        <xs:element name="IbisLocalSender" type="IbisLocalSenderType" minOccurs="0" />
        <xs:element name="IbisWebServiceSender" type="IbisWebServiceSenderType" minOccurs="0" />
        <xs:element name="JmsSender" type="JmsSenderType" minOccurs="0" />
        <xs:element name="LdapSender" type="LdapSenderType" minOccurs="0" />
        <xs:element name="LogSender" type="LogSenderType" minOccurs="0" />
        <xs:element name="MailSender" type="MailSenderType" minOccurs="0" />
        <xs:element name="MessageStoreSender" type="MessageStoreSenderType" minOccurs="0" />
        <xs:element name="MqttSender" type="MqttSenderType" minOccurs="0" />
        <xs:element name="ParallelSendersSender" type="ParallelSendersSenderType" minOccurs="0" />
        <xs:element name="ReloadSender" type="ReloadSenderType" minOccurs="0" />
        <xs:element name="RestSender" type="RestSenderType" minOccurs="0" />
        <xs:element name="ResultSet2FileSender" type="ResultSet2FileSenderType" minOccurs="0" />
        <xs:element name="SambaSender" type="SambaSenderType" minOccurs="0" />
        <xs:element name="SchedulerSender" type="SchedulerSenderType" minOccurs="0" />
        <xs:element name="SenderSeriesSender" type="SenderSeriesSenderType" minOccurs="0" />
        <xs:element name="SenderWrapperSender" type="SenderWrapperSenderType" minOccurs="0" />
        <xs:element name="ShadowSender" type="ShadowSenderType" minOccurs="0" />
        <xs:element name="TimeoutGuardSenderWithParametersBaseSender" type="TimeoutGuardSenderWithParametersBaseSenderType" minOccurs="0" />
        <xs:element name="WebServiceNtlmSender" type="WebServiceNtlmSenderType" minOccurs="0" />
        <xs:element name="WebServiceSender" type="WebServiceSenderType" minOccurs="0" />
        <xs:element name="XComSender" type="XComSenderType" minOccurs="0" />
        <xs:element name="XfbSender" type="XfbSenderType" minOccurs="0" />
        <xs:element name="XmlJmsBrowserSender" type="XmlJmsBrowserSenderType" minOccurs="0" />
        <xs:element name="XmlQuerySender" type="XmlQuerySenderType" minOccurs="0" />
        <xs:element name="XmlValidatorSender" type="XmlValidatorSenderType" minOccurs="0" />
        <xs:element name="XsltSender" type="XsltSenderType" minOccurs="0" />
        <xs:element name="ZipWriterSender" type="ZipWriterSenderType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="DummyMessageLog" type="DummyMessageLogType" minOccurs="0" />
        <xs:element name="EsbJmsMessageLog" type="EsbJmsMessageLogType" minOccurs="0" />
        <xs:element name="JdbcMessageLog" type="JdbcMessageLogType" minOccurs="0" />
        <xs:element name="JmsMessageLog" type="JmsMessageLogType" minOccurs="0" />
        <xs:element name="OracleMessageLog" type="OracleMessageLogType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlOutputValidator" type="ApiWsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapOutputValidator" type="EsbSoapOutputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlOutputValidator" type="FxfXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlOutputValidator" type="Json2XmlOutputValidatorType" minOccurs="0" />
        <xs:element name="SoapOutputValidator" type="SoapOutputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlOutputValidator" type="WsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="XmlOutputValidator" type="XmlOutputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapOutputWrapper" type="ApiSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="BisOutputWrapper" type="BisOutputWrapperType" minOccurs="0" />
        <xs:element name="DirectOutputWrapper" type="DirectOutputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapOutputWrapper" type="EsbSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="FxfOutputWrapper" type="FxfOutputWrapperType" minOccurs="0" />
        <xs:element name="SoapOutputWrapper" type="SoapOutputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addInputToResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; the input is added to the result in an input element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for audittrailxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. if specified, the value of the pipelinesession variable is used as audit trail (instead of the default 'no audit trail) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract audit trail from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockPrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;blocksize &amp;gt; 0&lt;/code&gt;, this string is inserted at the start of the set of lines. (default: &amp;lt;block&amp;gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls multiline behaviour. when set to a value greater than 0, it specifies the number of rows send in a block to the sender. (default: 0 (one line at a time, no prefix of suffix))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;blocksize &amp;gt; 0&lt;/code&gt;, this string is inserted at the end of the set of lines. (default: &amp;lt;/block&amp;gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setprocessfile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkRootTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, besides the xml well-formedness the root element of the result is checked to be equal to the value set (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkXmlWellFormed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the xml well-formedness of the result is checked (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectResults" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether all the results of each iteration will be collected in one result message. if set &lt;code&gt;false&lt;/code&gt;, only a small summary is returned (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for correlationidxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. is specified, the value of the pipelinesession variable is used as input for the xpathexpression or stylesheet, instead of the current input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementXPathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>expression used to determine the set of elements iterated over, i.e. the set of child elements (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="endPosition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;endposition &amp;gt;= startposition&lt;/code&gt;, this field contains the end position of the key in the current record (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exceptionOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a piperunexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when hideregex is not empty and only applies to error/logstore) either &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;firsthalf&lt;/code&gt;. when &lt;code&gt;firsthalf&lt;/code&gt; only the first half of the string is masked, otherwise (&lt;code&gt;all&lt;/code&gt;) the entire string is masked (default: all)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>next to common usage in {@link abstractpipe}, also strings in the error/logstore are masked (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreExceptions" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; ignore any exception thrown by executing sender (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="itemNoSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable to store number of item processed. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for labelxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linePrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>this string is inserted at the start of each line (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>this string is inserted at the end of each line (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>indicates wether the server uses the correlationid or the messageid in the correlationid field of the reply. this requirers the sender to have set the correlationid at the time of sending. (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of times a processing attempt is retried after a timeout or an exception is caught or after a incorrect reply is received (see also &lt;code&gt;retryxpath&lt;/code&gt;) (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:string">
      <xs:annotation>
        <xs:documentation>force the transformer generated from the xpath-expression to omit the xml declaration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either 'text' or 'xml'. only valid for xpathexpression (default: text)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="parallel" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the calls for all items are done in parallel (a new thread is started for each call). when collectresults set &lt;code&gt;true&lt;/code&gt;, this pipe will wait for all calls to finish before results are collected and pipe result is returned (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="presumedTimeOutInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>when the previous call was a timeout, the maximum time (in seconds) after this timeout to presume the current call is also a timeout. a value of -1 indicates to never presume timeouts (default: 10 s)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="processFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of a file to be processed. otherwise, the input itself is transformed (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeDuplicates" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; duplicate input elements are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeXmlDeclarationInResults" type="xs:string">
      <xs:annotation>
        <xs:documentation>postprocess each partial result, to remove the xml-declaration, as this is not allowed inside an xml-document (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultOnTimeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>result returned when no return-message was received within the timeout limit (e.g. 'receiver timed out'). (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMaxInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of seconds waited after an unsuccessful processing attempt before another processing attempt is made (default: 600)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMinInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the starting number of seconds waited after an unsuccessful processing attempt before another processing attempt is made. each next retry this interval is doubled with a upper limit of &lt;code&gt;retrymaxinterval&lt;/code&gt; (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for retryxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression evaluated on each technical successful reply. retry is done if condition returns true (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startPosition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;startposition &amp;gt;= 0&lt;/code&gt;, this field contains the start position of the key in the current record (first character is 0); all sequenced lines with the same key are put in one block and send to the sender (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stopConditionXPathExpression" type="xs:string" />
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is first base64 decoded and then streamed to the httpservletresponse object (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stubFileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the pipe returns a message from a file, instead of doing the regular process (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to apply to each message, before sending it (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOutOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a timeoutexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useInputForExtract" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is used to extract audit trail, correlationid and label (instead of the wrapped input) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>alternatively: xpath-expression to create stylesheet from (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used for &lt;code&gt;elementxpathexpression&lt;/code&gt;, otherwise xslt processor 1.0 (org.apache.xalan) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ForwardType">
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="path" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="FtpErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="certificate" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) resource url to certificate to be used for authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) alias used to obtain certificate password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificatePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  (default: pkcs12)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>remote directory in which files have to be uploaded (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteFilenamePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>filename pattern for uploaded files (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="FtpFileRetrieverPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deleteAfterGet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if true, the remote file is deleted after it is retrieved (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="localDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>local directory in which files have to be downloaded (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="localFilenamePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>pattern (in messageformat) of the local filename (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>remote directory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="FtpListenerType">
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the alias to obtain credentials to authenticatie on remote server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) alias used to obtain certificate password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="consoleKnownHostsVerifier" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp)  (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>selects the algorithm to generate keymanagers. can be left empty to use the servers default algorithm (default: websphere: ibmx509)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyboardInteractive" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, keyboardinteractive is used to login (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="passive" type="xs:string">
      <xs:annotation>
        <xs:documentation>if true, passive ftp is used: before data is sent, a pasv command is issued, and the connection is set up by the server (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="privateKeyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(sftp) name of the alias to obtain credentials for passphrase of private key file (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the alias to obtain credentials to authenticate on proxy (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>remote directory from which files have to be downloaded (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="responseTime" type="xs:string">
      <xs:annotation>
        <xs:documentation>time between pollings (default: 3600000 (one hour))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>selects the algorithm to generate trustmanagers. can be left empty to use the servers default algorithm (default: websphere: ibmx509)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) alias used to obtain truststore password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="FtpSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="certificate" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) resource url to certificate to be used for authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps) alias used to obtain certificate password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificatePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(ftps)  (default: pkcs12)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>remote directory in which files have to be uploaded (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteFilenamePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>filename pattern for uploaded files (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="FxfInputWrapperType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addOutputNamespace" type="xs:string" />
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clientFilenameSessionKey" type="xs:string" />
    <xs:attribute name="cmhVersion" type="xs:string" />
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt; (default: wrap)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the soap header (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fixResultNamespace" type="xs:string" />
    <xs:attribute name="flowId" type="xs:string" />
    <xs:attribute name="flowIdSessionKey" type="xs:string" />
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fxfDirSessionKey" type="xs:string" />
    <xs:attribute name="fxfFileSessionKey" type="xs:string" />
    <xs:attribute name="fxfVersion" type="xs:string" />
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreSoapFault" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;false&lt;/code&gt; and the soap body contains a soap fault, a piperunexception is thrown (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mode" type="xs:string" />
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when not empty, this namespace is added to the root element in the soap body (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, namespaces (and prefixes) in the content of the soap body are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeUnusedOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt; and &lt;code&gt;removeoutputnamespaces=false&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, unused namespaces in the content of the soap body are removed (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retrievePhysicalDestination" type="xs:string" />
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the root element in the soap body is changed to this value (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodySessionKey" type="xs:string" />
    <xs:attribute name="soapBodyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to apply to the input message. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="soapHeaderStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to create the content of the soap header. as input for this stylesheet a dummy xml string is used. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) namespace of the soap envelope (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transferFlowIdSessionKey" type="xs:string" />
    <xs:attribute name="transformFilename" type="xs:string" />
    <xs:attribute name="useFixedValues" type="xs:string" />
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="FxfListenerType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="ackMode" type="xs:string" />
    <xs:attribute name="acknowledgeMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: auto_acknowledge)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to jms server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cacheMode" type="xs:string" />
    <xs:attribute name="commitOnState" type="xs:string">
      <xs:annotation>
        <xs:documentation>&lt;i&gt;deprecated&lt;/i&gt; exit state to control commit or rollback of jmssession. only used if &lt;code&gt;jmstransacted&lt;/code&gt; is set true. (default: success)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="copyAEProperties" type="xs:string" />
    <xs:attribute name="correlationIdMaxLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the correlationid exceeds this maximum length, the correlationid is trimmed from the left side of a string to this maximum length (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHex" type="xs:string">
      <xs:annotation>
        <xs:documentation>transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part). useful when sending messages to mq which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: mqjms1044: string is not a valid hexadecimal number (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createProcessedDirectory" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the jms destination (queue or topic) to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;topic&lt;/code&gt; (default: &lt;code&gt;queue&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forceMessageIdAsCorrelationId" type="xs:string" />
    <xs:attribute name="fxfFileSessionKey" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsTransacted" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="listenerPort" type="xs:string" />
    <xs:attribute name="lookupDestination" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the destinationname is used directly instead of performing a jndi lookup (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageProtocol" type="xs:string" />
    <xs:attribute name="messageSelector" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the value of this attribute is used as a selector to filter messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in milliseconds) it takes for the message to expire. if the message is not consumed before, it will be lost. make sure to set it to a positive value for request/repy type of messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="moveProcessedFile" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistent" type="xs:string">
      <xs:annotation>
        <xs:documentation>rather useless attribute, and not the same as &lt;code&gt;deliverymode&lt;/code&gt;. you probably want to use that. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pollGuardInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>interval in milliseconds for the poll guard to check whether a successful poll was done by the receive (https://docs.oracle.com/javaee/7/api/javax/jms/messageconsumer.html#receive-long-) since last check. when polling has stopped this will be logged and the listener will be stopped and started in an attempt to workaround problems with polling. polling might stop due to bugs in the jms driver/implementation which should be fixed by the supplier. as the poll time includes reading and processing of the message no successful poll might be registered since the last check when message processing takes a long time, hence while messages are being processed the check on last successful poll will be skipped. set to -1 to disable (default: ten times the specified timeout)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="processedSiblingDirectory" type="xs:string" />
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the queueconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;queue&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyDeliveryMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls mode that reply messages are sent with: either 'persistent' or 'non_persistent' (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyEncodingStyleURI" type="xs:string" />
    <xs:attribute name="replyMessageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>time that replymessage will live (default: 0 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyMessageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of the jmstype field of the reply message (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyNamespaceURI" type="xs:string" />
    <xs:attribute name="replyPriority" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets the priority that is used to deliver the reply message. ranges from 0 to 9. defaults to -1, meaning not set. effectively the default priority is set by jms to 4 (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replySoapAction" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soap" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="subscriberType" type="xs:string" />
    <xs:attribute name="timeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>receiver timeout, in milliseconds (default: 3000 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the topicconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;topic&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useReplyTo" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xPathLoggingKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of all xpath keys that need to be logged. (overrides &lt;code&gt;msg.log.keys&lt;/code&gt; property) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="FxfOutputWrapperType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addOutputNamespace" type="xs:string" />
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clientFilenameSessionKey" type="xs:string" />
    <xs:attribute name="cmhVersion" type="xs:string" />
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt; (default: wrap)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the soap header (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fixResultNamespace" type="xs:string" />
    <xs:attribute name="flowId" type="xs:string" />
    <xs:attribute name="flowIdSessionKey" type="xs:string" />
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fxfDirSessionKey" type="xs:string" />
    <xs:attribute name="fxfFileSessionKey" type="xs:string" />
    <xs:attribute name="fxfVersion" type="xs:string" />
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreSoapFault" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;false&lt;/code&gt; and the soap body contains a soap fault, a piperunexception is thrown (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mode" type="xs:string" />
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when not empty, this namespace is added to the root element in the soap body (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, namespaces (and prefixes) in the content of the soap body are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeUnusedOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt; and &lt;code&gt;removeoutputnamespaces=false&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, unused namespaces in the content of the soap body are removed (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retrievePhysicalDestination" type="xs:string" />
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the root element in the soap body is changed to this value (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodySessionKey" type="xs:string" />
    <xs:attribute name="soapBodyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to apply to the input message. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="soapHeaderStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to create the content of the soap header. as input for this stylesheet a dummy xml string is used. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) namespace of the soap envelope (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transferFlowIdSessionKey" type="xs:string" />
    <xs:attribute name="transformFilename" type="xs:string" />
    <xs:attribute name="useFixedValues" type="xs:string" />
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="FxfWrapperPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addOutputNamespace" type="xs:string" />
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clientFilenameSessionKey" type="xs:string" />
    <xs:attribute name="cmhVersion" type="xs:string" />
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt; (default: wrap)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the soap header (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fixResultNamespace" type="xs:string" />
    <xs:attribute name="flowId" type="xs:string" />
    <xs:attribute name="flowIdSessionKey" type="xs:string" />
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fxfDirSessionKey" type="xs:string" />
    <xs:attribute name="fxfFileSessionKey" type="xs:string" />
    <xs:attribute name="fxfVersion" type="xs:string" />
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreSoapFault" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;false&lt;/code&gt; and the soap body contains a soap fault, a piperunexception is thrown (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mode" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when not empty, this namespace is added to the root element in the soap body (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, namespaces (and prefixes) in the content of the soap body are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeUnusedOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt; and &lt;code&gt;removeoutputnamespaces=false&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, unused namespaces in the content of the soap body are removed (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retrievePhysicalDestination" type="xs:string" />
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the root element in the soap body is changed to this value (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodySessionKey" type="xs:string" />
    <xs:attribute name="soapBodyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to apply to the input message. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="soapHeaderStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to create the content of the soap header. as input for this stylesheet a dummy xml string is used. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) namespace of the soap envelope (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transferFlowIdSessionKey" type="xs:string" />
    <xs:attribute name="transformFilename" type="xs:string" />
    <xs:attribute name="useFixedValues" type="xs:string" />
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="FxfXmlInputValidatorType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="direction" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fxfVersion" type="xs:string" />
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputSoapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>identical to the &lt;code&gt;soapbody&lt;/code&gt; attribute except that it's used for the output message instead of the input message. for more information see &lt;a href="#note1"&gt;note 1&lt;/a&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="responseRoot" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>always envelope (not allowed to change) (default: envelope)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocationToAdd" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references which will be added to the wsdl (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap body. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap body, for example to allow element x and an empty soap body use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>creates &lt;code&gt;schemalocation&lt;/code&gt; attribute based on the wsdl and replaces the namespace of the soap body element (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap header. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap header, for example to allow element x and an empty soap header use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be used when the soap header element exists multiple times (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>soap envelope xsd version to use: 1.1, 1.2 or any (both 1.1 and 1.2) (default: 1.1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wsdl" type="xs:string">
      <xs:annotation>
        <xs:documentation>the wsdl to read the xsd's from (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="FxfXmlOutputValidatorType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="direction" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fxfVersion" type="xs:string" />
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputSoapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>identical to the &lt;code&gt;soapbody&lt;/code&gt; attribute except that it's used for the output message instead of the input message. for more information see &lt;a href="#note1"&gt;note 1&lt;/a&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="responseRoot" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>always envelope (not allowed to change) (default: envelope)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocationToAdd" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references which will be added to the wsdl (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap body. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap body, for example to allow element x and an empty soap body use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>creates &lt;code&gt;schemalocation&lt;/code&gt; attribute based on the wsdl and replaces the namespace of the soap body element (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap header. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap header, for example to allow element x and an empty soap header use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be used when the soap header element exists multiple times (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>soap envelope xsd version to use: 1.1, 1.2 or any (both 1.1 and 1.2) (default: 1.1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wsdl" type="xs:string">
      <xs:annotation>
        <xs:documentation>the wsdl to read the xsd's from (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="FxfXmlValidatorPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="direction" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fxfVersion" type="xs:string" />
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputSoapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>identical to the &lt;code&gt;soapbody&lt;/code&gt; attribute except that it's used for the output message instead of the input message. for more information see &lt;a href="#note1"&gt;note 1&lt;/a&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="responseRoot" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>always envelope (not allowed to change) (default: envelope)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocationToAdd" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references which will be added to the wsdl (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap body. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap body, for example to allow element x and an empty soap body use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>creates &lt;code&gt;schemalocation&lt;/code&gt; attribute based on the wsdl and replaces the namespace of the soap body element (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap header. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap header, for example to allow element x and an empty soap header use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be used when the soap header element exists multiple times (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>soap envelope xsd version to use: 1.1, 1.2 or any (both 1.1 and 1.2) (default: 1.1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wsdl" type="xs:string">
      <xs:annotation>
        <xs:documentation>the wsdl to read the xsd's from (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="GetFromSessionPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the key in the &lt;code&gt;pipelinesession&lt;/code&gt; to retrieve the output message from (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string" />
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="GetPrincipalPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="HashPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="algorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: hmacsha256)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authalias to retrieve the secret from (password field). (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encoding" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: iso8859_1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secret" type="xs:string">
      <xs:annotation>
        <xs:documentation>the secret to hash with (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="HttpErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="allowSelfSignedCertificates" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, self signed certificates are accepted (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authDomain" type="xs:string" />
    <xs:attribute name="base64" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the result is base64 encoded (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificate" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource url to certificate to be used for authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain certificate password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificatePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charSet" type="xs:string" />
    <xs:attribute name="contentType" type="xs:string">
      <xs:annotation>
        <xs:documentation>content-type of the request, only for post and put methods (default: text/html; charset=utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodeMessages" type="xs:string">
      <xs:annotation>
        <xs:documentation>specifies whether messages will encoded, e.g. spaces will be replaced by '+' etc. (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="followRedirects" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, a redirect request will be honoured, e.g. to switch to https (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="headersParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of parameter names which should be set as http headers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCertificateExpiredException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the certificateexpiredexception is ignored (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreRedirects" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, besides http status code 200 (ok) also the code 301 (moved_permanently), 302 (moved_temporarily) and 307 (temporary_redirect) are considered successful (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputMessageParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;) name of the request parameter which is used to put the input message in (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: pkcs12)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConnections" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of concurrent connections (default: 10)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxExecuteRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of times it the execution is retried (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="methodType" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of method to be executed, either 'GET', 'POST', 'PUT', 'DELETE', 'HEAD' or 'REPORT' (default: GET)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mtomContentTransferEncoding" type="xs:string" />
    <xs:attribute name="mtomEnabled" type="xs:string" />
    <xs:attribute name="multipart" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true and &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;, request parameters are put in a multipart/form-data entity instead of in the request body (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartResponse" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true the response body is expected to be in mime multipart which is the case when a soap message with attachments is received (see also google). the first part will be returned as result of this sender. other parts are returned as streams in sessionkeys with names multipart1, multipart2, etc. the http connection is held open until the last stream is read. (default: false)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartXmlSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set and &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;, a multipart/form-data entity is created instead of a request body. for each part element in the session key a part in the multipart entity is created (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="paramsInUrl" type="xs:string">
      <xs:annotation>
        <xs:documentation>when false and &lt;code&gt;methodetype=post&lt;/code&gt;, request parameters are put in the request body instead of in the url (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="protocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>secure socket protocol (such as 'ssl' and 'tls') to use when a sslcontext object is generated. if empty the protocol 'ssl' is used (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to proxy (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: 80)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyRealm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultStatusCodeSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the status code of the http response is put in specified in the sessionkey and the (error or okay) response message is returned (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether connections checked to be stale, i.e. appear open, but are not. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleTimeout" type="xs:string" />
    <xs:attribute name="storeResultAsByteArrayInSessionKey" type="xs:string" />
    <xs:attribute name="storeResultAsStreamInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, a pointer to an input stream of the result is put in the specified sessionkey (as the sender interface only allows a sender to return a string a sessionkey is used instead to return the stream) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToFileNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to a file (instead of passed as a string) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to the httpservletresponse object of the restservicedispatcher (instead of passed as a string) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>&gt;(only used when &lt;code&gt;xhtml=true&lt;/code&gt;) stylesheet to apply to the html response (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a senderexception (or timeoutexception) is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in ms of obtaining a connection/result. 0 means no timeout (default: 10000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource url to truststore to be used for authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain truststore password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: jks)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>url or base of url to be used  (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>parameter that is used to obtain url; overrides url-attribute. (default: url)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="userName" type="xs:string">
      <xs:annotation>
        <xs:documentation>username used in authentication to host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the hostname in the certificate will be checked against the actual hostname (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xhtml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the html response is transformed to xhtml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the xml tag to encapsulate the result in (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="HttpListenerType">
    <xs:attribute name="applicationFaultsAsExceptions" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener as known to the adapter (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="running" type="xs:string" />
    <xs:attribute name="serviceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the service that is provided by the adapter of this listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="HttpSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="allowSelfSignedCertificates" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, self signed certificates are accepted (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authDomain" type="xs:string" />
    <xs:attribute name="base64" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the result is base64 encoded (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificate" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource url to certificate to be used for authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain certificate password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificatePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charSet" type="xs:string" />
    <xs:attribute name="contentType" type="xs:string">
      <xs:annotation>
        <xs:documentation>content-type of the request, only for post and put methods (default: text/html; charset=utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodeMessages" type="xs:string">
      <xs:annotation>
        <xs:documentation>specifies whether messages will encoded, e.g. spaces will be replaced by '+' etc. (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="followRedirects" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, a redirect request will be honoured, e.g. to switch to https (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="headersParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of parameter names which should be set as http headers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCertificateExpiredException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the certificateexpiredexception is ignored (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreRedirects" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, besides http status code 200 (ok) also the code 301 (moved_permanently), 302 (moved_temporarily) and 307 (temporary_redirect) are considered successful (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputMessageParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;) name of the request parameter which is used to put the input message in (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: pkcs12)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConnections" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of concurrent connections (default: 10)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxExecuteRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of times it the execution is retried (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="methodType" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of method to be executed, either 'GET', 'POST', 'PUT', 'DELETE', 'HEAD' or 'REPORT' (default: GET)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mtomContentTransferEncoding" type="xs:string" />
    <xs:attribute name="mtomEnabled" type="xs:string" />
    <xs:attribute name="multipart" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true and &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;, request parameters are put in a multipart/form-data entity instead of in the request body (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartResponse" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true the response body is expected to be in mime multipart which is the case when a soap message with attachments is received (see also &lt;a href="https://docs.oracle.com/javaee/7/api/javax/xml/soap/soapmessage.html"&gt;https://docs.oracle.com/javaee/7/api/javax/xml/soap/soapmessage.html&lt;/a&gt;). the first part will be returned as result of this sender. other parts are returned as streams in sessionkeys with names multipart1, multipart2, etc. the http connection is held open until the last stream is read. (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartXmlSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set and &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;, a multipart/form-data entity is created instead of a request body. for each part element in the session key a part in the multipart entity is created (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="paramsInUrl" type="xs:string">
      <xs:annotation>
        <xs:documentation>when false and &lt;code&gt;methodetype=post&lt;/code&gt;, request parameters are put in the request body instead of in the url (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="protocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>secure socket protocol (such as 'ssl' and 'tls') to use when a sslcontext object is generated. if empty the protocol 'ssl' is used (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to proxy (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: 80)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyRealm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultStatusCodeSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the status code of the http response is put in specified in the sessionkey and the (error or okay) response message is returned (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether connections checked to be stale, i.e. appear open, but are not. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleTimeout" type="xs:string" />
    <xs:attribute name="storeResultAsByteArrayInSessionKey" type="xs:string" />
    <xs:attribute name="storeResultAsStreamInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, a pointer to an input stream of the result is put in the specified sessionkey (as the sender interface only allows a sender to return a string a sessionkey is used instead to return the stream) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToFileNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to a file (instead of passed as a string) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to the httpservletresponse object of the restservicedispatcher (instead of passed as a string) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>&gt;(only used when &lt;code&gt;xhtml=true&lt;/code&gt;) stylesheet to apply to the html response (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a senderexception (or timeoutexception) is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in ms of obtaining a connection/result. 0 means no timeout (default: 10000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource url to truststore to be used for authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain truststore password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: jks)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>url or base of url to be used  (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>parameter that is used to obtain url; overrides url-attribute. (default: url)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="userName" type="xs:string">
      <xs:annotation>
        <xs:documentation>username used in authentication to host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the hostname in the certificate will be checked against the actual hostname (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xhtml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the html response is transformed to xhtml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the xml tag to encapsulate the result in (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="IbisDocPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="IbisJavaErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="dispatchType" type="xs:string">
      <xs:annotation>
        <xs:documentation>set to 'dll' to make the dispatcher communicate with a dll set on the classpath (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartResponse" type="xs:string">
      <xs:annotation>
        <xs:documentation>currently used to mimic the httpsender when it is stubbed locally. it could be useful in other situations too although currently the response string is used which isn't streamed, it would be better to pass the multipart as an input stream in the context map in which case content type and charset could also be passed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="returnedSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of keys of session variables that should be returned to caller, for correct results as well as for erronous results. (only for listeners that support it, like javalistener) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceName" type="xs:string" />
    <xs:attribute name="serviceNameSessionKey" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="IbisJavaSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="dispatchType" type="xs:string">
      <xs:annotation>
        <xs:documentation>set to 'dll' to make the dispatcher communicate with a dll set on the classpath (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartResponse" type="xs:string">
      <xs:annotation>
        <xs:documentation>currently used to mimic the httpsender when it is stubbed locally. it could be useful in other situations too although currently the response string is used which isn't streamed, it would be better to pass the multipart as an input stream in the context map in which case content type and charset could also be passed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="returnedSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of keys of session variables that should be returned to caller, for correct results as well as for erronous results. (only for listeners that support it, like javalistener) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceName" type="xs:string" />
    <xs:attribute name="serviceNameSessionKey" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="IbisLocalErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="checkDependency" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the sender waits upon open until the called {@link nl.nn.adapterframework.receivers.javalistener javalistener} is opened (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dependencyTimeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum time (in seconds) the sender waits for the listener to start. a value of -1 indicates to wait indefinitely (default: 60 s)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="isolated" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the call is made in a separate thread, possibly using separate transaction (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="javaListener" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the {@link nl.nn.adapterframework.receivers.javalistener javalistener} that should be called (will be ignored when javalistenersessionkey is set) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="javaListenerSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the sessionkey which holds the name of the {@link nl.nn.adapterframework.receivers.javalistener javalistener} that should be called (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="returnedSessionKeys" type="xs:string" />
    <xs:attribute name="serviceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the {@link nl.nn.adapterframework.http.webservicelistener webservicelistener} that should be called (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the call is made asynchronously. this implies &lt;code&gt;isolated=true&lt;/code&gt; (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwJavaListenerNotFoundException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the xml-string "&amp;lt;error&amp;gt;could not find javalistener [...]&amp;lt;/error&amp;gt;" is returned instead of throwing a senderexception (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="IbisLocalSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="checkDependency" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the sender waits upon open until the called {@link nl.nn.adapterframework.receivers.javalistener javalistener} is opened (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dependencyTimeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum time (in seconds) the sender waits for the listener to start. a value of -1 indicates to wait indefinitely (default: 60 s)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="isolated" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the call is made in a separate thread, possibly using separate transaction (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="javaListener" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the {@link nl.nn.adapterframework.receivers.javalistener javalistener} that should be called (will be ignored when javalistenersessionkey is set) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="javaListenerSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the sessionkey which holds the name of the {@link nl.nn.adapterframework.receivers.javalistener javalistener} that should be called (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="returnedSessionKeys" type="xs:string" />
    <xs:attribute name="serviceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the {@link nl.nn.adapterframework.http.webservicelistener webservicelistener} that should be called (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the call is made asynchronously. this implies &lt;code&gt;isolated=true&lt;/code&gt; (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwJavaListenerNotFoundException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the xml-string "&amp;lt;error&amp;gt;could not find javalistener [...]&amp;lt;/error&amp;gt;" is returned instead of throwing a senderexception (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="IbisWebServiceErrorSenderType">
    <xs:attribute name="ibisHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>name (or ipaddress) and optinally port of the host where the ibis to be called is running (default: localhost)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ibisInstance" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the ibis instance to be called (default: name of the current instance)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the receiver that should be called (default: servicelistener)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="IbisWebServiceSenderType">
    <xs:attribute name="ibisHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>name (or ipaddress) and optinally port of the host where the ibis to be called is running (default: localhost)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ibisInstance" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the ibis instance to be called (default: name of the current instance)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the receiver that should be called (default: servicelistener)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="IfMultipartPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elseForwardName" type="xs:string" />
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="thenForwardName" type="xs:string" />
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="IncreaseIntegerPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="increment" type="xs:string">
      <xs:annotation>
        <xs:documentation>amount to increment the value (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>reference to the session variable whose value is to be increased (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="IsUserInRolePipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="notInRoleForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>user may not assume role (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="role" type="xs:string">
      <xs:annotation>
        <xs:documentation>the j2ee role to check.  (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="IsXmlIfPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elseForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when 'false' (default: else)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elseForwardOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>return elseforward when input is empty (or thenforward) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="thenForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when 'true'&lt;/code&gt; (default: then)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="JavaListenerType">
    <xs:attribute name="httpWsdl" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the wsdl of the service provided by this listener is available for download  (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="isolated" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener as known to the adapter. an {@link nl.nn.adapterframework.pipes.ibislocalsender ibislocalsender} refers to this name in its &lt;code&gt;javalistener&lt;/code&gt;-attribute. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceName" type="xs:string" />
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the request is executed asynchronously. this implies &lt;code&gt;isolated=true&lt;/code&gt;. n.b. be aware that there is no limit on the number of threads generated (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the javalistener throw a listenerexception when it occurs or return an error message (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="JdbcErrorStorageType">
    <xs:attribute name="active" type="xs:string" />
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the full message is stored with the log. can be set to &lt;code&gt;false&lt;/code&gt; to reduce table size, by avoiding to store the full message (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commentField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column comments are stored in (default: comments)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="correlationIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column correlation-ids are stored in (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createTable" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the table is created if it does not exist (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="dateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column the timestamp is stored in (default: messagedate)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dateFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column the timestamps are stored in (default: timestamp)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expiryDateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column the timestamp for expiry is stored in (default: expirydate)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hostField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column that stores the hostname of the server (default: host)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="idField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column messageids are stored in (default: messageid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indexName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the index, to be used in hints for query optimizer too (only for oracle) (default: ix_ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="keyField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column that contains the primary key of the table (default: messagekey)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column that contains the primary key of the table (default: int default autoincrement)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column labels are stored in (default: label)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column message themselves are stored in (default: message)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column message themselves are stored in (default: long binary)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="onlyStoreWhenMessageIdUnique" type="xs:string" />
    <xs:attribute name="order" type="xs:string" />
    <xs:attribute name="prefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>prefix to be prefixed on all database objects (tables, indices, sequences), e.q. to access a different oracle schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retention" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in days) to keep the record in the database before making it eligible for deletion by a cleanup process. when set to -1, the record will live on forever (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaOwner4Check" type="xs:string">
      <xs:annotation>
        <xs:documentation>schema owner to be used to check the database (default: &amp;lt;current_schema&amp;gt; (only for oracle))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sequenceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the sequence used to generate the primary key (only for oracle)&lt;br&gt;n.b. the default name has been changed in version 4.6 (default: seq_ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>optional identifier for this storage, to be able to share the physical table between a number of receivers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column slotids are stored in (default: slotid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeFullMessage" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the messages are stored compressed (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tableName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the table messages are stored in (default: ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="textFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the columns messageid and correlationid, slotid and comments are stored in. n.b. (100) is appended for id's, (1000) is appended for comments. (default: varchar)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>possible values are e (error store), m (message store), l (message log for pipe) or a (message log for receiver). receiverbase will always set type to e for errorstorage and always set type to a for messagelog. genericmessagesendingpipe will set type to l for messagelog (when type isn't specified). see {@link messagestoresender} for type m (default: e for errorstorage on receiver, a for messagelog on receiver and l for messagelog on pipe)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="typeField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column types are stored in (default: type)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="JdbcListenerType">
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used to read blobs (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls automatically whether blobdata is stored compressed and/or serialized in the database (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is considered stored compressed in the database (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commitLocalTransactionQuery" type="xs:string" />
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="messageFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of the field containing the message data: either string, clob or blob (default: &lt;i&gt;string&lt;/i&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startLocalTransactionQuery" type="xs:string" />
    <xs:attribute name="trace" type="xs:string" />
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="JdbcMessageLogType">
    <xs:attribute name="active" type="xs:string" />
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the full message is stored with the log. can be set to &lt;code&gt;false&lt;/code&gt; to reduce table size, by avoiding to store the full message (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commentField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column comments are stored in (default: comments)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="correlationIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column correlation-ids are stored in (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createTable" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the table is created if it does not exist (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="dateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column the timestamp is stored in (default: messagedate)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dateFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column the timestamps are stored in (default: timestamp)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expiryDateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column the timestamp for expiry is stored in (default: expirydate)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hostField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column that stores the hostname of the server (default: host)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="idField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column messageids are stored in (default: messageid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indexName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the index, to be used in hints for query optimizer too (only for oracle) (default: ix_ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="keyField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column that contains the primary key of the table (default: messagekey)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column that contains the primary key of the table (default: int default autoincrement)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column labels are stored in (default: label)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column message themselves are stored in (default: message)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column message themselves are stored in (default: long binary)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="onlyStoreWhenMessageIdUnique" type="xs:string" />
    <xs:attribute name="order" type="xs:string" />
    <xs:attribute name="prefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>prefix to be prefixed on all database objects (tables, indices, sequences), e.q. to access a different oracle schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retention" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in days) to keep the record in the database before making it eligible for deletion by a cleanup process. when set to -1, the record will live on forever (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaOwner4Check" type="xs:string">
      <xs:annotation>
        <xs:documentation>schema owner to be used to check the database (default: &amp;lt;current_schema&amp;gt; (only for oracle))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sequenceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the sequence used to generate the primary key (only for oracle)&lt;br&gt;n.b. the default name has been changed in version 4.6 (default: seq_ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>optional identifier for this storage, to be able to share the physical table between a number of receivers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column slotids are stored in (default: slotid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeFullMessage" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the messages are stored compressed (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tableName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the table messages are stored in (default: ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="textFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the columns messageid and correlationid, slotid and comments are stored in. n.b. (100) is appended for id's, (1000) is appended for comments. (default: varchar)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>possible values are e (error store), m (message store), l (message log for pipe) or a (message log for receiver). receiverbase will always set type to e for errorstorage and always set type to a for messagelog. genericmessagesendingpipe will set type to l for messagelog (when type isn't specified). see {@link messagestoresender} for type m (default: e for errorstorage on receiver, a for messagelog on receiver and l for messagelog on pipe)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="typeField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column types are stored in (default: type)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="JdbcQueryListenerType">
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used to read blobs (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls automatically whether blobdata is stored compressed and/or serialized in the database (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is considered stored compressed in the database (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commitLocalTransactionQuery" type="xs:string" />
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="keyField" type="xs:string">
      <xs:annotation>
        <xs:documentation>primary key field of the table, used to identify messages (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageField" type="xs:string">
      <xs:annotation>
        <xs:documentation>(optional) field containing the message data (default: &lt;i&gt;same as keyfield&lt;/i&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of the field containing the message data: either string, clob or blob (default: &lt;i&gt;string&lt;/i&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="selectQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>query that returns a row to be processed. must contain a key field and optionally a message field (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startLocalTransactionQuery" type="xs:string" />
    <xs:attribute name="trace" type="xs:string" />
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="updateStatusToErrorQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>sql statement to the status of a row to 'error'. must contain one parameter, that is set to the value of the key (default: same as &lt;code&gt;updatestatustoprocessedquery&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="updateStatusToProcessedQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>sql statement to the status of a row to 'processed'. must contain one parameter, that is set to the value of the key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="JdbcTableListenerType">
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used to read blobs (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls automatically whether blobdata is stored compressed and/or serialized in the database (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is considered stored compressed in the database (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commitLocalTransactionQuery" type="xs:string" />
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="keyField" type="xs:string">
      <xs:annotation>
        <xs:documentation>primary key field of the table, used to identify messages (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageField" type="xs:string">
      <xs:annotation>
        <xs:documentation>(optional) field containing the message data (default: &lt;i&gt;same as keyfield&lt;/i&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of the field containing the message data: either string, clob or blob (default: &lt;i&gt;string&lt;/i&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="orderField" type="xs:string">
      <xs:annotation>
        <xs:documentation>(optional) field determining the order in which messages are processed (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startLocalTransactionQuery" type="xs:string" />
    <xs:attribute name="statusField" type="xs:string">
      <xs:annotation>
        <xs:documentation>field containing the status of the message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueAvailable" type="xs:string">
      <xs:annotation>
        <xs:documentation>(optional) value of status field indicating row is available to be processed. if not specified, any row not having any of the other status values is considered available. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueError" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of status field indicating the processing of the row resulted in an error (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusValueProcessed" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of status field indicating row is processed ok (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tableName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the table to be used (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timestampField" type="xs:string">
      <xs:annotation>
        <xs:documentation>(optional) field used to store the date and time of the last change of the status field (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trace" type="xs:string" />
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="JmsCommunicatorPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapInputWrapper" type="ApiSoapInputWrapperType" minOccurs="0" />
        <xs:element name="BisInputWrapper" type="BisInputWrapperType" minOccurs="0" />
        <xs:element name="DirectInputWrapper" type="DirectInputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapInputWrapper" type="EsbSoapInputWrapperType" minOccurs="0" />
        <xs:element name="FxfInputWrapper" type="FxfInputWrapperType" minOccurs="0" />
        <xs:element name="SoapInputWrapper" type="SoapInputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlInputValidator" type="ApiWsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapInputValidator" type="EsbSoapInputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlInputValidator" type="FxfXmlInputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlInputValidator" type="Json2XmlInputValidatorType" minOccurs="0" />
        <xs:element name="SoapInputValidator" type="SoapInputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlInputValidator" type="WsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="XmlInputValidator" type="XmlInputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiListener" type="ApiListenerType" minOccurs="0" />
        <xs:element name="BisJmsListener" type="BisJmsListenerType" minOccurs="0" />
        <xs:element name="DirectoryListener" type="DirectoryListenerType" minOccurs="0" />
        <xs:element name="EsbJmsListener" type="EsbJmsListenerType" minOccurs="0" />
        <xs:element name="ExchangeMailListener" type="ExchangeMailListenerType" minOccurs="0" />
        <xs:element name="FileRecordListener" type="FileRecordListenerType" minOccurs="0" />
        <xs:element name="FtpListener" type="FtpListenerType" minOccurs="0" />
        <xs:element name="FxfListener" type="FxfListenerType" minOccurs="0" />
        <xs:element name="HttpListener" type="HttpListenerType" minOccurs="0" />
        <xs:element name="JavaListener" type="JavaListenerType" minOccurs="0" />
        <xs:element name="JdbcListener" type="JdbcListenerType" minOccurs="0" />
        <xs:element name="JdbcQueryListener" type="JdbcQueryListenerType" minOccurs="0" />
        <xs:element name="JdbcTableListener" type="JdbcTableListenerType" minOccurs="0" />
        <xs:element name="JmsListener" type="JmsListenerType" minOccurs="0" />
        <xs:element name="MessageStoreListener" type="MessageStoreListenerType" minOccurs="0" />
        <xs:element name="MqttListener" type="MqttListenerType" minOccurs="0" />
        <xs:element name="PullingJmsListener" type="PullingJmsListenerType" minOccurs="0" />
        <xs:element name="PushingJmsListener" type="PushingJmsListenerType" minOccurs="0" />
        <xs:element name="PushingListenerAdapterListener" type="PushingListenerAdapterListenerType" minOccurs="0" />
        <xs:element name="RestListener" type="RestListenerType" minOccurs="0" />
        <xs:element name="SimpleJdbcListener" type="SimpleJdbcListenerType" minOccurs="0" />
        <xs:element name="WebServiceListener" type="WebServiceListenerType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="DummyMessageLog" type="DummyMessageLogType" minOccurs="0" />
        <xs:element name="EsbJmsMessageLog" type="EsbJmsMessageLogType" minOccurs="0" />
        <xs:element name="JdbcMessageLog" type="JdbcMessageLogType" minOccurs="0" />
        <xs:element name="JmsMessageLog" type="JmsMessageLogType" minOccurs="0" />
        <xs:element name="OracleMessageLog" type="OracleMessageLogType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlOutputValidator" type="ApiWsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapOutputValidator" type="EsbSoapOutputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlOutputValidator" type="FxfXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlOutputValidator" type="Json2XmlOutputValidatorType" minOccurs="0" />
        <xs:element name="SoapOutputValidator" type="SoapOutputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlOutputValidator" type="WsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="XmlOutputValidator" type="XmlOutputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapOutputWrapper" type="ApiSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="BisOutputWrapper" type="BisOutputWrapperType" minOccurs="0" />
        <xs:element name="DirectOutputWrapper" type="DirectOutputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapOutputWrapper" type="EsbSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="FxfOutputWrapper" type="FxfOutputWrapperType" minOccurs="0" />
        <xs:element name="SoapOutputWrapper" type="SoapOutputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for audittrailxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. if specified, the value of the pipelinesession variable is used as audit trail (instead of the default 'no audit trail) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract audit trail from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkRootTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, besides the xml well-formedness the root element of the result is checked to be equal to the value set (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkXmlWellFormed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the xml well-formedness of the result is checked (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for correlationidxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. is specified, the value of the pipelinesession variable is used as input for the xpathexpression or stylesheet, instead of the current input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exceptionOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a piperunexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when hideregex is not empty and only applies to error/logstore) either &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;firsthalf&lt;/code&gt;. when &lt;code&gt;firsthalf&lt;/code&gt; only the first half of the string is masked, otherwise (&lt;code&gt;all&lt;/code&gt;) the entire string is masked (default: all)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>next to common usage in {@link abstractpipe}, also strings in the error/logstore are masked (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for labelxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>indicates wether the server uses the correlationid or the messageid in the correlationid field of the reply. this requirers the sender to have set the correlationid at the time of sending. (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of times a processing attempt is retried after a timeout or an exception is caught or after a incorrect reply is received (see also &lt;code&gt;retryxpath&lt;/code&gt;) (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="presumedTimeOutInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>when the previous call was a timeout, the maximum time (in seconds) after this timeout to presume the current call is also a timeout. a value of -1 indicates to never presume timeouts (default: 10 s)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultOnTimeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>result returned when no return-message was received within the timeout limit (e.g. 'receiver timed out'). (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMaxInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of seconds waited after an unsuccessful processing attempt before another processing attempt is made (default: 600)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMinInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the starting number of seconds waited after an unsuccessful processing attempt before another processing attempt is made. each next retry this interval is doubled with a upper limit of &lt;code&gt;retrymaxinterval&lt;/code&gt; (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for retryxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression evaluated on each technical successful reply. retry is done if condition returns true (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is first base64 decoded and then streamed to the httpservletresponse object (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stubFileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the pipe returns a message from a file, instead of doing the regular process (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOutOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a timeoutexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useInputForExtract" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is used to extract audit trail, correlationid and label (instead of the wrapped input) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="JmsErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="ackMode" type="xs:string" />
    <xs:attribute name="acknowledgeMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: auto_acknowledge)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to jms server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdMaxLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the correlationid exceeds this maximum length, the correlationid is trimmed from the left side of a string to this maximum length (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHex" type="xs:string">
      <xs:annotation>
        <xs:documentation>transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part). useful when sending messages to mq which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: mqjms1044: string is not a valid hexadecimal number (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deliveryMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls mode that messages are sent with: either 'persistent' or 'non_persistent' (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the jms destination (queue or topic) to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;topic&lt;/code&gt; (default: &lt;code&gt;queue&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyleURI" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsTransacted" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when synchronous='true' and and replytoname is set) eithter 'correlationid', 'correlationid_from_message' or 'messageid'. indicates wether the server uses the correlationid from the pipeline, the correlationid from the message or the messageid in the correlationid field of the reply. this requires the sender to have set the correlationid at the time of sending. (default: messageid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lookupDestination" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the destinationname is used directly instead of performing a jndi lookup (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageSelector" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the value of this attribute is used as a selector to filter messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in milliseconds) it takes for the message to expire. if the message is not consumed before, it will be lost. make sure to set it to a positive value for request/repy type of messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of the jmstype field (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistent" type="xs:string">
      <xs:annotation>
        <xs:documentation>rather useless attribute, and not the same as &lt;code&gt;deliverymode&lt;/code&gt;. you probably want to use that. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="priority" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets the priority that is used to deliver the message. ranges from 0 to 9. defaults to -1, meaning not set. effectively the default priority is set by jms to 4 (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the queueconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;queue&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replySoapHeaderSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to store soap header of reply (default: soapheader)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum time in ms to wait for a reply. 0 means no timeout. (only for synchronous=true) (default: 5000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespaceURI" type="xs:string" />
    <xs:attribute name="soap" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapAction" type="xs:string">
      <xs:annotation>
        <xs:documentation>soapaction string sent as messageproperty (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of parameter containing soap header (default: soapheader)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="subscriberType" type="xs:string" />
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the sender operates in rr mode: the a reply is expected, either on the queue specified in 'replytoname', or on a dynamically generated temporary queue (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the topicconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;topic&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="JmsErrorStorageType">
    <xs:attribute name="ackMode" type="xs:string" />
    <xs:attribute name="acknowledgeMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: auto_acknowledge)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to jms server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdMaxLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the correlationid exceeds this maximum length, the correlationid is trimmed from the left side of a string to this maximum length (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHex" type="xs:string">
      <xs:annotation>
        <xs:documentation>transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part). useful when sending messages to mq which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: mqjms1044: string is not a valid hexadecimal number (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the jms destination (queue or topic) to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;topic&lt;/code&gt; (default: &lt;code&gt;queue&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsTransacted" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="lookupDestination" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the destinationname is used directly instead of performing a jndi lookup (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageSelector" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the value of this attribute is used as a selector to filter messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in milliseconds) it takes for the message to expire. if the message is not consumed before, it will be lost. make sure to set it to a positive value for request/repy type of messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistent" type="xs:string">
      <xs:annotation>
        <xs:documentation>rather useless attribute, and not the same as &lt;code&gt;deliverymode&lt;/code&gt;. you probably want to use that. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the queueconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;queue&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>optional identifier for this storage, to be able to share the physical storage between a number of receivers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="subscriberType" type="xs:string" />
    <xs:attribute name="timeOut" type="xs:string" />
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the topicconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;topic&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string" />
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="JmsListenerType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="ackMode" type="xs:string" />
    <xs:attribute name="acknowledgeMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: auto_acknowledge)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to jms server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cacheMode" type="xs:string" />
    <xs:attribute name="commitOnState" type="xs:string">
      <xs:annotation>
        <xs:documentation>&lt;i&gt;deprecated&lt;/i&gt; exit state to control commit or rollback of jmssession. only used if &lt;code&gt;jmstransacted&lt;/code&gt; is set true. (default: success)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdMaxLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the correlationid exceeds this maximum length, the correlationid is trimmed from the left side of a string to this maximum length (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHex" type="xs:string">
      <xs:annotation>
        <xs:documentation>transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part). useful when sending messages to mq which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: mqjms1044: string is not a valid hexadecimal number (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the jms destination (queue or topic) to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;topic&lt;/code&gt; (default: &lt;code&gt;queue&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forceMessageIdAsCorrelationId" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsTransacted" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="listenerPort" type="xs:string" />
    <xs:attribute name="lookupDestination" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the destinationname is used directly instead of performing a jndi lookup (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageSelector" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the value of this attribute is used as a selector to filter messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in milliseconds) it takes for the message to expire. if the message is not consumed before, it will be lost. make sure to set it to a positive value for request/repy type of messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistent" type="xs:string">
      <xs:annotation>
        <xs:documentation>rather useless attribute, and not the same as &lt;code&gt;deliverymode&lt;/code&gt;. you probably want to use that. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pollGuardInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>interval in milliseconds for the poll guard to check whether a successful poll was done by the receive (https://docs.oracle.com/javaee/7/api/javax/jms/messageconsumer.html#receive-long-) since last check. when polling has stopped this will be logged and the listener will be stopped and started in an attempt to workaround problems with polling. polling might stop due to bugs in the jms driver/implementation which should be fixed by the supplier. as the poll time includes reading and processing of the message no successful poll might be registered since the last check when message processing takes a long time, hence while messages are being processed the check on last successful poll will be skipped. set to -1 to disable (default: ten times the specified timeout)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the queueconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;queue&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyDeliveryMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls mode that reply messages are sent with: either 'persistent' or 'non_persistent' (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyEncodingStyleURI" type="xs:string" />
    <xs:attribute name="replyMessageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>time that replymessage will live (default: 0 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyMessageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of the jmstype field of the reply message (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyNamespaceURI" type="xs:string" />
    <xs:attribute name="replyPriority" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets the priority that is used to deliver the reply message. ranges from 0 to 9. defaults to -1, meaning not set. effectively the default priority is set by jms to 4 (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replySoapAction" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soap" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="subscriberType" type="xs:string" />
    <xs:attribute name="timeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>receiver timeout, in milliseconds (default: 3000 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the topicconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;topic&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useReplyTo" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xPathLoggingKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of all xpath keys that need to be logged. (overrides &lt;code&gt;msg.log.keys&lt;/code&gt; property) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="JmsMessageLogType">
    <xs:attribute name="ackMode" type="xs:string" />
    <xs:attribute name="acknowledgeMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: auto_acknowledge)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string" />
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to jms server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdMaxLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the correlationid exceeds this maximum length, the correlationid is trimmed from the left side of a string to this maximum length (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHex" type="xs:string">
      <xs:annotation>
        <xs:documentation>transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part). useful when sending messages to mq which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: mqjms1044: string is not a valid hexadecimal number (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the jms destination (queue or topic) to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;topic&lt;/code&gt; (default: &lt;code&gt;queue&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsTransacted" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="lookupDestination" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the destinationname is used directly instead of performing a jndi lookup (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageSelector" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the value of this attribute is used as a selector to filter messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in milliseconds) it takes for the message to expire. if the message is not consumed before, it will be lost. make sure to set it to a positive value for request/repy type of messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistent" type="xs:string">
      <xs:annotation>
        <xs:documentation>rather useless attribute, and not the same as &lt;code&gt;deliverymode&lt;/code&gt;. you probably want to use that. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the queueconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;queue&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>optional identifier for this storage, to be able to share the physical storage between a number of receivers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="subscriberType" type="xs:string" />
    <xs:attribute name="timeOut" type="xs:string" />
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the topicconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;topic&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string" />
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="JmsSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="ackMode" type="xs:string" />
    <xs:attribute name="acknowledgeMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: auto_acknowledge)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to jms server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdMaxLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the correlationid exceeds this maximum length, the correlationid is trimmed from the left side of a string to this maximum length (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHex" type="xs:string">
      <xs:annotation>
        <xs:documentation>transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part). useful when sending messages to mq which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: mqjms1044: string is not a valid hexadecimal number (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deliveryMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls mode that messages are sent with: either 'persistent' or 'non_persistent' (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the jms destination (queue or topic) to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;topic&lt;/code&gt; (default: &lt;code&gt;queue&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyleURI" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsTransacted" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when synchronous='true' and and replytoname is set) eithter 'correlationid', 'correlationid_from_message' or 'messageid'. indicates wether the server uses the correlationid from the pipeline, the correlationid from the message or the messageid in the correlationid field of the reply. this requires the sender to have set the correlationid at the time of sending. (default: messageid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lookupDestination" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the destinationname is used directly instead of performing a jndi lookup (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageSelector" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the value of this attribute is used as a selector to filter messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in milliseconds) it takes for the message to expire. if the message is not consumed before, it will be lost. make sure to set it to a positive value for request/repy type of messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of the jmstype field (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistent" type="xs:string">
      <xs:annotation>
        <xs:documentation>rather useless attribute, and not the same as &lt;code&gt;deliverymode&lt;/code&gt;. you probably want to use that. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="priority" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets the priority that is used to deliver the message. ranges from 0 to 9. defaults to -1, meaning not set. effectively the default priority is set by jms to 4 (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the queueconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;queue&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replySoapHeaderSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to store soap header of reply (default: soapheader)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum time in ms to wait for a reply. 0 means no timeout. (only for synchronous=true) (default: 5000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespaceURI" type="xs:string" />
    <xs:attribute name="soap" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapAction" type="xs:string">
      <xs:annotation>
        <xs:documentation>soapaction string sent as messageproperty (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of parameter containing soap header (default: soapheader)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="subscriberType" type="xs:string" />
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the sender operates in rr mode: the a reply is expected, either on the queue specified in 'replytoname', or on a dynamically generated temporary queue (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the topicconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;topic&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="JobType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="DirectoryCleaner" type="DirectoryCleanerType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="adapterName" type="xs:string">
      <xs:annotation>
        <xs:documentation>adapter on which job operates (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="configurationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>configuration on which job operates (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cronExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>cron expression that determines the frequency of execution (see below) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="description" type="xs:string">
      <xs:annotation>
        <xs:documentation>optional description of the job (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="function" type="xs:string">
      <xs:annotation>
        <xs:documentation>one of: stopadapter, startadapter, stopreceiver, startreceiver, sendmessage, executequery (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="interval" type="xs:string">
      <xs:annotation>
        <xs:documentation>repeat the job at the specified number of ms. keep cronexpression empty to use interval. set to 0 to only run once at startup of the application. a value of 0 in combination with function 'sendmessage' will set dependencytimeout on the ibislocalsender to -1 the keep waiting indefinitely instead of max 60 seconds for the adapter to start. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsRealm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jobGroup" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the job (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of threads that may execute concurrently (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="query" type="xs:string">
      <xs:annotation>
        <xs:documentation>the sql query text to be executed (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queryTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of seconds the driver will wait for a statement object to execute. if the limit is exceeded, a timeoutexception is thrown. 0 means no timeout (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="receiverName" type="xs:string">
      <xs:annotation>
        <xs:documentation>receiver on which job operates. if function is 'sendmessage' is used this name is also used as name of javalistener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="Json2XmlInputValidatorType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the root element. or a comma separated list of names to choose from (only one is allowed) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="Json2XmlOutputValidatorType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the root element. or a comma separated list of names to choose from (only one is allowed) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="Json2XmlValidatorPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the root element. or a comma separated list of names to choose from (only one is allowed) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="JsonPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="version" type="xs:string" />
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="JsonWellFormedCheckerPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="JsonXsltPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indentXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, result is pretty-printed. (only used when &lt;code&gt;skipemptytags=true&lt;/code&gt;) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of transformation (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:string">
      <xs:annotation>
        <xs:documentation>force the transformer generated from the xpath-expression to omit the xml declaration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either 'text' or 'xml'. only valid for xpathexpression (default: text)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string" />
    <xs:attribute name="skipEmptyTags" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; empty tags in the output are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to apply to the input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath-expression to apply to the input message. it's possible to refer to a parameter (which e.g. contains a value from a sessionkey) by using the parameter name prefixed with $ (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="LabelFormatPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="LarvaPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="LdapChallengePipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="errorSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable used to store cause of errors (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: com.sun.jndi.ldap.ldapctxfactory)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ldapProviderURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>url to the ldap server. &lt;br/&gt;example: ldap://su05b9.itc.intranet (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="LdapErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="attributesToReturn" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of attributes to return. when no are attributes specified, all the attributes from the object read are returned. (default: &lt;i&gt;all attributes&lt;/i&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="errorSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable used to store cause of errors (default: errorreason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="ldapProviderURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>url to context to search in, e.g. 'ldap://edsnlm01.group.intranet/ou=people, o=ing' to search in te people group of ing cds. used to overwrite the providerurl specified in jmsrealm. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="manipulationSubject" type="xs:string">
      <xs:annotation>
        <xs:documentation>specifies subject to perform operation on. must be one of 'entry' or 'attribute' (default: attribute)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxEntriesReturned" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of entries to be returned by a search query, or 0 for unlimited (default: &lt;i&gt;0 (unlimited)&lt;/i&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="operation" type="xs:string" />
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyNotFound" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;operation=search/deepsearch&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt; the xml '&amp;lt;ldapresult&amp;gt;object not found&amp;lt;/ldapresult&amp;gt;' is returned instead of the partialresultexception 'unprocessed continuation reference(s)' (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="searchTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>specifies the time (in ms) that is spent searching for results for operation search (default: 20000 ms)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="unicodePwd" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true the attributes passed by the input xml are scanned for an attribute with id unicodepwd, when found the value of this attribute will be encoded as required by active directory (a utf-16 encoded unicode string containing the password surrounded by quotation marks) before sending it to the ldap server (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="usePooling" type="xs:string">
      <xs:annotation>
        <xs:documentation>specifies whether connection pooling is used or not (default: true when principal not set as parameter, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="LdapFindMemberPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string" />
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dnFind" type="xs:string" />
    <xs:attribute name="dnSearchIn" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exceptionForwardName" type="xs:string" />
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="host" type="xs:string" />
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="notFoundForwardName" type="xs:string" />
    <xs:attribute name="password" type="xs:string" />
    <xs:attribute name="port" type="xs:string" />
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="recursiveSearch" type="xs:string" />
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useSsl" type="xs:string" />
    <xs:attribute name="userName" type="xs:string" />
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="LdapSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="attributesToReturn" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of attributes to return. when no are attributes specified, all the attributes from the object read are returned. (default: &lt;i&gt;all attributes&lt;/i&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="errorSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable used to store cause of errors (default: errorreason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="ldapProviderURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>url to context to search in, e.g. 'ldap://edsnlm01.group.intranet/ou=people, o=ing' to search in te people group of ing cds. used to overwrite the providerurl specified in jmsrealm. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="manipulationSubject" type="xs:string">
      <xs:annotation>
        <xs:documentation>specifies subject to perform operation on. must be one of 'entry' or 'attribute' (default: attribute)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxEntriesReturned" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of entries to be returned by a search query, or 0 for unlimited (default: &lt;i&gt;0 (unlimited)&lt;/i&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="operation" type="xs:string" />
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyNotFound" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;operation=search/deepsearch&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt; the xml '&amp;lt;ldapresult&amp;gt;object not found&amp;lt;/ldapresult&amp;gt;' is returned instead of the partialresultexception 'unprocessed continuation reference(s)' (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="searchTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>specifies the time (in ms) that is spent searching for results for operation search (default: 20000 ms)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="unicodePwd" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true the attributes passed by the input xml are scanned for an attribute with id unicodepwd, when found the value of this attribute will be encoded as required by active directory (a utf-16 encoded unicode string containing the password surrounded by quotation marks) before sending it to the ldap server (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="usePooling" type="xs:string">
      <xs:annotation>
        <xs:documentation>specifies whether connection pooling is used or not (default: true when principal not set as parameter, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="LockerType">
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="dateFormatSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>format for date which is added after &lt;code&gt;objectid&lt;/code&gt; (e.g. yyyymmdd to be sure the job is executed only once a day) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="firstDelay" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time in ms to wait before the first attempt to acquire a lock is made, this may be 0 but keep in mind that the other thread or ibis instance will propably not get much change to acquire a lock when another message is already waiting for the thread having the current lock in which case it will probably acquire a new lock soon after releasing the current lock (default: 10000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreTableNotExist" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="numRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of times an attempt should be made to acquire a lock, after this many times an exception is thrown when no lock could be acquired, when -1 the number of retries is unlimited (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="objectId" type="xs:string">
      <xs:annotation>
        <xs:documentation>identifier for this lock (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retention" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (for type=p in days and for type=t in hours) to keep the record in the database before making it eligible for deletion by a cleanup process (default: 30 days (type=p), 4 hours (type=t))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryDelay" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time in ms to wait before another attempt to acquire a lock is made (default: 10000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>type for this lock: p(ermanent) or t(emporary). a temporary lock is deleted after the job has completed (default: t)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="LogErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="logCategory" type="xs:string">
      <xs:annotation>
        <xs:documentation>category under which messages are logged (default: name of the sender)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logLevel" type="xs:string">
      <xs:annotation>
        <xs:documentation>level on which messages are logged (default: info)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="LogSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="logCategory" type="xs:string">
      <xs:annotation>
        <xs:documentation>category under which messages are logged (default: name of the sender)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logLevel" type="xs:string">
      <xs:annotation>
        <xs:documentation>level on which messages are logged (default: info)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="MailErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="defaultAttachmentName" type="xs:string">
      <xs:annotation>
        <xs:documentation>when this name is used, it will be followed by a number which is equal to the node's position (default: attachment)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="smtpAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to smtphost (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="smtpHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the host by which the messages are to be send (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="smtpPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>password of userid on the smtphost (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="smtpUserid" type="xs:string">
      <xs:annotation>
        <xs:documentation>userid on the smtphost (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in milliseconds). used for socket connection timeout and socket i/o timeout (default: 20000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="MailSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="defaultAttachmentName" type="xs:string">
      <xs:annotation>
        <xs:documentation>when this name is used, it will be followed by a number which is equal to the node's position (default: attachment)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="smtpAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to smtphost (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="smtpHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the host by which the messages are to be send (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="smtpPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>password of userid on the smtphost (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="smtpUserid" type="xs:string">
      <xs:annotation>
        <xs:documentation>userid on the smtphost (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in milliseconds). used for socket connection timeout and socket i/o timeout (default: 20000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="MailSenderPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapInputWrapper" type="ApiSoapInputWrapperType" minOccurs="0" />
        <xs:element name="BisInputWrapper" type="BisInputWrapperType" minOccurs="0" />
        <xs:element name="DirectInputWrapper" type="DirectInputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapInputWrapper" type="EsbSoapInputWrapperType" minOccurs="0" />
        <xs:element name="FxfInputWrapper" type="FxfInputWrapperType" minOccurs="0" />
        <xs:element name="SoapInputWrapper" type="SoapInputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlInputValidator" type="ApiWsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapInputValidator" type="EsbSoapInputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlInputValidator" type="FxfXmlInputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlInputValidator" type="Json2XmlInputValidatorType" minOccurs="0" />
        <xs:element name="SoapInputValidator" type="SoapInputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlInputValidator" type="WsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="XmlInputValidator" type="XmlInputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="DummyMessageLog" type="DummyMessageLogType" minOccurs="0" />
        <xs:element name="EsbJmsMessageLog" type="EsbJmsMessageLogType" minOccurs="0" />
        <xs:element name="JdbcMessageLog" type="JdbcMessageLogType" minOccurs="0" />
        <xs:element name="JmsMessageLog" type="JmsMessageLogType" minOccurs="0" />
        <xs:element name="OracleMessageLog" type="OracleMessageLogType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlOutputValidator" type="ApiWsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapOutputValidator" type="EsbSoapOutputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlOutputValidator" type="FxfXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlOutputValidator" type="Json2XmlOutputValidatorType" minOccurs="0" />
        <xs:element name="SoapOutputValidator" type="SoapOutputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlOutputValidator" type="WsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="XmlOutputValidator" type="XmlOutputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapOutputWrapper" type="ApiSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="BisOutputWrapper" type="BisOutputWrapperType" minOccurs="0" />
        <xs:element name="DirectOutputWrapper" type="DirectOutputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapOutputWrapper" type="EsbSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="FxfOutputWrapper" type="FxfOutputWrapperType" minOccurs="0" />
        <xs:element name="SoapOutputWrapper" type="SoapOutputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for audittrailxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. if specified, the value of the pipelinesession variable is used as audit trail (instead of the default 'no audit trail) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract audit trail from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkRootTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, besides the xml well-formedness the root element of the result is checked to be equal to the value set (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkXmlWellFormed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the xml well-formedness of the result is checked (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for correlationidxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. is specified, the value of the pipelinesession variable is used as input for the xpathexpression or stylesheet, instead of the current input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exceptionOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a piperunexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when hideregex is not empty and only applies to error/logstore) either &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;firsthalf&lt;/code&gt;. when &lt;code&gt;firsthalf&lt;/code&gt; only the first half of the string is masked, otherwise (&lt;code&gt;all&lt;/code&gt;) the entire string is masked (default: all)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>next to common usage in {@link abstractpipe}, also strings in the error/logstore are masked (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for labelxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>indicates wether the server uses the correlationid or the messageid in the correlationid field of the reply. this requirers the sender to have set the correlationid at the time of sending. (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of times a processing attempt is retried after a timeout or an exception is caught or after a incorrect reply is received (see also &lt;code&gt;retryxpath&lt;/code&gt;) (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="presumedTimeOutInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>when the previous call was a timeout, the maximum time (in seconds) after this timeout to presume the current call is also a timeout. a value of -1 indicates to never presume timeouts (default: 10 s)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultOnTimeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>result returned when no return-message was received within the timeout limit (e.g. 'receiver timed out'). (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMaxInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of seconds waited after an unsuccessful processing attempt before another processing attempt is made (default: 600)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMinInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the starting number of seconds waited after an unsuccessful processing attempt before another processing attempt is made. each next retry this interval is doubled with a upper limit of &lt;code&gt;retrymaxinterval&lt;/code&gt; (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for retryxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression evaluated on each technical successful reply. retry is done if condition returns true (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is first base64 decoded and then streamed to the httpservletresponse object (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stubFileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the pipe returns a message from a file, instead of doing the regular process (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOutOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a timeoutexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useInputForExtract" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is used to extract audit trail, correlationid and label (instead of the wrapped input) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="MessageStoreErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string" />
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the full message is stored with the log. can be set to &lt;code&gt;false&lt;/code&gt; to reduce table size, by avoiding to store the full message (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commentField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column comments are stored in (default: comments)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="correlationIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column correlation-ids are stored in (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createTable" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the table is created if it does not exist (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="dateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column the timestamp is stored in (default: messagedate)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dateFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column the timestamps are stored in (default: timestamp)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expiryDateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column the timestamp for expiry is stored in (default: expirydate)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hostField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column that stores the hostname of the server (default: host)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="idField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column messageids are stored in (default: messageid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indexName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the index, to be used in hints for query optimizer too (only for oracle) (default: ix_ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="keyField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column that contains the primary key of the table (default: messagekey)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column that contains the primary key of the table (default: int default autoincrement)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column labels are stored in (default: label)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column message themselves are stored in (default: message)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column message themselves are stored in (default: long binary)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="onlyStoreWhenMessageIdUnique" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="order" type="xs:string" />
    <xs:attribute name="prefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>prefix to be prefixed on all database objects (tables, indices, sequences), e.q. to access a different oracle schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retention" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in days) to keep the record in the database before making it eligible for deletion by a cleanup process. when set to -1, the record will live on forever (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaOwner4Check" type="xs:string">
      <xs:annotation>
        <xs:documentation>schema owner to be used to check the database (default: &amp;lt;current_schema&amp;gt; (only for oracle))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sequenceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the sequence used to generate the primary key (only for oracle)&lt;br&gt;n.b. the default name has been changed in version 4.6 (default: seq_ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of sessionkey's to be stored together with the message. please note: corresponding {@link messagestorelistener} must have the same value for this attribute (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>optional identifier for this storage, to be able to share the physical table between a number of receivers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column slotids are stored in (default: slotid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeFullMessage" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the messages are stored compressed (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tableName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the table messages are stored in (default: ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="textFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the columns messageid and correlationid, slotid and comments are stored in. n.b. (100) is appended for id's, (1000) is appended for comments. (default: varchar)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>possible values are e (error store), m (message store), l (message log for pipe) or a (message log for receiver). receiverbase will always set type to e for errorstorage and always set type to a for messagelog. genericmessagesendingpipe will set type to l for messagelog (when type isn't specified). see {@link messagestoresender} for type m (default: e for errorstorage on receiver, a for messagelog on receiver and l for messagelog on pipe)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="typeField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column types are stored in (default: type)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="MessageStoreListenerType">
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used to read blobs (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls automatically whether blobdata is stored compressed and/or serialized in the database (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is considered stored compressed in the database (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commitLocalTransactionQuery" type="xs:string" />
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="keyField" type="xs:string">
      <xs:annotation>
        <xs:documentation>primary key field of the table, used to identify messages (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageField" type="xs:string">
      <xs:annotation>
        <xs:documentation>(optional) field containing the message data (default: &lt;i&gt;same as keyfield&lt;/i&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of the field containing the message data: either string, clob or blob (default: &lt;i&gt;string&lt;/i&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="moveToMessageLog" type="xs:string">
      <xs:annotation>
        <xs:documentation>move to messagelog after processing, as the message is already stored in the ibisstore only some fields need to be updated, use a messagelog element with class {@link dummytransactionalstorage} to enable it in the console (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="selectQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>query that returns a row to be processed. must contain a key field and optionally a message field (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of sessionkey's to be read together with the message. please note: corresponding {@link messagestoresender} must have the same value for this attribute (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>identifier for this service (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startLocalTransactionQuery" type="xs:string" />
    <xs:attribute name="trace" type="xs:string" />
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="updateStatusToErrorQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>sql statement to the status of a row to 'error'. must contain one parameter, that is set to the value of the key (default: same as &lt;code&gt;updatestatustoprocessedquery&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="updateStatusToProcessedQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>sql statement to the status of a row to 'processed'. must contain one parameter, that is set to the value of the key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="MessageStoreSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string" />
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the full message is stored with the log. can be set to &lt;code&gt;false&lt;/code&gt; to reduce table size, by avoiding to store the full message (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commentField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column comments are stored in (default: comments)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="correlationIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column correlation-ids are stored in (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createTable" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the table is created if it does not exist (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="dateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column the timestamp is stored in (default: messagedate)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dateFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column the timestamps are stored in (default: timestamp)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expiryDateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column the timestamp for expiry is stored in (default: expirydate)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hostField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column that stores the hostname of the server (default: host)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="idField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column messageids are stored in (default: messageid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indexName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the index, to be used in hints for query optimizer too (only for oracle) (default: ix_ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="keyField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column that contains the primary key of the table (default: messagekey)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column that contains the primary key of the table (default: int default autoincrement)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column labels are stored in (default: label)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column message themselves are stored in (default: message)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column message themselves are stored in (default: long binary)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="onlyStoreWhenMessageIdUnique" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="order" type="xs:string" />
    <xs:attribute name="prefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>prefix to be prefixed on all database objects (tables, indices, sequences), e.q. to access a different oracle schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retention" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in days) to keep the record in the database before making it eligible for deletion by a cleanup process. when set to -1, the record will live on forever (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaOwner4Check" type="xs:string">
      <xs:annotation>
        <xs:documentation>schema owner to be used to check the database (default: &amp;lt;current_schema&amp;gt; (only for oracle))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sequenceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the sequence used to generate the primary key (only for oracle)&lt;br&gt;n.b. the default name has been changed in version 4.6 (default: seq_ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of sessionkey's to be stored together with the message. please note: corresponding {@link messagestorelistener} must have the same value for this attribute (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>optional identifier for this storage, to be able to share the physical table between a number of receivers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column slotids are stored in (default: slotid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeFullMessage" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the messages are stored compressed (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tableName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the table messages are stored in (default: ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="textFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the columns messageid and correlationid, slotid and comments are stored in. n.b. (100) is appended for id's, (1000) is appended for comments. (default: varchar)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>possible values are e (error store), m (message store), l (message log for pipe) or a (message log for receiver). receiverbase will always set type to e for errorstorage and always set type to a for messagelog. genericmessagesendingpipe will set type to l for messagelog (when type isn't specified). see {@link messagestoresender} for type m (default: e for errorstorage on receiver, a for messagelog on receiver and l for messagelog on pipe)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="typeField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column types are stored in (default: type)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="MoveFilePipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="append" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; and the destination file already exists, the content of the file to move is written to the end of the destination file. this implies &lt;code&gt;overwrite=false&lt;/code&gt; (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the directory to move to is created if it does not exist (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deleteEmptyDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the directory from which a file is moved is deleted when it contains no other files (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directory" type="xs:string">
      <xs:annotation>
        <xs:documentation>base directory where files are moved from (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filename" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the file to move (if not specified, the input for this pipe is assumed to be the name of the file (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="move2dir" type="xs:string">
      <xs:annotation>
        <xs:documentation>destination directory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="move2file" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the destination file (if not specified, the name of the file to move is taken) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="move2fileSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key that contains the name of the file to use (only used if move2file is not set) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numberOfAttempts" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum number of attempts before throwing an exception (default: 10)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numberOfBackups" type="xs:string">
      <xs:annotation>
        <xs:documentation>number of copies held of a file with the same name. backup files have a dot and a number suffixed to their name. if set to 0, no backups will be kept. (default: 5)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="overwrite" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the destination file will be deleted if it already exists. when set &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;numberofbackups&lt;/code&gt; set to 0, a counter is added to the destination filename ('basename_###.ext') (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>string which is inserted at the start of the destination file (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="suffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>string which is inserted at the end of the destination file (and replaces the extension if present) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;numberofbackups&lt;/code&gt; is set to 0 and the destination file already exists a piperunexception is thrown (instead of adding a counter to the destination filename) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="waitBeforeRetry" type="xs:string">
      <xs:annotation>
        <xs:documentation>time between attempts (default: 1000 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wildcard" type="xs:string">
      <xs:annotation>
        <xs:documentation>filter of files to replace (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wildcardSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key that contains the name of the filter to use (only used if wildcard is not set) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="MqttErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="authAlias" type="xs:string" />
    <xs:attribute name="automaticReconnect" type="xs:string" />
    <xs:attribute name="brokerUrl" type="xs:string" />
    <xs:attribute name="charset" type="xs:string" />
    <xs:attribute name="cleanSession" type="xs:string" />
    <xs:attribute name="clientId" type="xs:string" />
    <xs:attribute name="keepAliveInterval" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="password" type="xs:string" />
    <xs:attribute name="persistenceDirectory" type="xs:string" />
    <xs:attribute name="qos" type="xs:string" />
    <xs:attribute name="timeout" type="xs:string" />
    <xs:attribute name="topic" type="xs:string" />
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="MqttListenerType">
    <xs:attribute name="authAlias" type="xs:string" />
    <xs:attribute name="automaticReconnect" type="xs:string" />
    <xs:attribute name="brokerUrl" type="xs:string" />
    <xs:attribute name="charset" type="xs:string" />
    <xs:attribute name="cleanSession" type="xs:string" />
    <xs:attribute name="clientId" type="xs:string" />
    <xs:attribute name="keepAliveInterval" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="password" type="xs:string" />
    <xs:attribute name="persistenceDirectory" type="xs:string" />
    <xs:attribute name="qos" type="xs:string" />
    <xs:attribute name="timeout" type="xs:string" />
    <xs:attribute name="topic" type="xs:string" />
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="MqttSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="authAlias" type="xs:string" />
    <xs:attribute name="automaticReconnect" type="xs:string" />
    <xs:attribute name="brokerUrl" type="xs:string" />
    <xs:attribute name="charset" type="xs:string" />
    <xs:attribute name="cleanSession" type="xs:string" />
    <xs:attribute name="clientId" type="xs:string" />
    <xs:attribute name="keepAliveInterval" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="password" type="xs:string" />
    <xs:attribute name="persistenceDirectory" type="xs:string" />
    <xs:attribute name="qos" type="xs:string" />
    <xs:attribute name="timeout" type="xs:string" />
    <xs:attribute name="topic" type="xs:string" />
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="OracleErrorStorageType">
    <xs:attribute name="active" type="xs:string" />
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the full message is stored with the log. can be set to &lt;code&gt;false&lt;/code&gt; to reduce table size, by avoiding to store the full message (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commentField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column comments are stored in (default: comments)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="correlationIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column correlation-ids are stored in (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createTable" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the table is created if it does not exist (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="dateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column the timestamp is stored in (default: messagedate)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dateFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column the timestamps are stored in (default: timestamp)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expiryDateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column the timestamp for expiry is stored in (default: expirydate)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hostField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column that stores the hostname of the server (default: host)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="idField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column messageids are stored in (default: messageid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indexName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the index, to be used in hints for query optimizer too (only for oracle) (default: ix_ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="keyField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column that contains the primary key of the table (default: messagekey)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column that contains the primary key of the table (default: int default autoincrement)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column labels are stored in (default: label)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column message themselves are stored in (default: message)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column message themselves are stored in (default: long binary)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="onlyStoreWhenMessageIdUnique" type="xs:string" />
    <xs:attribute name="order" type="xs:string" />
    <xs:attribute name="prefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>prefix to be prefixed on all database objects (tables, indices, sequences), e.q. to access a different oracle schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retention" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in days) to keep the record in the database before making it eligible for deletion by a cleanup process. when set to -1, the record will live on forever (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaOwner4Check" type="xs:string">
      <xs:annotation>
        <xs:documentation>schema owner to be used to check the database (default: &amp;lt;current_schema&amp;gt; (only for oracle))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sequenceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the sequence used to generate the primary key (only for oracle)&lt;br&gt;n.b. the default name has been changed in version 4.6 (default: seq_ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>optional identifier for this storage, to be able to share the physical table between a number of receivers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column slotids are stored in (default: slotid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeFullMessage" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the messages are stored compressed (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tableName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the table messages are stored in (default: ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="textFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the columns messageid and correlationid, slotid and comments are stored in. n.b. (100) is appended for id's, (1000) is appended for comments. (default: varchar)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>possible values are e (error store), m (message store), l (message log for pipe) or a (message log for receiver). receiverbase will always set type to e for errorstorage and always set type to a for messagelog. genericmessagesendingpipe will set type to l for messagelog (when type isn't specified). see {@link messagestoresender} for type m (default: e for errorstorage on receiver, a for messagelog on receiver and l for messagelog on pipe)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="typeField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column types are stored in (default: type)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="OracleMessageLogType">
    <xs:attribute name="active" type="xs:string" />
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the full message is stored with the log. can be set to &lt;code&gt;false&lt;/code&gt; to reduce table size, by avoiding to store the full message (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commentField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column comments are stored in (default: comments)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="correlationIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column correlation-ids are stored in (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createTable" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the table is created if it does not exist (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="dateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column the timestamp is stored in (default: messagedate)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dateFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column the timestamps are stored in (default: timestamp)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expiryDateField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column the timestamp for expiry is stored in (default: expirydate)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hostField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column that stores the hostname of the server (default: host)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="idField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column messageids are stored in (default: messageid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indexName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the index, to be used in hints for query optimizer too (only for oracle) (default: ix_ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="keyField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column that contains the primary key of the table (default: messagekey)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column that contains the primary key of the table (default: int default autoincrement)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column labels are stored in (default: label)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column message themselves are stored in (default: message)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the column message themselves are stored in (default: long binary)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="onlyStoreWhenMessageIdUnique" type="xs:string" />
    <xs:attribute name="order" type="xs:string" />
    <xs:attribute name="prefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>prefix to be prefixed on all database objects (tables, indices, sequences), e.q. to access a different oracle schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retention" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in days) to keep the record in the database before making it eligible for deletion by a cleanup process. when set to -1, the record will live on forever (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaOwner4Check" type="xs:string">
      <xs:annotation>
        <xs:documentation>schema owner to be used to check the database (default: &amp;lt;current_schema&amp;gt; (only for oracle))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sequenceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the sequence used to generate the primary key (only for oracle)&lt;br&gt;n.b. the default name has been changed in version 4.6 (default: seq_ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotId" type="xs:string">
      <xs:annotation>
        <xs:documentation>optional identifier for this storage, to be able to share the physical table between a number of receivers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="slotIdField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column slotids are stored in (default: slotid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeFullMessage" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, the messages are stored compressed (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tableName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the table messages are stored in (default: ibisstore)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="textFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>the type of the columns messageid and correlationid, slotid and comments are stored in. n.b. (100) is appended for id's, (1000) is appended for comments. (default: varchar)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>possible values are e (error store), m (message store), l (message log for pipe) or a (message log for receiver). receiverbase will always set type to e for errorstorage and always set type to a for messagelog. genericmessagesendingpipe will set type to l for messagelog (when type isn't specified). see {@link messagestoresender} for type m (default: e for errorstorage on receiver, a for messagelog on receiver and l for messagelog on pipe)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="typeField" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the column types are stored in (default: type)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ParallelSendersSenderType">
    <xs:sequence>
      <xs:element name="Cache" type="CacheType" minOccurs="0" maxOccurs="unbounded" />
      <xs:choice minOccurs="0">
        <xs:element name="Afm2EdiFactSender" type="Afm2EdiFactSenderType" minOccurs="0" />
        <xs:element name="BisJmsSender" type="BisJmsSenderType" minOccurs="0" />
        <xs:element name="CommandSender" type="CommandSenderType" minOccurs="0" />
        <xs:element name="DelaySender" type="DelaySenderType" minOccurs="0" />
        <xs:element name="DirectQuerySender" type="DirectQuerySenderType" minOccurs="0" />
        <xs:element name="EchoSender" type="EchoSenderType" minOccurs="0" />
        <xs:element name="EsbJmsSender" type="EsbJmsSenderType" minOccurs="0" />
        <xs:element name="FileSender" type="FileSenderType" minOccurs="0" />
        <xs:element name="FixedQuerySender" type="FixedQuerySenderType" minOccurs="0" />
        <xs:element name="FixedResultSender" type="FixedResultSenderType" minOccurs="0" />
        <xs:element name="FtpSender" type="FtpSenderType" minOccurs="0" />
        <xs:element name="HttpSender" type="HttpSenderType" minOccurs="0" />
        <xs:element name="IbisJavaSender" type="IbisJavaSenderType" minOccurs="0" />
        <xs:element name="IbisLocalSender" type="IbisLocalSenderType" minOccurs="0" />
        <xs:element name="IbisWebServiceSender" type="IbisWebServiceSenderType" minOccurs="0" />
        <xs:element name="JmsSender" type="JmsSenderType" minOccurs="0" />
        <xs:element name="LdapSender" type="LdapSenderType" minOccurs="0" />
        <xs:element name="LogSender" type="LogSenderType" minOccurs="0" />
        <xs:element name="MailSender" type="MailSenderType" minOccurs="0" />
        <xs:element name="MessageStoreSender" type="MessageStoreSenderType" minOccurs="0" />
        <xs:element name="MqttSender" type="MqttSenderType" minOccurs="0" />
        <xs:element name="ParallelSendersSender" type="ParallelSendersSenderType" minOccurs="0" />
        <xs:element name="ReloadSender" type="ReloadSenderType" minOccurs="0" />
        <xs:element name="RestSender" type="RestSenderType" minOccurs="0" />
        <xs:element name="ResultSet2FileSender" type="ResultSet2FileSenderType" minOccurs="0" />
        <xs:element name="SambaSender" type="SambaSenderType" minOccurs="0" />
        <xs:element name="SchedulerSender" type="SchedulerSenderType" minOccurs="0" />
        <xs:element name="SenderSeriesSender" type="SenderSeriesSenderType" minOccurs="0" />
        <xs:element name="SenderWrapperSender" type="SenderWrapperSenderType" minOccurs="0" />
        <xs:element name="ShadowSender" type="ShadowSenderType" minOccurs="0" />
        <xs:element name="TimeoutGuardSenderWithParametersBaseSender" type="TimeoutGuardSenderWithParametersBaseSenderType" minOccurs="0" />
        <xs:element name="WebServiceNtlmSender" type="WebServiceNtlmSenderType" minOccurs="0" />
        <xs:element name="WebServiceSender" type="WebServiceSenderType" minOccurs="0" />
        <xs:element name="XComSender" type="XComSenderType" minOccurs="0" />
        <xs:element name="XfbSender" type="XfbSenderType" minOccurs="0" />
        <xs:element name="XmlJmsBrowserSender" type="XmlJmsBrowserSenderType" minOccurs="0" />
        <xs:element name="XmlQuerySender" type="XmlQuerySenderType" minOccurs="0" />
        <xs:element name="XmlValidatorSender" type="XmlValidatorSenderType" minOccurs="0" />
        <xs:element name="XsltSender" type="XsltSenderType" minOccurs="0" />
        <xs:element name="ZipWriterSender" type="ZipWriterSenderType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConcurrentThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets and upper limit to the amount of concurrent threads that can be run simultaneously. use 0 to disable. (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ParamType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="decimalSeparator" type="xs:string">
      <xs:annotation>
        <xs:documentation>used in combination with type &lt;code&gt;number&lt;/code&gt; (default: system default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="defaultValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>if the result of sessionkey, xpathexpressen and/or stylesheet returns null or an empty string, this value is returned (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="defaultValueMethods" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of methods (defaultvalue, sessionkey, pattern, value or input) to use as default value. used in the order they appear until a non-null value is found. (default: defaultvalue)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="formatString" type="xs:string">
      <xs:annotation>
        <xs:documentation>used in combination with types &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;datetime&lt;/code&gt; (default: depends on type)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="groupingSeparator" type="xs:string">
      <xs:annotation>
        <xs:documentation>used in combination with type &lt;code&gt;number&lt;/code&gt; (default: system default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hidden" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set to &lt;code&gt;true&lt;/code&gt;, the value of the parameter will not be shown in the log (replaced by asterisks) (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxInclusive" type="xs:string">
      <xs:annotation>
        <xs:documentation>used in combination with type &lt;code&gt;number&lt;/code&gt;; if set and the value of the parameter exceeds this maximum value, this maximum value is taken (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the value of the parameter exceeds this maximum length, the length is trimmed to this maximum length (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="minInclusive" type="xs:string">
      <xs:annotation>
        <xs:documentation>used in combination with type &lt;code&gt;number&lt;/code&gt;; if set and the value of the parameter exceeds this minimum value, this minimum value is taken (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="minLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the value of the parameter deceeds this minimum length, the value is padded (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the parameter (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of parameter is determined using substitution and formating. the expression can contain references to session-variables or other parameters using {name-of-parameter} and is formatted using java.text.messageformat. {now}, {uid}, {uuid}, {hostname} and {fixeddate} are named constants that can be used in the expression. if fname is a parameter or session variable that resolves to eric, then the pattern 'hi {fname}, hoe gaat het?' resolves to 'hi eric, hoe gaat het?'. a guid can be generated using {hostname}_{uid}, see also &lt;a href="http://java.sun.com/j2se/1.4.2/docs/api/java/rmi/server/uid.html"&gt;http://java.sun.com/j2se/1.4.2/docs/api/java/rmi/server/uid.html&lt;/a&gt; for more information about (g)uid's or &lt;a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/uuid.html"&gt;http://docs.oracle.com/javase/1.5.0/docs/api/java/util/uuid.html&lt;/a&gt; for more information about uuid's. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed before the stylesheet/xpathexpression is executed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. is specified, the value of the pipelinesession variable is used as input for the xpathexpression or stylesheet, instead of the current input message. if no xpathexpression or stylesheet are specified, the value itself is returned. if the value '*' is specified, all existing sessionkeys are added as parameter of which the name starts with the name of this parameter. if also the name of the parameter has the value '*' then all existing sessionkeys are added as parameter (except tsreceived) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKeyXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>instead of a fixed &lt;code&gt;sessionkey&lt;/code&gt; it's also possible to use a xpath expression to extract the name of the &lt;code&gt;sessionkey&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string" />
    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation>a fixed value (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>the xpath expression to extract the parameter value from the (xml formatted) input or session-variable. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:string">
      <xs:annotation>
        <xs:documentation>(applicable for xpathexpression and stylesheetname) when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="PasswordGeneratorPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lCharacters" type="xs:string">
      <xs:annotation>
        <xs:documentation>the lowercase characters to use (default: ('a'..'z'))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numOfDigits" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of digits in the generated password (default: 2)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numOfLCharacters" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of lowercase characters in the generated password (default: 2)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numOfSigns" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of sign characters in the generated password (default: 2)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numOfUCharacters" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of uppercase characters in the generated password (default: 2)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numbers" type="xs:string">
      <xs:annotation>
        <xs:documentation>the numbers to use (default: ('0'..'9'))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="signs" type="xs:string">
      <xs:annotation>
        <xs:documentation>the signs to use (default: (;:_%$#@!&amp;gt;&amp;lt;))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="uCharacters" type="xs:string">
      <xs:annotation>
        <xs:documentation>the uppercase characters to use (default: ('a'..'z'))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useSecureRandom" type="xs:string">
      <xs:annotation>
        <xs:documentation>whether the securerandom algorithm is to be used (slower) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="PasswordHashPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hashSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of sessionkey that holds the hash which will be used to validate the password (input of the pipe) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rounds" type="xs:string" />
    <xs:attribute name="roundsSessionKey" type="xs:string" />
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="PipelineType">
    <xs:sequence>
      <xs:element name="Cache" type="CacheType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlInputValidator" type="ApiWsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapInputValidator" type="EsbSoapInputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlInputValidator" type="FxfXmlInputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlInputValidator" type="Json2XmlInputValidatorType" minOccurs="0" />
        <xs:element name="SoapInputValidator" type="SoapInputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlInputValidator" type="WsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="XmlInputValidator" type="XmlInputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapInputWrapper" type="ApiSoapInputWrapperType" minOccurs="0" />
        <xs:element name="BisInputWrapper" type="BisInputWrapperType" minOccurs="0" />
        <xs:element name="DirectInputWrapper" type="DirectInputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapInputWrapper" type="EsbSoapInputWrapperType" minOccurs="0" />
        <xs:element name="FxfInputWrapper" type="FxfInputWrapperType" minOccurs="0" />
        <xs:element name="SoapInputWrapper" type="SoapInputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Adios2XmlPipe" type="Adios2XmlPipeType" minOccurs="0" />
        <xs:element name="ApiPrincipalPipe" type="ApiPrincipalPipeType" minOccurs="0" />
        <xs:element name="ApiSoapWrapperPipe" type="ApiSoapWrapperPipeType" minOccurs="0" />
        <xs:element name="ApiStreamPipe" type="ApiStreamPipeType" minOccurs="0" />
        <xs:element name="ApiWsdlXmlValidatorPipe" type="ApiWsdlXmlValidatorPipeType" minOccurs="0" />
        <xs:element name="Base64Pipe" type="Base64PipeType" minOccurs="0" />
        <xs:element name="BatchBlobTransformerPipe" type="BatchBlobTransformerPipeType" minOccurs="0" />
        <xs:element name="BatchClobTransformerPipe" type="BatchClobTransformerPipeType" minOccurs="0" />
        <xs:element name="BatchFileTransformerPipe" type="BatchFileTransformerPipeType" minOccurs="0" />
        <xs:element name="BisWrapperPipe" type="BisWrapperPipeType" minOccurs="0" />
        <xs:element name="BlobLineIteratingPipe" type="BlobLineIteratingPipeType" minOccurs="0" />
        <xs:element name="BytesOutputPipe" type="BytesOutputPipeType" minOccurs="0" />
        <xs:element name="ChecksumPipe" type="ChecksumPipeType" minOccurs="0" />
        <xs:element name="CleanupOldFilesPipe" type="CleanupOldFilesPipeType" minOccurs="0" />
        <xs:element name="ClobLineIteratingPipe" type="ClobLineIteratingPipeType" minOccurs="0" />
        <xs:element name="CompareIntegerPipe" type="CompareIntegerPipeType" minOccurs="0" />
        <xs:element name="CompareStringPipe" type="CompareStringPipeType" minOccurs="0" />
        <xs:element name="CompressPipe" type="CompressPipeType" minOccurs="0" />
        <xs:element name="CounterSwitchPipe" type="CounterSwitchPipeType" minOccurs="0" />
        <xs:element name="CreateRestViewPipe" type="CreateRestViewPipeType" minOccurs="0" />
        <xs:element name="CredentialCheckingPipe" type="CredentialCheckingPipeType" minOccurs="0" />
        <xs:element name="CrlPipe" type="CrlPipeType" minOccurs="0" />
        <xs:element name="DelayPipe" type="DelayPipeType" minOccurs="0" />
        <xs:element name="DigesterPipe" type="DigesterPipeType" minOccurs="0" />
        <xs:element name="DirectWrapperPipe" type="DirectWrapperPipeType" minOccurs="0" />
        <xs:element name="DomainTransformerPipe" type="DomainTransformerPipeType" minOccurs="0" />
        <xs:element name="EchoPipe" type="EchoPipeType" minOccurs="0" />
        <xs:element name="EsbSoapValidatorPipe" type="EsbSoapValidatorPipeType" minOccurs="0" />
        <xs:element name="EsbSoapWrapperPipe" type="EsbSoapWrapperPipeType" minOccurs="0" />
        <xs:element name="EscapePipe" type="EscapePipeType" minOccurs="0" />
        <xs:element name="EtagHandlerPipe" type="EtagHandlerPipeType" minOccurs="0" />
        <xs:element name="ExceptionPipe" type="ExceptionPipeType" minOccurs="0" />
        <xs:element name="ExecuteJdbcPropertiesPipe" type="ExecuteJdbcPropertiesPipeType" minOccurs="0" />
        <xs:element name="ExecutePipe" type="ExecutePipeType" minOccurs="0" />
        <xs:element name="FileLineIteratorPipe" type="FileLineIteratorPipeType" minOccurs="0" />
        <xs:element name="FilePipe" type="FilePipeType" minOccurs="0" />
        <xs:element name="FilenameSwitchPipe" type="FilenameSwitchPipeType" minOccurs="0" />
        <xs:element name="FixedForwardPipe" type="FixedForwardPipeType" minOccurs="0" />
        <xs:element name="FixedResultPipe" type="FixedResultPipeType" minOccurs="0" />
        <xs:element name="ForEachChildElementPipe" type="ForEachChildElementPipeType" minOccurs="0" />
        <xs:element name="FtpFileRetrieverPipe" type="FtpFileRetrieverPipeType" minOccurs="0" />
        <xs:element name="FxfWrapperPipe" type="FxfWrapperPipeType" minOccurs="0" />
        <xs:element name="FxfXmlValidatorPipe" type="FxfXmlValidatorPipeType" minOccurs="0" />
        <xs:element name="GetFromSessionPipe" type="GetFromSessionPipeType" minOccurs="0" />
        <xs:element name="GetPrincipalPipe" type="GetPrincipalPipeType" minOccurs="0" />
        <xs:element name="HashPipe" type="HashPipeType" minOccurs="0" />
        <xs:element name="IbisDocPipe" type="IbisDocPipeType" minOccurs="0" />
        <xs:element name="IfMultipartPipe" type="IfMultipartPipeType" minOccurs="0" />
        <xs:element name="IncreaseIntegerPipe" type="IncreaseIntegerPipeType" minOccurs="0" />
        <xs:element name="IsUserInRolePipe" type="IsUserInRolePipeType" minOccurs="0" />
        <xs:element name="IsXmlIfPipe" type="IsXmlIfPipeType" minOccurs="0" />
        <xs:element name="JmsCommunicatorPipe" type="JmsCommunicatorPipeType" minOccurs="0" />
        <xs:element name="Json2XmlValidatorPipe" type="Json2XmlValidatorPipeType" minOccurs="0" />
        <xs:element name="JsonPipe" type="JsonPipeType" minOccurs="0" />
        <xs:element name="JsonWellFormedCheckerPipe" type="JsonWellFormedCheckerPipeType" minOccurs="0" />
        <xs:element name="JsonXsltPipe" type="JsonXsltPipeType" minOccurs="0" />
        <xs:element name="LabelFormatPipe" type="LabelFormatPipeType" minOccurs="0" />
        <xs:element name="LarvaPipe" type="LarvaPipeType" minOccurs="0" />
        <xs:element name="LdapChallengePipe" type="LdapChallengePipeType" minOccurs="0" />
        <xs:element name="LdapFindMemberPipe" type="LdapFindMemberPipeType" minOccurs="0" />
        <xs:element name="MailSenderPipe" type="MailSenderPipeType" minOccurs="0" />
        <xs:element name="MoveFilePipe" type="MoveFilePipeType" minOccurs="0" />
        <xs:element name="PasswordGeneratorPipe" type="PasswordGeneratorPipeType" minOccurs="0" />
        <xs:element name="PasswordHashPipe" type="PasswordHashPipeType" minOccurs="0" />
        <xs:element name="PostboxRetrieverPipe" type="PostboxRetrieverPipeType" minOccurs="0" />
        <xs:element name="PostboxSenderPipe" type="PostboxSenderPipeType" minOccurs="0" />
        <xs:element name="PutInSessionPipe" type="PutInSessionPipeType" minOccurs="0" />
        <xs:element name="PutParametersInSessionPipe" type="PutParametersInSessionPipeType" minOccurs="0" />
        <xs:element name="PutSystemDateInSessionPipe" type="PutSystemDateInSessionPipeType" minOccurs="0" />
        <xs:element name="RekenBoxCallerPipe" type="RekenBoxCallerPipeType" minOccurs="0" />
        <xs:element name="RemoveCacheKeyPipe" type="RemoveCacheKeyPipeType" minOccurs="0" />
        <xs:element name="RemoveFromSessionPipe" type="RemoveFromSessionPipeType" minOccurs="0" />
        <xs:element name="ReplacerPipe" type="ReplacerPipeType" minOccurs="0" />
        <xs:element name="ResultSetIteratingPipe" type="ResultSetIteratingPipeType" minOccurs="0" />
        <xs:element name="RhinoPipe" type="RhinoPipeType" minOccurs="0" />
        <xs:element name="ScanTibcoSolutionPipe" type="ScanTibcoSolutionPipeType" minOccurs="0" />
        <xs:element name="SenderPipe" type="SenderPipeType" minOccurs="0" />
        <xs:element name="ShowConfigPipe" type="ShowConfigPipeType" minOccurs="0" />
        <xs:element name="ShowConfigurationPipe" type="ShowConfigurationPipeType" minOccurs="0" />
        <xs:element name="ShowConfigurationStatusPipe" type="ShowConfigurationStatusPipeType" minOccurs="0" />
        <xs:element name="ShowEnvironmentVariablesPipe" type="ShowEnvironmentVariablesPipeType" minOccurs="0" />
        <xs:element name="ShowFlowDiagramPipe" type="ShowFlowDiagramPipeType" minOccurs="0" />
        <xs:element name="SizePipe" type="SizePipeType" minOccurs="0" />
        <xs:element name="SkipPipe" type="SkipPipeType" minOccurs="0" />
        <xs:element name="SoapValidatorPipe" type="SoapValidatorPipeType" minOccurs="0" />
        <xs:element name="SoapWrapperPipe" type="SoapWrapperPipeType" minOccurs="0" />
        <xs:element name="Stream2StringPipe" type="Stream2StringPipeType" minOccurs="0" />
        <xs:element name="StreamLineIteratorPipe" type="StreamLineIteratorPipeType" minOccurs="0" />
        <xs:element name="StreamPipe" type="StreamPipeType" minOccurs="0" />
        <xs:element name="StreamTransformerPipe" type="StreamTransformerPipeType" minOccurs="0" />
        <xs:element name="TestPipeLinePipe" type="TestPipeLinePipeType" minOccurs="0" />
        <xs:element name="Text2XmlPipe" type="Text2XmlPipeType" minOccurs="0" />
        <xs:element name="TimeoutGuardPipe" type="TimeoutGuardPipeType" minOccurs="0" />
        <xs:element name="UUIDGeneratorPipe" type="UUIDGeneratorPipeType" minOccurs="0" />
        <xs:element name="UnzipPipe" type="UnzipPipeType" minOccurs="0" />
        <xs:element name="UploadConfigPipe" type="UploadConfigPipeType" minOccurs="0" />
        <xs:element name="UploadFilePipe" type="UploadFilePipeType" minOccurs="0" />
        <xs:element name="WebservicesPipe" type="WebservicesPipeType" minOccurs="0" />
        <xs:element name="WsdlGeneratorPipe" type="WsdlGeneratorPipeType" minOccurs="0" />
        <xs:element name="WsdlXmlValidatorPipe" type="WsdlXmlValidatorPipeType" minOccurs="0" />
        <xs:element name="XPathPipe" type="XPathPipeType" minOccurs="0" />
        <xs:element name="XQueryPipe" type="XQueryPipeType" minOccurs="0" />
        <xs:element name="XmlBuilderPipe" type="XmlBuilderPipeType" minOccurs="0" />
        <xs:element name="XmlFileElementIteratorPipe" type="XmlFileElementIteratorPipeType" minOccurs="0" />
        <xs:element name="XmlIfPipe" type="XmlIfPipeType" minOccurs="0" />
        <xs:element name="XmlParamSwitchPipe" type="XmlParamSwitchPipeType" minOccurs="0" />
        <xs:element name="XmlSwitchPipe" type="XmlSwitchPipeType" minOccurs="0" />
        <xs:element name="XmlValidatorPipe" type="XmlValidatorPipeType" minOccurs="0" />
        <xs:element name="XmlWellFormedCheckerPipe" type="XmlWellFormedCheckerPipeType" minOccurs="0" />
        <xs:element name="XsltParamPipe" type="XsltParamPipeType" minOccurs="0" />
        <xs:element name="XsltPipe" type="XsltPipeType" minOccurs="0" />
        <xs:element name="ZipIteratorPipe" type="ZipIteratorPipeType" minOccurs="0" />
        <xs:element name="ZipWriterPipe" type="ZipWriterPipeType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Exit" type="ExitType" minOccurs="0" maxOccurs="unbounded" />
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapOutputWrapper" type="ApiSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="BisOutputWrapper" type="BisOutputWrapperType" minOccurs="0" />
        <xs:element name="DirectOutputWrapper" type="DirectOutputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapOutputWrapper" type="EsbSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="FxfOutputWrapper" type="FxfOutputWrapperType" minOccurs="0" />
        <xs:element name="SoapOutputWrapper" type="SoapOutputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlOutputValidator" type="ApiWsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapOutputValidator" type="EsbSoapOutputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlOutputValidator" type="FxfXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlOutputValidator" type="Json2XmlOutputValidatorType" minOccurs="0" />
        <xs:element name="SoapOutputValidator" type="SoapOutputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlOutputValidator" type="WsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="XmlOutputValidator" type="XmlOutputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="adapterToRunBeforeOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when specified and an empty message is received the specified adapter is run before passing the message (response from specified adapter) to the pipeline (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commitOnState" type="xs:string">
      <xs:annotation>
        <xs:documentation>if the pipelineresult.getstate() equals this value, the transaction is committed, otherwise it is rolled back. (default: &lt;code&gt;success&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="firstPipe" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the first pipe to execute when a message is to be processed (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forceFixedForwarding" type="xs:string">
      <xs:annotation>
        <xs:documentation>forces that each pipe in the pipeline is not automatically added to the globalforwards table (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeOriginalMessageWithoutNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; the original message without namespaces (and prefixes) is stored under the session key originalmessagewithoutnamespaces (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set to &lt;code&gt;true, messages will be processed under transaction control. (see below)&lt;/code&gt; (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transformNullMessage" type="xs:string">
      <xs:annotation>
        <xs:documentation>when specified and &lt;code&gt;null&lt;/code&gt; is received as a message the message is changed to the specified value (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="PostboxRetrieverPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:choice minOccurs="0">
        <xs:element name="ApiListener" type="ApiListenerType" minOccurs="0" />
        <xs:element name="BisJmsListener" type="BisJmsListenerType" minOccurs="0" />
        <xs:element name="DirectoryListener" type="DirectoryListenerType" minOccurs="0" />
        <xs:element name="EsbJmsListener" type="EsbJmsListenerType" minOccurs="0" />
        <xs:element name="ExchangeMailListener" type="ExchangeMailListenerType" minOccurs="0" />
        <xs:element name="FileRecordListener" type="FileRecordListenerType" minOccurs="0" />
        <xs:element name="FtpListener" type="FtpListenerType" minOccurs="0" />
        <xs:element name="FxfListener" type="FxfListenerType" minOccurs="0" />
        <xs:element name="HttpListener" type="HttpListenerType" minOccurs="0" />
        <xs:element name="JavaListener" type="JavaListenerType" minOccurs="0" />
        <xs:element name="JdbcListener" type="JdbcListenerType" minOccurs="0" />
        <xs:element name="JdbcQueryListener" type="JdbcQueryListenerType" minOccurs="0" />
        <xs:element name="JdbcTableListener" type="JdbcTableListenerType" minOccurs="0" />
        <xs:element name="JmsListener" type="JmsListenerType" minOccurs="0" />
        <xs:element name="MessageStoreListener" type="MessageStoreListenerType" minOccurs="0" />
        <xs:element name="MqttListener" type="MqttListenerType" minOccurs="0" />
        <xs:element name="PullingJmsListener" type="PullingJmsListenerType" minOccurs="0" />
        <xs:element name="PushingJmsListener" type="PushingJmsListenerType" minOccurs="0" />
        <xs:element name="PushingListenerAdapterListener" type="PushingListenerAdapterListenerType" minOccurs="0" />
        <xs:element name="RestListener" type="RestListenerType" minOccurs="0" />
        <xs:element name="SimpleJdbcListener" type="SimpleJdbcListenerType" minOccurs="0" />
        <xs:element name="WebServiceListener" type="WebServiceListenerType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultOnEmptyPostbox" type="xs:string">
      <xs:annotation>
        <xs:documentation>result when no object is on postbox (default: empty postbox)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="PostboxSenderPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapInputWrapper" type="ApiSoapInputWrapperType" minOccurs="0" />
        <xs:element name="BisInputWrapper" type="BisInputWrapperType" minOccurs="0" />
        <xs:element name="DirectInputWrapper" type="DirectInputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapInputWrapper" type="EsbSoapInputWrapperType" minOccurs="0" />
        <xs:element name="FxfInputWrapper" type="FxfInputWrapperType" minOccurs="0" />
        <xs:element name="SoapInputWrapper" type="SoapInputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlInputValidator" type="ApiWsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapInputValidator" type="EsbSoapInputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlInputValidator" type="FxfXmlInputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlInputValidator" type="Json2XmlInputValidatorType" minOccurs="0" />
        <xs:element name="SoapInputValidator" type="SoapInputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlInputValidator" type="WsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="XmlInputValidator" type="XmlInputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="Afm2EdiFactSender" type="Afm2EdiFactSenderType" minOccurs="0" />
        <xs:element name="BisJmsSender" type="BisJmsSenderType" minOccurs="0" />
        <xs:element name="CommandSender" type="CommandSenderType" minOccurs="0" />
        <xs:element name="DelaySender" type="DelaySenderType" minOccurs="0" />
        <xs:element name="DirectQuerySender" type="DirectQuerySenderType" minOccurs="0" />
        <xs:element name="EchoSender" type="EchoSenderType" minOccurs="0" />
        <xs:element name="EsbJmsSender" type="EsbJmsSenderType" minOccurs="0" />
        <xs:element name="FileSender" type="FileSenderType" minOccurs="0" />
        <xs:element name="FixedQuerySender" type="FixedQuerySenderType" minOccurs="0" />
        <xs:element name="FixedResultSender" type="FixedResultSenderType" minOccurs="0" />
        <xs:element name="FtpSender" type="FtpSenderType" minOccurs="0" />
        <xs:element name="HttpSender" type="HttpSenderType" minOccurs="0" />
        <xs:element name="IbisJavaSender" type="IbisJavaSenderType" minOccurs="0" />
        <xs:element name="IbisLocalSender" type="IbisLocalSenderType" minOccurs="0" />
        <xs:element name="IbisWebServiceSender" type="IbisWebServiceSenderType" minOccurs="0" />
        <xs:element name="JmsSender" type="JmsSenderType" minOccurs="0" />
        <xs:element name="LdapSender" type="LdapSenderType" minOccurs="0" />
        <xs:element name="LogSender" type="LogSenderType" minOccurs="0" />
        <xs:element name="MailSender" type="MailSenderType" minOccurs="0" />
        <xs:element name="MessageStoreSender" type="MessageStoreSenderType" minOccurs="0" />
        <xs:element name="MqttSender" type="MqttSenderType" minOccurs="0" />
        <xs:element name="ParallelSendersSender" type="ParallelSendersSenderType" minOccurs="0" />
        <xs:element name="ReloadSender" type="ReloadSenderType" minOccurs="0" />
        <xs:element name="RestSender" type="RestSenderType" minOccurs="0" />
        <xs:element name="ResultSet2FileSender" type="ResultSet2FileSenderType" minOccurs="0" />
        <xs:element name="SambaSender" type="SambaSenderType" minOccurs="0" />
        <xs:element name="SchedulerSender" type="SchedulerSenderType" minOccurs="0" />
        <xs:element name="SenderSeriesSender" type="SenderSeriesSenderType" minOccurs="0" />
        <xs:element name="SenderWrapperSender" type="SenderWrapperSenderType" minOccurs="0" />
        <xs:element name="ShadowSender" type="ShadowSenderType" minOccurs="0" />
        <xs:element name="TimeoutGuardSenderWithParametersBaseSender" type="TimeoutGuardSenderWithParametersBaseSenderType" minOccurs="0" />
        <xs:element name="WebServiceNtlmSender" type="WebServiceNtlmSenderType" minOccurs="0" />
        <xs:element name="WebServiceSender" type="WebServiceSenderType" minOccurs="0" />
        <xs:element name="XComSender" type="XComSenderType" minOccurs="0" />
        <xs:element name="XfbSender" type="XfbSenderType" minOccurs="0" />
        <xs:element name="XmlJmsBrowserSender" type="XmlJmsBrowserSenderType" minOccurs="0" />
        <xs:element name="XmlQuerySender" type="XmlQuerySenderType" minOccurs="0" />
        <xs:element name="XmlValidatorSender" type="XmlValidatorSenderType" minOccurs="0" />
        <xs:element name="XsltSender" type="XsltSenderType" minOccurs="0" />
        <xs:element name="ZipWriterSender" type="ZipWriterSenderType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiListener" type="ApiListenerType" minOccurs="0" />
        <xs:element name="BisJmsListener" type="BisJmsListenerType" minOccurs="0" />
        <xs:element name="DirectoryListener" type="DirectoryListenerType" minOccurs="0" />
        <xs:element name="EsbJmsListener" type="EsbJmsListenerType" minOccurs="0" />
        <xs:element name="ExchangeMailListener" type="ExchangeMailListenerType" minOccurs="0" />
        <xs:element name="FileRecordListener" type="FileRecordListenerType" minOccurs="0" />
        <xs:element name="FtpListener" type="FtpListenerType" minOccurs="0" />
        <xs:element name="FxfListener" type="FxfListenerType" minOccurs="0" />
        <xs:element name="HttpListener" type="HttpListenerType" minOccurs="0" />
        <xs:element name="JavaListener" type="JavaListenerType" minOccurs="0" />
        <xs:element name="JdbcListener" type="JdbcListenerType" minOccurs="0" />
        <xs:element name="JdbcQueryListener" type="JdbcQueryListenerType" minOccurs="0" />
        <xs:element name="JdbcTableListener" type="JdbcTableListenerType" minOccurs="0" />
        <xs:element name="JmsListener" type="JmsListenerType" minOccurs="0" />
        <xs:element name="MessageStoreListener" type="MessageStoreListenerType" minOccurs="0" />
        <xs:element name="MqttListener" type="MqttListenerType" minOccurs="0" />
        <xs:element name="PullingJmsListener" type="PullingJmsListenerType" minOccurs="0" />
        <xs:element name="PushingJmsListener" type="PushingJmsListenerType" minOccurs="0" />
        <xs:element name="PushingListenerAdapterListener" type="PushingListenerAdapterListenerType" minOccurs="0" />
        <xs:element name="RestListener" type="RestListenerType" minOccurs="0" />
        <xs:element name="SimpleJdbcListener" type="SimpleJdbcListenerType" minOccurs="0" />
        <xs:element name="WebServiceListener" type="WebServiceListenerType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="DummyMessageLog" type="DummyMessageLogType" minOccurs="0" />
        <xs:element name="EsbJmsMessageLog" type="EsbJmsMessageLogType" minOccurs="0" />
        <xs:element name="JdbcMessageLog" type="JdbcMessageLogType" minOccurs="0" />
        <xs:element name="JmsMessageLog" type="JmsMessageLogType" minOccurs="0" />
        <xs:element name="OracleMessageLog" type="OracleMessageLogType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlOutputValidator" type="ApiWsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapOutputValidator" type="EsbSoapOutputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlOutputValidator" type="FxfXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlOutputValidator" type="Json2XmlOutputValidatorType" minOccurs="0" />
        <xs:element name="SoapOutputValidator" type="SoapOutputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlOutputValidator" type="WsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="XmlOutputValidator" type="XmlOutputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapOutputWrapper" type="ApiSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="BisOutputWrapper" type="BisOutputWrapperType" minOccurs="0" />
        <xs:element name="DirectOutputWrapper" type="DirectOutputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapOutputWrapper" type="EsbSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="FxfOutputWrapper" type="FxfOutputWrapperType" minOccurs="0" />
        <xs:element name="SoapOutputWrapper" type="SoapOutputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for audittrailxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. if specified, the value of the pipelinesession variable is used as audit trail (instead of the default 'no audit trail) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract audit trail from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkRootTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, besides the xml well-formedness the root element of the result is checked to be equal to the value set (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkXmlWellFormed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the xml well-formedness of the result is checked (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for correlationidxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. is specified, the value of the pipelinesession variable is used as input for the xpathexpression or stylesheet, instead of the current input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exceptionOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a piperunexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when hideregex is not empty and only applies to error/logstore) either &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;firsthalf&lt;/code&gt;. when &lt;code&gt;firsthalf&lt;/code&gt; only the first half of the string is masked, otherwise (&lt;code&gt;all&lt;/code&gt;) the entire string is masked (default: all)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>next to common usage in {@link abstractpipe}, also strings in the error/logstore are masked (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for labelxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>indicates wether the server uses the correlationid or the messageid in the correlationid field of the reply. this requirers the sender to have set the correlationid at the time of sending. (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of times a processing attempt is retried after a timeout or an exception is caught or after a incorrect reply is received (see also &lt;code&gt;retryxpath&lt;/code&gt;) (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="presumedTimeOutInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>when the previous call was a timeout, the maximum time (in seconds) after this timeout to presume the current call is also a timeout. a value of -1 indicates to never presume timeouts (default: 10 s)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultOnTimeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>result returned when no return-message was received within the timeout limit (e.g. 'receiver timed out'). (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMaxInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of seconds waited after an unsuccessful processing attempt before another processing attempt is made (default: 600)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMinInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the starting number of seconds waited after an unsuccessful processing attempt before another processing attempt is made. each next retry this interval is doubled with a upper limit of &lt;code&gt;retrymaxinterval&lt;/code&gt; (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for retryxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression evaluated on each technical successful reply. retry is done if condition returns true (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is first base64 decoded and then streamed to the httpservletresponse object (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stubFileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the pipe returns a message from a file, instead of doing the regular process (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOutOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a timeoutexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useInputForExtract" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is used to extract audit trail, correlationid and label (instead of the wrapped input) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="PullingJmsListenerType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="ackMode" type="xs:string" />
    <xs:attribute name="acknowledgeMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: auto_acknowledge)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to jms server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commitOnState" type="xs:string">
      <xs:annotation>
        <xs:documentation>&lt;i&gt;deprecated&lt;/i&gt; exit state to control commit or rollback of jmssession. only used if &lt;code&gt;jmstransacted&lt;/code&gt; is set true. (default: success)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdMaxLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the correlationid exceeds this maximum length, the correlationid is trimmed from the left side of a string to this maximum length (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHex" type="xs:string">
      <xs:annotation>
        <xs:documentation>transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part). useful when sending messages to mq which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: mqjms1044: string is not a valid hexadecimal number (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the jms destination (queue or topic) to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;topic&lt;/code&gt; (default: &lt;code&gt;queue&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forceMessageIdAsCorrelationId" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsTransacted" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="lookupDestination" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the destinationname is used directly instead of performing a jndi lookup (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageSelector" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the value of this attribute is used as a selector to filter messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in milliseconds) it takes for the message to expire. if the message is not consumed before, it will be lost. make sure to set it to a positive value for request/repy type of messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistent" type="xs:string">
      <xs:annotation>
        <xs:documentation>rather useless attribute, and not the same as &lt;code&gt;deliverymode&lt;/code&gt;. you probably want to use that. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the queueconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;queue&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyDeliveryMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls mode that reply messages are sent with: either 'persistent' or 'non_persistent' (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyEncodingStyleURI" type="xs:string" />
    <xs:attribute name="replyMessageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>time that replymessage will live (default: 0 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyMessageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of the jmstype field of the reply message (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyNamespaceURI" type="xs:string" />
    <xs:attribute name="replyPriority" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets the priority that is used to deliver the reply message. ranges from 0 to 9. defaults to -1, meaning not set. effectively the default priority is set by jms to 4 (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replySoapAction" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soap" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="subscriberType" type="xs:string" />
    <xs:attribute name="timeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>receiver timeout, in milliseconds (default: 3000 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the topicconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;topic&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useReplyTo" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xPathLoggingKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of all xpath keys that need to be logged. (overrides &lt;code&gt;msg.log.keys&lt;/code&gt; property) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="PushingJmsListenerType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="ackMode" type="xs:string" />
    <xs:attribute name="acknowledgeMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: auto_acknowledge)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to jms server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cacheMode" type="xs:string" />
    <xs:attribute name="commitOnState" type="xs:string">
      <xs:annotation>
        <xs:documentation>&lt;i&gt;deprecated&lt;/i&gt; exit state to control commit or rollback of jmssession. only used if &lt;code&gt;jmstransacted&lt;/code&gt; is set true. (default: success)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdMaxLength" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the length of the correlationid exceeds this maximum length, the correlationid is trimmed from the left side of a string to this maximum length (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIdToHex" type="xs:string">
      <xs:annotation>
        <xs:documentation>transform the value of the correlationid to a hexadecimal value if it starts with id: (preserving the id: part). useful when sending messages to mq which expects this value to be in hexadecimal format when it starts with id:, otherwise generating the error: mqjms1044: string is not a valid hexadecimal number (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the jms destination (queue or topic) to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destinationType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;topic&lt;/code&gt; (default: &lt;code&gt;queue&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forceMessageIdAsCorrelationId" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jmsTransacted" type="xs:string" />
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="listenerPort" type="xs:string" />
    <xs:attribute name="lookupDestination" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt;, the destinationname is used directly instead of performing a jndi lookup (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageSelector" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the value of this attribute is used as a selector to filter messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="messageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>the time (in milliseconds) it takes for the message to expire. if the message is not consumed before, it will be lost. make sure to set it to a positive value for request/repy type of messages. (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistent" type="xs:string">
      <xs:annotation>
        <xs:documentation>rather useless attribute, and not the same as &lt;code&gt;deliverymode&lt;/code&gt;. you probably want to use that. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pollGuardInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>interval in milliseconds for the poll guard to check whether a successful poll was done by the receive (https://docs.oracle.com/javaee/7/api/javax/jms/messageconsumer.html#receive-long-) since last check. when polling has stopped this will be logged and the listener will be stopped and started in an attempt to workaround problems with polling. polling might stop due to bugs in the jms driver/implementation which should be fixed by the supplier. as the poll time includes reading and processing of the message no successful poll might be registered since the last check when message processing takes a long time, hence while messages are being processed the check on last successful poll will be skipped. set to -1 to disable (default: ten times the specified timeout)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queueConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the queueconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;queue&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyDeliveryMode" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls mode that reply messages are sent with: either 'persistent' or 'non_persistent' (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyEncodingStyleURI" type="xs:string" />
    <xs:attribute name="replyMessageTimeToLive" type="xs:string">
      <xs:annotation>
        <xs:documentation>time that replymessage will live (default: 0 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyMessageType" type="xs:string">
      <xs:annotation>
        <xs:documentation>value of the jmstype field of the reply message (default: not set by application)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replyNamespaceURI" type="xs:string" />
    <xs:attribute name="replyPriority" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets the priority that is used to deliver the reply message. ranges from 0 to 9. defaults to -1, meaning not set. effectively the default priority is set by jms to 4 (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replySoapAction" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soap" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="subscriberType" type="xs:string" />
    <xs:attribute name="timeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>receiver timeout, in milliseconds (default: 3000 [ms])</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="topicConnectionFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>jndi-name of the topicconnectionfactory, used when &lt;code&gt;destinationtype&lt;code&gt;=&lt;/code&gt;topic&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useReplyTo" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xPathLoggingKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of all xpath keys that need to be logged. (overrides &lt;code&gt;msg.log.keys&lt;/code&gt; property) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="PushingListenerAdapterListenerType">
    <xs:attribute name="applicationFaultsAsExceptions" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener as known to the adapter (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="running" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="PutInSessionPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the key in the &lt;code&gt;pipelinesession&lt;/code&gt; to store the input in (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation>the value to store the in the &lt;code&gt;pipelinesession&lt;/code&gt;. if not set, the input of the pipe is stored (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="PutParametersInSessionPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="PutSystemDateInSessionPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dateFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>format to store date in (default: fullisoformat: yyyy-mm-dd't'hh:mm:sszzz)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="returnFixedDate" type="xs:string">
      <xs:annotation>
        <xs:documentation>if &lt;code&gt;true&lt;/code&gt;, the date/time returned will always be december 17, 2001, 09:30:47 (for testing purposes only). it is overridden by the value of the pipelinesession key &lt;code&gt;stub4testtool.fixeddate&lt;/code&gt; when it exists (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable to store result in (default: systemdate)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ReceiverType">
    <xs:sequence>
      <xs:choice minOccurs="0">
        <xs:element name="ApiListener" type="ApiListenerType" minOccurs="0" />
        <xs:element name="BisJmsListener" type="BisJmsListenerType" minOccurs="0" />
        <xs:element name="DirectoryListener" type="DirectoryListenerType" minOccurs="0" />
        <xs:element name="EsbJmsListener" type="EsbJmsListenerType" minOccurs="0" />
        <xs:element name="ExchangeMailListener" type="ExchangeMailListenerType" minOccurs="0" />
        <xs:element name="FileRecordListener" type="FileRecordListenerType" minOccurs="0" />
        <xs:element name="FtpListener" type="FtpListenerType" minOccurs="0" />
        <xs:element name="FxfListener" type="FxfListenerType" minOccurs="0" />
        <xs:element name="HttpListener" type="HttpListenerType" minOccurs="0" />
        <xs:element name="JavaListener" type="JavaListenerType" minOccurs="0" />
        <xs:element name="JdbcListener" type="JdbcListenerType" minOccurs="0" />
        <xs:element name="JdbcQueryListener" type="JdbcQueryListenerType" minOccurs="0" />
        <xs:element name="JdbcTableListener" type="JdbcTableListenerType" minOccurs="0" />
        <xs:element name="JmsListener" type="JmsListenerType" minOccurs="0" />
        <xs:element name="MessageStoreListener" type="MessageStoreListenerType" minOccurs="0" />
        <xs:element name="MqttListener" type="MqttListenerType" minOccurs="0" />
        <xs:element name="PullingJmsListener" type="PullingJmsListenerType" minOccurs="0" />
        <xs:element name="PushingJmsListener" type="PushingJmsListenerType" minOccurs="0" />
        <xs:element name="PushingListenerAdapterListener" type="PushingListenerAdapterListenerType" minOccurs="0" />
        <xs:element name="RestListener" type="RestListenerType" minOccurs="0" />
        <xs:element name="SimpleJdbcListener" type="SimpleJdbcListenerType" minOccurs="0" />
        <xs:element name="WebServiceListener" type="WebServiceListenerType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="Afm2EdiFactErrorSender" type="Afm2EdiFactErrorSenderType" minOccurs="0" />
        <xs:element name="BisJmsErrorSender" type="BisJmsErrorSenderType" minOccurs="0" />
        <xs:element name="CommandErrorSender" type="CommandErrorSenderType" minOccurs="0" />
        <xs:element name="DelayErrorSender" type="DelayErrorSenderType" minOccurs="0" />
        <xs:element name="DirectQueryErrorSender" type="DirectQueryErrorSenderType" minOccurs="0" />
        <xs:element name="EchoErrorSender" type="EchoErrorSenderType" minOccurs="0" />
        <xs:element name="EsbJmsErrorSender" type="EsbJmsErrorSenderType" minOccurs="0" />
        <xs:element name="FileErrorSender" type="FileErrorSenderType" minOccurs="0" />
        <xs:element name="FixedQueryErrorSender" type="FixedQueryErrorSenderType" minOccurs="0" />
        <xs:element name="FixedResultErrorSender" type="FixedResultErrorSenderType" minOccurs="0" />
        <xs:element name="FtpErrorSender" type="FtpErrorSenderType" minOccurs="0" />
        <xs:element name="HttpErrorSender" type="HttpErrorSenderType" minOccurs="0" />
        <xs:element name="IbisJavaErrorSender" type="IbisJavaErrorSenderType" minOccurs="0" />
        <xs:element name="IbisLocalErrorSender" type="IbisLocalErrorSenderType" minOccurs="0" />
        <xs:element name="IbisWebServiceErrorSender" type="IbisWebServiceErrorSenderType" minOccurs="0" />
        <xs:element name="JmsErrorSender" type="JmsErrorSenderType" minOccurs="0" />
        <xs:element name="LdapErrorSender" type="LdapErrorSenderType" minOccurs="0" />
        <xs:element name="LogErrorSender" type="LogErrorSenderType" minOccurs="0" />
        <xs:element name="MailErrorSender" type="MailErrorSenderType" minOccurs="0" />
        <xs:element name="MessageStoreErrorSender" type="MessageStoreErrorSenderType" minOccurs="0" />
        <xs:element name="MqttErrorSender" type="MqttErrorSenderType" minOccurs="0" />
        <xs:element name="ReloadErrorSender" type="ReloadErrorSenderType" minOccurs="0" />
        <xs:element name="RestErrorSender" type="RestErrorSenderType" minOccurs="0" />
        <xs:element name="ResultSet2FileErrorSender" type="ResultSet2FileErrorSenderType" minOccurs="0" />
        <xs:element name="SambaErrorSender" type="SambaErrorSenderType" minOccurs="0" />
        <xs:element name="SchedulerErrorSender" type="SchedulerErrorSenderType" minOccurs="0" />
        <xs:element name="ShadowErrorSender" type="ShadowErrorSenderType" minOccurs="0" />
        <xs:element name="WebServiceErrorSender" type="WebServiceErrorSenderType" minOccurs="0" />
        <xs:element name="WebServiceNtlmErrorSender" type="WebServiceNtlmErrorSenderType" minOccurs="0" />
        <xs:element name="XComErrorSender" type="XComErrorSenderType" minOccurs="0" />
        <xs:element name="XfbErrorSender" type="XfbErrorSenderType" minOccurs="0" />
        <xs:element name="XmlJmsBrowserErrorSender" type="XmlJmsBrowserErrorSenderType" minOccurs="0" />
        <xs:element name="XmlQueryErrorSender" type="XmlQueryErrorSenderType" minOccurs="0" />
        <xs:element name="XmlValidatorErrorSender" type="XmlValidatorErrorSenderType" minOccurs="0" />
        <xs:element name="XsltErrorSender" type="XsltErrorSenderType" minOccurs="0" />
        <xs:element name="ZipWriterErrorSender" type="ZipWriterErrorSenderType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="DummyErrorStorage" type="DummyErrorStorageType" minOccurs="0" />
        <xs:element name="EsbJmsErrorStorage" type="EsbJmsErrorStorageType" minOccurs="0" />
        <xs:element name="JdbcErrorStorage" type="JdbcErrorStorageType" minOccurs="0" />
        <xs:element name="JmsErrorStorage" type="JmsErrorStorageType" minOccurs="0" />
        <xs:element name="OracleErrorStorage" type="OracleErrorStorageType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="DummyMessageLog" type="DummyMessageLogType" minOccurs="0" />
        <xs:element name="EsbJmsMessageLog" type="EsbJmsMessageLogType" minOccurs="0" />
        <xs:element name="JdbcMessageLog" type="JdbcMessageLogType" minOccurs="0" />
        <xs:element name="JmsMessageLog" type="JmsMessageLogType" minOccurs="0" />
        <xs:element name="OracleMessageLog" type="OracleMessageLogType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="Afm2EdiFactSender" type="Afm2EdiFactSenderType" minOccurs="0" />
        <xs:element name="BisJmsSender" type="BisJmsSenderType" minOccurs="0" />
        <xs:element name="CommandSender" type="CommandSenderType" minOccurs="0" />
        <xs:element name="DelaySender" type="DelaySenderType" minOccurs="0" />
        <xs:element name="DirectQuerySender" type="DirectQuerySenderType" minOccurs="0" />
        <xs:element name="EchoSender" type="EchoSenderType" minOccurs="0" />
        <xs:element name="EsbJmsSender" type="EsbJmsSenderType" minOccurs="0" />
        <xs:element name="FileSender" type="FileSenderType" minOccurs="0" />
        <xs:element name="FixedQuerySender" type="FixedQuerySenderType" minOccurs="0" />
        <xs:element name="FixedResultSender" type="FixedResultSenderType" minOccurs="0" />
        <xs:element name="FtpSender" type="FtpSenderType" minOccurs="0" />
        <xs:element name="HttpSender" type="HttpSenderType" minOccurs="0" />
        <xs:element name="IbisJavaSender" type="IbisJavaSenderType" minOccurs="0" />
        <xs:element name="IbisLocalSender" type="IbisLocalSenderType" minOccurs="0" />
        <xs:element name="IbisWebServiceSender" type="IbisWebServiceSenderType" minOccurs="0" />
        <xs:element name="JmsSender" type="JmsSenderType" minOccurs="0" />
        <xs:element name="LdapSender" type="LdapSenderType" minOccurs="0" />
        <xs:element name="LogSender" type="LogSenderType" minOccurs="0" />
        <xs:element name="MailSender" type="MailSenderType" minOccurs="0" />
        <xs:element name="MessageStoreSender" type="MessageStoreSenderType" minOccurs="0" />
        <xs:element name="MqttSender" type="MqttSenderType" minOccurs="0" />
        <xs:element name="ParallelSendersSender" type="ParallelSendersSenderType" minOccurs="0" />
        <xs:element name="ReloadSender" type="ReloadSenderType" minOccurs="0" />
        <xs:element name="RestSender" type="RestSenderType" minOccurs="0" />
        <xs:element name="ResultSet2FileSender" type="ResultSet2FileSenderType" minOccurs="0" />
        <xs:element name="SambaSender" type="SambaSenderType" minOccurs="0" />
        <xs:element name="SchedulerSender" type="SchedulerSenderType" minOccurs="0" />
        <xs:element name="SenderSeriesSender" type="SenderSeriesSenderType" minOccurs="0" />
        <xs:element name="SenderWrapperSender" type="SenderWrapperSenderType" minOccurs="0" />
        <xs:element name="ShadowSender" type="ShadowSenderType" minOccurs="0" />
        <xs:element name="TimeoutGuardSenderWithParametersBaseSender" type="TimeoutGuardSenderWithParametersBaseSenderType" minOccurs="0" />
        <xs:element name="WebServiceNtlmSender" type="WebServiceNtlmSenderType" minOccurs="0" />
        <xs:element name="WebServiceSender" type="WebServiceSenderType" minOccurs="0" />
        <xs:element name="XComSender" type="XComSenderType" minOccurs="0" />
        <xs:element name="XfbSender" type="XfbSenderType" minOccurs="0" />
        <xs:element name="XmlJmsBrowserSender" type="XmlJmsBrowserSenderType" minOccurs="0" />
        <xs:element name="XmlQuerySender" type="XmlQuerySenderType" minOccurs="0" />
        <xs:element name="XmlValidatorSender" type="XmlValidatorSenderType" minOccurs="0" />
        <xs:element name="XsltSender" type="XsltSenderType" minOccurs="0" />
        <xs:element name="ZipWriterSender" type="ZipWriterSenderType" minOccurs="0" />
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the receiver is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkForDuplicates" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set to &lt;code&gt;true&lt;/code&gt;, each message is checked for presence in the message log. if already present, it is not processed again. (only required for non xa compatible messaging). requires messagelog!&lt;/code&gt; (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkForDuplicatesMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;checkforduplicates=true&lt;/code&gt;) either 'correlationid' or 'messageid'. indicates whether the messageid or the correlationid is used for checking presence in the message log (default: messageid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for correlationidxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. adapter;pipeline;pipe) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hiddenInputSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of keys of session variables which are available when the &lt;code&gt;pipelinesession&lt;/code&gt; is created and of which the value will not be shown in the log (replaced by asterisks) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when hideregex is not empty) either &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;firsthalf&lt;/code&gt;. when &lt;code&gt;firsthalf&lt;/code&gt; only the first half of the string is masked, otherwise (&lt;code&gt;all&lt;/code&gt;) the entire string is masked (default: all)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the error/logstore. everything character between to strings in this expression will be replaced by a '*'that fits the expression is replaced. for example, the regular expression (?&amp;lt;=&amp;lt;party&amp;gt;).*?(?=&amp;lt;/party&amp;gt;) will replace every character between keys&lt;party&gt; and &lt;/party&gt;  (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for labelxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxDeliveries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum delivery count after which to stop processing the message. when -1 the delivery count is ignored (default: 5)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of times a processing attempt is retried after an exception is caught or rollback is experienced (only applicable for transacted receivers). if maxretries &amp;lt; 0 the number of attempts is infinite (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the receiver as known to the adapter (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of threads that may execute a pipeline concurrently (only for pulling listeners) (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numThreadsPolling" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of threads that are activily polling for messages concurrently. '0' means 'limited only by &lt;code&gt;numthreads&lt;/code&gt;' (only for pulling listeners) (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onError" type="xs:string">
      <xs:annotation>
        <xs:documentation>one of 'continue' or 'close'. controls the behaviour of the receiver when it encounters an error sending a reply or receives an exception asynchronously (default: continue)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="poisonMessageIdCacheSize" type="xs:string" />
    <xs:attribute name="pollInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of seconds waited after an unsuccesful poll attempt before another poll attempt is made. (only for polling listeners, not for e.g. ifsa, jms, webservice or javalisteners) (default: 10)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="processResultCacheSize" type="xs:string" />
    <xs:attribute name="recover" type="xs:string" />
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="returnedSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of keys of session variables that should be returned to caller, for correct results as well as for erronous results. (only for listeners that support it, like javalistener) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set to &lt;code&gt;true&lt;/code&gt;, messages will be received and processed under transaction control. if processing fails, messages will be sent to the error-sender. (see below)&lt;/code&gt; (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to receive and process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used for extracting correlationid and label, otherwise xslt processor 1.0 (org.apache.xalan) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="RekenBoxCallerPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cleanup" type="xs:string" />
    <xs:attribute name="commandLineType" type="xs:string" />
    <xs:attribute name="dataFilenamePrefix" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="executableExtension" type="xs:string" />
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputOutputDirectory" type="xs:string" />
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxRequestNumber" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rekenBoxName" type="xs:string" />
    <xs:attribute name="rekenboxSessionKey" type="xs:string" />
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="runPath" type="xs:string" />
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="templateDir" type="xs:string" />
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ReloadErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="forceReload" type="xs:string">
      <xs:annotation>
        <xs:documentation>reload the configuration regardless of the version (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ReloadSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="forceReload" type="xs:string">
      <xs:annotation>
        <xs:documentation>reload the configuration regardless of the version (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="RemoveCacheKeyPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cacheName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the cache to remove (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyInputSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to use as input for transformation of request message to key by keyxpath or keystylesheet (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for keyxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>setcacheemptykeys (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract cache key from request message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyXPathOutputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>output type of xpath expression to extract cache key from request message, must be 'xml' or 'text' (default: text)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="RemoveFromSessionPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the key in the &lt;code&gt;pipelinesession&lt;/code&gt; to remove. if this key is empty the input message is interpretted as key. for multiple keys use ',' as delimiter (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ReplacerPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowUnicodeSupplementaryCharacters" type="xs:string">
      <xs:annotation>
        <xs:documentation>replacenonvalidxmlcharacters (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="find" type="xs:string">
      <xs:annotation>
        <xs:documentation>string to search for (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineSeparatorSymbol" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets the string the representation in find and replace of the line separator (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="replace" type="xs:string">
      <xs:annotation>
        <xs:documentation>string that will replace each of the strings found (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceNonXmlChar" type="xs:string">
      <xs:annotation>
        <xs:documentation>character that will replace each non valid xml character (empty string is also possible) (use &amp;amp;#x00bf; for inverted question mark) (default: empty string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="replaceNonXmlChars" type="xs:string">
      <xs:annotation>
        <xs:documentation>replacenonvalidxmlcharacters (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="RestErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="allowSelfSignedCertificates" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, self signed certificates are accepted (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authDomain" type="xs:string" />
    <xs:attribute name="base64" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the result is base64 encoded (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificate" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource url to certificate to be used for authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain certificate password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificatePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charSet" type="xs:string" />
    <xs:attribute name="contentType" type="xs:string">
      <xs:annotation>
        <xs:documentation>content-type of the request, only for post and put methods (default: text/html; charset=utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodeMessages" type="xs:string">
      <xs:annotation>
        <xs:documentation>specifies whether messages will encoded, e.g. spaces will be replaced by '+' etc. (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="followRedirects" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, a redirect request will be honoured, e.g. to switch to https (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="headersParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of parameter names which should be set as http headers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCertificateExpiredException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the certificateexpiredexception is ignored (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreRedirects" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, besides http status code 200 (ok) also the code 301 (moved_permanently), 302 (moved_temporarily) and 307 (temporary_redirect) are considered successful (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputMessageParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;) name of the request parameter which is used to put the input message in (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: pkcs12)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConnections" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of concurrent connections (default: 10)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxExecuteRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of times it the execution is retried (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="methodType" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of method to be executed, either 'GET', 'POST', 'PUT', 'DELETE', 'HEAD' or 'REPORT' (default: GET)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mtomContentTransferEncoding" type="xs:string" />
    <xs:attribute name="mtomEnabled" type="xs:string" />
    <xs:attribute name="multipart" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true and &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;, request parameters are put in a multipart/form-data entity instead of in the request body (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartResponse" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true the response body is expected to be in mime multipart which is the case when a soap message with attachments is received (see also &lt;a href="https://docs.oracle.com/javaee/7/api/javax/xml/soap/soapmessage.html"&gt;https://docs.oracle.com/javaee/7/api/javax/xml/soap/soapmessage.html&lt;/a&gt;). the first part will be returned as result of this sender. other parts are returned as streams in sessionkeys with names multipart1, multipart2, etc. the http connection is held open until the last stream is read. (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartXmlSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set and &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;, a multipart/form-data entity is created instead of a request body. for each part element in the session key a part in the multipart entity is created (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="paramsInUrl" type="xs:string">
      <xs:annotation>
        <xs:documentation>when false and &lt;code&gt;methodetype=post&lt;/code&gt;, request parameters are put in the request body instead of in the url (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="protocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>secure socket protocol (such as 'ssl' and 'tls') to use when a sslcontext object is generated. if empty the protocol 'ssl' is used (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to proxy (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: 80)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyRealm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultStatusCodeSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the status code of the http response is put in specified in the sessionkey and the (error or okay) response message is returned (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether connections checked to be stale, i.e. appear open, but are not. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleTimeout" type="xs:string" />
    <xs:attribute name="storeResultAsByteArrayInSessionKey" type="xs:string" />
    <xs:attribute name="storeResultAsStreamInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, a pointer to an input stream of the result is put in the specified sessionkey (as the sender interface only allows a sender to return a string a sessionkey is used instead to return the stream) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToFileNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to a file (instead of passed as a string) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to the httpservletresponse object of the restservicedispatcher (instead of passed as a string) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>&gt;(only used when &lt;code&gt;xhtml=true&lt;/code&gt;) stylesheet to apply to the html response (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a senderexception (or timeoutexception) is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in ms of obtaining a connection/result. 0 means no timeout (default: 10000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource url to truststore to be used for authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain truststore password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: jks)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>url or base of url to be used  (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>parameter that is used to obtain url; overrides url-attribute. (default: url)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="userName" type="xs:string">
      <xs:annotation>
        <xs:documentation>username used in authentication to host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the hostname in the certificate will be checked against the actual hostname (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xhtml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the html response is transformed to xhtml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the xml tag to encapsulate the result in (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="RestListenerType">
    <xs:attribute name="applicationFaultsAsExceptions" type="xs:string" />
    <xs:attribute name="authRoles" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of authorization roles which are granted for this rest service (default: ibisadmin,ibisdataadmin,ibistester,ibisobserver,ibiswebservice)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="consumes" type="xs:string">
      <xs:annotation>
        <xs:documentation>mediatype (e.g. xml, json, text) the {@link nl.nn.adapterframework.http.restservicedispatcher restservicedispatcher} receives as input (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="contentTypeSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>setproduces (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="etagSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable to store etag (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="generateEtag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to true the ibis will automatically create an etag (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="method" type="xs:string">
      <xs:annotation>
        <xs:documentation>method (e.g. get or post) to match (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener as known to the adapter (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produces" type="xs:string">
      <xs:annotation>
        <xs:documentation>mediatype (e.g. xml, json, text) the {@link nl.nn.adapterframework.http.restservicedispatcher restservicedispatcher} sends as output, if set to json the ibis will automatically try to convert the xml message (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restPath" type="xs:string" />
    <xs:attribute name="retrieveMultipart" type="xs:string">
      <xs:annotation>
        <xs:documentation>indicates whether the parts of a multipart entity should be retrieved and put in session keys. this can only be done once! (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="running" type="xs:string" />
    <xs:attribute name="uriPattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>uri pattern to match.  (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateEtag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to true the ibis will automatically validate and process etags (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeSecLogMessage" type="xs:string" />
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="RestSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="allowSelfSignedCertificates" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, self signed certificates are accepted (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authDomain" type="xs:string" />
    <xs:attribute name="base64" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the result is base64 encoded (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificate" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource url to certificate to be used for authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain certificate password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificatePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charSet" type="xs:string" />
    <xs:attribute name="contentType" type="xs:string">
      <xs:annotation>
        <xs:documentation>content-type of the request, only for post and put methods (default: text/html; charset=utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodeMessages" type="xs:string">
      <xs:annotation>
        <xs:documentation>specifies whether messages will encoded, e.g. spaces will be replaced by '+' etc. (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="followRedirects" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, a redirect request will be honoured, e.g. to switch to https (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="headersParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of parameter names which should be set as http headers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCertificateExpiredException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the certificateexpiredexception is ignored (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreRedirects" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, besides http status code 200 (ok) also the code 301 (moved_permanently), 302 (moved_temporarily) and 307 (temporary_redirect) are considered successful (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputMessageParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;) name of the request parameter which is used to put the input message in (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: pkcs12)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConnections" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of concurrent connections (default: 10)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxExecuteRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of times it the execution is retried (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="methodType" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of method to be executed, either 'GET', 'POST', 'PUT', 'DELETE', 'HEAD' or 'REPORT' (default: GET)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mtomContentTransferEncoding" type="xs:string" />
    <xs:attribute name="mtomEnabled" type="xs:string" />
    <xs:attribute name="multipart" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true and &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;, request parameters are put in a multipart/form-data entity instead of in the request body (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartResponse" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true the response body is expected to be in mime multipart which is the case when a soap message with attachments is received (see also &lt;a href="https://docs.oracle.com/javaee/7/api/javax/xml/soap/soapmessage.html"&gt;https://docs.oracle.com/javaee/7/api/javax/xml/soap/soapmessage.html&lt;/a&gt;). the first part will be returned as result of this sender. other parts are returned as streams in sessionkeys with names multipart1, multipart2, etc. the http connection is held open until the last stream is read. (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartXmlSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set and &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;, a multipart/form-data entity is created instead of a request body. for each part element in the session key a part in the multipart entity is created (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="paramsInUrl" type="xs:string">
      <xs:annotation>
        <xs:documentation>when false and &lt;code&gt;methodetype=post&lt;/code&gt;, request parameters are put in the request body instead of in the url (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="protocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>secure socket protocol (such as 'ssl' and 'tls') to use when a sslcontext object is generated. if empty the protocol 'ssl' is used (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to proxy (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: 80)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyRealm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultStatusCodeSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the status code of the http response is put in specified in the sessionkey and the (error or okay) response message is returned (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether connections checked to be stale, i.e. appear open, but are not. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleTimeout" type="xs:string" />
    <xs:attribute name="storeResultAsByteArrayInSessionKey" type="xs:string" />
    <xs:attribute name="storeResultAsStreamInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, a pointer to an input stream of the result is put in the specified sessionkey (as the sender interface only allows a sender to return a string a sessionkey is used instead to return the stream) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToFileNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to a file (instead of passed as a string) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to the httpservletresponse object of the restservicedispatcher (instead of passed as a string) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>&gt;(only used when &lt;code&gt;xhtml=true&lt;/code&gt;) stylesheet to apply to the html response (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a senderexception (or timeoutexception) is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in ms of obtaining a connection/result. 0 means no timeout (default: 10000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource url to truststore to be used for authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain truststore password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: jks)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>url or base of url to be used  (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>parameter that is used to obtain url; overrides url-attribute. (default: url)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="userName" type="xs:string">
      <xs:annotation>
        <xs:documentation>username used in authentication to host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the hostname in the certificate will be checked against the actual hostname (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xhtml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the html response is transformed to xhtml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the xml tag to encapsulate the result in (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ResultSet2FileErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="append" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; and the file already exists, the resultset rows are written to the end of the file (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobBase64Direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether the streamed blobdata will need to be base64 &lt;code&gt;encode&lt;/code&gt; or &lt;code&gt;decode&lt;/code&gt; or not. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used to read and write blobs (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobColumn" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for querytype 'updateblob': column that contains the blob to be updated (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>for querytype 'updateblob': key of session variable that contains the data (string or inputstream) to be loaded to the blob. when empty, the input of the pipe, which then must be a string, is used. for querytype 'select': key of session variable that contains the outputstream, writer or filename to write the blob to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls automatically whether blobdata is stored compressed and/or serialized in the database (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is stored compressed in the database (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobColumn" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for querytype 'updateclob': column that contains the clob to be updated (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>for querytype 'updateclob': key of session variable that contains the clob (string or inputstream) to be loaded to the clob. when empty, the input of the pipe, which then must be a string, is used. for querytype 'select': key of session variable that contains the outputstream, writer or filename to write the clob to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeOutputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the outputstream is not closed after blob or clob has been written to it (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="columnsReturned" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of columns whose values are to be returned. works only if the driver implements jdbc 3.0 getgeneratedkeys() (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="fileNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>the session key that contains the name of the file to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="includeFieldDefinition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the result contains besides the returned rows also a header with information about the fetched fields (default: application default (true))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="lockRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, exclusive row-level locks are obtained on all the rows identified by the select statement (by appending ' for update nowait skip locked' to the end of the query) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWait" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and &gt;=0, ' for update wait #' is used instead of ' for update nowait skip locked' (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRecordsSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set (and &amp;gt;=0), this session key contains the maximum number of records which are processed. if &lt;code&gt;query&lt;/code&gt; contains a group field (3), then also following records with the same group field value as the last record are processed (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum number of rows returned (default: -1 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="nullValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>value used in result as contents of fields that contain no value (sql-null) (default: &lt;i&gt;empty string&lt;/&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="packageContent" type="xs:string" />
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="query" type="xs:string">
      <xs:annotation>
        <xs:documentation>the sql query text to be excecuted each time sendmessage() is called (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queryType" type="xs:string" />
    <xs:attribute name="resultQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>query that can be used to obtain result of side-effecto of update-query, like generated value of sequence. example: select mysequence.currval from dual (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rowIdSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified, the rowid of the processed row is put in the pipelinesession under the specified key (only applicable for &lt;code&gt;querytype=other&lt;/code&gt;). &lt;b&gt;note:&lt;/b&gt; if multiple rows are processed a sqlexception is thrown. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalar" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the value of the first column of the first row (or the startrow) is returned as the only result, as a simple non-xml value (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalarExtended" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startRow" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of the first row returned from the output (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of the optional status field which is set after the row is written to the file: timestamp (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used when reading a stream (that is e.g. going to be written to a blob or clob). when empty, the stream is copied directly to the blob, without conversion (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to the httpservletresponse object of the restservicedispatcher (instead of passed as a string) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of seconds the driver will wait for a statement object to execute. if the limit is exceeded, a timeoutexception is thrown. 0 means no timeout (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="trimSpaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>remove trailing blanks from all values. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useNamedParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, every string in the message which equals &lt;code&gt;paramname&lt;/code&gt; will be replaced by the setter method for the corresponding parameter (the parameters don't need to be in the correct order and unused parameters are skipped) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ResultSet2FileSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="append" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; and the file already exists, the resultset rows are written to the end of the file (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobBase64Direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether the streamed blobdata will need to be base64 &lt;code&gt;encode&lt;/code&gt; or &lt;code&gt;decode&lt;/code&gt; or not. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used to read and write blobs (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobColumn" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for querytype 'updateblob': column that contains the blob to be updated (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>for querytype 'updateblob': key of session variable that contains the data (string or inputstream) to be loaded to the blob. when empty, the input of the pipe, which then must be a string, is used. for querytype 'select': key of session variable that contains the outputstream, writer or filename to write the blob to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls automatically whether blobdata is stored compressed and/or serialized in the database (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is stored compressed in the database (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobColumn" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for querytype 'updateclob': column that contains the clob to be updated (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>for querytype 'updateclob': key of session variable that contains the clob (string or inputstream) to be loaded to the clob. when empty, the input of the pipe, which then must be a string, is used. for querytype 'select': key of session variable that contains the outputstream, writer or filename to write the clob to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeOutputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the outputstream is not closed after blob or clob has been written to it (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="columnsReturned" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of columns whose values are to be returned. works only if the driver implements jdbc 3.0 getgeneratedkeys() (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="fileNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>the session key that contains the name of the file to use (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="includeFieldDefinition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the result contains besides the returned rows also a header with information about the fetched fields (default: application default (true))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="lockRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, exclusive row-level locks are obtained on all the rows identified by the select statement (by appending ' for update nowait skip locked' to the end of the query) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWait" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and &gt;=0, ' for update wait #' is used instead of ' for update nowait skip locked' (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRecordsSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set (and &amp;gt;=0), this session key contains the maximum number of records which are processed. if &lt;code&gt;query&lt;/code&gt; contains a group field (3), then also following records with the same group field value as the last record are processed (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum number of rows returned (default: -1 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="nullValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>value used in result as contents of fields that contain no value (sql-null) (default: &lt;i&gt;empty string&lt;/&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="packageContent" type="xs:string" />
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="query" type="xs:string">
      <xs:annotation>
        <xs:documentation>the sql query text to be excecuted each time sendmessage() is called (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queryType" type="xs:string" />
    <xs:attribute name="resultQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>query that can be used to obtain result of side-effecto of update-query, like generated value of sequence. example: select mysequence.currval from dual (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rowIdSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified, the rowid of the processed row is put in the pipelinesession under the specified key (only applicable for &lt;code&gt;querytype=other&lt;/code&gt;). &lt;b&gt;note:&lt;/b&gt; if multiple rows are processed a sqlexception is thrown. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalar" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the value of the first column of the first row (or the startrow) is returned as the only result, as a simple non-xml value (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalarExtended" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startRow" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of the first row returned from the output (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statusFieldType" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of the optional status field which is set after the row is written to the file: timestamp (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used when reading a stream (that is e.g. going to be written to a blob or clob). when empty, the stream is copied directly to the blob, without conversion (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to the httpservletresponse object of the restservicedispatcher (instead of passed as a string) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of seconds the driver will wait for a statement object to execute. if the limit is exceeded, a timeoutexception is thrown. 0 means no timeout (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="trimSpaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>remove trailing blanks from all values. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useNamedParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, every string in the message which equals &lt;code&gt;paramname&lt;/code&gt; will be replaced by the setter method for the corresponding parameter (the parameters don't need to be in the correct order and unused parameters are skipped) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ResultSetIteratingPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapInputWrapper" type="ApiSoapInputWrapperType" minOccurs="0" />
        <xs:element name="BisInputWrapper" type="BisInputWrapperType" minOccurs="0" />
        <xs:element name="DirectInputWrapper" type="DirectInputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapInputWrapper" type="EsbSoapInputWrapperType" minOccurs="0" />
        <xs:element name="FxfInputWrapper" type="FxfInputWrapperType" minOccurs="0" />
        <xs:element name="SoapInputWrapper" type="SoapInputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlInputValidator" type="ApiWsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapInputValidator" type="EsbSoapInputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlInputValidator" type="FxfXmlInputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlInputValidator" type="Json2XmlInputValidatorType" minOccurs="0" />
        <xs:element name="SoapInputValidator" type="SoapInputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlInputValidator" type="WsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="XmlInputValidator" type="XmlInputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="Afm2EdiFactSender" type="Afm2EdiFactSenderType" minOccurs="0" />
        <xs:element name="BisJmsSender" type="BisJmsSenderType" minOccurs="0" />
        <xs:element name="CommandSender" type="CommandSenderType" minOccurs="0" />
        <xs:element name="DelaySender" type="DelaySenderType" minOccurs="0" />
        <xs:element name="DirectQuerySender" type="DirectQuerySenderType" minOccurs="0" />
        <xs:element name="EchoSender" type="EchoSenderType" minOccurs="0" />
        <xs:element name="EsbJmsSender" type="EsbJmsSenderType" minOccurs="0" />
        <xs:element name="FileSender" type="FileSenderType" minOccurs="0" />
        <xs:element name="FixedQuerySender" type="FixedQuerySenderType" minOccurs="0" />
        <xs:element name="FixedResultSender" type="FixedResultSenderType" minOccurs="0" />
        <xs:element name="FtpSender" type="FtpSenderType" minOccurs="0" />
        <xs:element name="HttpSender" type="HttpSenderType" minOccurs="0" />
        <xs:element name="IbisJavaSender" type="IbisJavaSenderType" minOccurs="0" />
        <xs:element name="IbisLocalSender" type="IbisLocalSenderType" minOccurs="0" />
        <xs:element name="IbisWebServiceSender" type="IbisWebServiceSenderType" minOccurs="0" />
        <xs:element name="JmsSender" type="JmsSenderType" minOccurs="0" />
        <xs:element name="LdapSender" type="LdapSenderType" minOccurs="0" />
        <xs:element name="LogSender" type="LogSenderType" minOccurs="0" />
        <xs:element name="MailSender" type="MailSenderType" minOccurs="0" />
        <xs:element name="MessageStoreSender" type="MessageStoreSenderType" minOccurs="0" />
        <xs:element name="MqttSender" type="MqttSenderType" minOccurs="0" />
        <xs:element name="ParallelSendersSender" type="ParallelSendersSenderType" minOccurs="0" />
        <xs:element name="ReloadSender" type="ReloadSenderType" minOccurs="0" />
        <xs:element name="RestSender" type="RestSenderType" minOccurs="0" />
        <xs:element name="ResultSet2FileSender" type="ResultSet2FileSenderType" minOccurs="0" />
        <xs:element name="SambaSender" type="SambaSenderType" minOccurs="0" />
        <xs:element name="SchedulerSender" type="SchedulerSenderType" minOccurs="0" />
        <xs:element name="SenderSeriesSender" type="SenderSeriesSenderType" minOccurs="0" />
        <xs:element name="SenderWrapperSender" type="SenderWrapperSenderType" minOccurs="0" />
        <xs:element name="ShadowSender" type="ShadowSenderType" minOccurs="0" />
        <xs:element name="TimeoutGuardSenderWithParametersBaseSender" type="TimeoutGuardSenderWithParametersBaseSenderType" minOccurs="0" />
        <xs:element name="WebServiceNtlmSender" type="WebServiceNtlmSenderType" minOccurs="0" />
        <xs:element name="WebServiceSender" type="WebServiceSenderType" minOccurs="0" />
        <xs:element name="XComSender" type="XComSenderType" minOccurs="0" />
        <xs:element name="XfbSender" type="XfbSenderType" minOccurs="0" />
        <xs:element name="XmlJmsBrowserSender" type="XmlJmsBrowserSenderType" minOccurs="0" />
        <xs:element name="XmlQuerySender" type="XmlQuerySenderType" minOccurs="0" />
        <xs:element name="XmlValidatorSender" type="XmlValidatorSenderType" minOccurs="0" />
        <xs:element name="XsltSender" type="XsltSenderType" minOccurs="0" />
        <xs:element name="ZipWriterSender" type="ZipWriterSenderType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="DummyMessageLog" type="DummyMessageLogType" minOccurs="0" />
        <xs:element name="EsbJmsMessageLog" type="EsbJmsMessageLogType" minOccurs="0" />
        <xs:element name="JdbcMessageLog" type="JdbcMessageLogType" minOccurs="0" />
        <xs:element name="JmsMessageLog" type="JmsMessageLogType" minOccurs="0" />
        <xs:element name="OracleMessageLog" type="OracleMessageLogType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlOutputValidator" type="ApiWsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapOutputValidator" type="EsbSoapOutputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlOutputValidator" type="FxfXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlOutputValidator" type="Json2XmlOutputValidatorType" minOccurs="0" />
        <xs:element name="SoapOutputValidator" type="SoapOutputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlOutputValidator" type="WsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="XmlOutputValidator" type="XmlOutputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapOutputWrapper" type="ApiSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="BisOutputWrapper" type="BisOutputWrapperType" minOccurs="0" />
        <xs:element name="DirectOutputWrapper" type="DirectOutputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapOutputWrapper" type="EsbSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="FxfOutputWrapper" type="FxfOutputWrapperType" minOccurs="0" />
        <xs:element name="SoapOutputWrapper" type="SoapOutputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addInputToResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; the input is added to the result in an input element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for audittrailxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. if specified, the value of the pipelinesession variable is used as audit trail (instead of the default 'no audit trail) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract audit trail from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockPrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;blocksize &amp;gt; 0&lt;/code&gt;, this string is inserted at the start of the set of lines. (default: &amp;lt;block&amp;gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls multiline behaviour. when set to a value greater than 0, it specifies the number of rows send in a block to the sender. (default: 0 (one line at a time, no prefix of suffix))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;blocksize &amp;gt; 0&lt;/code&gt;, this string is inserted at the end of the set of lines. (default: &amp;lt;/block&amp;gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkRootTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, besides the xml well-formedness the root element of the result is checked to be equal to the value set (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkXmlWellFormed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the xml well-formedness of the result is checked (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectResults" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether all the results of each iteration will be collected in one result message. if set &lt;code&gt;false&lt;/code&gt;, only a small summary is returned (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for correlationidxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. is specified, the value of the pipelinesession variable is used as input for the xpathexpression or stylesheet, instead of the current input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be configured from jmsrealm, too (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="endPosition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;endposition &amp;gt;= startposition&lt;/code&gt;, this field contains the end position of the key in the current record (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exceptionOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a piperunexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when hideregex is not empty and only applies to error/logstore) either &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;firsthalf&lt;/code&gt;. when &lt;code&gt;firsthalf&lt;/code&gt; only the first half of the string is masked, otherwise (&lt;code&gt;all&lt;/code&gt;) the entire string is masked (default: all)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>next to common usage in {@link abstractpipe}, also strings in the error/logstore are masked (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreExceptions" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; ignore any exception thrown by executing sender (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="itemNoSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable to store number of item processed. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for labelxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linePrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>this string is inserted at the start of each line (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>this string is inserted at the end of each line (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>indicates wether the server uses the correlationid or the messageid in the correlationid field of the reply. this requirers the sender to have set the correlationid at the time of sending. (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, exclusive row-level locks are obtained on all the rows identified by the select statement (by appending ' for update nowait skip locked' to the end of the query) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWait" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and &gt;=0, ' for update wait #' is used instead of ' for update nowait skip locked' (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of times a processing attempt is retried after a timeout or an exception is caught or after a incorrect reply is received (see also &lt;code&gt;retryxpath&lt;/code&gt;) (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:string">
      <xs:annotation>
        <xs:documentation>force the transformer generated from the xpath-expression to omit the xml declaration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either 'text' or 'xml'. only valid for xpathexpression (default: text)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="parallel" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the calls for all items are done in parallel (a new thread is started for each call). when collectresults set &lt;code&gt;true&lt;/code&gt;, this pipe will wait for all calls to finish before results are collected and pipe result is returned (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="presumedTimeOutInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>when the previous call was a timeout, the maximum time (in seconds) after this timeout to presume the current call is also a timeout. a value of -1 indicates to never presume timeouts (default: 10 s)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="query" type="xs:string">
      <xs:annotation>
        <xs:documentation>the sql query text to be excecuted each time sendmessage() is called. when not set, the input message is taken as the query (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeDuplicates" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; duplicate input elements are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeXmlDeclarationInResults" type="xs:string">
      <xs:annotation>
        <xs:documentation>postprocess each partial result, to remove the xml-declaration, as this is not allowed inside an xml-document (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultOnTimeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>result returned when no return-message was received within the timeout limit (e.g. 'receiver timed out'). (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMaxInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of seconds waited after an unsuccessful processing attempt before another processing attempt is made (default: 600)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMinInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the starting number of seconds waited after an unsuccessful processing attempt before another processing attempt is made. each next retry this interval is doubled with a upper limit of &lt;code&gt;retrymaxinterval&lt;/code&gt; (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for retryxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression evaluated on each technical successful reply. retry is done if condition returns true (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startPosition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;startposition &amp;gt;= 0&lt;/code&gt;, this field contains the start position of the key in the current record (first character is 0); all sequenced lines with the same key are put in one block and send to the sender (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stopConditionXPathExpression" type="xs:string" />
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is first base64 decoded and then streamed to the httpservletresponse object (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stubFileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the pipe returns a message from a file, instead of doing the regular process (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to apply to each message, before sending it (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOutOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a timeoutexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useInputForExtract" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is used to extract audit trail, correlationid and label (instead of the wrapped input) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>alternatively: xpath-expression to create stylesheet from (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="RhinoPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="debug" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fileName" type="xs:string" />
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsfunctionArguments" type="xs:string" />
    <xs:attribute name="jsfunctionName" type="xs:string" />
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="lookupAtRuntime" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string" />
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="SambaErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="action" type="xs:string">
      <xs:annotation>
        <xs:documentation>possible values: delete, download, list, mkdir, rename, rmdir, upload (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for the smb share (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authDomain" type="xs:string">
      <xs:annotation>
        <xs:documentation>in case the user account is bound to a domain (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="share" type="xs:string">
      <xs:annotation>
        <xs:documentation>the destination, aka smb://xxx/yyy share (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share username (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SambaSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="action" type="xs:string">
      <xs:annotation>
        <xs:documentation>possible values: delete, download, list, mkdir, rename, rmdir, upload (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for the smb share (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authDomain" type="xs:string">
      <xs:annotation>
        <xs:documentation>in case the user account is bound to a domain (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="share" type="xs:string">
      <xs:annotation>
        <xs:documentation>the destination, aka smb://xxx/yyy share (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string">
      <xs:annotation>
        <xs:documentation>the smb share username (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ScanTibcoSolutionPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="level" type="xs:string" />
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="url" type="xs:string" />
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="SchedulerErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SchedulerSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SenderPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapInputWrapper" type="ApiSoapInputWrapperType" minOccurs="0" />
        <xs:element name="BisInputWrapper" type="BisInputWrapperType" minOccurs="0" />
        <xs:element name="DirectInputWrapper" type="DirectInputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapInputWrapper" type="EsbSoapInputWrapperType" minOccurs="0" />
        <xs:element name="FxfInputWrapper" type="FxfInputWrapperType" minOccurs="0" />
        <xs:element name="SoapInputWrapper" type="SoapInputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlInputValidator" type="ApiWsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapInputValidator" type="EsbSoapInputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlInputValidator" type="FxfXmlInputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlInputValidator" type="Json2XmlInputValidatorType" minOccurs="0" />
        <xs:element name="SoapInputValidator" type="SoapInputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlInputValidator" type="WsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="XmlInputValidator" type="XmlInputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="Afm2EdiFactSender" type="Afm2EdiFactSenderType" minOccurs="0" />
        <xs:element name="BisJmsSender" type="BisJmsSenderType" minOccurs="0" />
        <xs:element name="CommandSender" type="CommandSenderType" minOccurs="0" />
        <xs:element name="DelaySender" type="DelaySenderType" minOccurs="0" />
        <xs:element name="DirectQuerySender" type="DirectQuerySenderType" minOccurs="0" />
        <xs:element name="EchoSender" type="EchoSenderType" minOccurs="0" />
        <xs:element name="EsbJmsSender" type="EsbJmsSenderType" minOccurs="0" />
        <xs:element name="FileSender" type="FileSenderType" minOccurs="0" />
        <xs:element name="FixedQuerySender" type="FixedQuerySenderType" minOccurs="0" />
        <xs:element name="FixedResultSender" type="FixedResultSenderType" minOccurs="0" />
        <xs:element name="FtpSender" type="FtpSenderType" minOccurs="0" />
        <xs:element name="HttpSender" type="HttpSenderType" minOccurs="0" />
        <xs:element name="IbisJavaSender" type="IbisJavaSenderType" minOccurs="0" />
        <xs:element name="IbisLocalSender" type="IbisLocalSenderType" minOccurs="0" />
        <xs:element name="IbisWebServiceSender" type="IbisWebServiceSenderType" minOccurs="0" />
        <xs:element name="JmsSender" type="JmsSenderType" minOccurs="0" />
        <xs:element name="LdapSender" type="LdapSenderType" minOccurs="0" />
        <xs:element name="LogSender" type="LogSenderType" minOccurs="0" />
        <xs:element name="MailSender" type="MailSenderType" minOccurs="0" />
        <xs:element name="MessageStoreSender" type="MessageStoreSenderType" minOccurs="0" />
        <xs:element name="MqttSender" type="MqttSenderType" minOccurs="0" />
        <xs:element name="ParallelSendersSender" type="ParallelSendersSenderType" minOccurs="0" />
        <xs:element name="ReloadSender" type="ReloadSenderType" minOccurs="0" />
        <xs:element name="RestSender" type="RestSenderType" minOccurs="0" />
        <xs:element name="ResultSet2FileSender" type="ResultSet2FileSenderType" minOccurs="0" />
        <xs:element name="SambaSender" type="SambaSenderType" minOccurs="0" />
        <xs:element name="SchedulerSender" type="SchedulerSenderType" minOccurs="0" />
        <xs:element name="SenderSeriesSender" type="SenderSeriesSenderType" minOccurs="0" />
        <xs:element name="SenderWrapperSender" type="SenderWrapperSenderType" minOccurs="0" />
        <xs:element name="ShadowSender" type="ShadowSenderType" minOccurs="0" />
        <xs:element name="TimeoutGuardSenderWithParametersBaseSender" type="TimeoutGuardSenderWithParametersBaseSenderType" minOccurs="0" />
        <xs:element name="WebServiceNtlmSender" type="WebServiceNtlmSenderType" minOccurs="0" />
        <xs:element name="WebServiceSender" type="WebServiceSenderType" minOccurs="0" />
        <xs:element name="XComSender" type="XComSenderType" minOccurs="0" />
        <xs:element name="XfbSender" type="XfbSenderType" minOccurs="0" />
        <xs:element name="XmlJmsBrowserSender" type="XmlJmsBrowserSenderType" minOccurs="0" />
        <xs:element name="XmlQuerySender" type="XmlQuerySenderType" minOccurs="0" />
        <xs:element name="XmlValidatorSender" type="XmlValidatorSenderType" minOccurs="0" />
        <xs:element name="XsltSender" type="XsltSenderType" minOccurs="0" />
        <xs:element name="ZipWriterSender" type="ZipWriterSenderType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiListener" type="ApiListenerType" minOccurs="0" />
        <xs:element name="BisJmsListener" type="BisJmsListenerType" minOccurs="0" />
        <xs:element name="DirectoryListener" type="DirectoryListenerType" minOccurs="0" />
        <xs:element name="EsbJmsListener" type="EsbJmsListenerType" minOccurs="0" />
        <xs:element name="ExchangeMailListener" type="ExchangeMailListenerType" minOccurs="0" />
        <xs:element name="FileRecordListener" type="FileRecordListenerType" minOccurs="0" />
        <xs:element name="FtpListener" type="FtpListenerType" minOccurs="0" />
        <xs:element name="FxfListener" type="FxfListenerType" minOccurs="0" />
        <xs:element name="HttpListener" type="HttpListenerType" minOccurs="0" />
        <xs:element name="JavaListener" type="JavaListenerType" minOccurs="0" />
        <xs:element name="JdbcListener" type="JdbcListenerType" minOccurs="0" />
        <xs:element name="JdbcQueryListener" type="JdbcQueryListenerType" minOccurs="0" />
        <xs:element name="JdbcTableListener" type="JdbcTableListenerType" minOccurs="0" />
        <xs:element name="JmsListener" type="JmsListenerType" minOccurs="0" />
        <xs:element name="MessageStoreListener" type="MessageStoreListenerType" minOccurs="0" />
        <xs:element name="MqttListener" type="MqttListenerType" minOccurs="0" />
        <xs:element name="PullingJmsListener" type="PullingJmsListenerType" minOccurs="0" />
        <xs:element name="PushingJmsListener" type="PushingJmsListenerType" minOccurs="0" />
        <xs:element name="PushingListenerAdapterListener" type="PushingListenerAdapterListenerType" minOccurs="0" />
        <xs:element name="RestListener" type="RestListenerType" minOccurs="0" />
        <xs:element name="SimpleJdbcListener" type="SimpleJdbcListenerType" minOccurs="0" />
        <xs:element name="WebServiceListener" type="WebServiceListenerType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="DummyMessageLog" type="DummyMessageLogType" minOccurs="0" />
        <xs:element name="EsbJmsMessageLog" type="EsbJmsMessageLogType" minOccurs="0" />
        <xs:element name="JdbcMessageLog" type="JdbcMessageLogType" minOccurs="0" />
        <xs:element name="JmsMessageLog" type="JmsMessageLogType" minOccurs="0" />
        <xs:element name="OracleMessageLog" type="OracleMessageLogType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlOutputValidator" type="ApiWsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapOutputValidator" type="EsbSoapOutputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlOutputValidator" type="FxfXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlOutputValidator" type="Json2XmlOutputValidatorType" minOccurs="0" />
        <xs:element name="SoapOutputValidator" type="SoapOutputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlOutputValidator" type="WsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="XmlOutputValidator" type="XmlOutputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapOutputWrapper" type="ApiSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="BisOutputWrapper" type="BisOutputWrapperType" minOccurs="0" />
        <xs:element name="DirectOutputWrapper" type="DirectOutputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapOutputWrapper" type="EsbSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="FxfOutputWrapper" type="FxfOutputWrapperType" minOccurs="0" />
        <xs:element name="SoapOutputWrapper" type="SoapOutputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for audittrailxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. if specified, the value of the pipelinesession variable is used as audit trail (instead of the default 'no audit trail) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract audit trail from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkRootTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, besides the xml well-formedness the root element of the result is checked to be equal to the value set (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkXmlWellFormed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the xml well-formedness of the result is checked (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for correlationidxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. is specified, the value of the pipelinesession variable is used as input for the xpathexpression or stylesheet, instead of the current input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exceptionOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a piperunexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when hideregex is not empty and only applies to error/logstore) either &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;firsthalf&lt;/code&gt;. when &lt;code&gt;firsthalf&lt;/code&gt; only the first half of the string is masked, otherwise (&lt;code&gt;all&lt;/code&gt;) the entire string is masked (default: all)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>next to common usage in {@link abstractpipe}, also strings in the error/logstore are masked (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for labelxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>indicates wether the server uses the correlationid or the messageid in the correlationid field of the reply. this requirers the sender to have set the correlationid at the time of sending. (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of times a processing attempt is retried after a timeout or an exception is caught or after a incorrect reply is received (see also &lt;code&gt;retryxpath&lt;/code&gt;) (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="presumedTimeOutInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>when the previous call was a timeout, the maximum time (in seconds) after this timeout to presume the current call is also a timeout. a value of -1 indicates to never presume timeouts (default: 10 s)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultOnTimeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>result returned when no return-message was received within the timeout limit (e.g. 'receiver timed out'). (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMaxInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of seconds waited after an unsuccessful processing attempt before another processing attempt is made (default: 600)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMinInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the starting number of seconds waited after an unsuccessful processing attempt before another processing attempt is made. each next retry this interval is doubled with a upper limit of &lt;code&gt;retrymaxinterval&lt;/code&gt; (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for retryxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression evaluated on each technical successful reply. retry is done if condition returns true (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is first base64 decoded and then streamed to the httpservletresponse object (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stubFileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the pipe returns a message from a file, instead of doing the regular process (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOutOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a timeoutexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useInputForExtract" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is used to extract audit trail, correlationid and label (instead of the wrapped input) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="SenderSeriesSenderType">
    <xs:sequence>
      <xs:element name="Cache" type="CacheType" minOccurs="0" maxOccurs="unbounded" />
      <xs:choice minOccurs="0">
        <xs:element name="Afm2EdiFactSender" type="Afm2EdiFactSenderType" minOccurs="0" />
        <xs:element name="BisJmsSender" type="BisJmsSenderType" minOccurs="0" />
        <xs:element name="CommandSender" type="CommandSenderType" minOccurs="0" />
        <xs:element name="DelaySender" type="DelaySenderType" minOccurs="0" />
        <xs:element name="DirectQuerySender" type="DirectQuerySenderType" minOccurs="0" />
        <xs:element name="EchoSender" type="EchoSenderType" minOccurs="0" />
        <xs:element name="EsbJmsSender" type="EsbJmsSenderType" minOccurs="0" />
        <xs:element name="FileSender" type="FileSenderType" minOccurs="0" />
        <xs:element name="FixedQuerySender" type="FixedQuerySenderType" minOccurs="0" />
        <xs:element name="FixedResultSender" type="FixedResultSenderType" minOccurs="0" />
        <xs:element name="FtpSender" type="FtpSenderType" minOccurs="0" />
        <xs:element name="HttpSender" type="HttpSenderType" minOccurs="0" />
        <xs:element name="IbisJavaSender" type="IbisJavaSenderType" minOccurs="0" />
        <xs:element name="IbisLocalSender" type="IbisLocalSenderType" minOccurs="0" />
        <xs:element name="IbisWebServiceSender" type="IbisWebServiceSenderType" minOccurs="0" />
        <xs:element name="JmsSender" type="JmsSenderType" minOccurs="0" />
        <xs:element name="LdapSender" type="LdapSenderType" minOccurs="0" />
        <xs:element name="LogSender" type="LogSenderType" minOccurs="0" />
        <xs:element name="MailSender" type="MailSenderType" minOccurs="0" />
        <xs:element name="MessageStoreSender" type="MessageStoreSenderType" minOccurs="0" />
        <xs:element name="MqttSender" type="MqttSenderType" minOccurs="0" />
        <xs:element name="ParallelSendersSender" type="ParallelSendersSenderType" minOccurs="0" />
        <xs:element name="ReloadSender" type="ReloadSenderType" minOccurs="0" />
        <xs:element name="RestSender" type="RestSenderType" minOccurs="0" />
        <xs:element name="ResultSet2FileSender" type="ResultSet2FileSenderType" minOccurs="0" />
        <xs:element name="SambaSender" type="SambaSenderType" minOccurs="0" />
        <xs:element name="SchedulerSender" type="SchedulerSenderType" minOccurs="0" />
        <xs:element name="SenderSeriesSender" type="SenderSeriesSenderType" minOccurs="0" />
        <xs:element name="SenderWrapperSender" type="SenderWrapperSenderType" minOccurs="0" />
        <xs:element name="ShadowSender" type="ShadowSenderType" minOccurs="0" />
        <xs:element name="TimeoutGuardSenderWithParametersBaseSender" type="TimeoutGuardSenderWithParametersBaseSenderType" minOccurs="0" />
        <xs:element name="WebServiceNtlmSender" type="WebServiceNtlmSenderType" minOccurs="0" />
        <xs:element name="WebServiceSender" type="WebServiceSenderType" minOccurs="0" />
        <xs:element name="XComSender" type="XComSenderType" minOccurs="0" />
        <xs:element name="XfbSender" type="XfbSenderType" minOccurs="0" />
        <xs:element name="XmlJmsBrowserSender" type="XmlJmsBrowserSenderType" minOccurs="0" />
        <xs:element name="XmlQuerySender" type="XmlQuerySenderType" minOccurs="0" />
        <xs:element name="XmlValidatorSender" type="XmlValidatorSenderType" minOccurs="0" />
        <xs:element name="XsltSender" type="XsltSenderType" minOccurs="0" />
        <xs:element name="ZipWriterSender" type="ZipWriterSenderType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="SenderWrapperSenderType">
    <xs:sequence>
      <xs:element name="Cache" type="CacheType" minOccurs="0" maxOccurs="unbounded" />
      <xs:choice minOccurs="0">
        <xs:element name="Afm2EdiFactSender" type="Afm2EdiFactSenderType" minOccurs="0" />
        <xs:element name="BisJmsSender" type="BisJmsSenderType" minOccurs="0" />
        <xs:element name="CommandSender" type="CommandSenderType" minOccurs="0" />
        <xs:element name="DelaySender" type="DelaySenderType" minOccurs="0" />
        <xs:element name="DirectQuerySender" type="DirectQuerySenderType" minOccurs="0" />
        <xs:element name="EchoSender" type="EchoSenderType" minOccurs="0" />
        <xs:element name="EsbJmsSender" type="EsbJmsSenderType" minOccurs="0" />
        <xs:element name="FileSender" type="FileSenderType" minOccurs="0" />
        <xs:element name="FixedQuerySender" type="FixedQuerySenderType" minOccurs="0" />
        <xs:element name="FixedResultSender" type="FixedResultSenderType" minOccurs="0" />
        <xs:element name="FtpSender" type="FtpSenderType" minOccurs="0" />
        <xs:element name="HttpSender" type="HttpSenderType" minOccurs="0" />
        <xs:element name="IbisJavaSender" type="IbisJavaSenderType" minOccurs="0" />
        <xs:element name="IbisLocalSender" type="IbisLocalSenderType" minOccurs="0" />
        <xs:element name="IbisWebServiceSender" type="IbisWebServiceSenderType" minOccurs="0" />
        <xs:element name="JmsSender" type="JmsSenderType" minOccurs="0" />
        <xs:element name="LdapSender" type="LdapSenderType" minOccurs="0" />
        <xs:element name="LogSender" type="LogSenderType" minOccurs="0" />
        <xs:element name="MailSender" type="MailSenderType" minOccurs="0" />
        <xs:element name="MessageStoreSender" type="MessageStoreSenderType" minOccurs="0" />
        <xs:element name="MqttSender" type="MqttSenderType" minOccurs="0" />
        <xs:element name="ParallelSendersSender" type="ParallelSendersSenderType" minOccurs="0" />
        <xs:element name="ReloadSender" type="ReloadSenderType" minOccurs="0" />
        <xs:element name="RestSender" type="RestSenderType" minOccurs="0" />
        <xs:element name="ResultSet2FileSender" type="ResultSet2FileSenderType" minOccurs="0" />
        <xs:element name="SambaSender" type="SambaSenderType" minOccurs="0" />
        <xs:element name="SchedulerSender" type="SchedulerSenderType" minOccurs="0" />
        <xs:element name="SenderSeriesSender" type="SenderSeriesSenderType" minOccurs="0" />
        <xs:element name="SenderWrapperSender" type="SenderWrapperSenderType" minOccurs="0" />
        <xs:element name="ShadowSender" type="ShadowSenderType" minOccurs="0" />
        <xs:element name="TimeoutGuardSenderWithParametersBaseSender" type="TimeoutGuardSenderWithParametersBaseSenderType" minOccurs="0" />
        <xs:element name="WebServiceNtlmSender" type="WebServiceNtlmSenderType" minOccurs="0" />
        <xs:element name="WebServiceSender" type="WebServiceSenderType" minOccurs="0" />
        <xs:element name="XComSender" type="XComSenderType" minOccurs="0" />
        <xs:element name="XfbSender" type="XfbSenderType" minOccurs="0" />
        <xs:element name="XmlJmsBrowserSender" type="XmlJmsBrowserSenderType" minOccurs="0" />
        <xs:element name="XmlQuerySender" type="XmlQuerySenderType" minOccurs="0" />
        <xs:element name="XmlValidatorSender" type="XmlValidatorSenderType" minOccurs="0" />
        <xs:element name="XsltSender" type="XsltSenderType" minOccurs="0" />
        <xs:element name="ZipWriterSender" type="ZipWriterSenderType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ShadowErrorSenderType">
    <xs:sequence>
      <xs:element name="Cache" type="CacheType" minOccurs="0" maxOccurs="unbounded" />
      <xs:choice minOccurs="0">
        <xs:element name="Afm2EdiFactSender" type="Afm2EdiFactSenderType" minOccurs="0" />
        <xs:element name="BisJmsSender" type="BisJmsSenderType" minOccurs="0" />
        <xs:element name="CommandSender" type="CommandSenderType" minOccurs="0" />
        <xs:element name="DelaySender" type="DelaySenderType" minOccurs="0" />
        <xs:element name="DirectQuerySender" type="DirectQuerySenderType" minOccurs="0" />
        <xs:element name="EchoSender" type="EchoSenderType" minOccurs="0" />
        <xs:element name="EsbJmsSender" type="EsbJmsSenderType" minOccurs="0" />
        <xs:element name="FileSender" type="FileSenderType" minOccurs="0" />
        <xs:element name="FixedQuerySender" type="FixedQuerySenderType" minOccurs="0" />
        <xs:element name="FixedResultSender" type="FixedResultSenderType" minOccurs="0" />
        <xs:element name="FtpSender" type="FtpSenderType" minOccurs="0" />
        <xs:element name="HttpSender" type="HttpSenderType" minOccurs="0" />
        <xs:element name="IbisJavaSender" type="IbisJavaSenderType" minOccurs="0" />
        <xs:element name="IbisLocalSender" type="IbisLocalSenderType" minOccurs="0" />
        <xs:element name="IbisWebServiceSender" type="IbisWebServiceSenderType" minOccurs="0" />
        <xs:element name="JmsSender" type="JmsSenderType" minOccurs="0" />
        <xs:element name="LdapSender" type="LdapSenderType" minOccurs="0" />
        <xs:element name="LogSender" type="LogSenderType" minOccurs="0" />
        <xs:element name="MailSender" type="MailSenderType" minOccurs="0" />
        <xs:element name="MessageStoreSender" type="MessageStoreSenderType" minOccurs="0" />
        <xs:element name="MqttSender" type="MqttSenderType" minOccurs="0" />
        <xs:element name="ParallelSendersSender" type="ParallelSendersSenderType" minOccurs="0" />
        <xs:element name="ReloadSender" type="ReloadSenderType" minOccurs="0" />
        <xs:element name="RestSender" type="RestSenderType" minOccurs="0" />
        <xs:element name="ResultSet2FileSender" type="ResultSet2FileSenderType" minOccurs="0" />
        <xs:element name="SambaSender" type="SambaSenderType" minOccurs="0" />
        <xs:element name="SchedulerSender" type="SchedulerSenderType" minOccurs="0" />
        <xs:element name="SenderSeriesSender" type="SenderSeriesSenderType" minOccurs="0" />
        <xs:element name="SenderWrapperSender" type="SenderWrapperSenderType" minOccurs="0" />
        <xs:element name="ShadowSender" type="ShadowSenderType" minOccurs="0" />
        <xs:element name="TimeoutGuardSenderWithParametersBaseSender" type="TimeoutGuardSenderWithParametersBaseSenderType" minOccurs="0" />
        <xs:element name="WebServiceNtlmSender" type="WebServiceNtlmSenderType" minOccurs="0" />
        <xs:element name="WebServiceSender" type="WebServiceSenderType" minOccurs="0" />
        <xs:element name="XComSender" type="XComSenderType" minOccurs="0" />
        <xs:element name="XfbSender" type="XfbSenderType" minOccurs="0" />
        <xs:element name="XmlJmsBrowserSender" type="XmlJmsBrowserSenderType" minOccurs="0" />
        <xs:element name="XmlQuerySender" type="XmlQuerySenderType" minOccurs="0" />
        <xs:element name="XmlValidatorSender" type="XmlValidatorSenderType" minOccurs="0" />
        <xs:element name="XsltSender" type="XsltSenderType" minOccurs="0" />
        <xs:element name="ZipWriterSender" type="ZipWriterSenderType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConcurrentThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets and upper limit to the amount of concurrent threads that can be run simultaneously. use 0 to disable. (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="originalSender" type="xs:string">
      <xs:annotation>
        <xs:documentation>the default or original sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultSender" type="xs:string">
      <xs:annotation>
        <xs:documentation>the sender which will process all results (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ShadowSenderType">
    <xs:sequence>
      <xs:element name="Cache" type="CacheType" minOccurs="0" maxOccurs="unbounded" />
      <xs:choice minOccurs="0">
        <xs:element name="Afm2EdiFactSender" type="Afm2EdiFactSenderType" minOccurs="0" />
        <xs:element name="BisJmsSender" type="BisJmsSenderType" minOccurs="0" />
        <xs:element name="CommandSender" type="CommandSenderType" minOccurs="0" />
        <xs:element name="DelaySender" type="DelaySenderType" minOccurs="0" />
        <xs:element name="DirectQuerySender" type="DirectQuerySenderType" minOccurs="0" />
        <xs:element name="EchoSender" type="EchoSenderType" minOccurs="0" />
        <xs:element name="EsbJmsSender" type="EsbJmsSenderType" minOccurs="0" />
        <xs:element name="FileSender" type="FileSenderType" minOccurs="0" />
        <xs:element name="FixedQuerySender" type="FixedQuerySenderType" minOccurs="0" />
        <xs:element name="FixedResultSender" type="FixedResultSenderType" minOccurs="0" />
        <xs:element name="FtpSender" type="FtpSenderType" minOccurs="0" />
        <xs:element name="HttpSender" type="HttpSenderType" minOccurs="0" />
        <xs:element name="IbisJavaSender" type="IbisJavaSenderType" minOccurs="0" />
        <xs:element name="IbisLocalSender" type="IbisLocalSenderType" minOccurs="0" />
        <xs:element name="IbisWebServiceSender" type="IbisWebServiceSenderType" minOccurs="0" />
        <xs:element name="JmsSender" type="JmsSenderType" minOccurs="0" />
        <xs:element name="LdapSender" type="LdapSenderType" minOccurs="0" />
        <xs:element name="LogSender" type="LogSenderType" minOccurs="0" />
        <xs:element name="MailSender" type="MailSenderType" minOccurs="0" />
        <xs:element name="MessageStoreSender" type="MessageStoreSenderType" minOccurs="0" />
        <xs:element name="MqttSender" type="MqttSenderType" minOccurs="0" />
        <xs:element name="ParallelSendersSender" type="ParallelSendersSenderType" minOccurs="0" />
        <xs:element name="ReloadSender" type="ReloadSenderType" minOccurs="0" />
        <xs:element name="RestSender" type="RestSenderType" minOccurs="0" />
        <xs:element name="ResultSet2FileSender" type="ResultSet2FileSenderType" minOccurs="0" />
        <xs:element name="SambaSender" type="SambaSenderType" minOccurs="0" />
        <xs:element name="SchedulerSender" type="SchedulerSenderType" minOccurs="0" />
        <xs:element name="SenderSeriesSender" type="SenderSeriesSenderType" minOccurs="0" />
        <xs:element name="SenderWrapperSender" type="SenderWrapperSenderType" minOccurs="0" />
        <xs:element name="ShadowSender" type="ShadowSenderType" minOccurs="0" />
        <xs:element name="TimeoutGuardSenderWithParametersBaseSender" type="TimeoutGuardSenderWithParametersBaseSenderType" minOccurs="0" />
        <xs:element name="WebServiceNtlmSender" type="WebServiceNtlmSenderType" minOccurs="0" />
        <xs:element name="WebServiceSender" type="WebServiceSenderType" minOccurs="0" />
        <xs:element name="XComSender" type="XComSenderType" minOccurs="0" />
        <xs:element name="XfbSender" type="XfbSenderType" minOccurs="0" />
        <xs:element name="XmlJmsBrowserSender" type="XmlJmsBrowserSenderType" minOccurs="0" />
        <xs:element name="XmlQuerySender" type="XmlQuerySenderType" minOccurs="0" />
        <xs:element name="XmlValidatorSender" type="XmlValidatorSenderType" minOccurs="0" />
        <xs:element name="XsltSender" type="XsltSenderType" minOccurs="0" />
        <xs:element name="ZipWriterSender" type="ZipWriterSenderType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConcurrentThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>sets and upper limit to the amount of concurrent threads that can be run simultaneously. use 0 to disable. (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="originalSender" type="xs:string">
      <xs:annotation>
        <xs:documentation>the default or original sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultSender" type="xs:string">
      <xs:annotation>
        <xs:documentation>the sender which will process all results (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ShowConfigPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a piperunexception is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in seconds of obtaining a result (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ShowConfigurationPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a piperunexception is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in seconds of obtaining a result (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ShowConfigurationStatusPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a piperunexception is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in seconds of obtaining a result (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ShowEnvironmentVariablesPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a piperunexception is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in seconds of obtaining a result (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="ShowFlowDiagramPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a piperunexception is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in seconds of obtaining a result (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="SimpleJdbcListenerType">
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="selectQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>count query that returns the number of available records. when there are available records the pipeline is activated (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trace" type="xs:string" />
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="SizePipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="SkipPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="SoapInputValidatorType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputSoapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>identical to the &lt;code&gt;soapbody&lt;/code&gt; attribute except that it's used for the output message instead of the input message. for more information see &lt;a href="#note1"&gt;note 1&lt;/a&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="responseRoot" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>always envelope (not allowed to change) (default: envelope)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap body. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap body, for example to allow element x and an empty soap body use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap header. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap header, for example to allow element x and an empty soap header use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be used when the soap header element exists multiple times (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>soap envelope xsd version to use: 1.1, 1.2 or any (both 1.1 and 1.2) (default: 1.1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SoapInputWrapperType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt; (default: wrap)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the soap header (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreSoapFault" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;false&lt;/code&gt; and the soap body contains a soap fault, a piperunexception is thrown (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when not empty, this namespace is added to the root element in the soap body (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, namespaces (and prefixes) in the content of the soap body are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeUnusedOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt; and &lt;code&gt;removeoutputnamespaces=false&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, unused namespaces in the content of the soap body are removed (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the root element in the soap body is changed to this value (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to apply to the input message. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="soapHeaderStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to create the content of the soap header. as input for this stylesheet a dummy xml string is used. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) namespace of the soap envelope (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SoapOutputValidatorType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputSoapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>identical to the &lt;code&gt;soapbody&lt;/code&gt; attribute except that it's used for the output message instead of the input message. for more information see &lt;a href="#note1"&gt;note 1&lt;/a&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="responseRoot" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>always envelope (not allowed to change) (default: envelope)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap body. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap body, for example to allow element x and an empty soap body use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap header. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap header, for example to allow element x and an empty soap header use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be used when the soap header element exists multiple times (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>soap envelope xsd version to use: 1.1, 1.2 or any (both 1.1 and 1.2) (default: 1.1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SoapOutputWrapperType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt; (default: wrap)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the soap header (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreSoapFault" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;false&lt;/code&gt; and the soap body contains a soap fault, a piperunexception is thrown (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when not empty, this namespace is added to the root element in the soap body (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, namespaces (and prefixes) in the content of the soap body are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeUnusedOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt; and &lt;code&gt;removeoutputnamespaces=false&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, unused namespaces in the content of the soap body are removed (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the root element in the soap body is changed to this value (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to apply to the input message. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="soapHeaderStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to create the content of the soap header. as input for this stylesheet a dummy xml string is used. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) namespace of the soap envelope (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SoapValidatorPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputSoapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>identical to the &lt;code&gt;soapbody&lt;/code&gt; attribute except that it's used for the output message instead of the input message. for more information see &lt;a href="#note1"&gt;note 1&lt;/a&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="responseRoot" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>always envelope (not allowed to change) (default: envelope)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap body. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap body, for example to allow element x and an empty soap body use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap header. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap header, for example to allow element x and an empty soap header use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be used when the soap header element exists multiple times (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>soap envelope xsd version to use: 1.1, 1.2 or any (both 1.1 and 1.2) (default: 1.1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="SoapWrapperPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;wrap&lt;/code&gt; or &lt;code&gt;unwrap&lt;/code&gt; (default: wrap)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the soap header (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreSoapFault" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;false&lt;/code&gt; and the soap body contains a soap fault, a piperunexception is thrown (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) when not empty, this namespace is added to the root element in the soap body (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, namespaces (and prefixes) in the content of the soap body are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeUnusedOutputNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=unwrap&lt;/code&gt; and &lt;code&gt;removeoutputnamespaces=false&lt;/code&gt;) when &lt;code&gt;true&lt;/code&gt;, unused namespaces in the content of the soap body are removed (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the root element in the soap body is changed to this value (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to apply to the input message. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderSessionKey" type="xs:string" />
    <xs:attribute name="soapHeaderStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) stylesheet to create the content of the soap header. as input for this stylesheet a dummy xml string is used. note: outputtype=&lt;code&gt;xml&lt;/code&gt; and xslt2=&lt;code&gt;true&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;direction=wrap&lt;/code&gt;) namespace of the soap envelope (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="Stream2StringPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="StreamLineIteratorPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapInputWrapper" type="ApiSoapInputWrapperType" minOccurs="0" />
        <xs:element name="BisInputWrapper" type="BisInputWrapperType" minOccurs="0" />
        <xs:element name="DirectInputWrapper" type="DirectInputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapInputWrapper" type="EsbSoapInputWrapperType" minOccurs="0" />
        <xs:element name="FxfInputWrapper" type="FxfInputWrapperType" minOccurs="0" />
        <xs:element name="SoapInputWrapper" type="SoapInputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlInputValidator" type="ApiWsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapInputValidator" type="EsbSoapInputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlInputValidator" type="FxfXmlInputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlInputValidator" type="Json2XmlInputValidatorType" minOccurs="0" />
        <xs:element name="SoapInputValidator" type="SoapInputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlInputValidator" type="WsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="XmlInputValidator" type="XmlInputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="Afm2EdiFactSender" type="Afm2EdiFactSenderType" minOccurs="0" />
        <xs:element name="BisJmsSender" type="BisJmsSenderType" minOccurs="0" />
        <xs:element name="CommandSender" type="CommandSenderType" minOccurs="0" />
        <xs:element name="DelaySender" type="DelaySenderType" minOccurs="0" />
        <xs:element name="DirectQuerySender" type="DirectQuerySenderType" minOccurs="0" />
        <xs:element name="EchoSender" type="EchoSenderType" minOccurs="0" />
        <xs:element name="EsbJmsSender" type="EsbJmsSenderType" minOccurs="0" />
        <xs:element name="FileSender" type="FileSenderType" minOccurs="0" />
        <xs:element name="FixedQuerySender" type="FixedQuerySenderType" minOccurs="0" />
        <xs:element name="FixedResultSender" type="FixedResultSenderType" minOccurs="0" />
        <xs:element name="FtpSender" type="FtpSenderType" minOccurs="0" />
        <xs:element name="HttpSender" type="HttpSenderType" minOccurs="0" />
        <xs:element name="IbisJavaSender" type="IbisJavaSenderType" minOccurs="0" />
        <xs:element name="IbisLocalSender" type="IbisLocalSenderType" minOccurs="0" />
        <xs:element name="IbisWebServiceSender" type="IbisWebServiceSenderType" minOccurs="0" />
        <xs:element name="JmsSender" type="JmsSenderType" minOccurs="0" />
        <xs:element name="LdapSender" type="LdapSenderType" minOccurs="0" />
        <xs:element name="LogSender" type="LogSenderType" minOccurs="0" />
        <xs:element name="MailSender" type="MailSenderType" minOccurs="0" />
        <xs:element name="MessageStoreSender" type="MessageStoreSenderType" minOccurs="0" />
        <xs:element name="MqttSender" type="MqttSenderType" minOccurs="0" />
        <xs:element name="ParallelSendersSender" type="ParallelSendersSenderType" minOccurs="0" />
        <xs:element name="ReloadSender" type="ReloadSenderType" minOccurs="0" />
        <xs:element name="RestSender" type="RestSenderType" minOccurs="0" />
        <xs:element name="ResultSet2FileSender" type="ResultSet2FileSenderType" minOccurs="0" />
        <xs:element name="SambaSender" type="SambaSenderType" minOccurs="0" />
        <xs:element name="SchedulerSender" type="SchedulerSenderType" minOccurs="0" />
        <xs:element name="SenderSeriesSender" type="SenderSeriesSenderType" minOccurs="0" />
        <xs:element name="SenderWrapperSender" type="SenderWrapperSenderType" minOccurs="0" />
        <xs:element name="ShadowSender" type="ShadowSenderType" minOccurs="0" />
        <xs:element name="TimeoutGuardSenderWithParametersBaseSender" type="TimeoutGuardSenderWithParametersBaseSenderType" minOccurs="0" />
        <xs:element name="WebServiceNtlmSender" type="WebServiceNtlmSenderType" minOccurs="0" />
        <xs:element name="WebServiceSender" type="WebServiceSenderType" minOccurs="0" />
        <xs:element name="XComSender" type="XComSenderType" minOccurs="0" />
        <xs:element name="XfbSender" type="XfbSenderType" minOccurs="0" />
        <xs:element name="XmlJmsBrowserSender" type="XmlJmsBrowserSenderType" minOccurs="0" />
        <xs:element name="XmlQuerySender" type="XmlQuerySenderType" minOccurs="0" />
        <xs:element name="XmlValidatorSender" type="XmlValidatorSenderType" minOccurs="0" />
        <xs:element name="XsltSender" type="XsltSenderType" minOccurs="0" />
        <xs:element name="ZipWriterSender" type="ZipWriterSenderType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="DummyMessageLog" type="DummyMessageLogType" minOccurs="0" />
        <xs:element name="EsbJmsMessageLog" type="EsbJmsMessageLogType" minOccurs="0" />
        <xs:element name="JdbcMessageLog" type="JdbcMessageLogType" minOccurs="0" />
        <xs:element name="JmsMessageLog" type="JmsMessageLogType" minOccurs="0" />
        <xs:element name="OracleMessageLog" type="OracleMessageLogType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlOutputValidator" type="ApiWsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapOutputValidator" type="EsbSoapOutputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlOutputValidator" type="FxfXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlOutputValidator" type="Json2XmlOutputValidatorType" minOccurs="0" />
        <xs:element name="SoapOutputValidator" type="SoapOutputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlOutputValidator" type="WsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="XmlOutputValidator" type="XmlOutputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapOutputWrapper" type="ApiSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="BisOutputWrapper" type="BisOutputWrapperType" minOccurs="0" />
        <xs:element name="DirectOutputWrapper" type="DirectOutputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapOutputWrapper" type="EsbSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="FxfOutputWrapper" type="FxfOutputWrapperType" minOccurs="0" />
        <xs:element name="SoapOutputWrapper" type="SoapOutputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addInputToResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; the input is added to the result in an input element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for audittrailxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. if specified, the value of the pipelinesession variable is used as audit trail (instead of the default 'no audit trail) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract audit trail from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockPrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;blocksize &amp;gt; 0&lt;/code&gt;, this string is inserted at the start of the set of lines. (default: &amp;lt;block&amp;gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls multiline behaviour. when set to a value greater than 0, it specifies the number of rows send in a block to the sender. (default: 0 (one line at a time, no prefix of suffix))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;blocksize &amp;gt; 0&lt;/code&gt;, this string is inserted at the end of the set of lines. (default: &amp;lt;/block&amp;gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkRootTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, besides the xml well-formedness the root element of the result is checked to be equal to the value set (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkXmlWellFormed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the xml well-formedness of the result is checked (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectResults" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether all the results of each iteration will be collected in one result message. if set &lt;code&gt;false&lt;/code&gt;, only a small summary is returned (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for correlationidxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. is specified, the value of the pipelinesession variable is used as input for the xpathexpression or stylesheet, instead of the current input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="endOfLineString" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, each line has to end with this string. if the line doesn't end with this string next lines are added (including line separators) until the total line ends with the given string (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="endPosition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;endposition &amp;gt;= startposition&lt;/code&gt;, this field contains the end position of the key in the current record (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exceptionOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a piperunexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when hideregex is not empty and only applies to error/logstore) either &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;firsthalf&lt;/code&gt;. when &lt;code&gt;firsthalf&lt;/code&gt; only the first half of the string is masked, otherwise (&lt;code&gt;all&lt;/code&gt;) the entire string is masked (default: all)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>next to common usage in {@link abstractpipe}, also strings in the error/logstore are masked (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreExceptions" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; ignore any exception thrown by executing sender (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="itemNoSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable to store number of item processed. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for labelxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linePrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>this string is inserted at the start of each line (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>this string is inserted at the end of each line (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>indicates wether the server uses the correlationid or the messageid in the correlationid field of the reply. this requirers the sender to have set the correlationid at the time of sending. (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of times a processing attempt is retried after a timeout or an exception is caught or after a incorrect reply is received (see also &lt;code&gt;retryxpath&lt;/code&gt;) (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:string">
      <xs:annotation>
        <xs:documentation>force the transformer generated from the xpath-expression to omit the xml declaration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either 'text' or 'xml'. only valid for xpathexpression (default: text)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="parallel" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the calls for all items are done in parallel (a new thread is started for each call). when collectresults set &lt;code&gt;true&lt;/code&gt;, this pipe will wait for all calls to finish before results are collected and pipe result is returned (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="presumedTimeOutInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>when the previous call was a timeout, the maximum time (in seconds) after this timeout to presume the current call is also a timeout. a value of -1 indicates to never presume timeouts (default: 10 s)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeDuplicates" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; duplicate input elements are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeXmlDeclarationInResults" type="xs:string">
      <xs:annotation>
        <xs:documentation>postprocess each partial result, to remove the xml-declaration, as this is not allowed inside an xml-document (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultOnTimeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>result returned when no return-message was received within the timeout limit (e.g. 'receiver timed out'). (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMaxInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of seconds waited after an unsuccessful processing attempt before another processing attempt is made (default: 600)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMinInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the starting number of seconds waited after an unsuccessful processing attempt before another processing attempt is made. each next retry this interval is doubled with a upper limit of &lt;code&gt;retrymaxinterval&lt;/code&gt; (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for retryxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression evaluated on each technical successful reply. retry is done if condition returns true (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startPosition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;startposition &amp;gt;= 0&lt;/code&gt;, this field contains the start position of the key in the current record (first character is 0); all sequenced lines with the same key are put in one block and send to the sender (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stopConditionXPathExpression" type="xs:string" />
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is first base64 decoded and then streamed to the httpservletresponse object (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stubFileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the pipe returns a message from a file, instead of doing the regular process (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to apply to each message, before sending it (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOutOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a timeoutexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useInputForExtract" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is used to extract audit trail, correlationid and label (instead of the wrapped input) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>alternatively: xpath-expression to create stylesheet from (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="StreamPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusFailureAsSoapFault" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) when true and the antivirusfailed forward is specified and the antivirus scan did not pass, a soap fault is returned instead of only a plain error message (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusFailureReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) if not empty and the antivirusfailed forward is specified and the antivirus scan did not pass, the error message (or soap fault) is stored in this session key and the first string part is returned to the pipeline (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusMessagePartName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) name of antivirus scan message parts (default: &lt;code&gt;antivirus_msg&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusPartName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) name of antivirus scan status parts (default: &lt;code&gt;antivirus_rc&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="antiVirusPassedMessage" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt; and when &lt;code&gt;checkantivirus=true&lt;/code&gt;) message of antivirus scan parts which indicates the antivirus scan passed (default: &lt;code&gt;pass&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkAntiVirus" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt;) when true parts are checked for antivirus scan returncode. these antivirus scan parts have been added by another application (so the antivirus scan is not performed in this pipe). for each file part an antivirus scan part have been added by this other application (directly after this file part) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="extractFirstStringPart" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used for parameter &lt;code&gt;httprequest&lt;/code&gt;) when true the first part is not put in a session key but returned to the pipeline (as the result of this pipe) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartXmlSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;extractfirststringpart=true&lt;/code&gt;) the session key to put the xml in with info about the stored parts (default: &lt;code&gt;multipartxml&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="StreamTransformerPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>characterset used for reading file or inputstream (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeOriginalBlock" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; the original block is stored under the session key originalblock (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="TestPipeLinePipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a piperunexception is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in seconds of obtaining a result (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="Text2XmlPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="includeXmlDeclaration" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether a declation is included above the xml text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="splitLines" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether the lines of the input are places in separated &amp;lt;line&amp;gt; tags (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useCdataSection" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether the text to encapsulate should be put in a cdata section (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xmlTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>the xml tag to encapsulate the text in (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="TimeoutGuardPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a piperunexception is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in seconds of obtaining a result (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="TimeoutGuardSenderWithParametersBaseSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a senderexception (or timeoutexception) is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the xml tag to encapsulate the result in (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="UUIDGeneratorPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string">
      <xs:annotation>
        <xs:documentation>either &lt;code&gt;alphanumeric&lt;/code&gt; or &lt;code&gt;numeric&lt;/code&gt; (default: alphanumeric)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="UnzipPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectFileContents" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set &lt;code&gt;true&lt;/code&gt;, the content of the files in the zip is returned in the result xml message of this pipe. please note this can consume a lot of memory for large files or a large number of files (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectFileContentsBase64Encoded" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of file extensions. files with an extension which is part of this list will be base64 encoded. all other files are assumed to have utf-8 when reading it from the zip and are added as escaped xml with non-unicode-characters being replaced by inverted question mark appended with #, the character number and ; (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectResults" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set &lt;code&gt;false&lt;/code&gt;, only a small summary (count of items in zip) is returned (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="createSubdirectories" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set &lt;code&gt;true&lt;/code&gt;, subdirectories in the zip file are created in the directory to extract the archive to (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deleteOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, file is automatically deleted upon normal jvm termination (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directory" type="xs:string">
      <xs:annotation>
        <xs:documentation>directory to extract the archive to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directorySessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>sessionkey with a directory value to extract the archive to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keepOriginalFileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set &lt;code&gt;false&lt;/code&gt;, a suffix is added to the original filename to be sure it is unique (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="UploadConfigPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a piperunexception is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in seconds of obtaining a result (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="UploadFilePipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directory" type="xs:string">
      <xs:annotation>
        <xs:documentation>base directory where files are unzipped to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directorySessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>the session key that contains the base directory where files are unzipped to (default: destination)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the key in the &lt;code&gt;pipelinesession&lt;/code&gt; which contains the inputstream (default: file)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="WebServiceErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="allowSelfSignedCertificates" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, self signed certificates are accepted (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authDomain" type="xs:string" />
    <xs:attribute name="base64" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the result is base64 encoded (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificate" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource url to certificate to be used for authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain certificate password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificatePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charSet" type="xs:string" />
    <xs:attribute name="contentType" type="xs:string">
      <xs:annotation>
        <xs:documentation>content-type of the request, only for post and put methods (default: text/html; charset=utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodeMessages" type="xs:string">
      <xs:annotation>
        <xs:documentation>specifies whether messages will encoded, e.g. spaces will be replaced by '+' etc. (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the messageheader (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="followRedirects" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, a redirect request will be honoured, e.g. to switch to https (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="headersParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of parameter names which should be set as http headers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCertificateExpiredException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the certificateexpiredexception is ignored (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreRedirects" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, besides http status code 200 (ok) also the code 301 (moved_permanently), 302 (moved_temporarily) and 307 (temporary_redirect) are considered successful (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputMessageParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;) name of the request parameter which is used to put the input message in (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: pkcs12)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConnections" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of concurrent connections (default: 10)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxExecuteRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of times it the execution is retried (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="methodType" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of method to be executed, either 'GET', 'POST', 'PUT', 'DELETE', 'HEAD' or 'REPORT' (default: GET)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mtomContentTransferEncoding" type="xs:string" />
    <xs:attribute name="mtomEnabled" type="xs:string" />
    <xs:attribute name="multipart" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true and &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;, request parameters are put in a multipart/form-data entity instead of in the request body (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartResponse" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true the response body is expected to be in mime multipart which is the case when a soap message with attachments is received (see also &lt;a href="https://docs.oracle.com/javaee/7/api/javax/xml/soap/soapmessage.html"&gt;https://docs.oracle.com/javaee/7/api/javax/xml/soap/soapmessage.html&lt;/a&gt;). the first part will be returned as result of this sender. other parts are returned as streams in sessionkeys with names multipart1, multipart2, etc. the http connection is held open until the last stream is read. (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartXmlSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set and &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;, a multipart/form-data entity is created instead of a request body. for each part element in the session key a part in the multipart entity is created (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions to be added in the soap envelope tag. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="paramsInUrl" type="xs:string">
      <xs:annotation>
        <xs:documentation>when false and &lt;code&gt;methodetype=post&lt;/code&gt;, request parameters are put in the request body instead of in the url (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="protocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>secure socket protocol (such as 'ssl' and 'tls') to use when a sslcontext object is generated. if empty the protocol 'ssl' is used (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to proxy (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: 80)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyRealm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultStatusCodeSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the status code of the http response is put in specified in the sessionkey and the (error or okay) response message is returned (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespaceParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>parameter to obtain the servicenamespace (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soap" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope and the soap envelope is removed from received messages (soap envelope will not be visible to the pipeline) (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapAction" type="xs:string">
      <xs:annotation>
        <xs:documentation>the soapactionuri to be set in the requestheader (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapActionParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>parameter to obtain the soapactionuri (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether connections checked to be stale, i.e. appear open, but are not. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleTimeout" type="xs:string" />
    <xs:attribute name="storeResultAsByteArrayInSessionKey" type="xs:string" />
    <xs:attribute name="storeResultAsStreamInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, a pointer to an input stream of the result is put in the specified sessionkey (as the sender interface only allows a sender to return a string a sessionkey is used instead to return the stream) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToFileNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to a file (instead of passed as a string) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to the httpservletresponse object of the restservicedispatcher (instead of passed as a string) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>&gt;(only used when &lt;code&gt;xhtml=true&lt;/code&gt;) stylesheet to apply to the html response (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwApplicationFaults" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether soap faults generated by the application generate an exception, or are treated as 'normal' messages (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a senderexception (or timeoutexception) is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in ms of obtaining a connection/result. 0 means no timeout (default: 10000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource url to truststore to be used for authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain truststore password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: jks)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>url or base of url to be used  (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>parameter that is used to obtain url; overrides url-attribute. (default: url)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="userName" type="xs:string">
      <xs:annotation>
        <xs:documentation>username used in authentication to host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the hostname in the certificate will be checked against the actual hostname (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xhtml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the html response is transformed to xhtml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the xml tag to encapsulate the result in (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="WebServiceListenerType">
    <xs:attribute name="address" type="xs:string" />
    <xs:attribute name="applicationFaultsAsExceptions" type="xs:string" />
    <xs:attribute name="applicationFaultsAsSoapFaults" type="xs:string" />
    <xs:attribute name="attachmentSessionKeys" type="xs:string" />
    <xs:attribute name="mtomEnabled" type="xs:string" />
    <xs:attribute name="multipartXmlSessionKey" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the listener as known to the adapter (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="running" type="xs:string" />
    <xs:attribute name="serviceNamespaceURI" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace of the service that is provided by the adapter of this listener (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soap" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; the soap envelope is removed from received messages and a soap envelope is added to returned messages (soap envelope will not be visible to the pipeline) (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="WebServiceNtlmErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authDomain" type="xs:string" />
    <xs:attribute name="contentType" type="xs:string">
      <xs:annotation>
        <xs:documentation>content-type of the request (default: text/html; charset=utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConnections" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of concurrent connections (default: 10)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: 80)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapAction" type="xs:string">
      <xs:annotation>
        <xs:documentation>the soapactionuri to be set in the requestheader (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in ms of obtaining a connection/result. 0 means no timeout (default: 10000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>url or base of url to be used  (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="userName" type="xs:string">
      <xs:annotation>
        <xs:documentation>username used in authentication to host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="WebServiceNtlmSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authDomain" type="xs:string" />
    <xs:attribute name="contentType" type="xs:string">
      <xs:annotation>
        <xs:documentation>content-type of the request (default: text/html; charset=utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConnections" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of concurrent connections (default: 10)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: 80)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapAction" type="xs:string">
      <xs:annotation>
        <xs:documentation>the soapactionuri to be set in the requestheader (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in ms of obtaining a connection/result. 0 means no timeout (default: 10000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>url or base of url to be used  (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="userName" type="xs:string">
      <xs:annotation>
        <xs:documentation>username used in authentication to host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="WebServiceSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="allowSelfSignedCertificates" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, self signed certificates are accepted (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="authDomain" type="xs:string" />
    <xs:attribute name="base64" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the result is base64 encoded (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificate" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource url to certificate to be used for authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificateAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain certificate password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="certificatePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charSet" type="xs:string" />
    <xs:attribute name="contentType" type="xs:string">
      <xs:annotation>
        <xs:documentation>content-type of the request, only for post and put methods (default: text/html; charset=utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodeMessages" type="xs:string">
      <xs:annotation>
        <xs:documentation>specifies whether messages will encoded, e.g. spaces will be replaced by '+' etc. (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encodingStyle" type="xs:string">
      <xs:annotation>
        <xs:documentation>the encodingstyle to be set in the messageheader (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="followRedirects" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, a redirect request will be honoured, e.g. to switch to https (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="headersParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of parameter names which should be set as http headers (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCertificateExpiredException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the certificateexpiredexception is ignored (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreRedirects" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, besides http status code 200 (ok) also the code 301 (moved_permanently), 302 (moved_temporarily) and 307 (temporary_redirect) are considered successful (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputMessageParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;) name of the request parameter which is used to put the input message in (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keyManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="keystoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: pkcs12)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxConnections" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of concurrent connections (default: 10)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxExecuteRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of times it the execution is retried (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="methodType" type="xs:string">
      <xs:annotation>
        <xs:documentation>type of method to be executed, either 'GET', 'POST', 'PUT', 'DELETE', 'HEAD' or 'REPORT' (default: GET)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mtomContentTransferEncoding" type="xs:string" />
    <xs:attribute name="mtomEnabled" type="xs:string" />
    <xs:attribute name="multipart" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true and &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;, request parameters are put in a multipart/form-data entity instead of in the request body (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartResponse" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true the response body is expected to be in mime multipart which is the case when a soap message with attachments is received (see also &lt;a href="https://docs.oracle.com/javaee/7/api/javax/xml/soap/soapmessage.html"&gt;https://docs.oracle.com/javaee/7/api/javax/xml/soap/soapmessage.html&lt;/a&gt;). the first part will be returned as result of this sender. other parts are returned as streams in sessionkeys with names multipart1, multipart2, etc. the http connection is held open until the last stream is read. (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multipartXmlSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set and &lt;code&gt;methodetype=post&lt;/code&gt; and &lt;code&gt;paramsinurl=false&lt;/code&gt;, a multipart/form-data entity is created instead of a request body. for each part element in the session key a part in the multipart entity is created (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions to be added in the soap envelope tag. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="paramsInUrl" type="xs:string">
      <xs:annotation>
        <xs:documentation>when false and &lt;code&gt;methodetype=post&lt;/code&gt;, request parameters are put in the request body instead of in the url (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="password" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="protocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>secure socket protocol (such as 'ssl' and 'tls') to use when a sslcontext object is generated. if empty the protocol 'ssl' is used (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to proxy (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyHost" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyPort" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: 80)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyRealm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="proxyUsername" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultStatusCodeSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the status code of the http response is put in specified in the sessionkey and the (error or okay) response message is returned (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the message sent. identifies the service to be called. may be overriden by an actual namespace setting in the message to be sent (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceNamespaceParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>parameter to obtain the servicenamespace (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soap" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, messages sent are put in a soap envelope and the soap envelope is removed from received messages (soap envelope will not be visible to the pipeline) (default: &lt;code&gt;true&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapAction" type="xs:string">
      <xs:annotation>
        <xs:documentation>the soapactionuri to be set in the requestheader (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapActionParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>parameter to obtain the soapactionuri (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether connections checked to be stale, i.e. appear open, but are not. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="staleTimeout" type="xs:string" />
    <xs:attribute name="storeResultAsByteArrayInSessionKey" type="xs:string" />
    <xs:attribute name="storeResultAsStreamInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, a pointer to an input stream of the result is put in the specified sessionkey (as the sender interface only allows a sender to return a string a sessionkey is used instead to return the stream) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToFileNameSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to a file (instead of passed as a string) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to the httpservletresponse object of the restservicedispatcher (instead of passed as a string) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>&gt;(only used when &lt;code&gt;xhtml=true&lt;/code&gt;) stylesheet to apply to the html response (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwApplicationFaults" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether soap faults generated by the application generate an exception, or are treated as 'normal' messages (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a senderexception (or timeoutexception) is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in ms of obtaining a connection/result. 0 means no timeout (default: 10000)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trustManagerAlgorithm" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststore" type="xs:string">
      <xs:annotation>
        <xs:documentation>resource url to truststore to be used for authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain truststore password (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststorePassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="truststoreType" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: jks)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="url" type="xs:string">
      <xs:annotation>
        <xs:documentation>url or base of url to be used  (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>parameter that is used to obtain url; overrides url-attribute. (default: url)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="userName" type="xs:string">
      <xs:annotation>
        <xs:documentation>username used in authentication to host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verifyHostname" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the hostname in the certificate will be checked against the actual hostname (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>alias used to obtain credentials for authentication to web services security (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPassword" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssPasswordDigest" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the password is sent digested. otherwise it is sent in clear text (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wssUserName" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xhtml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the html response is transformed to xhtml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, the xml tag to encapsulate the result in (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="WebservicesPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, a piperunexception is thrown. otherwise the output is only logged as an error (and returned in a xml string with 'error' tags) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout in seconds of obtaining a result (default: 30)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="WsdlGeneratorPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="from" type="xs:string">
      <xs:annotation>
        <xs:documentation>either parent (adapter of pipeline which contains this pipe) or input (name of adapter specified by input of pipe) (default: parent)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="WsdlXmlInputValidatorType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputSoapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>identical to the &lt;code&gt;soapbody&lt;/code&gt; attribute except that it's used for the output message instead of the input message. for more information see &lt;a href="#note1"&gt;note 1&lt;/a&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="responseRoot" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>always envelope (not allowed to change) (default: envelope)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocationToAdd" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references which will be added to the wsdl (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap body. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap body, for example to allow element x and an empty soap body use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>creates &lt;code&gt;schemalocation&lt;/code&gt; attribute based on the wsdl and replaces the namespace of the soap body element (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap header. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap header, for example to allow element x and an empty soap header use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be used when the soap header element exists multiple times (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>soap envelope xsd version to use: 1.1, 1.2 or any (both 1.1 and 1.2) (default: 1.1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wsdl" type="xs:string">
      <xs:annotation>
        <xs:documentation>the wsdl to read the xsd's from (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="WsdlXmlOutputValidatorType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputSoapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>identical to the &lt;code&gt;soapbody&lt;/code&gt; attribute except that it's used for the output message instead of the input message. for more information see &lt;a href="#note1"&gt;note 1&lt;/a&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="responseRoot" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>always envelope (not allowed to change) (default: envelope)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocationToAdd" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references which will be added to the wsdl (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap body. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap body, for example to allow element x and an empty soap body use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>creates &lt;code&gt;schemalocation&lt;/code&gt; attribute based on the wsdl and replaces the namespace of the soap body element (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap header. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap header, for example to allow element x and an empty soap header use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be used when the soap header element exists multiple times (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>soap envelope xsd version to use: 1.1, 1.2 or any (both 1.1 and 1.2) (default: 1.1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wsdl" type="xs:string">
      <xs:annotation>
        <xs:documentation>the wsdl to read the xsd's from (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="WsdlXmlValidatorPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="acceptNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml is allowed to be without namespaces. when no namespaces are detected (by the presence of the string 'xmlns') in the xml string, the root namespace is added to the xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="autoFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the format on 'output' is set to the same as the format of the input message on 'input' (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compactJsonArrays" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true assume arrays in json do not have the element containers like in xml (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deepSearch" type="xs:string" />
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failOnWildcards" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, an exception is thrown when a wildcard is found in the xml schema when parsing an object. this often indicates that an element is not properly typed in the xml schema, and could lead to ambuigities. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jsonWithRootElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, assume that json contains/must contain a root element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormat" type="xs:string">
      <xs:annotation>
        <xs:documentation>default format of the result. either 'xml' or 'json' (default: xml)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputFormatSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key to retrieve outputformat from. (default: outputformat)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputSoapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>identical to the &lt;code&gt;soapbody&lt;/code&gt; attribute except that it's used for the output message instead of the input message. for more information see &lt;a href="#note1"&gt;note 1&lt;/a&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="produceNamespaceLessXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, all xml that is generated is without a namespace set (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="responseRoot" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>always envelope (not allowed to change) (default: envelope)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocationToAdd" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references which will be added to the wsdl (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBody" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap body. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap body, for example to allow element x and an empty soap body use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapBodyNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>creates &lt;code&gt;schemalocation&lt;/code&gt; attribute based on the wsdl and replaces the namespace of the soap body element (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the child element of the soap header. or a comma separated list of names to choose from (only one is allowed) (wsdl generator will use the first element) (use empty value to allow an empty soap header, for example to allow element x and an empty soap header use: x,) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapHeaderNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>can be used when the soap header element exists multiple times (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapVersion" type="xs:string">
      <xs:annotation>
        <xs:documentation>soap envelope xsd version to use: 1.1, 1.2 or any (both 1.1 and 1.2) (default: 1.1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strictJsonArraySyntax" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true check that incoming json adheres to the specified syntax (compact or full), otherwise both types are accepted for conversion from json to xml (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>ony for json input: namespace of the resulting xml. need only be specified when the namespace of root name is ambiguous in the schema (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="wsdl" type="xs:string">
      <xs:annotation>
        <xs:documentation>the wsdl to read the xsd's from (default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XComErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the alias to obtain credentials to authenticatie on remote server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="codeflag" type="xs:string">
      <xs:annotation>
        <xs:documentation>characterset conversion, one of ascii or ebcdic (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compress" type="xs:string">
      <xs:annotation>
        <xs:documentation>one of yes, no, rle, compact, lzlarge, lzmedium or lzsmall (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="configFile" type="xs:string" />
    <xs:attribute name="fileOption" type="xs:string">
      <xs:annotation>
        <xs:documentation>one of create, append or replace (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logfile" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of logfile for xcomtcp to be used (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="xs:string">
      <xs:annotation>
        <xs:documentation>port of remote host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>remote directory is prefixed witht the remote file (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteFilePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>remote file to create. if empty, the name is equal to the local file (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteSystem" type="xs:string">
      <xs:annotation>
        <xs:documentation>hostname or tcpip adres of remote host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="userid" type="xs:string">
      <xs:annotation>
        <xs:documentation>loginname of user on remote system (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="workingDirName" type="xs:string">
      <xs:annotation>
        <xs:documentation>directory in which to run the xcomtcp command (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xcomtcp" type="xs:string">
      <xs:annotation>
        <xs:documentation>path to xcomtcp command (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XComSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="authAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the alias to obtain credentials to authenticatie on remote server (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="codeflag" type="xs:string">
      <xs:annotation>
        <xs:documentation>characterset conversion, one of ascii or ebcdic (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="compress" type="xs:string">
      <xs:annotation>
        <xs:documentation>one of yes, no, rle, compact, lzlarge, lzmedium or lzsmall (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="configFile" type="xs:string" />
    <xs:attribute name="fileOption" type="xs:string">
      <xs:annotation>
        <xs:documentation>one of create, append or replace (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logfile" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of logfile for xcomtcp to be used (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="xs:string">
      <xs:annotation>
        <xs:documentation>port of remote host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteDirectory" type="xs:string">
      <xs:annotation>
        <xs:documentation>remote directory is prefixed witht the remote file (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteFilePattern" type="xs:string">
      <xs:annotation>
        <xs:documentation>remote file to create. if empty, the name is equal to the local file (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remoteSystem" type="xs:string">
      <xs:annotation>
        <xs:documentation>hostname or tcpip adres of remote host (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="userid" type="xs:string">
      <xs:annotation>
        <xs:documentation>loginname of user on remote system (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="workingDirName" type="xs:string">
      <xs:annotation>
        <xs:documentation>directory in which to run the xcomtcp command (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xcomtcp" type="xs:string">
      <xs:annotation>
        <xs:documentation>path to xcomtcp command (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XPathPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indentXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, result is pretty-printed. (only used when &lt;code&gt;skipemptytags=true&lt;/code&gt;) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of transformation (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:string">
      <xs:annotation>
        <xs:documentation>force the transformer generated from the xpath-expression to omit the xml declaration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either 'text' or 'xml'. only valid for xpathexpression (default: text)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string" />
    <xs:attribute name="skipEmptyTags" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; empty tags in the output are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to apply to the input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath-expression to apply to the input message. it's possible to refer to a parameter (which e.g. contains a value from a sessionkey) by using the parameter name prefixed with $ (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XQueryPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xqueryFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the file on the file system to read the xquery from (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xqueryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the file (resource) on the classpath to read the xquery from (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XfbErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="appli" type="xs:string" />
    <xs:attribute name="copy" type="xs:string" />
    <xs:attribute name="copyPrefix" type="xs:string" />
    <xs:attribute name="flow" type="xs:string" />
    <xs:attribute name="ft" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noname" type="xs:string" />
    <xs:attribute name="script" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="XfbSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="appli" type="xs:string" />
    <xs:attribute name="copy" type="xs:string" />
    <xs:attribute name="copyPrefix" type="xs:string" />
    <xs:attribute name="flow" type="xs:string" />
    <xs:attribute name="ft" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noname" type="xs:string" />
    <xs:attribute name="script" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="XmlBuilderPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="substringEnd" type="xs:string">
      <xs:annotation>
        <xs:documentation>substring to end translation (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="substringStart" type="xs:string">
      <xs:annotation>
        <xs:documentation>substring to start translation (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="XmlFileElementIteratorPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapInputWrapper" type="ApiSoapInputWrapperType" minOccurs="0" />
        <xs:element name="BisInputWrapper" type="BisInputWrapperType" minOccurs="0" />
        <xs:element name="DirectInputWrapper" type="DirectInputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapInputWrapper" type="EsbSoapInputWrapperType" minOccurs="0" />
        <xs:element name="FxfInputWrapper" type="FxfInputWrapperType" minOccurs="0" />
        <xs:element name="SoapInputWrapper" type="SoapInputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlInputValidator" type="ApiWsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapInputValidator" type="EsbSoapInputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlInputValidator" type="FxfXmlInputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlInputValidator" type="Json2XmlInputValidatorType" minOccurs="0" />
        <xs:element name="SoapInputValidator" type="SoapInputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlInputValidator" type="WsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="XmlInputValidator" type="XmlInputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="Afm2EdiFactSender" type="Afm2EdiFactSenderType" minOccurs="0" />
        <xs:element name="BisJmsSender" type="BisJmsSenderType" minOccurs="0" />
        <xs:element name="CommandSender" type="CommandSenderType" minOccurs="0" />
        <xs:element name="DelaySender" type="DelaySenderType" minOccurs="0" />
        <xs:element name="DirectQuerySender" type="DirectQuerySenderType" minOccurs="0" />
        <xs:element name="EchoSender" type="EchoSenderType" minOccurs="0" />
        <xs:element name="EsbJmsSender" type="EsbJmsSenderType" minOccurs="0" />
        <xs:element name="FileSender" type="FileSenderType" minOccurs="0" />
        <xs:element name="FixedQuerySender" type="FixedQuerySenderType" minOccurs="0" />
        <xs:element name="FixedResultSender" type="FixedResultSenderType" minOccurs="0" />
        <xs:element name="FtpSender" type="FtpSenderType" minOccurs="0" />
        <xs:element name="HttpSender" type="HttpSenderType" minOccurs="0" />
        <xs:element name="IbisJavaSender" type="IbisJavaSenderType" minOccurs="0" />
        <xs:element name="IbisLocalSender" type="IbisLocalSenderType" minOccurs="0" />
        <xs:element name="IbisWebServiceSender" type="IbisWebServiceSenderType" minOccurs="0" />
        <xs:element name="JmsSender" type="JmsSenderType" minOccurs="0" />
        <xs:element name="LdapSender" type="LdapSenderType" minOccurs="0" />
        <xs:element name="LogSender" type="LogSenderType" minOccurs="0" />
        <xs:element name="MailSender" type="MailSenderType" minOccurs="0" />
        <xs:element name="MessageStoreSender" type="MessageStoreSenderType" minOccurs="0" />
        <xs:element name="MqttSender" type="MqttSenderType" minOccurs="0" />
        <xs:element name="ParallelSendersSender" type="ParallelSendersSenderType" minOccurs="0" />
        <xs:element name="ReloadSender" type="ReloadSenderType" minOccurs="0" />
        <xs:element name="RestSender" type="RestSenderType" minOccurs="0" />
        <xs:element name="ResultSet2FileSender" type="ResultSet2FileSenderType" minOccurs="0" />
        <xs:element name="SambaSender" type="SambaSenderType" minOccurs="0" />
        <xs:element name="SchedulerSender" type="SchedulerSenderType" minOccurs="0" />
        <xs:element name="SenderSeriesSender" type="SenderSeriesSenderType" minOccurs="0" />
        <xs:element name="SenderWrapperSender" type="SenderWrapperSenderType" minOccurs="0" />
        <xs:element name="ShadowSender" type="ShadowSenderType" minOccurs="0" />
        <xs:element name="TimeoutGuardSenderWithParametersBaseSender" type="TimeoutGuardSenderWithParametersBaseSenderType" minOccurs="0" />
        <xs:element name="WebServiceNtlmSender" type="WebServiceNtlmSenderType" minOccurs="0" />
        <xs:element name="WebServiceSender" type="WebServiceSenderType" minOccurs="0" />
        <xs:element name="XComSender" type="XComSenderType" minOccurs="0" />
        <xs:element name="XfbSender" type="XfbSenderType" minOccurs="0" />
        <xs:element name="XmlJmsBrowserSender" type="XmlJmsBrowserSenderType" minOccurs="0" />
        <xs:element name="XmlQuerySender" type="XmlQuerySenderType" minOccurs="0" />
        <xs:element name="XmlValidatorSender" type="XmlValidatorSenderType" minOccurs="0" />
        <xs:element name="XsltSender" type="XsltSenderType" minOccurs="0" />
        <xs:element name="ZipWriterSender" type="ZipWriterSenderType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="DummyMessageLog" type="DummyMessageLogType" minOccurs="0" />
        <xs:element name="EsbJmsMessageLog" type="EsbJmsMessageLogType" minOccurs="0" />
        <xs:element name="JdbcMessageLog" type="JdbcMessageLogType" minOccurs="0" />
        <xs:element name="JmsMessageLog" type="JmsMessageLogType" minOccurs="0" />
        <xs:element name="OracleMessageLog" type="OracleMessageLogType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlOutputValidator" type="ApiWsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapOutputValidator" type="EsbSoapOutputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlOutputValidator" type="FxfXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlOutputValidator" type="Json2XmlOutputValidatorType" minOccurs="0" />
        <xs:element name="SoapOutputValidator" type="SoapOutputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlOutputValidator" type="WsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="XmlOutputValidator" type="XmlOutputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapOutputWrapper" type="ApiSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="BisOutputWrapper" type="BisOutputWrapperType" minOccurs="0" />
        <xs:element name="DirectOutputWrapper" type="DirectOutputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapOutputWrapper" type="EsbSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="FxfOutputWrapper" type="FxfOutputWrapperType" minOccurs="0" />
        <xs:element name="SoapOutputWrapper" type="SoapOutputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addInputToResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; the input is added to the result in an input element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for audittrailxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. if specified, the value of the pipelinesession variable is used as audit trail (instead of the default 'no audit trail) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract audit trail from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockPrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;blocksize &amp;gt; 0&lt;/code&gt;, this string is inserted at the start of the set of lines. (default: &amp;lt;block&amp;gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls multiline behaviour. when set to a value greater than 0, it specifies the number of rows send in a block to the sender. (default: 0 (one line at a time, no prefix of suffix))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;blocksize &amp;gt; 0&lt;/code&gt;, this string is inserted at the end of the set of lines. (default: &amp;lt;/block&amp;gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkRootTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, besides the xml well-formedness the root element of the result is checked to be equal to the value set (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkXmlWellFormed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the xml well-formedness of the result is checked (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectResults" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether all the results of each iteration will be collected in one result message. if set &lt;code&gt;false&lt;/code&gt;, only a small summary is returned (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for correlationidxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. is specified, the value of the pipelinesession variable is used as input for the xpathexpression or stylesheet, instead of the current input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the element to iterate over, preceded with all ancestor elements and separated by semicolons (e.g. adapter;pipeline;pipe) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementName" type="xs:string">
      <xs:annotation>
        <xs:documentation>the name of the element to iterate over (alternatively: &lt;code&gt;elementchain&lt;/code&gt;) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="endPosition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;endposition &amp;gt;= startposition&lt;/code&gt;, this field contains the end position of the key in the current record (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exceptionOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a piperunexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when hideregex is not empty and only applies to error/logstore) either &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;firsthalf&lt;/code&gt;. when &lt;code&gt;firsthalf&lt;/code&gt; only the first half of the string is masked, otherwise (&lt;code&gt;all&lt;/code&gt;) the entire string is masked (default: all)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>next to common usage in {@link abstractpipe}, also strings in the error/logstore are masked (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreExceptions" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; ignore any exception thrown by executing sender (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="itemNoSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable to store number of item processed. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for labelxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linePrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>this string is inserted at the start of each line (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>this string is inserted at the end of each line (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>indicates wether the server uses the correlationid or the messageid in the correlationid field of the reply. this requirers the sender to have set the correlationid at the time of sending. (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of times a processing attempt is retried after a timeout or an exception is caught or after a incorrect reply is received (see also &lt;code&gt;retryxpath&lt;/code&gt;) (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:string">
      <xs:annotation>
        <xs:documentation>force the transformer generated from the xpath-expression to omit the xml declaration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either 'text' or 'xml'. only valid for xpathexpression (default: text)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="parallel" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the calls for all items are done in parallel (a new thread is started for each call). when collectresults set &lt;code&gt;true&lt;/code&gt;, this pipe will wait for all calls to finish before results are collected and pipe result is returned (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="presumedTimeOutInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>when the previous call was a timeout, the maximum time (in seconds) after this timeout to presume the current call is also a timeout. a value of -1 indicates to never presume timeouts (default: 10 s)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeDuplicates" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; duplicate input elements are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeXmlDeclarationInResults" type="xs:string">
      <xs:annotation>
        <xs:documentation>postprocess each partial result, to remove the xml-declaration, as this is not allowed inside an xml-document (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultOnTimeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>result returned when no return-message was received within the timeout limit (e.g. 'receiver timed out'). (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMaxInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of seconds waited after an unsuccessful processing attempt before another processing attempt is made (default: 600)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMinInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the starting number of seconds waited after an unsuccessful processing attempt before another processing attempt is made. each next retry this interval is doubled with a upper limit of &lt;code&gt;retrymaxinterval&lt;/code&gt; (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for retryxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression evaluated on each technical successful reply. retry is done if condition returns true (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startPosition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;startposition &amp;gt;= 0&lt;/code&gt;, this field contains the start position of the key in the current record (first character is 0); all sequenced lines with the same key are put in one block and send to the sender (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stopConditionXPathExpression" type="xs:string" />
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is first base64 decoded and then streamed to the httpservletresponse object (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stubFileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the pipe returns a message from a file, instead of doing the regular process (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to apply to each message, before sending it (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOutOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a timeoutexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useInputForExtract" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is used to extract audit trail, correlationid and label (instead of the wrapped input) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>alternatively: xpath-expression to create stylesheet from (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XmlIfPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elseForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when 'false' (default: else)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expressionValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>a string to compare the result of the xpathexpression (or the input-message itself) to. if not specified, a non-empty result leads to the 'then'-forward, an empty result to 'else'-forward (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="regex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to be applied to the input-message (ignored if xpathexpression is specified). the input-message matching the given regular expression leads to the 'then'-forward (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the key in the &lt;code&gt;pipelinesession&lt;/code&gt; to retrieve the input-message from. if not set, the current input message of the pipe is taken. n.b. same as &lt;code&gt;getinputfromsessionkey&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="thenForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when 'true'&lt;/code&gt; (default: then)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to be applied to the input-message. if not set, no transformation is done (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XmlInputValidatorType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the root element. or a comma separated list of names to choose from (only one is allowed) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XmlJmsBrowserErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XmlJmsBrowserSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XmlOutputValidatorType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the root element. or a comma separated list of names to choose from (only one is allowed) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XmlParamSwitchPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when the content, on which the switch is performed, is empty. if &lt;code&gt;emptyforwardname&lt;/code&gt; is not specified, &lt;code&gt;notfoundforwardname&lt;/code&gt; is used. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="notFoundForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when the pipename derived from the stylesheet could not be found. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceSelectionStylesheetFilename" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet may return a string representing the forward to look up (default: &lt;i&gt;a stylesheet that returns the name of the root-element&lt;/i&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the key in the &lt;code&gt;pipelinesession&lt;/code&gt; to retrieve the input message from. (n.b. same as &lt;code&gt;getinputfromsessionkey&lt;/code&gt;) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath-expression that returns a string representing the forward to look up. it's possible to refer to a parameter (which e.g. contains a value from a sessionkey) by using the parameter name prefixed with $ (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XmlQueryErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobBase64Direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether the streamed blobdata will need to be base64 &lt;code&gt;encode&lt;/code&gt; or &lt;code&gt;decode&lt;/code&gt; or not. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used to read and write blobs (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobColumn" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for querytype 'updateblob': column that contains the blob to be updated (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>for querytype 'updateblob': key of session variable that contains the data (string or inputstream) to be loaded to the blob. when empty, the input of the pipe, which then must be a string, is used. for querytype 'select': key of session variable that contains the outputstream, writer or filename to write the blob to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls automatically whether blobdata is stored compressed and/or serialized in the database (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is stored compressed in the database (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobColumn" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for querytype 'updateclob': column that contains the clob to be updated (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>for querytype 'updateclob': key of session variable that contains the clob (string or inputstream) to be loaded to the clob. when empty, the input of the pipe, which then must be a string, is used. for querytype 'select': key of session variable that contains the outputstream, writer or filename to write the clob to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeOutputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the outputstream is not closed after blob or clob has been written to it (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="columnsReturned" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of columns whose values are to be returned. works only if the driver implements jdbc 3.0 getgeneratedkeys() (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="includeFieldDefinition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the result contains besides the returned rows also a header with information about the fetched fields (default: application default (true))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="lockRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, exclusive row-level locks are obtained on all the rows identified by the select statement (by appending ' for update nowait skip locked' to the end of the query) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWait" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and &gt;=0, ' for update wait #' is used instead of ' for update nowait skip locked' (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum number of rows returned (default: -1 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="nullValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>value used in result as contents of fields that contain no value (sql-null) (default: &lt;i&gt;empty string&lt;/&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="packageContent" type="xs:string" />
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queryType" type="xs:string" />
    <xs:attribute name="resultQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>query that can be used to obtain result of side-effecto of update-query, like generated value of sequence. example: select mysequence.currval from dual (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rowIdSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified, the rowid of the processed row is put in the pipelinesession under the specified key (only applicable for &lt;code&gt;querytype=other&lt;/code&gt;). &lt;b&gt;note:&lt;/b&gt; if multiple rows are processed a sqlexception is thrown. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalar" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the value of the first column of the first row (or the startrow) is returned as the only result, as a simple non-xml value (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalarExtended" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startRow" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of the first row returned from the output (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used when reading a stream (that is e.g. going to be written to a blob or clob). when empty, the stream is copied directly to the blob, without conversion (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to the httpservletresponse object of the restservicedispatcher (instead of passed as a string) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of seconds the driver will wait for a statement object to execute. if the limit is exceeded, a timeoutexception is thrown. 0 means no timeout (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="trimSpaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>remove trailing blanks from all values. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useNamedParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, every string in the message which equals &lt;code&gt;paramname&lt;/code&gt; will be replaced by the setter method for the corresponding parameter (the parameters don't need to be in the correct order and unused parameters are skipped) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="XmlQuerySenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="authentication" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_authentication (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobBase64Direction" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether the streamed blobdata will need to be base64 &lt;code&gt;encode&lt;/code&gt; or &lt;code&gt;decode&lt;/code&gt; or not. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used to read and write blobs (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobColumn" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for querytype 'updateblob': column that contains the blob to be updated (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>for querytype 'updateblob': key of session variable that contains the data (string or inputstream) to be loaded to the blob. when empty, the input of the pipe, which then must be a string, is used. for querytype 'select': key of session variable that contains the outputstream, writer or filename to write the blob to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobSmartGet" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls automatically whether blobdata is stored compressed and/or serialized in the database (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blobsCompressed" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether blobdata is stored compressed in the database (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobColumn" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for querytype 'updateclob': column that contains the clob to be updated (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="clobSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>for querytype 'updateclob': key of session variable that contains the clob (string or inputstream) to be loaded to the clob. when empty, the input of the pipe, which then must be a string, is used. for querytype 'select': key of session variable that contains the outputstream, writer or filename to write the clob to (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeOutputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the outputstream is not closed after blob or clob has been written to it (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="columnsReturned" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of columns whose values are to be returned. works only if the driver implements jdbc 3.0 getgeneratedkeys() (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connectionsArePooled" type="xs:string" />
    <xs:attribute name="credentials" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_credentials (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datasourceName" type="xs:string" />
    <xs:attribute name="includeFieldDefinition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, the result contains besides the returned rows also a header with information about the fetched fields (default: application default (true))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initialContextFactoryName" type="xs:string">
      <xs:annotation>
        <xs:documentation>class to use as initial context factory (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiAuthAlias" type="xs:string">
      <xs:annotation>
        <xs:documentation>authentication alias, may be used to override principal and credential-settings (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndiContextPrefix" type="xs:string" />
    <xs:attribute name="jndiProperties" type="xs:string" />
    <xs:attribute name="lockRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, exclusive row-level locks are obtained on all the rows identified by the select statement (by appending ' for update nowait skip locked' to the end of the query) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lockWait" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and &gt;=0, ' for update wait #' is used instead of ' for update nowait skip locked' (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxRows" type="xs:string">
      <xs:annotation>
        <xs:documentation>maximum number of rows returned (default: -1 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="nullValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>value used in result as contents of fields that contain no value (sql-null) (default: &lt;i&gt;empty string&lt;/&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="packageContent" type="xs:string" />
    <xs:attribute name="principal" type="xs:string">
      <xs:annotation>
        <xs:documentation>username to connect to context, maps to context.security_principal (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="providerURL" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default:  )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queryType" type="xs:string" />
    <xs:attribute name="resultQuery" type="xs:string">
      <xs:annotation>
        <xs:documentation>query that can be used to obtain result of side-effecto of update-query, like generated value of sequence. example: select mysequence.currval from dual (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rowIdSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified, the rowid of the processed row is put in the pipelinesession under the specified key (only applicable for &lt;code&gt;querytype=other&lt;/code&gt;). &lt;b&gt;note:&lt;/b&gt; if multiple rows are processed a sqlexception is thrown. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalar" type="xs:string">
      <xs:annotation>
        <xs:documentation>when true, the value of the first column of the first row (or the startrow) is returned as the only result, as a simple non-xml value (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scalarExtended" type="xs:string" />
    <xs:attribute name="securityProtocol" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.security_protocol (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startRow" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of the first row returned from the output (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamCharset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used when reading a stream (that is e.g. going to be written to a blob or clob). when empty, the stream is copied directly to the blob, without conversion (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is streamed to the httpservletresponse object of the restservicedispatcher (instead of passed as a string) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="synchronous" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of seconds the driver will wait for a statement object to execute. if the limit is exceeded, a timeoutexception is thrown. 0 means no timeout (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transacted" type="xs:string" />
    <xs:attribute name="trimSpaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>remove trailing blanks from all values. (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="urlPkgPrefixes" type="xs:string">
      <xs:annotation>
        <xs:documentation>maps to the field context.url_pkg_prefixes (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useNamedParams" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt;, every string in the message which equals &lt;code&gt;paramname&lt;/code&gt; will be replaced by the setter method for the corresponding parameter (the parameters don't need to be in the correct order and unused parameters are skipped) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="username" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="XmlSwitchPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when the content, on which the switch is performed, is empty. if &lt;code&gt;emptyforwardname&lt;/code&gt; is not specified, &lt;code&gt;notfoundforwardname&lt;/code&gt; is used. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="notFoundForwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>forward returned when the pipename derived from the stylesheet could not be found. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="serviceSelectionStylesheetFilename" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet may return a string representing the forward to look up (default: &lt;i&gt;a stylesheet that returns the name of the root-element&lt;/i&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the key in the &lt;code&gt;pipelinesession&lt;/code&gt; to retrieve the input message from. (n.b. same as &lt;code&gt;getinputfromsessionkey&lt;/code&gt;) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath-expression that returns a string representing the forward to look up. it's possible to refer to a parameter (which e.g. contains a value from a sessionkey) by using the parameter name prefixed with $ (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XmlValidatorErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="addNamespaceToSchema" type="xs:string" />
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCaching" type="xs:string" />
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string" />
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string" />
    <xs:attribute name="lazyInit" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string" />
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XmlValidatorPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addNamespaceToSchema" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the namespace from schemalocation is added to the schema document as targetnamespace (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreUnknownNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>ignore namespaces in the input message which are unknown (default: true when schema or nonamespaceschemalocation is used, false otherwise)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of namespaces which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>comma separated list of schemalocations which are excluded from an import or include in the schema document (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="noNamespaceSchemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>a uri reference as a hint as to the location of a schema document with no target namespace. see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the root element. or a comma separated list of names to choose from (only one is allowed) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema" type="xs:string">
      <xs:annotation>
        <xs:documentation>the filename of the schema on the classpath. see doc on the method. (effectively the same as nonamespaceschemalocation) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaLocation" type="xs:string">
      <xs:annotation>
        <xs:documentation>pairs of uri references (one for the namespace name, and one for a hint as to the location of a schema document defining names for that namespace name). see doc on the method. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schemaSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="soapNamespace" type="xs:string">
      <xs:annotation>
        <xs:documentation>the namespace of the soap envelope, when this property has a value and the input message is a soap message the content of the soap body is used for validation, hence the soap envelope and soap body elements are not considered part of the message to validate. please note that this functionality is deprecated, using {@link nl.nn.adapterframework.soap.soapvalidator} is now the preferred solution in case a soap message needs to be validated, in other cases give this property an empty value (default: http://schemas.xmlsoap.org/soap/envelope/)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the comparison for importedschemalocationstoignore is done on base filename without any path (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XmlValidatorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="addNamespaceToSchema" type="xs:string" />
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>setvalidatefile (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fullSchemaChecking" type="xs:string">
      <xs:annotation>
        <xs:documentation>perform addional memory intensive checks (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreCaching" type="xs:string" />
    <xs:attribute name="importedNamespacesToIgnore" type="xs:string" />
    <xs:attribute name="importedSchemaLocationsToIgnore" type="xs:string" />
    <xs:attribute name="lazyInit" type="xs:string" />
    <xs:attribute name="name" type="xs:string" use="required" />
    <xs:attribute name="reasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set: key of session variable to store reasons of mis-validation in (default: failurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="throwException" type="xs:string">
      <xs:annotation>
        <xs:documentation>should the xmlvalidator throw a piperunexception on a validation error (if not, a forward with name 'failure' should be defined. (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useBaseImportedSchemaLocationsToIgnore" type="xs:string" />
    <xs:attribute name="validateFile" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input is assumed to be the name of the file to be validated. otherwise the input itself is validated (default: &lt;code&gt;false&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xmlReasonSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;reasonsessionkey&lt;/code&gt; but stores reasons in xml format and more extensive (default: xmlfailurereason)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XmlWellFormedCheckerPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="root" type="xs:string">
      <xs:annotation>
        <xs:documentation>name of the root element (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
  </xs:complexType>
  <xs:complexType name="XsltErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="indentXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, result is pretty-printed. (only used when &lt;code&gt;skipemptytags=true&lt;/code&gt;) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string" />
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:string">
      <xs:annotation>
        <xs:documentation>force the transformer generated from the xpath-expression to omit the xml declaration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either 'text' or 'xml'. only valid for xpathexpression (default: text)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipEmptyTags" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; empty tags in the output are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to apply to the input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>alternatively: xpath-expression to create stylesheet from (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XsltParamPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indentXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, result is pretty-printed. (only used when &lt;code&gt;skipemptytags=true&lt;/code&gt;) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of transformation (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:string">
      <xs:annotation>
        <xs:documentation>force the transformer generated from the xpath-expression to omit the xml declaration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either 'text' or 'xml'. only valid for xpathexpression (default: text)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string" />
    <xs:attribute name="skipEmptyTags" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; empty tags in the output are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to apply to the input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath-expression to apply to the input message. it's possible to refer to a parameter (which e.g. contains a value from a sessionkey) by using the parameter name prefixed with $ (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XsltPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indentXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, result is pretty-printed. (only used when &lt;code&gt;skipemptytags=true&lt;/code&gt;) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of transformation (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:string">
      <xs:annotation>
        <xs:documentation>force the transformer generated from the xpath-expression to omit the xml declaration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either 'text' or 'xml'. only valid for xpathexpression (default: text)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sessionKey" type="xs:string" />
    <xs:attribute name="skipEmptyTags" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; empty tags in the output are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to apply to the input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath-expression to apply to the input message. it's possible to refer to a parameter (which e.g. contains a value from a sessionkey) by using the parameter name prefixed with $ (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="XsltSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="indentXml" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, result is pretty-printed. (only used when &lt;code&gt;skipemptytags=true&lt;/code&gt;) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string" />
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:string">
      <xs:annotation>
        <xs:documentation>force the transformer generated from the xpath-expression to omit the xml declaration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either 'text' or 'xml'. only valid for xpathexpression (default: text)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeNamespaces" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; namespaces (and prefixes) in the input message are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipEmptyTags" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; empty tags in the output are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to apply to the input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>alternatively: xpath-expression to create stylesheet from (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="xslt2" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt; xslt processor 2.0 (net.sf.saxon) will be used, otherwise xslt processor 1.0 (org.apache.xalan) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ZipIteratorPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapInputWrapper" type="ApiSoapInputWrapperType" minOccurs="0" />
        <xs:element name="BisInputWrapper" type="BisInputWrapperType" minOccurs="0" />
        <xs:element name="DirectInputWrapper" type="DirectInputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapInputWrapper" type="EsbSoapInputWrapperType" minOccurs="0" />
        <xs:element name="FxfInputWrapper" type="FxfInputWrapperType" minOccurs="0" />
        <xs:element name="SoapInputWrapper" type="SoapInputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlInputValidator" type="ApiWsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapInputValidator" type="EsbSoapInputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlInputValidator" type="FxfXmlInputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlInputValidator" type="Json2XmlInputValidatorType" minOccurs="0" />
        <xs:element name="SoapInputValidator" type="SoapInputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlInputValidator" type="WsdlXmlInputValidatorType" minOccurs="0" />
        <xs:element name="XmlInputValidator" type="XmlInputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="Afm2EdiFactSender" type="Afm2EdiFactSenderType" minOccurs="0" />
        <xs:element name="BisJmsSender" type="BisJmsSenderType" minOccurs="0" />
        <xs:element name="CommandSender" type="CommandSenderType" minOccurs="0" />
        <xs:element name="DelaySender" type="DelaySenderType" minOccurs="0" />
        <xs:element name="DirectQuerySender" type="DirectQuerySenderType" minOccurs="0" />
        <xs:element name="EchoSender" type="EchoSenderType" minOccurs="0" />
        <xs:element name="EsbJmsSender" type="EsbJmsSenderType" minOccurs="0" />
        <xs:element name="FileSender" type="FileSenderType" minOccurs="0" />
        <xs:element name="FixedQuerySender" type="FixedQuerySenderType" minOccurs="0" />
        <xs:element name="FixedResultSender" type="FixedResultSenderType" minOccurs="0" />
        <xs:element name="FtpSender" type="FtpSenderType" minOccurs="0" />
        <xs:element name="HttpSender" type="HttpSenderType" minOccurs="0" />
        <xs:element name="IbisJavaSender" type="IbisJavaSenderType" minOccurs="0" />
        <xs:element name="IbisLocalSender" type="IbisLocalSenderType" minOccurs="0" />
        <xs:element name="IbisWebServiceSender" type="IbisWebServiceSenderType" minOccurs="0" />
        <xs:element name="JmsSender" type="JmsSenderType" minOccurs="0" />
        <xs:element name="LdapSender" type="LdapSenderType" minOccurs="0" />
        <xs:element name="LogSender" type="LogSenderType" minOccurs="0" />
        <xs:element name="MailSender" type="MailSenderType" minOccurs="0" />
        <xs:element name="MessageStoreSender" type="MessageStoreSenderType" minOccurs="0" />
        <xs:element name="MqttSender" type="MqttSenderType" minOccurs="0" />
        <xs:element name="ParallelSendersSender" type="ParallelSendersSenderType" minOccurs="0" />
        <xs:element name="ReloadSender" type="ReloadSenderType" minOccurs="0" />
        <xs:element name="RestSender" type="RestSenderType" minOccurs="0" />
        <xs:element name="ResultSet2FileSender" type="ResultSet2FileSenderType" minOccurs="0" />
        <xs:element name="SambaSender" type="SambaSenderType" minOccurs="0" />
        <xs:element name="SchedulerSender" type="SchedulerSenderType" minOccurs="0" />
        <xs:element name="SenderSeriesSender" type="SenderSeriesSenderType" minOccurs="0" />
        <xs:element name="SenderWrapperSender" type="SenderWrapperSenderType" minOccurs="0" />
        <xs:element name="ShadowSender" type="ShadowSenderType" minOccurs="0" />
        <xs:element name="TimeoutGuardSenderWithParametersBaseSender" type="TimeoutGuardSenderWithParametersBaseSenderType" minOccurs="0" />
        <xs:element name="WebServiceNtlmSender" type="WebServiceNtlmSenderType" minOccurs="0" />
        <xs:element name="WebServiceSender" type="WebServiceSenderType" minOccurs="0" />
        <xs:element name="XComSender" type="XComSenderType" minOccurs="0" />
        <xs:element name="XfbSender" type="XfbSenderType" minOccurs="0" />
        <xs:element name="XmlJmsBrowserSender" type="XmlJmsBrowserSenderType" minOccurs="0" />
        <xs:element name="XmlQuerySender" type="XmlQuerySenderType" minOccurs="0" />
        <xs:element name="XmlValidatorSender" type="XmlValidatorSenderType" minOccurs="0" />
        <xs:element name="XsltSender" type="XsltSenderType" minOccurs="0" />
        <xs:element name="ZipWriterSender" type="ZipWriterSenderType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="DummyMessageLog" type="DummyMessageLogType" minOccurs="0" />
        <xs:element name="EsbJmsMessageLog" type="EsbJmsMessageLogType" minOccurs="0" />
        <xs:element name="JdbcMessageLog" type="JdbcMessageLogType" minOccurs="0" />
        <xs:element name="JmsMessageLog" type="JmsMessageLogType" minOccurs="0" />
        <xs:element name="OracleMessageLog" type="OracleMessageLogType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiWsdlXmlOutputValidator" type="ApiWsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="EsbSoapOutputValidator" type="EsbSoapOutputValidatorType" minOccurs="0" />
        <xs:element name="FxfXmlOutputValidator" type="FxfXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="Json2XmlOutputValidator" type="Json2XmlOutputValidatorType" minOccurs="0" />
        <xs:element name="SoapOutputValidator" type="SoapOutputValidatorType" minOccurs="0" />
        <xs:element name="WsdlXmlOutputValidator" type="WsdlXmlOutputValidatorType" minOccurs="0" />
        <xs:element name="XmlOutputValidator" type="XmlOutputValidatorType" minOccurs="0" />
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="ApiSoapOutputWrapper" type="ApiSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="BisOutputWrapper" type="BisOutputWrapperType" minOccurs="0" />
        <xs:element name="DirectOutputWrapper" type="DirectOutputWrapperType" minOccurs="0" />
        <xs:element name="EsbSoapOutputWrapper" type="EsbSoapOutputWrapperType" minOccurs="0" />
        <xs:element name="FxfOutputWrapper" type="FxfOutputWrapperType" minOccurs="0" />
        <xs:element name="SoapOutputWrapper" type="SoapOutputWrapperType" minOccurs="0" />
      </xs:choice>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="addInputToResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; the input is added to the result in an input element (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for audittrailxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. if specified, the value of the pipelinesession variable is used as audit trail (instead of the default 'no audit trail) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auditTrailXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract audit trail from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockPrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;blocksize &amp;gt; 0&lt;/code&gt;, this string is inserted at the start of the set of lines. (default: &amp;lt;block&amp;gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls multiline behaviour. when set to a value greater than 0, it specifies the number of rows send in a block to the sender. (default: 0 (one line at a time, no prefix of suffix))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blockSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;blocksize &amp;gt; 0&lt;/code&gt;, this string is inserted at the end of the set of lines. (default: &amp;lt;/block&amp;gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>charset used when reading the contents of the entry (only used if streamingcontens=false&gt; (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkRootTag" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, besides the xml well-formedness the root element of the result is checked to be equal to the value set (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkXmlWellFormed" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the xml well-formedness of the result is checked (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="collectResults" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether all the results of each iteration will be collected in one result message. if set &lt;code&gt;false&lt;/code&gt;, only a small summary is returned (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="contentsSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key used to store contents of each zip entry (default: zipdata)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for correlationidxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of a pipelinesession-variable. is specified, the value of the pipelinesession variable is used as input for the xpathexpression or stylesheet, instead of the current input message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="correlationIDXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract correlationid from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="endPosition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;endposition &amp;gt;= startposition&lt;/code&gt;, this field contains the end position of the key in the current record (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exceptionOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a piperunexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when hideregex is not empty and only applies to error/logstore) either &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;firsthalf&lt;/code&gt;. when &lt;code&gt;firsthalf&lt;/code&gt; only the first half of the string is masked, otherwise (&lt;code&gt;all&lt;/code&gt;) the entire string is masked (default: all)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>next to common usage in {@link abstractpipe}, also strings in the error/logstore are masked (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ignoreExceptions" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; ignore any exception thrown by executing sender (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="itemNoSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>key of session variable to store number of item processed. (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for labelxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelStyleSheet" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression to extract label from message (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linePrefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>this string is inserted at the start of each line (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineSuffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>this string is inserted at the end of each line (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linkMethod" type="xs:string">
      <xs:annotation>
        <xs:documentation>indicates wether the server uses the correlationid or the messageid in the correlationid field of the reply. this requirers the sender to have set the correlationid at the time of sending. (default: correlationid)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxRetries" type="xs:string">
      <xs:annotation>
        <xs:documentation>the number of times a processing attempt is retried after a timeout or an exception is caught or after a incorrect reply is received (see also &lt;code&gt;retryxpath&lt;/code&gt;) (default: 0)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for xpathexpression. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="omitXmlDeclaration" type="xs:string">
      <xs:annotation>
        <xs:documentation>force the transformer generated from the xpath-expression to omit the xml declaration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outputType" type="xs:string">
      <xs:annotation>
        <xs:documentation>either 'text' or 'xml'. only valid for xpathexpression (default: text)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="parallel" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the calls for all items are done in parallel (a new thread is started for each call). when collectresults set &lt;code&gt;true&lt;/code&gt;, this pipe will wait for all calls to finish before results are collected and pipe result is returned (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="presumedTimeOutInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>when the previous call was a timeout, the maximum time (in seconds) after this timeout to presume the current call is also a timeout. a value of -1 indicates to never presume timeouts (default: 10 s)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="removeDuplicates" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;true&lt;/code&gt; duplicate input elements are removed (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeXmlDeclarationInResults" type="xs:string">
      <xs:annotation>
        <xs:documentation>postprocess each partial result, to remove the xml-declaration, as this is not allowed inside an xml-document (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="resultOnTimeOut" type="xs:string">
      <xs:annotation>
        <xs:documentation>result returned when no return-message was received within the timeout limit (e.g. 'receiver timed out'). (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMaxInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the maximum number of seconds waited after an unsuccessful processing attempt before another processing attempt is made (default: 600)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryMinInterval" type="xs:string">
      <xs:annotation>
        <xs:documentation>the starting number of seconds waited after an unsuccessful processing attempt before another processing attempt is made. each next retry this interval is doubled with a upper limit of &lt;code&gt;retrymaxinterval&lt;/code&gt; (default: 1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryNamespaceDefs" type="xs:string">
      <xs:annotation>
        <xs:documentation>namespace defintions for retryxpath. must be in the form of a comma or space separated list of &lt;code&gt;prefix=namespaceuri&lt;/code&gt;-definitions (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="retryXPath" type="xs:string">
      <xs:annotation>
        <xs:documentation>xpath expression evaluated on each technical successful reply. retry is done if condition returns true (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipBOM" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;true&lt;/code&gt;, a possible bytes order mark (bom) at the start of the file is skipped (only used for encoding uft-8) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="startPosition" type="xs:string">
      <xs:annotation>
        <xs:documentation>when &lt;code&gt;startposition &amp;gt;= 0&lt;/code&gt;, this field contains the start position of the key in the current record (first character is 0); all sequenced lines with the same key are put in one block and send to the sender (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stopConditionXPathExpression" type="xs:string" />
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamResultToServlet" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the result is first base64 decoded and then streamed to the httpservletresponse object (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="streamingContents" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, a string containing the contents of the entry is placed under the session key, instead of the inputstream to the contents (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stubFileName" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the pipe returns a message from a file, instead of doing the regular process (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="styleSheetName" type="xs:string">
      <xs:annotation>
        <xs:documentation>stylesheet to apply to each message, before sending it (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeOutOnResult" type="xs:string">
      <xs:annotation>
        <xs:documentation>when not empty, a timeoutexception is thrown when the result equals this value (for testing purposes only) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="useInputForExtract" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is used to extract audit trail, correlationid and label (instead of the wrapped input) (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="xpathExpression" type="xs:string">
      <xs:annotation>
        <xs:documentation>alternatively: xpath-expression to create stylesheet from (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ZipWriterErrorSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>characterset used for writing zip entry (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="zipWriterHandle" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key used to refer to zip session. must be used if zipwriterpipes are nested (default: zipwriterhandle)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ZipWriterPipeType">
    <xs:sequence>
      <xs:element name="Locker" type="LockerType" minOccurs="0" />
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Forward" type="ForwardType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="action" type="xs:string" />
    <xs:attribute name="active" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls whether pipe is included in configuration. when set &lt;code&gt;false&lt;/code&gt; or set to something else as &lt;code&gt;true&lt;/code&gt;, (even set to the empty string), the pipe is not included in the configuration (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for action='write': charset used to write strings to zip entries (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chompCharSize" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set (&gt;=0) and the character data length inside a xml element exceeds this size, the character data is chomped (with a clear comment) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for action='write': when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after the zip entry is written (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeOutputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for action='open': when set to &lt;code&gt;false&lt;/code&gt;, the outputstream is not closed after the zip creation is finished (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="completeFileHeader" type="xs:string">
      <xs:annotation>
        <xs:documentation>only for action='write': when set to &lt;code&gt;true&lt;/code&gt;, the fields 'crc-32', 'compressed size' and 'uncompressed size' in the zip entry file header are set explicitly (note: compression ratio is zero) (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="durationThreshold" type="xs:string">
      <xs:annotation>
        <xs:documentation>if durationthreshold &gt;=0 and the duration (in milliseconds) of the message processing exceeded the value specified, then the message is logged informatory (default: -1)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMove" type="xs:string">
      <xs:annotation>
        <xs:documentation>if set, the character data in this element is stored under a session key and in the message replaced by a reference to this session key: {sessionkey: + &lt;code&gt;elementtomovesessionkey&lt;/code&gt; + } (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveChain" type="xs:string">
      <xs:annotation>
        <xs:documentation>like &lt;code&gt;elementtomove&lt;/code&gt; but element is preceded with all ancestor elements and separated by semicolons (e.g. 'adapter;pipeline;pipe') (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="elementToMoveSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;elementtomove&lt;/code&gt; is set) name of the session key under which the character data is stored (default: ref_ + the name of the element)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="emptyInputReplacement" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set and the regular input is empty, this fixed value is taken as input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="forwardName" type="xs:string">
      <xs:annotation>
        <xs:documentation>if specified (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromFixedValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this fixed value is taken as input, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="getInputFromSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, input is taken from this session key, instead of regular input (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hideRegex" type="xs:string">
      <xs:annotation>
        <xs:documentation>regular expression to mask strings in the log. for example, the regular expression &lt;code&gt;(?&amp;lt;=&amp;lt;password&amp;gt;).*?(?=&amp;lt;/password&amp;gt;)&lt;/code&gt; will replace every character between keys '&amp;lt;password&amp;gt;' and '&amp;lt;/password&amp;gt;'. &lt;b&gt;note:&lt;/b&gt; this feature is used at adapter level, so one pipe affects all pipes in the pipeline (and multiple values in different pipes are merged) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifParam" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is only executed when the value of parameter with name &lt;code&gt;ifparam&lt;/code&gt; equals &lt;code&gt;ifvalue&lt;/code&gt; (otherwise this pipe is skipped) (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ifValue" type="xs:string">
      <xs:annotation>
        <xs:documentation>see &lt;code&gt;ifparam&lt;/code&gt; (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="logIntermediaryResults" type="xs:string" />
    <xs:attribute name="maxThreads" type="xs:string">
      <xs:annotation>
        <xs:documentation>dopipe (default: 0 (unlimited))</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the pipe (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespaceAware" type="xs:string">
      <xs:annotation>
        <xs:documentation>controls namespace-awareness of possible xml parsing in descender-classes (default: application default)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preserveInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set &lt;code&gt;true&lt;/code&gt;, the input of a pipe is restored before processing the next one (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="removeCompactMsgNamespaces" type="xs:string" />
    <xs:attribute name="restoreMovedElements" type="xs:string">
      <xs:annotation>
        <xs:documentation>setelementtomove (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="secLogSessionKeys" type="xs:string">
      <xs:annotation>
        <xs:documentation>(only used when &lt;code&gt;writetoseclog=true&lt;/code&gt;) comma separated list of keys of session variables that is appended to the security log record (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skipOnEmptyInput" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, this pipe is skipped (default: false)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="storeResultInSessionKey" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set, the result is stored under this session key (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactionAttribute" type="xs:string" />
    <xs:attribute name="transactionAttributeNum" type="xs:string" />
    <xs:attribute name="transactionTimeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>timeout (in seconds) of transaction started to process a message. (default: &lt;code&gt;0&lt;/code&gt; (use system default)&lt;/code&gt;)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="writeToSecLog" type="xs:string" />
    <xs:attribute name="zipWriterHandle" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key used to refer to zip session. must be used if zipwriterpipes are nested (default: zipwriterhandle)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ZipWriterSenderType">
    <xs:sequence>
      <xs:element name="Param" type="ParamType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="charset" type="xs:string">
      <xs:annotation>
        <xs:documentation>characterset used for writing zip entry (default: utf-8)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="closeInputstreamOnExit" type="xs:string">
      <xs:annotation>
        <xs:documentation>when set to &lt;code&gt;false&lt;/code&gt;, the inputstream is not closed after it has been used (default: true)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>name of the sender (default: )</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="zipWriterHandle" type="xs:string">
      <xs:annotation>
        <xs:documentation>session key used to refer to zip session. must be used if zipwriterpipes are nested (default: zipwriterhandle)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
</xs:schema>
